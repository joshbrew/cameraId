var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/onnxruntime-web/dist/ort.min.js
var require_ort_min = __commonJS({
  "node_modules/onnxruntime-web/dist/ort.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.ort = t() : e.ort = t();
    }(self, () => (() => {
      var __webpack_modules__ = { 5716: (e, t, n) => {
        "use strict";
        t.R = void 0;
        const r = n(6027), o = n(1723);
        t.R = new class {
          async init() {
          }
          async createSessionHandler(e2, t2) {
            const n2 = new r.Session(t2);
            return await n2.loadModel(e2), new o.OnnxjsSessionHandler(n2);
          }
        }();
      }, 2818: (e, t, n) => {
        "use strict";
        t.c8 = t.rX = void 0;
        const r = n(2235), o = n(5381), i = n(9544), a = n(6640);
        t.rX = () => {
          if (("number" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), "boolean" != typeof r.env.wasm.simd && (r.env.wasm.simd = true), "boolean" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = false), "number" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {
            const e2 = "undefined" == typeof navigator ? (0, o.cpus)().length : navigator.hardwareConcurrency;
            r.env.wasm.numThreads = Math.min(4, Math.ceil((e2 || 1) / 2));
          }
        }, t.c8 = new class {
          async init() {
            (0, t.rX)(), await (0, i.initializeWebAssemblyInstance)();
          }
          async createSessionHandler(e2, t2) {
            const n2 = new a.OnnxruntimeWebAssemblySessionHandler();
            return await n2.loadModel(e2, t2), Promise.resolve(n2);
          }
        }();
      }, 1057: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__exportStar || function(e2, t2) {
          for (var n2 in e2)
            "default" === n2 || Object.prototype.hasOwnProperty.call(t2, n2) || r(t2, e2, n2);
        };
        Object.defineProperty(t, "__esModule", { value: true }), o(n(2235), t);
        const i = n(2235), a = n(8408);
        {
          const e2 = n(5716).R;
          (0, i.registerBackend)("webgl", e2, -10);
        }
        {
          const e2 = n(2818).c8;
          (0, i.registerBackend)("cpu", e2, 10), (0, i.registerBackend)("wasm", e2, 10), (0, i.registerBackend)("xnnpack", e2, 9), (0, i.registerBackend)("webnn", e2, 9);
        }
        i.env.versions.web = a.version;
      }, 4910: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createAttributeWithCacheKey = void 0;
        class n {
          constructor(e2) {
            Object.assign(this, e2);
          }
          get cacheKey() {
            return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((e2) => `${this[e2]}`).join(";")), this._cacheKey;
          }
        }
        t.createAttributeWithCacheKey = (e2) => new n(e2);
      }, 6874: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Attribute = void 0;
        const r = n(5127), o = n(2446), i = n(9240), a = n(7273);
        var s = r.onnxruntime.experimental.fbs;
        class u {
          constructor(e2) {
            if (this._attributes = /* @__PURE__ */ new Map(), null != e2) {
              for (const t2 of e2)
                t2 instanceof o.onnx.AttributeProto ? this._attributes.set(t2.name, [u.getValue(t2), u.getType(t2)]) : t2 instanceof s.Attribute && this._attributes.set(t2.name(), [u.getValue(t2), u.getType(t2)]);
              if (this._attributes.size < e2.length)
                throw new Error("duplicated attribute names");
            }
          }
          set(e2, t2, n2) {
            this._attributes.set(e2, [n2, t2]);
          }
          delete(e2) {
            this._attributes.delete(e2);
          }
          getFloat(e2, t2) {
            return this.get(e2, "float", t2);
          }
          getInt(e2, t2) {
            return this.get(e2, "int", t2);
          }
          getString(e2, t2) {
            return this.get(e2, "string", t2);
          }
          getTensor(e2, t2) {
            return this.get(e2, "tensor", t2);
          }
          getFloats(e2, t2) {
            return this.get(e2, "floats", t2);
          }
          getInts(e2, t2) {
            return this.get(e2, "ints", t2);
          }
          getStrings(e2, t2) {
            return this.get(e2, "strings", t2);
          }
          getTensors(e2, t2) {
            return this.get(e2, "tensors", t2);
          }
          get(e2, t2, n2) {
            const r2 = this._attributes.get(e2);
            if (void 0 === r2) {
              if (void 0 !== n2)
                return n2;
              throw new Error(`required attribute not found: ${e2}`);
            }
            if (r2[1] !== t2)
              throw new Error(`type mismatch: expected ${t2} but got ${r2[1]}`);
            return r2[0];
          }
          static getType(e2) {
            const t2 = e2 instanceof o.onnx.AttributeProto ? e2.type : e2.type();
            switch (t2) {
              case o.onnx.AttributeProto.AttributeType.FLOAT:
                return "float";
              case o.onnx.AttributeProto.AttributeType.INT:
                return "int";
              case o.onnx.AttributeProto.AttributeType.STRING:
                return "string";
              case o.onnx.AttributeProto.AttributeType.TENSOR:
                return "tensor";
              case o.onnx.AttributeProto.AttributeType.FLOATS:
                return "floats";
              case o.onnx.AttributeProto.AttributeType.INTS:
                return "ints";
              case o.onnx.AttributeProto.AttributeType.STRINGS:
                return "strings";
              case o.onnx.AttributeProto.AttributeType.TENSORS:
                return "tensors";
              default:
                throw new Error(`attribute type is not supported yet: ${o.onnx.AttributeProto.AttributeType[t2]}`);
            }
          }
          static getValue(e2) {
            const t2 = e2 instanceof o.onnx.AttributeProto ? e2.type : e2.type();
            if (t2 === o.onnx.AttributeProto.AttributeType.GRAPH || t2 === o.onnx.AttributeProto.AttributeType.GRAPHS)
              throw new Error("graph attribute is not supported yet");
            const n2 = this.getValueNoCheck(e2);
            if (t2 === o.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n2))
              return a.LongUtil.longToNumber(n2);
            if (t2 === o.onnx.AttributeProto.AttributeType.INTS) {
              const e3 = n2, t3 = new Array(e3.length);
              for (let n3 = 0; n3 < e3.length; n3++) {
                const r2 = e3[n3];
                t3[n3] = a.LongUtil.longToNumber(r2);
              }
              return t3;
            }
            if (t2 === o.onnx.AttributeProto.AttributeType.TENSOR)
              return e2 instanceof o.onnx.AttributeProto ? i.Tensor.fromProto(n2) : i.Tensor.fromOrtTensor(n2);
            if (t2 === o.onnx.AttributeProto.AttributeType.TENSORS) {
              if (e2 instanceof o.onnx.AttributeProto)
                return n2.map((e3) => i.Tensor.fromProto(e3));
              if (e2 instanceof s.Attribute)
                return n2.map((e3) => i.Tensor.fromOrtTensor(e3));
            }
            if (t2 === o.onnx.AttributeProto.AttributeType.STRING && e2 instanceof o.onnx.AttributeProto) {
              const e3 = n2;
              return (0, a.decodeUtf8String)(e3);
            }
            return t2 === o.onnx.AttributeProto.AttributeType.STRINGS && e2 instanceof o.onnx.AttributeProto ? n2.map(a.decodeUtf8String) : n2;
          }
          static getValueNoCheck(e2) {
            return e2 instanceof o.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e2) : this.getValueNoCheckFromOrtFormat(e2);
          }
          static getValueNoCheckFromOnnxFormat(e2) {
            switch (e2.type) {
              case o.onnx.AttributeProto.AttributeType.FLOAT:
                return e2.f;
              case o.onnx.AttributeProto.AttributeType.INT:
                return e2.i;
              case o.onnx.AttributeProto.AttributeType.STRING:
                return e2.s;
              case o.onnx.AttributeProto.AttributeType.TENSOR:
                return e2.t;
              case o.onnx.AttributeProto.AttributeType.GRAPH:
                return e2.g;
              case o.onnx.AttributeProto.AttributeType.FLOATS:
                return e2.floats;
              case o.onnx.AttributeProto.AttributeType.INTS:
                return e2.ints;
              case o.onnx.AttributeProto.AttributeType.STRINGS:
                return e2.strings;
              case o.onnx.AttributeProto.AttributeType.TENSORS:
                return e2.tensors;
              case o.onnx.AttributeProto.AttributeType.GRAPHS:
                return e2.graphs;
              default:
                throw new Error(`unsupported attribute type: ${o.onnx.AttributeProto.AttributeType[e2.type]}`);
            }
          }
          static getValueNoCheckFromOrtFormat(e2) {
            switch (e2.type()) {
              case s.AttributeType.FLOAT:
                return e2.f();
              case s.AttributeType.INT:
                return e2.i();
              case s.AttributeType.STRING:
                return e2.s();
              case s.AttributeType.TENSOR:
                return e2.t();
              case s.AttributeType.GRAPH:
                return e2.g();
              case s.AttributeType.FLOATS:
                return e2.floatsArray();
              case s.AttributeType.INTS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.intsLength(); n2++)
                  t2.push(e2.ints(n2));
                return t2;
              }
              case s.AttributeType.STRINGS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.stringsLength(); n2++)
                  t2.push(e2.strings(n2));
                return t2;
              }
              case s.AttributeType.TENSORS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.tensorsLength(); n2++)
                  t2.push(e2.tensors(n2));
                return t2;
              }
              default:
                throw new Error(`unsupported attribute type: ${s.AttributeType[e2.type()]}`);
            }
          }
        }
        t.Attribute = u;
      }, 1975: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveBackend = t.backend = void 0;
        const r = n(4418), o = /* @__PURE__ */ new Map();
        async function i(e2) {
          const n2 = t.backend;
          if (void 0 !== n2[e2] && function(e3) {
            const t2 = e3;
            return "initialize" in t2 && "function" == typeof t2.initialize && "createSessionHandler" in t2 && "function" == typeof t2.createSessionHandler && "dispose" in t2 && "function" == typeof t2.dispose;
          }(n2[e2])) {
            const t2 = n2[e2];
            let r2 = t2.initialize();
            if ("object" == typeof r2 && "then" in r2 && (r2 = await r2), r2)
              return o.set(e2, t2), t2;
          }
        }
        t.backend = { webgl: new r.WebGLBackend() }, t.resolveBackend = async function e2(t2) {
          if (!t2)
            return e2(["webgl"]);
          {
            const e3 = "string" == typeof t2 ? [t2] : t2;
            for (const t3 of e3) {
              const e4 = o.get(t3);
              if (e4)
                return e4;
              const n2 = await i(t3);
              if (n2)
                return n2;
            }
          }
          throw new Error("no available backend to use");
        };
      }, 4418: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLBackend = void 0;
        const r = n(2235), o = n(1315), i = n(2171), a = n(3389);
        t.WebGLBackend = class {
          get contextId() {
            return r.env.webgl.contextId;
          }
          set contextId(e2) {
            r.env.webgl.contextId = e2;
          }
          get matmulMaxBatchSize() {
            return r.env.webgl.matmulMaxBatchSize;
          }
          set matmulMaxBatchSize(e2) {
            r.env.webgl.matmulMaxBatchSize = e2;
          }
          get textureCacheMode() {
            return r.env.webgl.textureCacheMode;
          }
          set textureCacheMode(e2) {
            r.env.webgl.textureCacheMode = e2;
          }
          get pack() {
            return r.env.webgl.pack;
          }
          set pack(e2) {
            r.env.webgl.pack = e2;
          }
          get async() {
            return r.env.webgl.async;
          }
          set async(e2) {
            r.env.webgl.async = e2;
          }
          initialize() {
            try {
              return this.glContext = (0, a.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), o.Logger.setWithEnv(r.env), o.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
            } catch (e2) {
              return o.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e2}`), false;
            }
          }
          createSessionHandler(e2) {
            return new i.WebGLSessionHandler(this, e2);
          }
          dispose() {
            this.glContext.dispose();
          }
        };
      }, 6859: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.CoordsGlslLib = void 0;
        const r = n(7273), o = n(1997), i = n(6757), a = n(7618), s = n(432);
        class u extends o.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
          }
          getCustomTypes() {
            return {};
          }
          offsetToCoords() {
            return { offsetToCoords: new o.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
          }
          coordsToOffset() {
            return { coordsToOffset: new o.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
          }
          getOutputSamplingSnippet() {
            const e2 = this.context.outputTextureLayout;
            return e2.isPacked ? this.getPackedOutputSamplingSnippet(e2) : this.getUnpackedOutputSamplingSnippet(e2);
          }
          getPackedOutputSamplingSnippet(e2) {
            const t2 = e2.unpackedShape, n2 = [e2.width, e2.height], r2 = {}, a2 = "getOutputCoords";
            switch (t2.length) {
              case 0:
                r2[a2] = this.getOutputScalarCoords();
                break;
              case 1:
                r2[a2] = this.getOutputPacked1DCoords(t2, n2);
                break;
              case 2:
                r2[a2] = this.getOutputPacked2DCoords(t2, n2);
                break;
              case 3:
                r2[a2] = this.getOutputPacked3DCoords(t2, n2);
                break;
              default:
                r2[a2] = this.getOutputPackedNDCoords(t2, n2);
            }
            const s2 = `
      void setOutput(vec4 val) {
        ${(0, i.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
            return r2.floatTextureSetRGBA = new o.GlslLibRoutine(s2), r2;
          }
          getUnpackedOutputSamplingSnippet(e2) {
            const t2 = e2.unpackedShape, n2 = [e2.width, e2.height], r2 = {}, a2 = "getOutputCoords";
            switch (t2.length) {
              case 0:
                r2[a2] = this.getOutputScalarCoords();
                break;
              case 1:
                r2[a2] = this.getOutputUnpacked1DCoords(t2, n2);
                break;
              case 2:
                r2[a2] = this.getOutputUnpacked2DCoords(t2, n2);
                break;
              case 3:
                r2[a2] = this.getOutputUnpacked3DCoords(t2, n2);
                break;
              case 4:
                r2[a2] = this.getOutputUnpacked4DCoords(t2, n2);
                break;
              case 5:
                r2[a2] = this.getOutputUnpacked5DCoords(t2, n2);
                break;
              case 6:
                r2[a2] = this.getOutputUnpacked6DCoords(t2, n2);
                break;
              default:
                throw new Error(`Unsupported output dimensionality: ${t2.length}`);
            }
            const s2 = `
        void setOutput(float val) {
          ${(0, i.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
            return r2.floatTextureSetR = new o.GlslLibRoutine(s2), r2;
          }
          getOutputScalarCoords() {
            return new o.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
          }
          getOutputPacked1DCoords(e2, t2) {
            const n2 = t2;
            let r2 = "";
            return 1 === n2[0] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n2[1]}.0);
          }
        `, new o.GlslLibRoutine(r2)) : 1 === n2[1] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n2[0]}.0);
          }
        `, new o.GlslLibRoutine(r2)) : (r2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n2[0]}, ${n2[1]}));
          return 2 * (resTexRC.y * ${n2[0]} + resTexRC.x);
        }
      `, new o.GlslLibRoutine(r2));
          }
          getOutputPacked2DCoords(e2, t2) {
            let n2 = "";
            if (r.ArrayUtil.arraysEqual(e2, t2))
              return n2 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t2[0]}, ${t2[1]}));
        }
      `, new o.GlslLibRoutine(n2);
            const i2 = t2, a2 = Math.ceil(e2[1] / 2);
            return n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i2[0]}, ${i2[1]}));

          int index = resTexRC.y * ${i2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a2}) * 2;
          int c = 2 * (index / ${a2});

          return ivec2(r, c);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputPacked3DCoords(e2, t2) {
            const n2 = [t2[0], t2[1]], r2 = Math.ceil(e2[2] / 2), i2 = r2 * Math.ceil(e2[1] / 2), a2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n2[0]}, ${n2[1]}));
          int index = resTexRC.y * ${n2[0]} + resTexRC.x;

          int b = index / ${i2};
          index -= b * ${i2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r2}) * 2;
          int c = 2 * (index / ${r2});

          return ivec3(b, r, c);
        }
      `;
            return new o.GlslLibRoutine(a2);
          }
          getOutputPackedNDCoords(e2, t2) {
            const n2 = [t2[0], t2[1]], r2 = Math.ceil(e2[e2.length - 1] / 2), i2 = r2 * Math.ceil(e2[e2.length - 2] / 2);
            let a2 = i2, s2 = "", u2 = "b, r, c";
            for (let t3 = 2; t3 < e2.length - 1; t3++)
              a2 *= e2[e2.length - t3 - 1], s2 = `
      int b${t3} = index / ${a2};
      index -= b${t3} * ${a2};
    ` + s2, u2 = `b${t3}, ` + u2;
            const l = `
      ivec${e2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n2[0]}, ${n2[1]}));
        int index = resTexRC.y * ${n2[0]} + resTexRC.x;

        ${s2}

        int b = index / ${i2};
        index -= b * ${i2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r2}) * 2;
        int c = 2 * (index / ${r2});

        return ivec${e2.length}(${u2});
      }
    `;
            return new o.GlslLibRoutine(l);
          }
          getOutputUnpacked1DCoords(e2, t2) {
            const n2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          return resTexRC.y * ${t2[0]} + resTexRC.x;
        }
      `;
            return new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked2DCoords(e2, t2) {
            const n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          int r = index / ${e2[1]};
          int c = index - r * ${e2[1]};
          return ivec2(r, c);
        }
      `;
            return new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked3DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec3(r, c, d);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked4DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec4(r, c, d, d2);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked5DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2", "d3"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new o.GlslLibRoutine(n2);
          }
          getOutputUnpacked6DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let i2 = null;
            r2 < 2 && (i2 = []), i2 = new Array(r2 - 1), i2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              i2[t3] = i2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2", "d3", "d4"], s2 = i2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === i2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t2[0]}, ${t2[1]}));
         int index = resTexRC.y * ${t2[0]} + resTexRC.x;
         ${s2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new o.GlslLibRoutine(n2);
          }
          getCommonUtilFuncs() {
            const e2 = {};
            let t2 = "uvFromFlat";
            e2[t2] = new o.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), t2 = "packedUVfrom1D", e2[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom2D", e2[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom3D", e2[t2] = new o.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "sampleTexture";
            const n2 = (0, i.getGlsl)(this.context.glContext.version);
            return e2[t2] = new o.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n2.texture2D}(textureSampler, uv).r;
        }`), e2;
          }
          getInputsSamplingSnippets() {
            const e2 = {}, t2 = this.context.outputTextureLayout;
            return this.context.programInfo.inputNames.forEach((n2, r2) => {
              const o2 = this.context.inputTextureLayouts[r2], i2 = (0, s.generateShaderFuncNameFromInputSamplerName)(n2);
              o2.isPacked ? e2[i2] = this.getPackedSamplerFromInput(i2, n2, o2) : e2[i2] = this.getUnpackedSamplerFromInput(i2, n2, o2);
              const a2 = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n2);
              o2.unpackedShape.length <= t2.unpackedShape.length && (o2.isPacked ? e2[a2] = this.getPackedSamplerAtOutputCoords(a2, o2, t2, n2) : e2[a2] = this.getUnpackedSamplerAtOutputCoords(a2, o2, t2, n2));
            }), e2;
          }
          getPackedSamplerAtOutputCoords(e2, t2, n2, i2) {
            const a2 = t2.unpackedShape, u2 = n2.unpackedShape, l = i2, c = (0, s.generateShaderFuncNameFromInputSamplerName)(l), p = a2.length, d = u2.length, f = r.BroadcastUtil.getBroadcastDims(a2, u2), h = (0, s.getCoordsDataType)(d), g = d - p;
            let b;
            const m = (0, s.getGlChannels)();
            b = 0 === p ? "" : d < 2 && f.length >= 1 ? "coords = 0;" : f.map((e3) => `coords.${m[e3 + g]} = 0;`).join("\n");
            let y = "";
            y = d < 2 && p > 0 ? "coords" : a2.map((e3, t3) => `coords.${m[t3 + g]}`).join(", ");
            let v = "return outputValue;";
            const _ = 1 === r.ShapeUtil.size(a2), w = 1 === r.ShapeUtil.size(u2);
            if (1 !== p || _ || w) {
              if (_ && !w)
                v = 1 === d ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
              else if (f.length) {
                const e3 = p - 2, t3 = p - 1;
                f.indexOf(e3) > -1 && f.indexOf(t3) > -1 ? v = "return vec4(outputValue.x);" : f.indexOf(e3) > -1 ? v = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : f.indexOf(t3) > -1 && (v = "return vec4(outputValue.xx, outputValue.zz);");
              }
            } else
              v = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
            const T = `
      vec4 ${e2}() {
        ${h} coords = getOutputCoords();
        
        int lastDim = coords.${m[d - 1]};
        coords.${m[d - 1]} = coords.${m[d - 2]};
        coords.${m[d - 2]} = lastDim;
      
        ${b}
        vec4 outputValue = ${c}(${y});
        ${v}
      }
    `;
            return new o.GlslLibRoutine(T, ["coordinates.getOutputCoords"]);
          }
          getUnpackedSamplerAtOutputCoords(e2, t2, n2, i2) {
            const a2 = [n2.width, n2.height], u2 = [t2.width, t2.height], l = t2.unpackedShape.length, c = n2.unpackedShape.length, p = t2.unpackedShape, d = n2.unpackedShape, f = (0, s.generateShaderFuncNameFromInputSamplerName)(i2);
            if (l === c && r.ArrayUtil.arraysEqual(u2, a2)) {
              const t3 = `
          float ${e2}() {
            return sampleTexture(${i2}, TexCoords);
          }
        `;
              return new o.GlslLibRoutine(t3, ["coordinates.sampleTexture"]);
            }
            const h = (0, s.getCoordsDataType)(c), g = r.BroadcastUtil.getBroadcastDims(p, d), b = c - l;
            let m;
            const y = (0, s.getGlChannels)();
            m = 0 === l ? "" : c < 2 && g.length >= 1 ? "coords = 0;" : g.map((e3) => `coords.${y[e3 + b]} = 0;`).join("\n");
            let v = "";
            v = c < 2 && l > 0 ? "coords" : t2.unpackedShape.map((e3, t3) => `coords.${y[t3 + b]}`).join(", ");
            const _ = `
        float ${e2}() {
          ${h} coords = getOutputCoords();
          ${m}
          return ${f}(${v});
        }
      `;
            return new o.GlslLibRoutine(_, ["coordinates.getOutputCoords"]);
          }
          getPackedSamplerFromInput(e2, t2, n2) {
            switch (n2.unpackedShape.length) {
              case 0:
                return this.getPackedSamplerScalar(e2, t2);
              case 1:
                return this.getPackedSampler1D(e2, t2, n2);
              case 2:
                return this.getPackedSampler2D(e2, t2, n2);
              case 3:
                return this.getPackedSampler3D(e2, t2, n2);
              default:
                return this.getPackedSamplerND(e2, t2, n2);
            }
          }
          getUnpackedSamplerFromInput(e2, t2, n2) {
            const r2 = n2.unpackedShape;
            switch (r2.length) {
              case 0:
                return this.getUnpackedSamplerScalar(e2, t2, n2);
              case 1:
                return this.getUnpackedSampler1D(e2, t2, n2);
              case 2:
                return this.getUnpackedSampler2D(e2, t2, n2);
              case 3:
                return this.getUnpackedSampler3D(e2, t2, n2);
              case 4:
                return this.getUnpackedSampler4D(e2, t2, n2);
              case 5:
                return this.getUnpackedSampler5D(e2, t2, n2);
              case 6:
                return this.getUnpackedSampler6D(e2, t2, n2);
              default:
                throw new Error(`Unsupported dimension ${r2.length}-D`);
            }
          }
          getPackedSamplerScalar(e2, t2) {
            const n2 = `
          vec4 ${e2}() {
            return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${t2}, halfCR);
          }
        `;
            return new o.GlslLibRoutine(n2);
          }
          getPackedSampler1D(e2, t2, n2) {
            const r2 = [n2.width, n2.height], a2 = [r2[1], r2[0]], s2 = (0, i.getGlsl)(this.context.glContext.version), u2 = `vec4 ${e2}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a2[0]}, ${a2[1]}, index);
      return ${s2.texture2D}(${t2}, uv);
    }`;
            return new o.GlslLibRoutine(u2, ["coordinates.packedUVfrom1D"]);
          }
          getPackedSampler2D(e2, t2, n2) {
            const a2 = n2.unpackedShape, s2 = [n2.width, n2.height], u2 = (0, i.getGlsl)(this.context.glContext.version), l = s2[0], c = s2[1];
            if (null != s2 && r.ArrayUtil.arraysEqual(a2, s2)) {
              const n3 = `vec4 ${e2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);
        return ${u2.texture2D}(${t2}, uv);
      }`;
              return new o.GlslLibRoutine(n3);
            }
            const p = s2, d = Math.ceil(a2[1] / 2), f = `vec4 ${e2}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);
      return ${u2.texture2D}(${t2}, uv);
    }`;
            return new o.GlslLibRoutine(f, ["coordinates.packedUVfrom2D"]);
          }
          getPackedSampler3D(e2, t2, n2) {
            const r2 = n2.unpackedShape, a2 = [n2.width, n2.height], u2 = [a2[0], a2[1]], l = (0, i.getGlsl)(this.context.glContext.version);
            if (1 === r2[0]) {
              const i2 = r2.slice(1), a3 = [1, 2], u3 = (0, s.squeezeInputShape)(r2, i2), l2 = ["b", "row", "col"], c2 = JSON.parse(JSON.stringify(n2));
              c2.unpackedShape = u3;
              const p2 = this.getPackedSamplerFromInput(e2, t2, c2), d2 = `${p2.routineBody}
      vec4 ${e2}(int b, int row, int col) {
        return ${e2}(${(0, s.getSqueezedParams)(l2, a3)});
      } `;
              return new o.GlslLibRoutine(d2, p2.dependencies);
            }
            const c = u2[0], p = u2[1], d = Math.ceil(r2[2] / 2), f = `vec4 ${e2}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${c}, ${d * Math.ceil(r2[1] / 2)}, ${d}, b, row, col);
      return ${l.texture2D}(${t2}, uv);}`;
            return new o.GlslLibRoutine(f, ["coordinates.packedUVfrom3D"]);
          }
          getPackedSamplerND(e2, t2, n2) {
            const r2 = n2.unpackedShape, a2 = r2.length, s2 = [n2.width, n2.height], u2 = (0, i.getGlsl)(this.context.glContext.version), l = [s2[0], s2[1]], c = l[1], p = l[0], d = Math.ceil(r2[a2 - 1] / 2);
            let f = d * Math.ceil(r2[a2 - 2] / 2), h = "int b, int row, int col", g = `b * ${f} + (row / 2) * ${d} + (col / 2)`;
            for (let e3 = 2; e3 < a2 - 1; e3++)
              h = `int b${e3}, ` + h, f *= r2[a2 - e3 - 1], g = `b${e3} * ${f} + ` + g;
            const b = `vec4 ${e2}(${h}) {
      int index = ${g};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});
      return ${u2.texture2D}(${t2}, uv);
    }`;
            return new o.GlslLibRoutine(b);
          }
          getUnpackedSamplerScalar(e2, t2, n2) {
            const [r2, i2] = [n2.width, n2.height];
            if (1 === r2 && 1 === i2) {
              const n3 = `
          float ${e2}() {
            return sampleTexture(${t2}, halfCR);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const a2 = `
        float ${e2}() {
          int offset_${t2} = coordsToOffset(TexCoords, ${r2}, ${i2});
          vec2 uv = uvFromFlat(${r2}, ${i2}, offset_${t2});
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler1D(e2, t2, n2) {
            const r2 = n2.width, i2 = n2.height;
            if (1 === i2 && 1 === r2) {
              const n3 = `
        float ${e2}(int index) {
          return sampleTexture(${t2}, halfCR);
        }
      `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            if (1 === i2) {
              const n3 = `
          float ${e2}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r2}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            if (1 === r2) {
              const n3 = `
          float ${e2}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i2}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const a2 = `
        float ${e2}(int index) {
          vec2 uv = uvFromFlat(${r2}, ${i2}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler2D(e2, t2, n2) {
            const i2 = n2.unpackedShape, u2 = [n2.height, n2.width];
            if (null != u2 && r.ArrayUtil.arraysEqual(i2, u2)) {
              const n3 = `
          float ${e2}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u2[1]}.0, ${u2[0]}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const { newShape: l, keptDims: c } = (0, a.squeezeShape)(i2), p = l;
            if (p.length < i2.length) {
              const r2 = (0, s.squeezeInputShape)(i2, p), a2 = JSON.parse(JSON.stringify(n2));
              a2.unpackedShape = r2;
              const u3 = ["col", "row"], l2 = `
          ${this.getUnpackedSamplerFromInput(e2, t2, a2).routineBody}
          float ${e2}(int row, int col) {
            return ${e2}(${(0, s.getSqueezedParams)(u3, c)});
          }
        `;
              return new o.GlslLibRoutine(l2, ["coordinates.sampleTexture"]);
            }
            const d = u2[1], f = u2[0];
            if (1 === f) {
              const n3 = `
          float ${e2}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${i2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            if (1 === d) {
              const n3 = `
          float ${e2}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${i2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new o.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            const h = `
        float ${e2}(int row, int col) {
          int index = col * ${i2[1]} + row;
          vec2 uv = uvFromFlat(${d}, ${f}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler3D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[1] * r2[2], u2 = r2[2], { newShape: l, keptDims: c } = (0, a.squeezeShape)(r2), p = l;
            if (p.length < r2.length) {
              const i3 = (0, s.squeezeInputShape)(r2, p), a2 = ["batch", "col", "row"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = i3;
              const l2 = this.getUnpackedSamplerFromInput(e2, t2, u3), d2 = c.reverse(), f = `
          ${l2.routineBody}
          float ${e2}(int batch, int row, int col) {
            return ${e2}(${(0, s.getSqueezedParams)(a2, d2)});
          }
        `;
              return new o.GlslLibRoutine(f, l2.dependencies);
            }
            const d = `
          float ${e2}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${i2} + col * ${u2} + row;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
      `;
            return new o.GlslLibRoutine(d, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler4D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[3], a2 = r2[2] * i2, s2 = `
        float ${e2}(int row, int col, int depth, int depth2) {
          int index = row * ${r2[1] * a2} + col * ${a2} +
              depth2 * ${i2} + depth;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler5D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[4], u2 = r2[3] * i2, l = r2[2] * u2, c = r2[1] * l, { newShape: p, keptDims: d } = (0, a.squeezeShape)(r2);
            if (p.length < r2.length) {
              const i3 = (0, s.squeezeInputShape)(r2, p), a2 = ["row", "col", "depth", "depth2", "depth3"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = i3;
              const l2 = `
          ${this.getUnpackedSamplerFromInput(e2, t2, u3).routineBody}
          float ${e2}(int row, int col, int depth, int depth2, int depth3) {
            return ${e2}(${(0, s.getSqueezedParams)(a2, d)});
          }
        `;
              return new o.GlslLibRoutine(l2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            const f = `
        float ${e2}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${c} + col * ${l} + depth * ${u2} +
          depth3 * ${i2} + depth2;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new o.GlslLibRoutine(f, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          getUnpackedSampler6D(e2, t2, n2) {
            const r2 = n2.unpackedShape, i2 = r2[5], u2 = r2[4] * i2, l = r2[3] * u2, c = r2[2] * l, p = r2[1] * c, { newShape: d, keptDims: f } = (0, a.squeezeShape)(r2);
            if (d.length < r2.length) {
              const i3 = (0, s.squeezeInputShape)(r2, d), a2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = i3;
              const l2 = `
            ${this.getUnpackedSamplerFromInput(e2, t2, u3).routineBody}
            float ${e2}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e2}(${(0, s.getSqueezedParams)(a2, f)});
            }
          `;
              return new o.GlslLibRoutine(l2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            const h = `
          float ${e2}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${c} + depth * ${l} +
            depth2 * ${u2} + depth3 * ${i2} + depth4;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
        `;
            return new o.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          toVec() {
            const e2 = this.context.outputTextureLayout, t2 = e2.shape.length, n2 = e2.strides, r2 = e2.width, i2 = e2.height, a2 = [];
            for (let e3 = 0; e3 < t2 - 1; ++e3)
              a2.push(`
        c[${e3}] = offset / ${n2[e3]};`), a2.push(`
        offset -= c[${e3}] * ${n2[e3]};`);
            a2.push(`
        c[${t2 - 1}] = offset;`);
            const s2 = `
      void toVec(vec2 texCoords, out int c[${t2}]) {
        int offset = coordsToOffset(texCoords, ${r2}, ${i2});
        ${a2.join("")}
      }
      void toVec(int offset, out int c[${t2}]) {
        ${a2.join("")}
      }
    `;
            return { toVec: new o.GlslLibRoutine(s2, ["coordinates.coordsToOffset"]) };
          }
          valueFrom() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const r2 = this.context.inputTextureLayouts[n2], i2 = (r2.unpackedShape.length > 0 ? r2.unpackedShape : r2.shape).length;
              let a2 = `_${t2}`;
              e2[a2] = new o.GlslLibRoutine(this.getValueFromSingle(t2, i2, r2.width, r2.height, false), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a2 += "_T", e2[a2] = new o.GlslLibRoutine(this.getValueFromSingle(t2, i2, r2.width, r2.height, true), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
            }), e2;
          }
          getValueFromSingle(e2, t2, n2, r2, o2) {
            let a2 = `_${e2}`;
            return o2 && (a2 += "_T"), `
        float ${a2}(int m[${t2}]) {
          int offset = indicesToOffset${a2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          float value = getColorAsFloat(${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e2}, coords));
          return value;
        }
        `;
          }
          getPackedValueFrom(e2, t2, n2, r2, o2) {
            let a2 = `_${e2}_Pack`;
            return o2 && (a2 += "_T"), `
        vec4 ${a2}(int m[${t2}]) {
          int offset = indicesToOffset_${e2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          return ${(0, i.getGlsl)(this.context.glContext.version).texture2D}(${e2}, coords);
        }
        `;
          }
        }
        t.CoordsGlslLib = u;
      }, 1997: (e, t) => {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: true }), t.TopologicalSortGlslRoutines = t.GlslLibRoutineNode = t.GlslLibRoutine = t.GlslLib = t.GlslContext = t.FunctionType = void 0, (n = t.FunctionType || (t.FunctionType = {}))[n.ValueBased = 0] = "ValueBased", n[n.Positional = 1] = "Positional", t.GlslContext = class {
          constructor(e2, t2, n2, r) {
            this.glContext = e2, this.programInfo = t2, this.inputTextureLayouts = n2, this.outputTextureLayout = r;
          }
        }, t.GlslLib = class {
          constructor(e2) {
            this.context = e2;
          }
        }, t.GlslLibRoutine = class {
          constructor(e2, t2) {
            this.routineBody = e2, this.dependencies = t2;
          }
        }, t.GlslLibRoutineNode = class {
          constructor(e2, t2, n2) {
            this.name = e2, this.dependencies = n2 || [], t2 && (this.routineBody = t2);
          }
          addDependency(e2) {
            e2 && this.dependencies.push(e2);
          }
        }, t.TopologicalSortGlslRoutines = class {
          static returnOrderedNodes(e2) {
            if (!e2 || 0 === e2.length)
              return [];
            if (1 === e2.length)
              return e2;
            const t2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), r = new Array();
            return this.createOrderedNodes(e2, t2, n2, r), r;
          }
          static createOrderedNodes(e2, t2, n2, r) {
            for (let o = 0; o < e2.length; ++o)
              this.dfsTraverse(e2[o], t2, n2, r);
          }
          static dfsTraverse(e2, t2, n2, r) {
            if (!e2 || n2.has(e2.name))
              return;
            if (t2.has(e2.name))
              throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
            t2.add(e2.name);
            const o = e2.dependencies;
            if (o && o.length > 0)
              for (let e3 = 0; e3 < o.length; ++e3)
                this.dfsTraverse(o[e3], t2, n2, r);
            r.push(e2), n2.add(e2.name), t2.delete(e2.name);
          }
        };
      }, 1371: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.EncodingGlslLib = void 0;
        const r = n(1997);
        class o extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
          }
          getCustomTypes() {
            return {};
          }
          encodeFloat32() {
            return { encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
          }
          decodeFloat32() {
            return { decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
          }
          encodeUint8() {
            const e2 = o.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { encode: new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e2}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
          }
          decodeUint8() {
            const e2 = o.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { decode: new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e2}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
          }
          static isLittleEndian() {
            const e2 = new ArrayBuffer(4), t2 = new Uint32Array(e2), n2 = new Uint8Array(e2);
            if (t2[0] = 3735928559, 239 === n2[0])
              return true;
            if (222 === n2[0])
              return false;
            throw new Error("unknown endianness");
          }
        }
        t.EncodingGlslLib = o;
      }, 2691: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FragColorGlslLib = void 0;
        const r = n(1997), o = n(6757);
        class i extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
          }
          getCustomTypes() {
            return {};
          }
          setFragColor() {
            const e2 = (0, o.getGlsl)(this.context.glContext.version);
            return { setFragColor: new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${e2.output} = encode(value);
        }
        `, ["encoding.encode"]) };
          }
          getColorAsFloat() {
            return { getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
          }
        }
        t.FragColorGlslLib = i;
      }, 3878: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.replaceInlines = void 0;
        const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
        t.replaceInlines = function(e2) {
          const t2 = {};
          let r;
          for (; null !== (r = n.exec(e2)); ) {
            const e3 = r[3].split(",").map((e4) => {
              const t3 = e4.trim().split(" ");
              return t3 && 2 === t3.length ? { type: t3[0], name: t3[1] } : null;
            }).filter((e4) => null !== e4);
            t2[r[2]] = { params: e3, body: r[4] };
          }
          for (const n2 in t2) {
            const o = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n2), i = new RegExp(o, "gm");
            for (; null !== (r = i.exec(e2)); ) {
              const o2 = r[1], i2 = r[2], a = r[3].split(","), s = o2 ? `${o2} ${i2};` : "";
              let u = t2[n2].body, l = "";
              t2[n2].params.forEach((e3, t3) => {
                e3 && (l += `${e3.type} ${e3.name} = ${a[t3]};
`);
              }), u = `${l}
 ${u}`, u = u.replace("return", `${i2} = `);
              const c = `
      ${s}
      {
        ${u}
      }
      `;
              e2 = e2.replace(r[0], c);
            }
          }
          return e2.replace(n, "");
        };
      }, 8897: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.GlslPreprocessor = void 0;
        const r = n(1997), o = n(3878), i = n(1248), a = n(6757);
        t.GlslPreprocessor = class {
          constructor(e2, t2, n2, o2) {
            this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(e2, t2, n2, o2), Object.keys(i.glslRegistry).forEach((e3) => {
              const t3 = new i.glslRegistry[e3](this.context);
              this.libs[e3] = t3;
            });
            const a2 = this.glslLibRoutineDependencyGraph;
            for (const e3 in this.libs) {
              const t3 = this.libs[e3].getFunctions();
              for (const n3 in t3) {
                const o3 = e3 + "." + n3;
                let i2;
                a2[o3] ? (i2 = a2[o3], i2.routineBody = t3[n3].routineBody) : (i2 = new r.GlslLibRoutineNode(o3, t3[n3].routineBody), a2[o3] = i2);
                const s = t3[n3].dependencies;
                if (s)
                  for (let e4 = 0; e4 < s.length; ++e4)
                    if (a2[s[e4]])
                      i2.addDependency(a2[s[e4]]);
                    else {
                      const t4 = new r.GlslLibRoutineNode(s[e4]);
                      a2[s[e4]] = t4, i2.addDependency(t4);
                    }
              }
            }
          }
          preprocess() {
            const e2 = this.context.programInfo;
            let t2 = e2.shaderSource;
            return this.context.programInfo.hasMain || (t2 = `${t2}
      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), t2 = (0, o.replaceInlines)(t2), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(e2.inputNames, e2.variables)}
    ${this.getImports(t2)}
    ${t2}`;
          }
          getImports(e2) {
            const t2 = this.selectGlslLibRoutinesToBeIncluded(e2);
            if (0 === t2.length)
              return "";
            let n2 = "";
            for (let e3 = 0; e3 < t2.length; ++e3) {
              if (!t2[e3].routineBody)
                throw new Error(`Missing body for the Glsl Library routine: ${t2[e3].name}`);
              n2 += t2[e3].routineBody + "\n";
            }
            return n2;
          }
          selectGlslLibRoutinesToBeIncluded(e2) {
            const t2 = [];
            return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n2) => {
              const r2 = n2.split(".")[1];
              -1 !== e2.indexOf(r2) && t2.push(this.glslLibRoutineDependencyGraph[n2]);
            }), r.TopologicalSortGlslRoutines.returnOrderedNodes(t2);
          }
          getUniforms(e2, t2) {
            const n2 = [];
            if (e2)
              for (const t3 of e2)
                n2.push(`uniform sampler2D ${t3};`);
            if (t2)
              for (const e3 of t2)
                n2.push(`uniform ${e3.type} ${e3.name}${e3.arrayLength ? `[${e3.arrayLength}]` : ""};`);
            return n2.join("\n");
          }
        };
      }, 1248: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.glslRegistry = void 0;
        const r = n(6859), o = n(1371), i = n(2691), a = n(9183), s = n(9314);
        t.glslRegistry = { encoding: o.EncodingGlslLib, fragcolor: i.FragColorGlslLib, vec: s.VecGlslLib, shapeUtils: a.ShapeUtilsGlslLib, coordinates: r.CoordsGlslLib };
      }, 9183: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ShapeUtilsGlslLib = void 0;
        const r = n(1997);
        class o extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
          }
          getCustomTypes() {
            return {};
          }
          bcastIndex() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = {};
            return this.context.programInfo.inputNames.forEach((n2, o2) => {
              const i = this.context.inputTextureLayouts[o2].unpackedShape;
              if (i.length <= e2) {
                const o3 = i.length, a = e2 - o3, s = `bcastIndices_${n2}`;
                let u = "";
                for (let e3 = 0; e3 < o3; ++e3)
                  u += `
          realIndices[${e3}] = int( mod(float(bcastedIndices[${a + e3}]), ${i[e3]}.0) );
          `;
                const l = `
        void ${s} (int bcastedIndices[${e2}], out int realIndices[${o3}]) {
          ${u}
        }
        `;
                t2[s] = new r.GlslLibRoutine(l);
              }
            }), t2;
          }
          bcastMatmulIndex() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = {};
            return this.context.programInfo.inputNames.forEach((n2, o2) => {
              const i = this.context.inputTextureLayouts[o2].shape;
              if (!(i.length < 2 || i.length > e2)) {
                const o3 = i.length, a = e2 - o3, s = `bcastMatmulIndices_${n2}`;
                let u = "";
                for (let e3 = 0; e3 < o3 - 2; ++e3)
                  u += `
          realIndices[${e3}] = int( mod(float(bcastedIndices[${a + e3}]), ${i[e3]}.0) );
          `;
                const l = `
        void ${s}(int bcastedIndices[${e2}], out int realIndices[${o3}]) {
          ${u}
          realIndices[${o3 - 1}] = bcastedIndices[${e2 - 1}];
          realIndices[${o3 - 2}] = bcastedIndices[${e2 - 2}];
        }
        `;
                t2[s] = new r.GlslLibRoutine(l);
              }
            }), t2;
          }
          indicesToOffset() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const i = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = i.length;
              let u = `indicesToOffset_${t2}`;
              e2[u] = new r.GlslLibRoutine(o.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${t2}_T`, e2[u] = new r.GlslLibRoutine(o.indexToOffsetSingle(u, s, a.slice().reverse()));
            }), e2;
          }
          static indexToOffsetSingle(e2, t2, n2) {
            let r2 = "";
            for (let e3 = t2 - 1; e3 >= 0; --e3)
              r2 += `
        offset += indices[${e3}] * ${n2[e3]};
        `;
            return `
      int ${e2}(int indices[${t2}]) {
        int offset = 0;
        ${r2}
        return offset;
      }
      `;
          }
          offsetToIndices() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const i = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = i.length;
              let u = `offsetToIndices_${t2}`;
              e2[u] = new r.GlslLibRoutine(o.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${t2}_T`, e2[u] = new r.GlslLibRoutine(o.offsetToIndicesSingle(u, s, a.slice().reverse()));
            }), e2;
          }
          static offsetToIndicesSingle(e2, t2, n2) {
            const r2 = [];
            for (let e3 = 0; e3 < t2 - 1; ++e3)
              r2.push(`
      indices[${e3}] = offset / ${n2[e3]};`), r2.push(`
        offset -= indices[${e3}] * ${n2[e3]};`);
            return r2.push(`
      indices[${t2 - 1}] = offset;`), `
      void ${e2}(int offset, out int indices[${t2}]) {
        ${r2.join("")}
      }
      `;
          }
          incrementIndices() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const o2 = this.context.inputTextureLayouts[n2].shape, i = o2.length, a = `incrementIndices_${t2}`;
              let s = "";
              for (let e3 = 0; e3 < i; ++e3)
                s += `
        shape[${e3}] = ${o2[e3]};`;
              const u = `
        void ${a}(int axis, out int indices[${i}]) {
          int shape[${i}];
          ${s};
          for(int i = ${i} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
              e2[a] = new r.GlslLibRoutine(u);
            }), e2;
          }
        }
        t.ShapeUtilsGlslLib = o;
      }, 6757: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getDefaultFragShaderMain = t.getFragShaderPreamble = t.getVertexShaderSource = t.getGlsl = void 0;
        const n = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
        function o(e2) {
          return 1 === e2 ? n : r;
        }
        t.getGlsl = o, t.getVertexShaderSource = function(e2) {
          const t2 = o(e2);
          return `${t2.version}
      precision highp float;
      ${t2.attribute} vec3 position;
      ${t2.attribute} vec2 textureCoord;

      ${t2.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
        }, t.getFragShaderPreamble = function(e2) {
          const t2 = o(e2);
          return `${t2.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t2.varyingFrag} vec2 TexCoords;
    ${t2.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
        }, t.getDefaultFragShaderMain = function(e2, t2) {
          return `
  void main() {
    int indices[${t2}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${o(e2).output} = result;
  }
  `;
        };
      }, 9314: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.VecGlslLib = void 0;
        const r = n(1997);
        class o extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getCustomTypes() {
            return {};
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
          }
          binaryVecFunctions() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n2 = {};
            for (const o2 in t2) {
              const i = `${o2}Vec`;
              let a = "";
              for (let n3 = 0; n3 < e2; ++n3)
                a += `
          dest[${n3}] ${t2[o2]} src[${n3}];
          `;
              const s = `
        void ${i}(int src[${e2}], out int dest[${e2}]) {
          ${a}
        }
        `;
              n2[i] = new r.GlslLibRoutine(s);
            }
            return n2;
          }
          copyVec() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = "";
            for (let n3 = 0; n3 < e2; ++n3)
              t2 += `
        dest[${n3}] = src[${n3}];
        `;
            const n2 = `
      void copyVec(int src[${e2}], out int dest[${e2}]) {
        ${t2}
      }
      `;
            return { copyVec: new r.GlslLibRoutine(n2) };
          }
          setVecItem() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = `
        if(index < 0)
            index =${e2} + index;
        if (index == 0)
            m[0] = value;
        `;
            for (let n3 = 1; n3 < e2 - 1; ++n3)
              t2 += `
        else if (index == ${n3})
            m[${n3}] = value;
            `;
            t2 += `
        else
            m[${e2 - 1}] = value;
        `;
            const n2 = `
      void setVecItem(out int m[${e2}], int index, int value) {
        ${t2}
      }
        `;
            return { setVecItem: new r.GlslLibRoutine(n2) };
          }
          getVecItem() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = `
        if(index < 0)
            index = ${e2} + index;
        if (index == 0)
            return m[0];
      `;
            for (let n3 = 1; n3 < e2 - 1; ++n3)
              t2 += `
        else if (index == ${n3})
            return m[${n3}];
      `;
            t2 += `
        else
            return m[${e2 - 1}];
        `;
            const n2 = `
      int getVecItem(int m[${e2}], int index) {
        ${t2}
      }
    `;
            return { getVecItem: new r.GlslLibRoutine(n2) };
          }
        }
        t.VecGlslLib = o;
      }, 7860: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLInferenceHandler = void 0;
        const r = n(1315), o = n(9240), i = n(7273), a = n(9), s = n(7379), u = n(2488), l = n(540), c = n(3314), p = n(5639);
        t.WebGLInferenceHandler = class {
          constructor(e2) {
            this.session = e2, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          calculateTextureWidthAndHeight(e2, t2) {
            return (0, c.calculateTextureWidthAndHeight)(this.session.layoutStrategy, e2, t2);
          }
          executeProgram(e2, t2) {
            if (t2.length < e2.inputNames.length)
              throw new Error(`Input size mustn't be less than ${e2.inputNames.length}.`);
            if (e2.inputNames.length !== e2.inputTypes.length)
              throw new Error("input names size does not match input types");
            const n2 = [];
            for (let r3 = 0; r3 < e2.inputNames.length; ++r3)
              n2[r3] = this.getOrCreateTextureData(t2[r3], e2.inputTypes[r3]);
            const r2 = ((e3, t3) => {
              const n3 = t3.map((e4) => `${e4.unpackedShape.join(",")};${e4.width}x${e4.height}`).join("_");
              let r3 = e3.name;
              return e3.cacheHint && (r3 += "[" + e3.cacheHint + "]"), r3 += ":" + n3, r3;
            })(e2, n2);
            let o2 = this.session.programManager.getArtifact(r2);
            const i2 = o2 ? o2.programInfo : "function" == typeof e2.get ? e2.get() : e2, a2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i2.output.dims, i2.output.textureType), s2 = this.createTextureData(a2, i2.output.type);
            return o2 || (o2 = this.session.programManager.build(i2, n2, s2), this.session.programManager.setArtifact(r2, o2)), this.runProgram(o2, n2, s2), s2;
          }
          run(e2, t2) {
            return this.executeProgram(e2, t2).tensor;
          }
          runProgram(e2, t2, n2) {
            for (let n3 = 0; n3 < t2.length; ++n3)
              if (!!t2[n3].isPacked != (e2.programInfo.inputTypes[n3] === p.TextureType.packed))
                throw new Error(`input[${n3}] property packed inconsistent`);
            if (!!n2.isPacked != (e2.programInfo.output.textureType === p.TextureType.packed))
              throw new Error("output property packed inconsistent");
            this.session.programManager.run(e2, t2, n2);
          }
          getOrCreateTextureData(e2, t2) {
            let n2 = this.getTextureData(e2.dataId, t2 === p.TextureType.packed);
            if (!n2 && (n2 = this.getTextureData(e2.dataId, t2 !== p.TextureType.packed), n2))
              return t2 === p.TextureType.packed ? this.pack(n2) : this.unpack(n2);
            if (!n2) {
              const r2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, e2.dims, t2);
              if (t2 === p.TextureType.packedLastDimension) {
                const n3 = 1, r3 = 4, o2 = e2.dims;
                if (4 === o2.length) {
                  const i2 = [o2[0], Math.ceil(o2[1] * o2[2] * o2[3] / r3)], a2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i2, t2);
                  let s2 = e2.numberData;
                  if (o2[1] * o2[2] * o2[3] % r3 != 0) {
                    const t3 = o2[0], i3 = o2[1] * o2[2] * o2[3], a3 = Math.ceil(i3 * n3 / r3) * r3;
                    s2 = new Float32Array(t3 * a3);
                    for (let r4 = 0; r4 < t3; ++r4) {
                      const t4 = r4 * i3, o3 = r4 * a3 + r4 % n3 * i3;
                      s2.set(e2.numberData.subarray(t4, t4 + i3), o3);
                    }
                  }
                  return this.createTextureData(a2, e2.type, s2, e2, 1);
                }
              }
              if (t2 === p.TextureType.packed) {
                const t3 = (0, c.createTextureLayoutFromShape)(this.session.layoutStrategy, e2.dims, 1, [], { reverseWH: true }), r3 = this.createTextureData(t3, e2.type, e2.numberData, e2, 1);
                n2 = this.pack(r3);
              } else
                n2 = this.createTextureData(r2, e2.type, e2.numberData, e2, 1);
            }
            return n2;
          }
          createTextureDataFromLayoutBindTensor(e2, t2, n2, r2) {
            return this.createTextureData(e2, t2, n2, r2, 1);
          }
          createTextureData(e2, t2, n2, o2, i2) {
            r.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(e2)}]`);
            const a2 = this.session.textureManager.createTextureFromLayout(t2, e2, n2, i2);
            return this.createTextureDataFromTexture(e2, t2, a2, o2);
          }
          reshapeUnpacked(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.unpacked), r2 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: i.ShapeUtil.computeStrides(t2), unpackedShape: t2 };
            return this.createTextureDataFromTexture(r2, e2.type, n2.texture).tensor;
          }
          reshapePacked(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.packed);
            if ((0, s.isReshapeCheap)(e2.dims, t2)) {
              const r3 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: i.ShapeUtil.computeStrides(t2), unpackedShape: t2, isPacked: true };
              return this.createTextureDataFromTexture(r3, e2.type, n2.texture).tensor;
            }
            const r2 = (0, s.processDims3D)(e2.dims), o2 = (0, s.processDims3D)(t2), a2 = this.reshapePacked(e2, r2), u2 = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a2, o2), [a2]);
            return this.reshapePacked(u2, t2);
          }
          cast(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.unpacked);
            return this.createTextureDataFromTexture(n2, t2, n2.texture).tensor;
          }
          createTextureDataFromTexture(e2, t2, n2, r2, i2) {
            const a2 = Object.assign(Object.assign({}, e2), { tensor: r2 || new o.Tensor(e2.unpackedShape, t2, (e3) => this.readTexture(a2), async (e3) => this.readTextureAsync(a2), void 0, i2), texture: n2 });
            return this.setTextureData(a2.tensor.dataId, a2, e2.isPacked), a2;
          }
          getTextureData(e2, t2 = false) {
            return this.session.isInitializer(e2) ? this.session.getTextureData(e2, t2) : t2 ? this.packedTextureDataCache.get(e2) : this.unpackedTextureDataCache.get(e2);
          }
          setTextureData(e2, t2, n2 = false) {
            this.session.isInitializer(e2) ? this.session.setTextureData(e2, t2, n2) : (n2 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e2, t2);
          }
          isTextureLayoutCached(e2, t2 = false) {
            return !!this.getTextureData(e2.dataId, t2);
          }
          dispose() {
            this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e2) => this.session.textureManager.releaseTexture(e2)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((e2) => this.session.textureManager.releaseTexture(e2)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          readTexture(e2) {
            return e2.isPacked ? this.readTexture(this.unpack(e2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e2, e2.tensor.type, e2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e2));
          }
          async readTextureAsync(e2) {
            return e2.isPacked ? this.readTextureAsync(this.unpack(e2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e2, e2.tensor.type, e2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e2));
          }
          pack(e2) {
            return this.executeProgram((0, a.createPackProgramInfoLoader)(this, e2.tensor), [e2.tensor]);
          }
          unpack(e2) {
            return this.executeProgram((0, l.createUnpackProgramInfoLoader)(this, e2.tensor), [e2.tensor]);
          }
        };
      }, 4110: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), i = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return o(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WEBGL_OP_RESOLVE_RULES = void 0;
        const a = n(8817), s = i(n(5194)), u = n(4752), l = n(6668), c = n(9754), p = n(5042), d = n(6742), f = n(4125), h = n(6149), g = n(5378), b = n(6981), m = n(7413), y = n(7006), v = n(8276), _ = n(5565), w = n(2834), T = n(1010), x = n(8126), O = n(2801), S = n(565), A = n(2444), P = n(815), I = n(564), E = n(5416), D = n(1240), $ = n(5944), k = n(5707), F = i(n(9087)), N3 = n(7862), R = n(3980);
        t.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", F.abs], ["Acos", "", "7+", F.acos], ["Add", "", "7+", s.add], ["And", "", "7+", s.and], ["Asin", "", "7+", F.asin], ["Atan", "", "7+", F.atan], ["AveragePool", "", "7+", w.averagePool, w.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a.batchNormalization, a.parseBatchNormalizationAttributes], ["Cast", "", "6+", u.cast, u.parseCastAttributes], ["Ceil", "", "6+", F.ceil], ["Clip", "", "6-10", F.clip, F.parseClipAttributes], ["Clip", "", "11+", F.clipV11], ["Concat", "", "4+", l.concat, l.parseConcatAttributes], ["Conv", "", "1+", c.conv, c.parseConvAttributes], ["ConvTranspose", "", "1+", p.convTranspose, p.parseConvTransposeAttributes], ["Cos", "", "7+", F.cos], ["Div", "", "7+", s.div], ["Dropout", "", "7+", F.identity], ["DepthToSpace", "", "1+", d.depthToSpace, d.parseDepthToSpaceAttributes], ["Equal", "", "7+", s.equal], ["Elu", "", "6+", F.elu, F.parseEluAttributes], ["Exp", "", "6+", F.exp], ["Flatten", "", "1+", f.flatten, f.parseFlattenAttributes], ["Floor", "", "6+", F.floor], ["FusedConv", "com.microsoft", "1+", c.conv, c.parseConvAttributes], ["Gather", "", "1+", h.gather, h.parseGatherAttributes], ["Gemm", "", "7-10", g.gemm, g.parseGemmAttributesV7], ["Gemm", "", "11+", g.gemm, g.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", w.globalAveragePool, w.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", w.globalMaxPool], ["Greater", "", "7+", s.greater], ["Identity", "", "1+", F.identity], ["ImageScaler", "", "1+", b.imageScaler, b.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", m.instanceNormalization, m.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", F.leakyRelu, F.parseLeakyReluAttributes], ["Less", "", "7+", s.less], ["LRN", "", "1+", y.lrn, y.parseLrnAttributes], ["Log", "", "6+", F.log], ["MatMul", "", "1+", v.matMul, v.parseMatMulAttributes], ["MaxPool", "", "1+", w.maxPool, w.parseMaxPoolAttributes], ["Mul", "", "7+", s.mul], ["Neg", "", "6+", F.neg], ["Not", "", "1+", F.not], ["Or", "", "7+", s.or], ["Pad", "", "2-10", _.padV2, _.parsePadAttributesV2], ["Pad", "", "11+", _.padV11, _.parsePadAttributesV11], ["Pow", "", "7+", s.pow], ["PRelu", "", "7+", s.pRelu], ["ReduceLogSum", "", "1+", T.reduceLogSum, T.parseReduceAttributes], ["ReduceMax", "", "1+", T.reduceMax, T.parseReduceAttributes], ["ReduceMean", "", "1+", T.reduceMean, T.parseReduceAttributes], ["ReduceMin", "", "1+", T.reduceMin, T.parseReduceAttributes], ["ReduceProd", "", "1+", T.reduceProd, T.parseReduceAttributes], ["ReduceSum", "", "1-12", T.reduceSum, T.parseReduceAttributes], ["ReduceSumSquare", "", "1+", T.reduceLogSumSquare, T.parseReduceAttributes], ["Relu", "", "6+", F.relu], ["Reshape", "", "5+", x.reshape], ["Resize", "", "10", O.resize, O.parseResizeAttributesV10], ["Resize", "", "11+", O.resize, O.parseResizeAttributesV11], ["Shape", "", "1+", S.shape], ["Sigmoid", "", "6+", F.sigmoid], ["Sin", "", "7+", F.sin], ["Slice", "", "10+", A.sliceV10], ["Slice", "", "1-9", A.slice, A.parseSliceAttributes], ["Softmax", "", "1-12", P.softmax, P.parseSoftmaxAttributes], ["Softmax", "", "13+", P.softmaxV13, P.parseSoftmaxAttributesV13], ["Split", "", "2-12", I.split, I.parseSplitAttributes], ["Sqrt", "", "6+", F.sqrt], ["Squeeze", "", "1-12", E.squeeze, E.parseSqueezeAttributes], ["Squeeze", "", "13+", E.squeezeV13], ["Sub", "", "7+", s.sub], ["Sum", "", "6+", D.sum], ["Tan", "", "7+", F.tan], ["Tanh", "", "6+", F.tanh], ["Tile", "", "6+", $.tile], ["Transpose", "", "1+", k.transpose, k.parseTransposeAttributes], ["Upsample", "", "7-8", R.upsample, R.parseUpsampleAttributesV7], ["Upsample", "", "9", R.upsample, R.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", N3.unsqueeze, N3.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", N3.unsqueezeV13], ["Xor", "", "7+", s.xor]];
      }, 8817: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseBatchNormalizationAttributes = t.batchNormalization = void 0;
        const r = n(4910), o = n(6757), i = n(5639), a = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] };
        t.batchNormalization = (e2, t2, n2) => (u(t2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(e2, t2, n2) }), t2)]), t.parseBatchNormalizationAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("epsilon", 1e-5), n2 = e2.attributes.getFloat("momentum", 0.9), o2 = e2.attributes.getInt("spatial", 1);
          return (0, r.createAttributeWithCacheKey)({ epsilon: t2, momentum: n2, spatial: o2 });
        };
        const s = (e2, t2, n2) => {
          const r2 = (0, o.getGlsl)(e2.session.backend.glContext.version), s2 = t2[0].dims.length, [u2, l] = e2.calculateTextureWidthAndHeight(t2[1].dims, i.TextureType.unpacked), c = `
  float process(int[${s2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u2}, ${l});
    float scale = getColorAsFloat(${r2.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r2.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r2.texture2D}(Variance, position));
    float b = getColorAsFloat(${r2.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n2.epsilon})) ) + b;
  }`;
          return Object.assign(Object.assign({}, a), { output: { dims: t2[0].dims, type: t2[0].type, textureType: i.TextureType.unpacked }, shaderSource: c });
        }, u = (e2) => {
          if (!e2 || 5 !== e2.length)
            throw new Error("BatchNormalization requires 5 inputs.");
          const t2 = e2[0], n2 = e2[1], r2 = e2[2], o2 = e2[3], i2 = e2[4];
          if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length || 1 !== o2.dims.length || 1 !== i2.dims.length)
            throw new Error("invalid input shape.");
          if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1] || o2.dims[0] !== t2.dims[1] || i2.dims[0] !== t2.dims[1])
            throw new Error("invalid input shape.");
          if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type || "float32" !== o2.type && "float64" !== o2.type || "float32" !== i2.type && "float64" !== i2.type)
            throw new Error("invalid input tensor types.");
        };
      }, 5194: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.xor = t.sub = t.pRelu = t.pow = t.or = t.mul = t.less = t.greater = t.equal = t.div = t.and = t.add = t.glslPRelu = t.glslPow = t.glslXor = t.glslOr = t.glslAnd = t.glslLess = t.glslGreater = t.glslEqual = t.glslSub = t.glslMul = t.glslDiv = t.glslAdd = void 0;
        const r = n(7273), o = n(1997), i = n(6757), a = n(5639);
        function s() {
          const e2 = "add_";
          return { body: `
  float ${e2}(float a, float b) {
    return a + b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function u() {
          const e2 = "div_";
          return { body: `
  float ${e2}(float a, float b) {
    return a / b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function l() {
          const e2 = "mul_";
          return { body: `
  float ${e2}(float a, float b) {
    return a * b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function c() {
          const e2 = "sub_";
          return { body: `
  float ${e2}(float a, float b) {
    return a - b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function p() {
          const e2 = "equal_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function d() {
          const e2 = "greater_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function f() {
          const e2 = "less_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function h() {
          const e2 = "and_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function g() {
          const e2 = "or_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function b() {
          const e2 = "xor_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function m() {
          return function(e2) {
            const t2 = `${e2}_`;
            return { body: `
  float ${t2}(float a, float b) {
    return ${e2}(a, b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return ${e2}(v1, v2);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }("pow");
        }
        function y() {
          const e2 = "prelu_";
          return { body: `
  float ${e2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        t.glslAdd = s, t.glslDiv = u, t.glslMul = l, t.glslSub = c, t.glslEqual = p, t.glslGreater = d, t.glslLess = f, t.glslAnd = h, t.glslOr = g, t.glslXor = b, t.glslPow = m, t.glslPRelu = y;
        const v = (e2, t2, n2, r2 = t2[0].type, o2) => {
          const i2 = e2.session.pack ? a.TextureType.packed : a.TextureType.unpacked;
          return { name: n2.name, inputNames: ["A", "B"], inputTypes: [i2, i2], cacheHint: o2, get: () => _(e2, t2, n2, r2) };
        }, _ = (e2, t2, n2, o2 = t2[0].type) => {
          const s2 = e2.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u2 = !r.ShapeUtil.areEqual(t2[0].dims, t2[1].dims);
          let l2 = t2[0].dims;
          const c2 = e2.session.pack;
          if (u2) {
            const a2 = r.BroadcastUtil.calcShape(t2[0].dims, t2[1].dims, false);
            if (!a2)
              throw new Error("Can't perform binary op on the given tensors");
            l2 = a2;
            const u3 = l2.length, p3 = 0 !== t2[0].dims.length ? t2[0].dims.length : 1, d3 = 0 !== t2[1].dims.length ? t2[1].dims.length : 1, f2 = 0 !== t2[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h2 = 0 !== t2[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g2 = (0, i.getGlsl)(e2.session.backend.glContext.version), b2 = c2 ? `
      ${n2.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n2.name}(a, b);
        ${g2.output} = result;
      }` : `
      ${n2.body}
      float process(int indices[${u3}]) {
        int aindices[${p3}];
        int bindices[${d3}];
        ${f2}
        ${h2}
        return ${n2.name}(_A(aindices), _B(bindices));
      }`;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: l2, type: o2, textureType: s2 }, shaderSource: b2, hasMain: c2 };
          }
          const p2 = (0, i.getGlsl)(e2.session.backend.glContext.version), d2 = `
    ${n2.body}
    void main() {
      vec4 v1 = ${p2.texture2D}(A, TexCoords);
      vec4 v2 = ${p2.texture2D}(B, TexCoords);
      vec4 result = ${n2.name}(v1, v2);
      ${p2.output} = result;
    }
    `;
          return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: t2[0].dims, type: o2, textureType: s2 }, shaderSource: d2, hasMain: true };
        };
        t.add = (e2, t2) => [e2.run(v(e2, t2, s()), t2)], t.and = (e2, t2) => [e2.run(v(e2, t2, h(), "bool"), t2)], t.div = (e2, t2) => [e2.run(v(e2, t2, u()), t2)], t.equal = (e2, t2) => [e2.run(v(e2, t2, p(), "bool"), t2)], t.greater = (e2, t2) => [e2.run(v(e2, t2, d(), "bool"), t2)], t.less = (e2, t2) => [e2.run(v(e2, t2, f(), "bool"), t2)], t.mul = (e2, t2) => [e2.run(v(e2, t2, l()), t2)], t.or = (e2, t2) => [e2.run(v(e2, t2, g(), "bool"), t2)], t.pow = (e2, t2) => [e2.run(v(e2, t2, m()), t2)], t.pRelu = (e2, t2) => [e2.run(v(e2, t2, y()), t2)], t.sub = (e2, t2) => [e2.run(v(e2, t2, c()), t2)], t.xor = (e2, t2) => [e2.run(v(e2, t2, b(), "bool"), t2)];
      }, 4752: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseCastAttributes = t.cast = void 0;
        const r = n(7273);
        t.cast = (e2, t2, n2) => (o(t2), [e2.cast(t2[0], n2)]), t.parseCastAttributes = (e2) => r.ProtoUtil.tensorDataTypeFromProto(e2.attributes.getInt("to"));
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Cast requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 4595: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedConcatProgramInfoLoader = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614);
        t.createPackedConcatProgramInfoLoader = (e2, t2, n2) => {
          const u = (l = t2.length, c = n2.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: l }, (e3, t3) => `X${t3}`), inputTypes: Array(l).fill(o.TextureType.packed), cacheHint: c });
          var l, c;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, u2) => {
            const l2 = n3[0].dims.slice();
            if (u2 >= l2.length || u2 < -1 * l2.length)
              throw new Error("axis specified for concat doesn't match input dimensionality");
            u2 < 0 && (u2 = l2.length + u2);
            const c2 = l2.slice(0);
            for (let e4 = 1; e4 < n3.length; e4++) {
              const t4 = n3[e4].dims.slice();
              for (let e5 = 0; e5 < l2.length; e5++)
                if (e5 === u2)
                  c2[u2] += t4[e5];
                else if (l2[e5] !== t4[e5])
                  throw new Error("non concat dimensions must match");
            }
            const p = c2.length, d = (0, a.getChannels)("coords", p), f = (0, i.getCoordsDataType)(p), h = (0, a.unpackFromChannel)(), g = n3.map((e4) => e4.dims), b = (0, i.getGlChannels)(p), m = new Array(g.length - 1);
            m[0] = g[0][u2];
            for (let e4 = 1; e4 < m.length; e4++)
              m[e4] = m[e4 - 1] + g[e4][u2];
            const y = b[u2], v = b.slice(-2), _ = b.join();
            let w = `if (${y} < ${m[0]}) {
        return getChannel(
            getX0(${_}), vec2(${v.join()}));
        }`;
            for (let e4 = 1; e4 < m.length; e4++) {
              const t4 = m[e4 - 1];
              w += `
            if (${y} < ${m[e4]}  && ${y} >= ${m[e4 - 1]}) {
              return getChannel(
                getX${e4}(${s(b, y, t4)}),
                vec2(${s(v, y, t4)}));
            }`;
            }
            const T = m.length, x = m[m.length - 1];
            w += `
            return getChannel(
              getX${T}(${s(b, y, x)}),
              vec2(${s(v, y, x)}));`;
            const O = (0, r.getGlsl)(e3.session.backend.glContext.version), S = `
          ${h}
          float getValue(${b.map((e4) => "int " + e4)}) {
            ${w}
          }

          void main() {
            ${f} coords = getOutputCoords();
            int lastDim = coords.${b[p - 1]};
            coords.${b[p - 1]} = coords.${b[p - 2]};
            coords.${b[p - 2]} = lastDim;

            vec4 result = vec4(getValue(${d}), 0., 0., 0.);

            ${d[p - 1]} = ${d[p - 1]} + 1;
            if (${d[p - 1]} < ${c2[p - 1]}) {
              result.g = getValue(${d});
            }

            ${d[p - 2]} = ${d[p - 2]} + 1;
            if (${d[p - 2]} < ${c2[p - 2]}) {
              result.a = getValue(${d});
            }

            ${d[p - 1]} = ${d[p - 1]} - 1;
            if (${d[p - 2]} < ${c2[p - 2]} &&
                ${d[p - 1]} < ${c2[p - 1]}) {
              result.b = getValue(${d});
            }
            ${O.output} = result;
          }
        `;
            return Object.assign(Object.assign({}, t3), { output: { dims: c2, type: n3[0].type, textureType: o.TextureType.packed }, shaderSource: S, hasMain: true });
          })(e2, u, t2, n2.axis) });
        };
        const s = (e2, t2, n2) => {
          const r2 = e2.indexOf(t2);
          return e2.map((e3, t3) => t3 === r2 ? `${e3} - ${n2}` : e3).join();
        };
      }, 6668: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConcatAttributes = t.concat = void 0;
        const r = n(4910), o = n(5639), i = n(4595);
        t.concat = (e2, t2, n2) => (p(t2), e2.session.pack && t2[0].dims.length > 1 ? [e2.run((0, i.createPackedConcatProgramInfoLoader)(e2, t2, n2), t2)] : [e2.run(a(e2, t2, n2), t2)]);
        const a = (e2, t2, n2) => {
          const r2 = (i2 = t2.length, a2 = n2.cacheKey, { name: "Concat", inputNames: Array.from({ length: i2 }, (e3, t3) => `X${t3}`), inputTypes: Array(i2).fill(o.TextureType.unpacked), cacheHint: a2 });
          var i2, a2;
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const i3 = n3[0].dims.slice();
            if (r3 >= i3.length || r3 < -1 * i3.length)
              throw new Error("axis specified for concat doesn't match input dimensionality");
            r3 < 0 && (r3 = i3.length + r3);
            const a3 = i3.slice(0);
            for (let e4 = 1; e4 < n3.length; e4++) {
              const t4 = n3[e4].dims.slice();
              for (let e5 = 0; e5 < i3.length; e5++)
                if (e5 === r3)
                  a3[r3] += t4[e5];
                else if (i3[e5] !== t4[e5])
                  throw new Error("non concat dimensions must match");
            }
            const p2 = a3.length, d = new Array(n3.length);
            let f = 0;
            for (let e4 = 0; e4 < d.length; ++e4)
              f += n3[e4].dims[r3], d[e4] = f;
            let h = "";
            h = n3.length < 5 ? s(d) : u(d);
            const g = `
        ${l(n3.length, p2)}
        ${c(d)}
        ${h}
        float process(int indices[${p2}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r3}]);

          if(textureIndex != 0) {
            indices[${r3}] = indices[${r3}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: a3, type: n3[0].type, textureType: o.TextureType.unpacked }, shaderSource: g });
          })(0, r2, t2, n2.axis) });
        }, s = (e2) => `int getTextureWhereDataResides(int index) {
      ${e2.map((e3, t2) => `if(index<${e3}) {return ${t2};}
`).join("")}
    }`, u = (e2) => s(e2), l = (e2, t2) => {
          const n2 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t2}]) {`];
          for (let t3 = 0; t3 < e2; ++t3)
            0 === t3 ? n2.push(`	if (textureIndex == ${t3}) { return _X${t3}(indices); }`) : t3 === e2 - 1 ? n2.push(`	else { return _X${t3}(indices); }`) : n2.push(`	else if (textureIndex == ${t3}) { return _X${t3}(indices); }`);
          return n2.push("	}"), n2.join("\n");
        }, c = (e2) => {
          const t2 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
          for (let n2 = 0; n2 < e2.length; ++n2)
            0 === n2 ? t2.push(`	if (index == ${n2}) { return ${e2[n2]}; }`) : n2 === e2.length - 1 ? t2.push(`	else { return ${e2[n2]}; }`) : t2.push(`	else if (index == ${n2}) { return ${e2[n2]}; }`);
          return t2.push("	}"), t2.join("\n");
        };
        t.parseConcatAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis") });
        const p = (e2) => {
          if (!e2 || e2.length < 1)
            throw new Error("too few inputs");
          const t2 = e2[0].type, n2 = e2[0].dims.length;
          if ("string" === t2)
            throw new Error("string tensor is not supported yet");
          for (const r2 of e2) {
            if (r2.type !== t2)
              throw new Error("input tensors should be one type");
            if (r2.dims.length !== n2)
              throw new Error("input tensors should have the same shape");
          }
        };
      }, 7825: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackedGroupedConvProgramInfoLoader = void 0;
        const r = n(1315), o = n(6757), i = n(5639), a = n(9754), s = n(2150);
        t.createUnpackedGroupedConvProgramInfoLoader = (e2, t2, n2) => {
          const u = (l = t2.length > 2, c = n2.cacheKey, { name: "GroupedConv", inputNames: l ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: l ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: c });
          var l, c;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, u2) => {
            const l2 = t3.length > 2 ? "value += getBias(output_channel);" : "", c2 = t3[0].dims.slice(), p = t3[1].dims.slice(), d = p[0] / u2.group;
            r.Logger.verbose("GroupedConv", `autpPad:${u2.autoPad}, dilations:${u2.dilations}, group:${u2.group}, kernelShape:${u2.kernelShape}, pads:${u2.pads}, strides:${u2.strides}`);
            const f = (0, a.calculateOutputShape)(c2, p, u2.dilations, u2.pads, u2.strides), h = (0, o.getGlsl)(e3.session.backend.glContext.version), { activationFunction: g, applyActivation: b } = (0, s.getActivationSnippet)(u2), m = `
  const ivec2 strides = ivec2(${u2.strides[0]}, ${u2.strides[1]});
  const ivec2 pads = ivec2(${u2.pads[0]}, ${u2.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${d};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u2.dilations[0]};

        if (xHeight < 0 || xHeight >= ${c2[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u2.dilations[1]};
          if (xWidth < 0 || xWidth >= ${c2[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${l2}
    ${b}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
            return Object.assign(Object.assign({}, n3), { output: { dims: f, type: t3[0].type, textureType: i.TextureType.unpacked }, shaderSource: m, hasMain: true });
          })(e2, t2, u, n2) });
        };
      }, 7708: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.conv2DPacked = t.conv2DPackedPointwise = void 0;
        const r = n(9754), o = n(5950), i = n(5632);
        t.conv2DPackedPointwise = (e2, t2, n2) => {
          const o2 = t2[0].dims, a = t2[1].dims, s = (0, r.calculateOutputShape)(o2, a, n2.dilations, n2.pads, n2.strides), u = e2.reshapePacked(t2[0], [o2[1], o2[2] * o2[3]]), l = e2.reshapePacked(t2[1], [a[0], a[1]]), c = t2.length > 2 ? [l, u, t2[2]] : [l, u], p = e2.run((0, i.createPackedMatmulProgramInfoLoader)(e2, c, n2), c);
          return e2.reshapePacked(p, s);
        }, t.conv2DPacked = (e2, t2, n2) => {
          const a = t2[0].dims, s = t2[1].dims, u = (0, r.calculateOutputShape)(a, s, n2.dilations, n2.pads, n2.strides), l = e2.run((0, o.createPackedIm2ColProgramInfoLoader)(e2, t2[0], t2[1], u, n2), [t2[0]]), c = e2.reshapePacked(t2[1], [s[0], s[1] * s[2] * s[3]]), p = 3 === t2.length ? [c, l, t2[2]] : [c, l], d = e2.run((0, i.createPackedMatmulProgramInfoLoader)(e2, p, n2), p);
          return e2.reshapePacked(d, u);
        };
      }, 5042: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConvTransposeAttributes = t.convTranspose = void 0;
        const r = n(4910), o = n(6757), i = n(5639), a = n(2150), s = (e2, t2, n2, r2, o2, i2) => (e2 - 1) * t2 + n2 + (r2 - 1) * o2 + 1 - i2, u = (e2, t2, n2, r2, o2) => {
          const i2 = Math.floor(e2 / 2);
          "SAME_UPPER" === t2 ? (n2[r2] = i2, n2[o2] = e2 - i2) : "SAME_LOWER" === t2 && (n2[r2] = e2 - i2, n2[o2] = i2);
        };
        t.convTranspose = (e2, t2, n2) => (d(t2, n2), l(e2, t2, n2));
        const l = (e2, t2, n2) => {
          const r2 = p(n2, t2);
          return [c(e2, t2, r2)];
        }, c = (e2, t2, n2) => e2.run(((e3, t3, n3) => {
          const r2 = (s2 = t3.length > 2, u2 = n3.cacheKey, { name: "ConvTranspose", inputNames: s2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: u2 });
          var s2, u2;
          return Object.assign(Object.assign({}, r2), { get: () => ((e4, t4, n4, r3) => {
            const s3 = t4.length > 2 ? "getB(output_channel)" : "0.0", u3 = t4[0].dims, l2 = t4[1].dims, c2 = l2[1], p2 = l2[0] / r3.group, d2 = [t4[0].dims[0], t4[1].dims[1] * r3.group, ...r3.outputShape], f = (0, o.getGlsl)(e4.session.backend.glContext.version), { activationFunction: h, applyActivation: g } = (0, a.getActivationSnippet)(r3), b = `
  const ivec2 strides = ivec2(${r3.strides[0]}, ${r3.strides[1]});
  const ivec2 pads = ivec2(${r3.pads[0]}, ${r3.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${c2};
    int wOutChannel = output_channel - group_id * ${c2};

    float value = ${s3};
    for (int inChannelOffset = 0; inChannelOffset < ${p2}; inChannelOffset++) {
      int input_channel = group_id * ${p2} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${l2[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${l2[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r3.dilations[0]}, wHOff * ${r3.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u3[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u3[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${f.output} = vec4(value, .0, .0, .0);
  }
`;
            return Object.assign(Object.assign({}, n4), { output: { dims: d2, type: t4[0].type, textureType: i.TextureType.unpacked }, shaderSource: b, hasMain: true });
          })(e3, t3, r2, n3) });
        })(e2, t2, n2), t2), p = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          if (0 === e2.kernelShape.length)
            for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
              n2.push(t2[1].dims[e3]);
          const r2 = e2.pads.slice(), o2 = e2.outputShape.slice();
          ((e3, t3, n3, r3, o3, i3, a2, l2) => {
            const c2 = e3.length - 2, p2 = 0 === l2.length;
            for (let d2 = 0; d2 < c2; ++d2) {
              const f = p2 ? e3[d2 + 2] * i3[d2] : l2[d2], h = s(e3[d2 + 2], i3[d2], o3[d2], t3[d2], n3[d2], f);
              u(h, r3, o3, d2, d2 + c2), p2 && l2.push(i3[d2] * (e3[d2 + 2] - 1) + a2[d2] + (t3[d2] - 1) * n3[d2] + 1 - o3[d2] - o3[d2 + c2]);
            }
          })(t2[0].dims, n2, e2.dilations, e2.autoPad, r2, e2.strides, e2.outputPadding, o2);
          const i2 = Object.assign({}, e2);
          return Object.assign(i2, { kernelShape: n2, pads: r2, outputShape: o2, cacheKey: e2.cacheKey }), i2;
        };
        t.parseConvTransposeAttributes = (e2) => {
          const t2 = e2.attributes, n2 = (0, a.parseInternalActivationAttributes)(t2), o2 = t2.getString("auto_pad", "NOTSET"), i2 = t2.getInts("dilations", [1, 1]), s2 = t2.getInt("group", 1), u2 = t2.getInts("kernel_shape", []), l2 = t2.getInts("output_padding", [0, 0]), c2 = t2.getInts("output_shape", []), p2 = t2.getInts("pads", [0, 0, 0, 0]), d2 = t2.getInts("strides", [1, 1]);
          return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: o2, dilations: i2, group: s2, kernelShape: u2, outputPadding: l2, outputShape: c2, pads: p2, strides: d2 }, n2));
        };
        const d = (e2, t2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Conv requires 2 or 3 inputs");
          if (4 !== e2[0].dims.length || 4 !== e2[1].dims.length)
            throw new Error("currently only support 2-dimensional conv");
          if (e2[0].dims[1] !== e2[1].dims[0])
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          const n2 = e2[1].dims[1] * t2.group;
          if (3 === e2.length && (1 !== e2[2].dims.length || e2[2].dims[0] !== n2))
            throw new Error("invalid bias");
          const r2 = e2[0].dims.length - 2;
          if (t2.dilations.length !== r2)
            throw new Error(`dilations should be ${r2}D`);
          if (t2.strides.length !== r2)
            throw new Error(`strides should be ${r2}D`);
          if (t2.pads.length !== 2 * r2)
            throw new Error(`pads should be ${2 * r2}D`);
          if (t2.outputPadding.length !== r2)
            throw new Error(`output_padding should be ${r2}D`);
          if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e2[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if (0 !== t2.outputShape.length && t2.outputShape.length !== e2[0].dims.length - 2)
            throw new Error("invalid output shape");
          if ("float32" !== e2[0].type || "float32" !== e2[1].type)
            throw new Error("ConvTranspose input(X,W) should be float tensor");
          if (3 === e2.length && "float32" !== e2[2].type)
            throw new Error("ConvTranspose input(bias) should be float tensor");
        };
      }, 9754: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConvAttributes = t.conv = t.calculateOutputShape = void 0;
        const r = n(4910), o = n(7273), i = n(7825), a = n(7708), s = n(3281), u = n(2150), l = n(1625), c = n(8276);
        t.calculateOutputShape = (e2, t2, n2, r2, o2) => {
          const i2 = e2[0], a2 = e2.slice(2), s2 = a2.length, u2 = t2[0], l2 = t2.slice(2).map((e3, t3) => e3 + (e3 - 1) * (n2[t3] - 1)), c2 = a2.map((e3, t3) => e3 + r2[t3] + r2[t3 + s2]).map((e3, t3) => Math.floor((e3 - l2[t3] + o2[t3]) / o2[t3]));
          return [i2, u2].concat(...c2);
        }, t.conv = (e2, t2, n2) => (g(t2, n2), p(e2, t2, n2));
        const p = (e2, t2, n2) => {
          const r2 = h(n2, t2), o2 = e2.session.pack, s2 = 1 === r2.kernelShape[0] && 1 === r2.kernelShape[1];
          return r2.group > 1 ? [e2.run((0, i.createUnpackedGroupedConvProgramInfoLoader)(e2, t2, r2), t2)] : s2 && o2 ? [d(e2, t2, r2)] : o2 && 4 === t2[0].dims.length && 1 === t2[0].dims[0] && !s2 ? [(0, a.conv2DPacked)(e2, t2, r2)] : [f(e2, t2, r2)];
        }, d = (e2, n2, r2) => {
          const o2 = n2[0].dims, i2 = n2[1].dims, a2 = (0, t.calculateOutputShape)(o2, i2, r2.dilations, r2.pads, r2.strides), s2 = e2.reshapeUnpacked(n2[0], [o2[1], o2[2] * o2[3]]), u2 = e2.reshapeUnpacked(n2[1], [i2[0], i2[1]]), l2 = n2.length > 2 ? [u2, s2, n2[2]] : [u2, s2], p2 = e2.run((0, c.createMatmulProgramInfoLoader)(l2, r2), l2);
          return e2.reshapeUnpacked(p2, a2);
        }, f = (e2, n2, r2) => {
          const o2 = n2[0].dims, i2 = n2[1].dims, a2 = (0, t.calculateOutputShape)(o2, i2, r2.dilations, r2.pads, r2.strides), u2 = e2.run((0, l.createIm2ColProgramInfoLoader)(e2, n2[0], n2[1], a2, r2), [n2[0]]), c2 = 3 === n2.length ? [u2, n2[1], n2[2]] : [u2, n2[1]];
          return e2.run((0, s.createDotProductProgramInfoLoader)(e2, n2, a2, r2), c2);
        }, h = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          if (0 === e2.kernelShape.length)
            for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
              n2.push(t2[1].dims[e3]);
          const r2 = e2.pads.slice();
          o.PoolConvUtil.adjustPadsBasedOnAutoPad(t2[0].dims, e2.strides, e2.dilations, n2, r2, e2.autoPad);
          const i2 = Object.assign({}, e2);
          return Object.assign(i2, { kernelShape: n2, pads: r2, cacheKey: e2.cacheKey }), i2;
        };
        t.parseConvAttributes = (e2) => {
          const t2 = e2.attributes, n2 = (0, u.parseInternalActivationAttributes)(t2), o2 = t2.getString("auto_pad", "NOTSET"), i2 = t2.getInts("dilations", [1, 1]), a2 = t2.getInt("group", 1), s2 = t2.getInts("kernel_shape", []), l2 = t2.getInts("pads", [0, 0, 0, 0]), c2 = t2.getInts("strides", [1, 1]);
          return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: o2, dilations: i2, group: a2, kernelShape: s2, pads: l2, strides: c2 }, n2));
        };
        const g = (e2, t2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Conv requires 2 or 3 inputs");
          if (4 !== e2[0].dims.length || 4 !== e2[1].dims.length)
            throw new Error("currently only support 2-dimensional conv");
          if (e2[0].dims[1] !== e2[1].dims[1] * t2.group)
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          if (3 === e2.length && (1 !== e2[2].dims.length || e2[1].dims[0] !== e2[2].dims[0]))
            throw new Error("invalid bias");
          const n2 = e2[0].dims.length - 2;
          if (t2.dilations.length !== n2)
            throw new Error(`dilations should be ${n2}D`);
          if (t2.strides.length !== n2)
            throw new Error(`strides should be ${n2}D`);
          if (t2.pads.length !== 2 * n2)
            throw new Error(`pads should be ${2 * n2}D`);
          if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e2[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if ("float32" !== e2[0].type || "float32" !== e2[1].type)
            throw new Error("Conv input(X,W) should be float tensor");
          if (3 === e2.length && "float32" !== e2[2].type)
            throw new Error("Conv input(bias) should be float tensor");
        };
      }, 6742: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseDepthToSpaceAttributes = t.depthToSpace = void 0;
        const r = n(5707);
        t.depthToSpace = (e2, t2, n2) => {
          o(t2);
          const i = n2.blocksize, a = i * i, s = "DCR" === n2.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u = "DCR" === n2.mode ? [t2[0].dims[0], i, i, t2[0].dims[1] / a, t2[0].dims[2], t2[0].dims[3]] : [t2[0].dims[0], t2[0].dims[1] / a, i, i, t2[0].dims[2], t2[0].dims[3]], l = e2.reshapeUnpacked(t2[0], u), c = { perm: s, cacheKey: `${s}` }, [p] = (0, r.transpose)(e2, [l], c), d = [t2[0].dims[0], t2[0].dims[1] / a, t2[0].dims[2] * i, t2[0].dims[3] * i];
          return [e2.reshapeUnpacked(p, d)];
        }, t.parseDepthToSpaceAttributes = (e2) => {
          const t2 = e2.attributes.getInt("blocksize");
          if (t2 < 1)
            throw new Error(`blocksize must be >= 1, but got : ${t2} for DepthToSpace`);
          const n2 = e2.attributes.getString("mode", "DCR");
          if ("DCR" !== n2 && "CRD" !== n2)
            throw new Error(`unrecognized mode: ${n2} for DepthToSpace`);
          return { mode: n2, blocksize: t2 };
        };
        const o = (e2) => {
          if (1 !== e2.length)
            throw new Error(`DepthToSpace expect 1 inputs, but got ${e2.length}`);
          if ("string" === e2[0].type || 4 !== e2[0].dims.length)
            throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
        };
      }, 3281: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createDotProductProgramInfoLoader = void 0;
        const r = n(7273), o = n(6757), i = n(5639), a = n(2150), s = n(1625);
        t.createDotProductProgramInfoLoader = (e2, t2, n2, u) => {
          const l = ((e3, t3) => ({ name: "ConvDotProduct", inputNames: e3 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: e3 ? [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.packedLastDimension], cacheKey: t3.activationCacheKey }))(t2.length > 2, u);
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, u2, l2) => {
            const c = n3[0].dims, p = n3[1].dims, d = [p[0], Math.ceil(c[1] * p[2] * p[3] / 4)], f = (0, s.calculateIm2ColDims)(c, p, u2), [h, g] = e3.calculateTextureWidthAndHeight(d, i.TextureType.packedLastDimension), b = r.ShapeUtil.computeStrides(f), [m, y] = e3.calculateTextureWidthAndHeight(f, i.TextureType.packedLastDimension), v = u2.length, _ = n3.length < 3 ? "0.0" : "_B(b)", w = Math.ceil(c[1] * p[2] * p[3] / 4), { activationFunction: T, applyActivation: x } = (0, a.getActivationSnippet)(l2), O = (0, o.getGlsl)(e3.session.backend.glContext.version), S = `
${T}
float process(int indices[${v}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};
  int kernelOffset = indices[1] * ${d[1]};
  float value = ${_};
  for (int i = 0; i < ${w}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});
    value += dot(${O.texture2D}(Im2Col, im2colCoords), ${O.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${x}
  return value;
}`;
            return Object.assign(Object.assign({}, t3), { output: { dims: u2, type: n3[0].type, textureType: i.TextureType.unpacked }, shaderSource: S });
          })(e2, l, t2, n2, u) });
        };
      }, 4125: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseFlattenAttributes = t.flatten = void 0;
        const r = n(7273);
        t.flatten = (e2, t2, n2) => {
          o(t2, n2);
          const i = r.ShapeUtil.flattenShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], i)];
        }, t.parseFlattenAttributes = (e2) => e2.attributes.getInt("axis", 1);
        const o = (e2, t2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Flatten requires 1 input.");
          const n2 = e2[0].dims.length;
          if (0 === n2)
            throw new Error("scalar tensor is not supported.");
          if (t2 < -n2 || t2 > n2)
            throw new Error("Invalid axis");
          if ("string" === e2[0].type)
            throw new Error("string tensor is not supported.");
        };
      }, 2150: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseInternalActivationAttributes = t.getActivationSnippet = void 0;
        const r = n(7273), o = n(9087);
        t.getActivationSnippet = function(e2) {
          let t2;
          switch (e2.activation) {
            case "Relu":
              t2 = (0, o.glslRelu)();
              break;
            case "Sigmoid":
              t2 = (0, o.glslSigmoid)();
              break;
            case "Clip":
              t2 = (0, o.glslClip)(e2.clipMin, e2.clipMax);
              break;
            default:
              return { activationFunction: "", applyActivation: "" };
          }
          const n2 = t2.name;
          return { activationFunction: t2.body, applyActivation: `value = ${n2}_(value);` };
        }, t.parseInternalActivationAttributes = (e2) => {
          const t2 = e2.getString("activation", "");
          if ("Clip" === t2) {
            const [n2, o2] = e2.getFloats("activation_params", [r.MIN_CLIP, r.MAX_CLIP]);
            return { activation: t2, clipMax: o2, clipMin: n2, activationCacheKey: `${t2}:${n2},${o2}` };
          }
          return { activation: t2, activationCacheKey: t2 };
        };
      }, 6149: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseGatherAttributes = t.gather = void 0;
        const r = n(4910), o = n(6145), i = n(7273), a = n(5639);
        t.gather = (e2, t2, n2) => (l(t2, n2.axis), [e2.run(u(e2, t2, n2), t2)]), t.parseGatherAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", 0) });
        const s = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, u = (e2, t2, n2) => {
          const r2 = Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey });
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const o2 = n3[0].dims.slice(), s2 = n3[1].dims.slice(), u2 = new Array(o2.length + s2.length - 1);
            r3 = i.ShapeUtil.normalizeAxis(r3, o2.length);
            const l2 = [];
            for (let e4 = 0; e4 < u2.length; e4++)
              e4 < r3 ? (u2[e4] = o2[e4], l2.push(`inputIdx[${e4}] = outputIdx[${e4}];`)) : e4 < r3 + s2.length ? (u2[e4] = s2[e4 - r3], l2.push(`indexDataIdx[${e4 - r3}] = outputIdx[${e4}];`)) : (u2[e4] = o2[e4 - s2.length + 1], l2.push(`inputIdx[${e4 - s2.length + 1}] = outputIdx[${e4}];`));
            const c = `
      float process(int outputIdx[${u2.length || 1}]) {
        int inputIdx[${o2.length}];
        int indexDataIdx[${s2.length || 1}];
        indexDataIdx[0] = 0;
        ${l2.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r3}] = idx < 0 ? idx + ${o2[r3]} : idx;
        return _A(inputIdx);
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: u2, type: n3[0].type, textureType: a.TextureType.unpacked }, shaderSource: c });
          })(0, r2, t2, n2.axis) });
        }, l = (e2, t2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Gather requires 2 inputs.");
          const n2 = e2[0].dims.length;
          if (n2 < 1)
            throw new Error("Invalid input shape.");
          if (t2 < -n2 || t2 > n2 - 1)
            throw new Error("Invalid axis.");
          if (-1 === o.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invaid input type.");
          if ("int32" !== e2[1].type && "int16" !== e2[1].type)
            throw new Error("Invaid input type.");
        };
      }, 5378: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseGemmAttributesV11 = t.parseGemmAttributesV7 = t.gemm = void 0;
        const r = n(4910), o = n(7273), i = n(5639);
        t.gemm = (e2, t2, n2) => (l(t2, n2), [e2.run(s(t2, n2), t2)]);
        const a = (e2, t2) => {
          const n2 = 0 !== e2.attributes.getInt("transA", 0), o2 = 0 !== e2.attributes.getInt("transB", 0), i2 = e2.attributes.getFloat("alpha", 1), a2 = e2.attributes.getFloat("beta", 1);
          return (0, r.createAttributeWithCacheKey)({ transA: n2, transB: o2, alpha: i2, beta: a2, isOptionalC: t2 });
        };
        t.parseGemmAttributesV7 = (e2) => a(e2, false), t.parseGemmAttributesV11 = (e2) => a(e2, true);
        const s = (e2, t2) => {
          const n2 = { name: "Gemm", inputNames: 3 === e2.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === e2.length ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], key: t2.cacheKey };
          return Object.assign(Object.assign({}, n2), { get: () => u(n2, e2, t2) });
        }, u = (e2, t2, n2) => {
          const r2 = t2[0].dims.slice(), a2 = t2[1].dims.slice(), [s2, u2] = o.GemmUtil.getShapeOfGemmResult(r2, n2.transA, a2, n2.transB, 3 === t2.length ? t2[2].dims : void 0), l2 = [s2, u2];
          if (!l2)
            throw new Error("Can't use gemm on the given tensors");
          let c = r2[r2.length - 1], p = "";
          n2.transA && (c = r2[0]), n2.transA && n2.transB ? p = "value += _A_T(a) * _B_T(b);" : n2.transA && !n2.transB ? p = "value += _A_T(a) * _B(b);" : !n2.transA && n2.transB ? p = "value += _A(a) * _B_T(b);" : n2.transA || n2.transB || (p = "value += _A(a) * _B(b);");
          const d = l2.length, f = `
      float process(int indices[${d}]) {
          int a[${d}];
          int b[${d}];
          ${3 === t2.length ? `int c[${t2[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === t2.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${c}; ++k) {
              a[${d - 1}] = k;
              b[${d - 2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3 === t2.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
          return Object.assign(Object.assign({}, e2), { output: { dims: l2, type: t2[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n2.alpha }, { name: "beta", type: "float", data: n2.beta }], shaderSource: f });
        }, l = (e2, t2) => {
          if (!e2)
            throw new Error("Input is missing");
          if (t2.isOptionalC && (e2.length < 2 || e2.length > 3))
            throw new Error("Invaid input shape.");
          if (!t2.isOptionalC && 3 !== e2.length)
            throw new Error("Gemm requires 3 inputs");
          if (3 === e2.length && 1 !== e2[2].dims.length && 2 !== e2[2].dims.length)
            throw new Error("Invalid input shape of C");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type || "float32" !== e2[1].type && "float64" !== e2[1].type || 3 === e2.length && "float32" !== e2[2].type && "float64" !== e2[2].type)
            throw new Error("Invalid input type.");
          if (e2[0].type !== e2[1].type || 3 === e2.length && e2[0].type !== e2[2].type)
            throw new Error("Input types are mismatched");
        };
      }, 5950: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedIm2ColProgramInfoLoader = void 0;
        const r = n(6757), o = n(5639), i = n(5614);
        t.createPackedIm2ColProgramInfoLoader = (e2, t2, n2, a, s) => {
          const u = (l = s.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [o.TextureType.packed], cacheHint: l });
          var l;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, a2, s2, u2) => {
            const l2 = n3.dims, c = a2.dims, p = s2.length, d = [c[1] * c[2] * c[3], s2[2] * s2[3]], f = c[2] * c[3], h = (0, i.unpackFromChannel)(), g = (0, r.getGlsl)(e3.session.backend.glContext.version);
            let b = "";
            for (let e4 = 0; e4 <= 1; e4++)
              for (let t4 = 0; t4 <= 1; t4++)
                b += `
            blockIndex = rc.x + ${t4};
            pos = rc.y + ${e4};

            if(blockIndex < ${d[1]} && pos < ${d[0]}) {
              offsetY = int(blockIndex / (${s2[p - 1]})) * ${u2.strides[0]} -
                ${u2.pads[0]};
              d0 = offsetY + ${u2.dilations[0]} * (imod(pos, ${f}) / ${c[2]});

              if(d0 < ${l2[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s2[p - 1]}) * ${u2.strides[1]} -
                  ${u2.pads[1]};
                d1 = offsetX + ${u2.dilations[1]} * imod(imod(pos, ${f}), ${c[2]});

                if(d1 < ${l2[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${f}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * e4 + t4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
            const m = `
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${g.output} = result;
      }
            `;
            return Object.assign(Object.assign({}, t3), { output: { dims: d, type: n3.type, textureType: o.TextureType.packed }, shaderSource: m, hasMain: true });
          })(e2, u, t2, n2, a, s) });
        };
      }, 1625: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.calculateIm2ColDims = t.createIm2ColProgramInfoLoader = void 0;
        const r = n(5639);
        t.createIm2ColProgramInfoLoader = (e2, n2, o, i, a) => {
          const s = (u = a.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r.TextureType.unpacked], cacheHint: u });
          var u;
          return Object.assign(Object.assign({}, s), { get: () => ((e3, n3, o2, i2, a2, s2) => {
            const u2 = o2.dims, l = i2.dims, c = a2.length, p = (0, t.calculateIm2ColDims)(u2, l, a2, 4), d = `
        const int XC = ${u2[1]};
        const int XH = ${u2[2]};
        const int XW = ${u2[3]};
        const int KH = ${s2.kernelShape[0]};
        const int KW = ${s2.kernelShape[1]};
        const int dilationH = ${s2.dilations[0]};
        const int dilationW = ${s2.dilations[1]};
        const int strideH = ${s2.strides[0]};
        const int strideW = ${s2.strides[1]};
        const int padH = ${s2.pads[0]};
        const int padW = ${s2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${c}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u2.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
            return Object.assign(Object.assign({}, n3), { output: { dims: p, type: o2.type, textureType: r.TextureType.packedLastDimension }, shaderSource: d });
          })(0, s, n2, o, i, a) });
        }, t.calculateIm2ColDims = (e2, t2, n2, r2 = 4) => [n2[0], n2[2], n2[3], Math.ceil(e2[1] * t2[2] * t2[3] / r2)];
      }, 6981: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseImageScalerAttributes = t.imageScaler = void 0;
        const r = n(4910), o = n(5639);
        t.imageScaler = (e2, t2, n2) => (u(t2), [e2.run(a(e2, t2, n2), t2)]), t.parseImageScalerAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("scale"), n2 = e2.attributes.getFloats("bias");
          return (0, r.createAttributeWithCacheKey)({ scale: t2, bias: n2 });
        };
        const i = { name: "ImageScaler", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] }, a = (e2, t2, n2) => {
          const r2 = Object.assign(Object.assign({}, i), { cacheHint: n2.cacheKey });
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const i2 = n3[0].dims.slice(), a2 = i2.length, u2 = `
      ${s(r3.bias.length)}
      float process(int indices[${a2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: i2, type: n3[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r3.bias.length, data: r3.bias }, { name: "scale", type: "float", data: r3.scale }], shaderSource: u2 });
          })(0, r2, t2, n2) });
        }, s = (e2) => {
          const t2 = [`float getBias(float bias[${e2}], int channel) {`];
          for (let n2 = 0; n2 < e2; ++n2)
            0 === n2 ? t2.push(`	if (channel == ${n2}) { return bias[${n2}]; }`) : n2 === e2 - 1 ? t2.push(`	else { return bias[${n2}]; }`) : t2.push(`	else if (channel == ${n2}) { return bias[${n2}]; }`);
          return t2.push("	}"), t2.join("\n");
        }, u = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("ImageScaler requires 1 input.");
          if (4 !== e2[0].dims.length)
            throw new Error("Invalid input shape.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 7413: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseInstanceNormalizationAttributes = t.instanceNormalization = void 0;
        const r = n(6757), o = n(5639);
        t.instanceNormalization = (e2, t2, n2) => {
          l(t2);
          const r2 = e2.run(a(t2[0]), t2);
          return [e2.run(u(e2, t2[0], n2, r2.dims), [t2[0], r2, t2[1], t2[2]])];
        }, t.parseInstanceNormalizationAttributes = (e2) => e2.attributes.getFloat("epsilon", 1e-5);
        const i = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] }, a = (e2) => Object.assign(Object.assign({}, i), { get: () => ((e3, t2) => {
          const n2 = t2.dims.slice(), r2 = n2[1], i2 = n2[2] * n2[3], a2 = [n2[0], r2], s2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i2});
        temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i2});

        return v;
      }`;
          return Object.assign(Object.assign({}, e3), { output: { dims: a2, type: t2.type, textureType: o.TextureType.packedLastDimension }, shaderSource: s2 });
        })(i, e2) }), s = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked, o.TextureType.unpacked] }, u = (e2, t2, n2, i2) => {
          const a2 = Object.assign(Object.assign({}, s), { cacheHint: `${n2}` });
          return Object.assign(Object.assign({}, a2), { get: () => ((e3, t3, n3, i3, a3) => {
            const s2 = (0, r.getGlsl)(e3.session.backend.glContext.version), [u2, l2] = e3.calculateTextureWidthAndHeight(a3, o.TextureType.packedLastDimension), [c, p] = [u2 / 4, l2], d = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${c}, ${p});
        return ${s2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: o.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: i3 }], shaderSource: d });
          })(e2, a2, t2, n2, i2) });
        }, l = (e2) => {
          if (!e2 || 3 !== e2.length)
            throw new Error("InstanceNormalization requires 3 inputs.");
          const t2 = e2[0], n2 = e2[1], r2 = e2[2];
          if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length)
            throw new Error("Invalid input shape.");
          if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1])
            throw new Error("Input shapes are mismatched.");
          if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type)
            throw new Error("Invalid input type.");
          if (4 !== e2[0].dims.length)
            throw new Error("Only support 4-D input shape.");
        };
      }, 7006: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createLrnProgramInfoLoader = t.parseLrnAttributes = t.lrn = void 0;
        const r = n(4910), o = n(5639);
        t.lrn = (e2, t2, n2) => (s(t2), [e2.run(a(t2, n2), t2)]), t.parseLrnAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("alpha", 1e-4), n2 = e2.attributes.getFloat("beta", 0.75), o2 = e2.attributes.getFloat("bias", 1), i2 = e2.attributes.getInt("size");
          return (0, r.createAttributeWithCacheKey)({ alpha: t2, beta: n2, bias: o2, size: i2 });
        };
        const i = { name: "LRN", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
        function a(e2, t2) {
          return Object.assign(Object.assign({}, i), { cacheHint: t2.cacheKey, get: () => function(e3, t3) {
            const n2 = e3[0].dims[1], r2 = e3[0].dims.length, a2 = -Math.floor((t3.size - 1) / 2), s2 = Math.ceil((t3.size - 1) / 2), u = `float(${t3.alpha}) / float(${t3.size})`, l = `
    float process(int indices[${r2}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${a2}; i <= ${s2}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${n2}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${t3.bias}) + ${u} * square_sum, float(${t3.beta}));
    }`;
            return Object.assign(Object.assign({}, i), { cacheHint: t3.cacheKey, output: { dims: e3[0].dims, type: e3[0].type, textureType: o.TextureType.unpacked }, shaderSource: l });
          }(e2, t2) });
        }
        t.createLrnProgramInfoLoader = a;
        const s = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("LRN requires 1 input.");
          if (4 !== e2[0].dims.length)
            throw new Error('currently only support LRN for input with "NCHW" format');
          if ("float32" !== e2[0].type)
            throw new Error("input should be float type");
        };
      }, 5632: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedMatmulProgramInfoLoader = void 0;
        const r = n(7273), o = n(6757), i = n(5639), a = n(432), s = n(2150), u = n(8276);
        t.createPackedMatmulProgramInfoLoader = (e2, t2, n2) => {
          const l = (c = t2.length > 2, p = n2.activationCacheKey, { name: "MatMul (packed)", inputNames: c ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: c ? [i.TextureType.packed, i.TextureType.packed, i.TextureType.packed] : [i.TextureType.packed, i.TextureType.packed], cacheHint: p });
          var c, p;
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, l2) => {
            const c2 = n3.length > 2, p2 = c2 ? "value += getBiasForMatmul();" : "", d = n3[0].dims, f = n3[1].dims, h = r.BroadcastUtil.calcShape(d, f, true), g = !r.ShapeUtil.areEqual(n3[0].dims, n3[1].dims);
            if (!h)
              throw new Error("Can't use matmul on the given tensors");
            const b = d[d.length - 1], m = Math.ceil(b / 2), y = d.length, v = f.length, _ = (0, o.getGlsl)(e3.session.backend.glContext.version), w = (0, a.getCoordsDataType)(h.length), T = h.length, x = (0, a.getGlChannels)(), { activationFunction: O, applyActivation: S } = (0, s.getActivationSnippet)(l2), A = c2 ? `${(0, u.getBiasForMatmul)(w, x, n3[2].dims, h, true)}` : "", P = g ? `${function(e4, t4, n4, o2) {
              let i2 = [], a2 = [];
              const s2 = n4[0].dims, u2 = n4[1].dims, l3 = s2.length, c3 = u2.length, p3 = o2.length, d2 = p3 - l3, f2 = p3 - c3;
              i2 = s2.map((e5, n5) => `coords.${t4[n5 + d2]}`), i2[l3 - 1] = "i*2", i2.join(", "), a2 = u2.map((e5, n5) => `coords.${t4[n5 + f2]}`), a2[c3 - 2] = "i*2", a2.join(", ");
              const h2 = r.BroadcastUtil.getBroadcastDims(s2, o2), g2 = r.BroadcastUtil.getBroadcastDims(u2, o2), b2 = h2.map((e5) => `coords.${t4[e5 + d2]} = 0;`).join("\n"), m2 = g2.map((e5) => `coords.${t4[e5 + f2]} = 0;`).join("\n"), y2 = `int lastDim = coords.${t4[p3 - 1]};
  coords.${t4[p3 - 1]} = coords.${t4[p3 - 2]};
  coords.${t4[p3 - 2]} = lastDim;`;
              return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${e4} coords = getOutputCoords();
  ${y2}
  ${b2}
  vec4 outputValue = getA(${i2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e4} coords = getOutputCoords();
  ${y2}
  ${m2}
  vec4 outputValue = getB(${a2});
  return outputValue;
}`;
            }(w, x, n3, h)}` : "", I = g ? "getAAtOutCoordsMatmul(i)" : `getA(${function(e4, t4) {
              let n4 = "";
              for (let r2 = 0; r2 < t4 - 2; r2++)
                n4 += `rc.${e4[r2]}, `;
              return n4 += `rc.${e4[t4 - 2]}, i*2`, n4;
            }(x, y)})`, E = g ? "getBAtOutCoordsMatmul(i)" : `getB(${function(e4, t4) {
              let n4 = "";
              for (let r2 = 0; r2 < t4 - 2; r2++)
                n4 += `rc.${e4[r2]}, `;
              return n4 += `i*2, rc.${e4[t4 - 1]}`, n4;
            }(x, v)})`, D = `
            ${P}
            ${A}
            ${O}
            void main() {
              ${g ? "" : `${w} rc =
          getOutputCoords(); int lastDim = rc.${x[T - 1]}; rc.${x[T - 1]} =
          rc.${x[T - 2]}; rc.${x[T - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${m}; i++) {
                vec4 a = ${I};
                vec4 b = ${E};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p2}
              ${S}
              ${_.output} = value;
            }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: h, type: n3[0].type, textureType: i.TextureType.packed }, shaderSource: D, hasMain: true });
          })(e2, l, t2, n2) });
        };
      }, 8276: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getBiasForMatmul = t.createMatmulProgramInfoLoader = t.parseMatMulAttributes = t.matMul = void 0;
        const r = n(7273), o = n(5639), i = n(432), a = n(2150), s = n(5632);
        t.matMul = (e2, t2, n2) => (c(t2), e2.session.pack ? [e2.run((0, s.createPackedMatmulProgramInfoLoader)(e2, t2, n2), t2)] : [e2.run(l(t2, n2), t2)]), t.parseMatMulAttributes = (e2) => (0, a.parseInternalActivationAttributes)(e2.attributes);
        const u = (e2, t2) => ({ name: "MatMul", inputNames: e2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: e2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: t2 });
        function l(e2, t2) {
          const n2 = u(e2.length > 2, t2.activationCacheKey);
          return Object.assign(Object.assign({}, n2), { get: () => function(e3, t3, n3) {
            const s2 = t3[0].dims, u2 = t3[1].dims, l2 = r.BroadcastUtil.calcShape(s2, u2, true);
            if (!l2)
              throw new Error("Can't use matmul on the given tensors");
            const c2 = (0, i.getCoordsDataType)(l2.length), d = (0, i.getGlChannels)(), { activationFunction: f, applyActivation: h } = (0, a.getActivationSnippet)(n3), g = t3.length > 2, b = g ? "value += getBiasForMatmul();" : "", m = g ? `${p(c2, d, t3[2].dims, l2, false)}` : "", y = l2.length, v = s2.length, _ = u2.length, w = `
    ${f}
    ${m}
    float process(int indices[${y}]) {
        int a[${v}];
        int b[${_}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s2[s2.length - 1]}; ++k) {
            a[${v - 1}] = k;
            b[${_ - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${b}
        ${h}
        return value;
    }`;
            return Object.assign(Object.assign({}, e3), { output: { dims: l2, type: t3[0].type, textureType: o.TextureType.unpacked }, shaderSource: w });
          }(n2, e2, t2) });
        }
        t.createMatmulProgramInfoLoader = l;
        const c = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("MatMul requires 2 inputs.");
          if (e2[0].dims[e2[0].dims.length - 1] !== e2[1].dims[e2[1].dims.length - 2])
            throw new Error("shared dimension does not match.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type || "float32" !== e2[1].type && "float64" !== e2[1].type)
            throw new Error("inputs should be float type");
          if (e2[0].type !== e2[1].type)
            throw new Error("inputs types should match");
        };
        function p(e2, t2, n2, o2, i2) {
          let a2 = "";
          const s2 = n2.length, u2 = o2.length, l2 = u2 - s2;
          a2 = u2 < 2 && s2 > 0 ? "coords" : n2.map((e3, n3) => `coords.${t2[n3 + l2]}`).join(", ");
          const c2 = r.BroadcastUtil.getBroadcastDims(n2, o2).map((e3) => `coords.${t2[e3 + l2]} = 0;`).join("\n");
          let p2 = "vec4(outputValue.xx, outputValue.yy)";
          return 1 === r.ShapeUtil.size(n2) && (p2 = "vec4(outputValue.x)"), i2 ? `
vec4 getBiasForMatmul() {
  ${e2} coords = getOutputCoords();
  ${c2}
  vec4 outputValue = getBias(${a2});
  return ${p2};
}` : `
float getBiasForMatmul() {
  ${e2} coords = getOutputCoords();
  ${c2}
  return getBias(coords.x);
}`;
        }
        t.getBiasForMatmul = p;
      }, 9: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackProgramInfoLoader = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614), s = { name: "pack", inputNames: ["A"], inputTypes: [o.TextureType.unpackedReversed] };
        t.createPackProgramInfoLoader = (e2, t2) => Object.assign(Object.assign({}, s), { get: () => ((e3, t3) => {
          const n2 = (0, r.getGlsl)(e3.session.backend.glContext.version), u = t3.dims, l = u.length, c = t3.dims.length, p = (0, i.getCoordsDataType)(c), d = (0, a.getChannels)("rc", c), f = (h = c, g = d, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? "" : `
    int r = ${g[h - 2]};
    int c = ${g[h - 1]};
    int rp1 = ${g[h - 2]} + 1;
    int cp1 = ${g[h - 1]} + 1;
    bool rEdge = rp1 >= ${m};
    bool cEdge = cp1 >= ${b};
    `);
          var h, g, b, m;
          let y;
          y = 0 === l ? [1, 1] : 1 === l ? [u[0], 1] : [u[c - 1], u[c - 2]];
          const v = function(e4, t4, n3) {
            if (0 === e4)
              return "false";
            if (1 === e4)
              return `rc > ${t4[0]}`;
            let r2 = "";
            for (let o2 = e4 - 2; o2 < e4; o2++)
              r2 += `${n3[o2]} >= ${t4[o2 - e4 + 2]}`, o2 < e4 - 1 && (r2 += "||");
            return r2;
          }(c, y, d), _ = function(e4, t4) {
            const n3 = e4.length;
            if (0 === n3)
              return "getA(), 0, 0, 0";
            if (1 === n3)
              return `getA(rc),
            rc + 1 >= ${e4[0]} ? 0. : getA(rc + 1),
            0, 0`;
            let r2 = "";
            if (n3 > 2)
              for (let e5 = 0; e5 < n3 - 2; ++e5)
                r2 += `${t4[e5]},`;
            return `getA(${r2}r, c),
          rEdge ? 0. : getA(${r2}rp1, c),
          cEdge ? 0. : getA(${r2}r, cp1),
          rEdge || cEdge ? 0. : getA(${r2}rp1, cp1)`;
          }(u, d), w = `
        void main() {
          ${p} rc = getOutputCoords();

          if(${v}) {
            ${n2.output} = vec4(0);
          } else {
            ${f}

            ${n2.output} = vec4(${_});
          }
        }
      `;
          return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: t3.dims, type: t3.type, textureType: o.TextureType.packed }, shaderSource: w });
        })(e2, t2) });
      }, 5614: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.unpackFromChannel = t.getChannels = t.getVecChannels = void 0;
        const r = n(432);
        function o(e2, t2) {
          return (0, r.getGlChannels)(t2).map((t3) => `${e2}.${t3}`);
        }
        t.getVecChannels = o, t.getChannels = function(e2, t2) {
          return 1 === t2 ? [e2] : o(e2, t2);
        }, t.unpackFromChannel = function() {
          return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
        };
      }, 5565: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parsePadAttributesV11 = t.padV11 = t.parsePadAttributesV2 = t.padV2 = void 0;
        const r = n(4910), o = n(7273), i = n(6757), a = n(5639), s = { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
        t.padV2 = (e2, t2, n2) => (c(t2), [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => l(e2, t2[0], n2) }), t2)]), t.parsePadAttributesV2 = (e2) => {
          const t2 = e2.attributes.getString("mode", "constant"), n2 = e2.attributes.getFloat("value", 0), o2 = e2.attributes.getInts("pads");
          return (0, r.createAttributeWithCacheKey)({ mode: t2, value: n2, pads: o2 });
        }, t.padV11 = (e2, n2, r2) => {
          p(n2);
          const o2 = u(e2, n2, r2);
          return (0, t.padV2)(e2, [n2[0]], o2);
        }, t.parsePadAttributesV11 = (e2) => e2.attributes.getString("mode", "constant");
        const u = (e2, t2, n2) => {
          if (!e2.session.isInitializer(t2[1].dataId) || t2.length >= 3 && !e2.session.isInitializer(t2[2].dataId))
            throw new Error("dynamic pad attributes are not allowed");
          const o2 = Array.from(t2[1].integerData), i2 = t2.length >= 3 ? t2[2].floatData[0] : 0;
          return (0, r.createAttributeWithCacheKey)({ mode: n2, pads: o2, value: i2 });
        }, l = (e2, t2, n2) => {
          const r2 = o.ShapeUtil.padShape(t2.dims.slice(), n2.pads), i2 = r2.length, s2 = `
      ${d(e2, t2, n2)}
      float process(int[${i2}] indices) {
          return padA(indices);
      }`;
          return { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked], output: { dims: r2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: s2 };
        }, c = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Pad requires 1 input");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        }, p = (e2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Pad requires 2 or 3 inputs");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
          if (e2.length >= 3 && "string" === e2[2].type)
            throw new Error("Invalid input type.");
        }, d = (e2, t2, n2) => {
          const r2 = (0, i.getGlsl)(e2.session.backend.glContext.version), [s2, u2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), l2 = o.ShapeUtil.computeStrides(t2.dims);
          switch (n2.mode) {
            case "constant":
              return f(r2, t2.dims, l2, s2, u2, n2.pads, n2.value);
            case "reflect":
              return h(r2, t2.dims, l2, s2, u2, n2.pads);
            case "edge":
              return g(r2, t2.dims, l2, s2, u2, n2.pads);
            default:
              throw new Error("Invalid mode");
          }
        }, f = (e2, t2, n2, r2, o2, i2, a2) => {
          const s2 = t2.length;
          let u2 = "";
          for (let e3 = s2 - 1; e3 >= 0; --e3)
            u2 += `
        k = m[${e3}] - ${i2[e3]};
        if (k < 0)  return constant;
        if (k >= ${t2[e3]}) return constant;
        offset += k * ${n2[e3]};
        `;
          return `
      float padA(int m[${s2}]) {
        const float constant = float(${a2});
        int offset = 0;
        int k = 0;
        ${u2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        }, h = (e2, t2, n2, r2, o2, i2) => {
          const a2 = t2.length;
          let s2 = "";
          for (let e3 = a2 - 1; e3 >= 0; --e3)
            s2 += `
        k = m[${e3}] - ${i2[e3]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (t2[e3] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${t2[e3]}) { k = _2n_1 - k; }
        }
        offset += k * ${n2[e3]};
        `;
          return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        }, g = (e2, t2, n2, r2, o2, i2) => {
          const a2 = t2.length;
          let s2 = "";
          for (let e3 = a2 - 1; e3 >= 0; --e3)
            s2 += `
        k = m[${e3}] - ${i2[e3]};
        if (k < 0)  k = 0;
        if (k >= ${t2[e3]}) k = ${t2[e3] - 1};
        offset += k * ${n2[e3]};
      `;
          return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${o2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        };
      }, 2834: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.globalMaxPool = t.parseMaxPoolAttributes = t.maxPool = t.parseGlobalAveragePoolAttributes = t.globalAveragePool = t.parseAveragePoolAttributes = t.averagePool = void 0;
        const r = n(4910), o = n(7273), i = n(5639);
        t.averagePool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "AveragePool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: n2.cacheKey };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => a(t2, r2, false, n2) }), t2)];
        }, t.parseAveragePoolAttributes = (e2) => {
          const t2 = e2.attributes.getString("auto_pad", "NOTSET"), n2 = e2.attributes.getInt("ceil_mode", 0), o2 = 0 !== e2.attributes.getInt("count_include_pad", 0), i2 = e2.attributes.getInts("kernel_shape"), a2 = e2.attributes.getInts("strides", []), s2 = e2.attributes.getInts("pads", []);
          if (0 !== n2)
            throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
          return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: o2, kernelShape: i2, strides: a2, pads: s2 });
        };
        const a = (e2, t2, n2, r2) => {
          const [a2, s2] = u(e2, r2, n2), l2 = o.ShapeUtil.size(a2.kernelShape);
          let c2 = "";
          a2.countIncludePad ? c2 += `value /= float(${l2});` : c2 += `value /= float(${l2} - pad);`;
          const p2 = `
        ${d(e2[0].dims, a2, "value += _X(x);", c2, "0.0")}
      `;
          return Object.assign(Object.assign({}, t2), { output: { dims: s2, type: e2[0].type, textureType: i.TextureType.unpacked }, shaderSource: p2 });
        };
        t.globalAveragePool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: `${n2.countIncludePad}` };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => a(t2, r2, true, n2) }), t2)];
        }, t.parseGlobalAveragePoolAttributes = (e2) => {
          const t2 = 0 !== e2.attributes.getInt("count_include_pad", 0);
          return (0, r.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: t2, kernelShape: [], strides: [], pads: [] });
        }, t.maxPool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "MaxPool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked], cacheHint: n2.cacheKey };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => s(t2, r2, false, n2) }), t2)];
        }, t.parseMaxPoolAttributes = (e2) => {
          const t2 = e2.attributes.getString("auto_pad", "NOTSET"), n2 = e2.attributes.getInt("ceil_mode", 0), o2 = e2.attributes.getInts("kernel_shape"), i2 = e2.attributes.getInts("strides", []), a2 = e2.attributes.getInts("pads", []), s2 = e2.attributes.getInt("storage_order", 0), u2 = e2.attributes.getInts("dilations", []);
          if (0 !== s2)
            throw new Error("column major storage order is not yet supported for MaxPool");
          if (0 !== n2)
            throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
          return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: false, kernelShape: o2, strides: i2, pads: a2, storageOrder: s2, dilations: u2 });
        };
        const s = (e2, t2, n2, r2) => {
          const [o2, a2] = u(e2, r2, n2), s2 = `
      ${d(e2[0].dims, o2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
          return Object.assign(Object.assign({}, t2), { output: { dims: a2, type: e2[0].type, textureType: i.TextureType.unpacked }, shaderSource: s2 });
        }, u = (e2, t2, n2) => {
          const r2 = e2[0].dims.slice(), i2 = Object.hasOwnProperty.call(t2, "dilations"), a2 = t2.kernelShape.slice(), s2 = t2.strides.slice(), u2 = i2 ? t2.dilations.slice() : [], l2 = t2.pads.slice();
          o.PoolConvUtil.adjustPoolAttributes(n2, r2, a2, s2, u2, l2);
          const c2 = o.PoolConvUtil.computePoolOutputShape(n2, r2, s2, u2, a2, l2, t2.autoPad), p2 = Object.assign({}, t2);
          return i2 ? Object.assign(p2, { kernelShape: a2, strides: s2, pads: l2, dilations: u2, cacheKey: t2.cacheKey }) : Object.assign(p2, { kernelShape: a2, strides: s2, pads: l2, cacheKey: t2.cacheKey }), [p2, c2];
        }, l = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, c = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] };
        t.globalMaxPool = (e2, t2) => (p(t2), [e2.run(Object.assign(Object.assign({}, c), { get: () => s(t2, c, true, l) }), t2)]);
        const p = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Pool ops requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        }, d = (e2, t2, n2, r2, i2) => {
          const a2 = e2.length;
          if (t2.kernelShape.length <= 2) {
            const o2 = t2.kernelShape[t2.kernelShape.length - 1], s2 = t2.strides[t2.strides.length - 1], u2 = t2.pads[t2.pads.length / 2 - 1], l2 = t2.pads[t2.pads.length - 1], c2 = e2[a2 - 1];
            let p2 = "", d2 = "", f2 = "";
            if (p2 = u2 + l2 !== 0 ? `
          for (int i = 0; i < ${o2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            if (x[${a2} - 1] < 0 || x[${a2} - 1] >= ${c2}) {
              pad++;
              continue;
            }
            ${n2}
          }` : `
          for (int i = 0; i < ${o2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            ${n2}
          }`, 2 === t2.kernelShape.length) {
              const n3 = t2.kernelShape[t2.kernelShape.length - 2], r3 = t2.strides[t2.strides.length - 2], i3 = t2.pads[t2.pads.length / 2 - 2], s3 = t2.pads[t2.pads.length - 2], u3 = e2[a2 - 2];
              d2 = i3 + s3 !== 0 ? `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${i3} + j;
              if (x[${a2} - 2] < 0 || x[${a2} - 2] >= ${u3}) {
                pad+= ${o2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${i3} + j;
            `, f2 = "\n          }\n        ";
            }
            return `
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);

          float value = ${i2};
          int pad = 0;
          ${d2}
          ${p2}
          ${f2}
          ${r2}
          return value;
        }
      `;
          }
          {
            const s2 = o.ShapeUtil.size(t2.kernelShape), u2 = o.ShapeUtil.computeStrides(t2.kernelShape), l2 = u2.length, c2 = t2.pads.length, p2 = h(l2), d2 = f(e2, "inputDims"), g = f(t2.pads, "pads"), b = f(u2, "kernelStrides"), m = f(t2.strides, "strides");
            let y = "";
            return y = t2.pads.reduce((e3, t3) => e3 + t3) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n2}
          }` : `
          }
          ${n2}
        `, `
        ${p2}
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);
          int offset[${l2}];
          int pads[${c2}];
          int inputDims[${a2}];
          int kernelStrides[${l2}];
          int strides[${l2}];
          ${g}
          ${d2}
          ${m}
          ${b}

          float value = ${i2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a2} - ${l2}; j < ${a2}; j++) {
              x[j] = indices[j] * strides[j - ${a2} + ${l2}]
                + offset[j - ${a2} + ${l2}] - pads[j - 2];
              ${y}
          }
          ${r2}

          return value;
        }
      `;
          }
        }, f = (e2, t2) => {
          let n2 = "";
          for (let r2 = 0; r2 < e2.length; r2++)
            n2 += `
      ${t2}[${r2}] = ${e2[r2]};
    `;
          return n2;
        }, h = (e2) => `
  void offsetToIndices(int offset, int[${e2}] strides, out int[${e2}] indices) {
    if (${e2} == 0) {
      return;
    }
    for (int i = 0; i < ${e2} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e2} - 1] = offset;
  }`;
      }, 1010: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.reduceLogSumSquare = t.reduceLogSum = t.reduceProd = t.reduceMin = t.reduceMax = t.reduceMean = t.reduceSum = t.parseReduceAttributes = void 0;
        const r = n(4910), o = n(6145), i = n(7273), a = n(5639), s = (e2, t2, n2, r2, o2) => {
          l(t2);
          const i2 = { name: r2, inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
          return [e2.run(Object.assign(Object.assign({}, i2), { cacheHint: n2.cacheKey, get: () => u(e2, t2, n2, r2, o2, i2) }), t2)];
        };
        t.parseReduceAttributes = (e2) => {
          const t2 = e2.attributes.getInts("axes", []), n2 = 1 === e2.attributes.getInt("keepdims", 1);
          return (0, r.createAttributeWithCacheKey)({ axes: t2, keepDims: n2 });
        };
        const u = (e2, t2, n2, r2, o2, s2) => {
          const u2 = [], l2 = t2[0].dims.length || 1, c = [], p = i.ShapeUtil.normalizeAxes(n2.axes, t2[0].dims.length), d = o2(t2, p);
          let f = d[1];
          for (let e3 = 0; e3 < t2[0].dims.length; e3++)
            p.indexOf(e3) >= 0 || 0 === p.length ? (n2.keepDims && u2.push(1), f = `
          for(int j${e3} = 0; j${e3} < ${t2[0].dims[e3]}; j${e3}++) {
            inputIdx[${e3}] = j${e3};
            ${f}
          }`) : (c.push(`inputIdx[${e3}] = outputIdx[${u2.length}];`), u2.push(t2[0].dims[e3]));
          const h = `
      float process(int outputIdx[${u2.length || 1}]) {
        float value;                 // final result
        int inputIdx[${l2}];      // addressing input data
        ${c.join("\n")}
        ${d[0]}       // init ops for reduce max/min
        ${f}
        ${d[2]}       // final computation for reduce mean
        return value;
      }`;
          return Object.assign(Object.assign({}, s2), { output: { dims: u2, type: t2[0].type, textureType: a.TextureType.unpacked }, shaderSource: h });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Reduce op requires 1 input.");
          if (-1 === o.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
        };
        t.reduceSum = (e2, t2, n2) => s(e2, t2, n2, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), t.reduceMean = (e2, t2, n2) => s(e2, t2, n2, "ReduceMean", (e3, t3) => {
          let n3 = 1;
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && (n3 *= e3[0].dims[r2]);
          return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n3}.;`];
        }), t.reduceMax = (e2, t2, n2) => s(e2, t2, n2, "ReduceMax", (e3, t3) => {
          const n3 = [];
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
          return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
        }), t.reduceMin = (e2, t2, n2) => s(e2, t2, n2, "ReduceMin", (e3, t3) => {
          const n3 = [];
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
          return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
        }), t.reduceProd = (e2, t2, n2) => s(e2, t2, n2, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), t.reduceLogSum = (e2, t2, n2) => s(e2, t2, n2, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), t.reduceLogSumSquare = (e2, t2, n2) => s(e2, t2, n2, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
      }, 7379: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.isReshapeCheap = t.processDims3D = t.createPackedReshape3DProgramInfoLoader = void 0;
        const r = n(7273), o = n(6757), i = n(5639), a = n(5614);
        t.createPackedReshape3DProgramInfoLoader = (e2, t2, n2) => {
          const s = ((e3) => ({ name: "Reshape (packed)", inputTypes: [i.TextureType.packed], inputNames: ["A"], cacheHint: `${e3}` }))(n2);
          return Object.assign(Object.assign({}, s), { get: () => ((e3, t3, n3, s2) => {
            const u = t3.dims, l = s2;
            let c = "";
            for (let e4 = 0; e4 < 4; e4++) {
              let t4 = "";
              switch (e4) {
                case 0:
                  t4 = "outputCoords = rc;";
                  break;
                case 1:
                  t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                  break;
                case 2:
                  t4 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                  break;
                case 3:
                  t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                  break;
                default:
                  throw new Error();
              }
              c += `
        ${t4}
        ${e4 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e4}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${e4 > 0 ? "}" : ""}
      `;
            }
            const p = (0, o.getGlsl)(e3.session.backend.glContext.version), d = `
      ${function(e4) {
              const t4 = r.ShapeUtil.computeStrides(e4), n4 = ["b", "r", "c"], o2 = "index";
              return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t4.map((e5, r2) => `int ${n4[r2]} = ${o2} / ${e5}; ${r2 === t4.length - 1 ? `int ${n4[r2 + 1]} = ${o2} - ${n4[r2]} * ${e5}` : `index -= ${n4[r2]} * ${e5}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
            }(u)}
      ${function(e4) {
              const t4 = r.ShapeUtil.computeStrides(e4);
              return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${t4[0]} + coords.z * ${t4[1]} + coords.y;
  }
`;
            }(l)}
      ${(0, a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${l[2]};
        int cols = ${l[1]};

        ${c}
        ${p.output} = result;
      }
    `;
            return Object.assign(Object.assign({}, n3), { output: { dims: l, type: t3.type, textureType: i.TextureType.packed }, shaderSource: d, hasMain: true });
          })(e2, t2, s, n2) });
        }, t.processDims3D = function(e2) {
          if (0 === e2.length)
            return [1, 1, 1];
          let t2 = 1;
          for (let n2 = 0; n2 < e2.length - 2; ++n2)
            t2 *= e2[n2];
          return [t2, e2.length > 1 ? e2[e2.length - 2] : 1, e2[e2.length - 1]];
        }, t.isReshapeCheap = function(e2, t2) {
          let n2 = false;
          return n2 = 0 === e2.length || 0 === t2.length || (e2.length < 2 || t2.length < 2 ? e2[e2.length - 1] === t2[t2.length - 1] : e2[e2.length - 1] === t2[t2.length - 1] && e2[e2.length - 2] === t2[t2.length - 2]), n2;
        };
      }, 8126: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.reshape = void 0;
        const r = n(7273);
        t.reshape = (e2, t2) => {
          const n2 = r.ShapeUtil.calculateReshapedDims(t2[0].dims, t2[1].integerData);
          return e2.session.pack ? [e2.reshapePacked(t2[0], n2)] : [e2.reshapeUnpacked(t2[0], n2)];
        };
      }, 2801: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseResizeAttributesV11 = t.parseResizeAttributesV10 = t.resize = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614), s = n(3980), u = { name: "Resize", inputNames: ["A"], inputTypes: [o.TextureType.packed] };
        t.resize = (e2, t2, n2) => ((0, s.validateInputs)(t2, n2), [e2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => l(e2, t2, n2) }), t2)]), t.parseResizeAttributesV10 = (e2) => (0, s.parseUpsampleAttributes)(e2, 10), t.parseResizeAttributesV11 = (e2) => (0, s.parseUpsampleAttributes)(e2, 11);
        const l = (e2, t2, n2) => {
          const s2 = (0, r.getGlsl)(e2.session.backend.glContext.version), [l2, p2] = c(t2, n2);
          if (l2.every((e3) => 1 === e3) && "tf_crop_and_resize" !== n2.coordinateTransformMode)
            return Object.assign(Object.assign({}, u), { output: { dims: p2, type: t2[0].type, textureType: o.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s2.texture2D}(X, TexCoords);
                    ${s2.output} = v;
                }` });
          const d2 = p2.length;
          if (d2 < 2)
            throw new Error(`output dimension should be at least 2, but got ${d2}`);
          const f = p2[d2 - 2], h = p2[d2 - 1], g = t2[0].dims;
          if (d2 !== g.length)
            throw new Error(`output dimension should match input ${g.length}, but got ${d2}`);
          const b = g[d2 - 2], m = g[d2 - 1], y = l2[d2 - 2], v = l2[d2 - 1];
          let _ = "";
          if ("linear" !== n2.mode)
            throw new Error(`resize (packed) does not support mode: '${n2.mode}'`);
          switch (n2.coordinateTransformMode) {
            case "asymmetric":
              _ = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
              break;
            case "half_pixel":
              _ = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
              break;
            case "pytorch_half_pixel":
              _ = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${f}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${f}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
              break;
            case "align_corners":
              _ = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h}.0 - 1.0, ${f}.0 - 1.0, ${h}.0 - 1.0,
                            ${f}.0 - 1.0);
                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,
                            ${b}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
              break;
            default:
              throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n2.coordinateTransformMode}'`);
          }
          const w = (0, i.getCoordsDataType)(d2), T = `
            const vec2 inputWH = vec2(${b}.0, ${m}.0);
            const vec4 scaleWHWH = vec4(float(${y}), float(${v}), float(${y}), float(${v}));
            ${(0, a.unpackFromChannel)()}
            ${_}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${f - 1};
                bool hasNextCol = rc.z < ${h - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s2.output} = vec4(newValue);
            }
        `;
          return Object.assign(Object.assign({}, u), { output: { dims: p2, type: t2[0].type, textureType: o.TextureType.packed }, hasMain: true, shaderSource: T });
        }, c = (e2, t2) => {
          const n2 = e2[0].dims;
          let r2, o2 = t2.scales;
          if (0 === o2.length) {
            const i3 = e2[t2.scalesInputIdx];
            if (i3 && 0 !== i3.size) {
              if (e2[t2.sizesInputIdx])
                throw new Error("Only one of scales or sizes must be provided as input.");
              o2 = p(i3, t2.mode, t2.isResize);
            } else {
              const i4 = e2[t2.sizesInputIdx];
              if (!i4 || 0 === i4.size)
                throw new Error("Either scales or sizes MUST be provided as input.");
              r2 = Array.from(i4.integerData), o2 = d(r2, n2, t2.mode, t2.isResize);
            }
          } else if (e2[t2.sizesInputIdx])
            throw new Error("Only one of scales or sizes must be provided as input.");
          const i2 = r2 || n2.map((e3, t3) => Math.floor(e3 * o2[t3]));
          return [o2, i2];
        }, p = (e2, t2, n2) => {
          const r2 = Array.from(e2.floatData);
          return (0, s.scalesValidation)(r2, t2, n2), r2;
        }, d = (e2, t2, n2, r2) => {
          const o2 = t2.length, i2 = new Array(o2);
          for (let n3 = 0, r3 = o2; n3 < r3; n3++)
            if (0 === t2[n3]) {
              if (0 !== e2[n3])
                throw new Error("Input dim is zero but required output dim is non-zero.");
              i2[n3] = 1;
            } else
              i2[n3] = e2[n3] / t2[n3];
          return (0, s.scalesValidation)(i2, n2, r2), i2;
        };
      }, 565: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.shape = void 0;
        const r = n(9240);
        t.shape = (e2, t2) => (o(t2), [new r.Tensor([t2[0].dims.length], "int32", void 0, void 0, new Int32Array(t2[0].dims))]);
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Shape requires 1 input.");
        };
      }, 2444: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.sliceV10 = t.parseSliceAttributes = t.slice = void 0;
        const r = n(4910), o = n(6145), i = n(7273), a = n(5639), s = { name: "Slice", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
        t.slice = (e2, t2, n2) => (l(t2), [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(e2, t2[0], n2) }), t2)]), t.parseSliceAttributes = (e2) => {
          const t2 = e2.attributes.getInts("starts"), n2 = e2.attributes.getInts("ends"), o2 = e2.attributes.getInts("axes", []);
          return (0, r.createAttributeWithCacheKey)({ starts: t2, ends: n2, axes: o2 });
        };
        const u = (e2, t2, n2) => {
          const r2 = 0 === n2.axes.length ? t2.dims.slice(0).map((e3, t3) => t3) : n2.axes, o2 = i.ShapeUtil.normalizeAxes(r2, t2.dims.length), u2 = n2.starts.map((e3, n3) => e3 > t2.dims[o2[n3]] - 1 ? t2.dims[o2[n3]] : i.ShapeUtil.normalizeAxis(e3, t2.dims[o2[n3]])), l2 = n2.ends.map((e3, n3) => e3 > t2.dims[o2[n3]] - 1 ? t2.dims[o2[n3]] : i.ShapeUtil.normalizeAxis(e3, t2.dims[o2[n3]])), c2 = t2.dims.slice(), p2 = [];
          for (let e3 = 0; e3 < o2.length; e3++)
            c2[o2[e3]] = l2[e3] - u2[e3], u2[e3] > 0 && p2.push(`outputIdx[${o2[e3]}] += ${u2[e3]};`);
          const d = `
      float process(int outputIdx[${c2.length}]) {
        ${p2.join("\n      ")}
        return _A(outputIdx);
      }`;
          return Object.assign(Object.assign({}, s), { output: { dims: c2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Slice requires 1 input.");
          if (-1 === o.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
        };
        t.sliceV10 = (e2, t2) => {
          p(t2);
          const n2 = c(e2, t2);
          return [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(e2, t2[0], n2) }), [t2[0]])];
        };
        const c = (e2, t2) => {
          if (!e2.session.isInitializer(t2[1].dataId) || !e2.session.isInitializer(t2[2].dataId) || t2.length >= 4 && !e2.session.isInitializer(t2[3].dataId) || t2.length >= 5 && !e2.session.isInitializer(t2[4].dataId))
            throw new Error("dynamic slice attributes are not allowed");
          if (t2.length >= 5 && t2[4].integerData.some((e3) => 1 !== e3))
            throw new Error("currently non-1 steps is not supported for Slice");
          const n2 = Array.from(t2[1].integerData), r2 = Array.from(t2[2].integerData), o2 = t2.length >= 4 ? Array.from(t2[3].integerData) : [];
          return { starts: n2, ends: r2, axes: o2, cacheKey: `${o2};${n2};${r2}` };
        }, p = (e2) => {
          if (!e2 || e2.length < 3 || e2.length > 5)
            throw new Error("Invalid input number.");
          if ("int32" !== e2[1].type || 1 !== e2[1].dims.length)
            throw new Error("Invalid input type.");
          if ("int32" !== e2[2].type || 1 !== e2[2].dims.length)
            throw new Error("Invalid input type.");
          if (e2.length >= 4 && ("int32" !== e2[3].type || 1 !== e2[3].dims.length))
            throw new Error("Invalid input type.");
          if (e2.length >= 5 && ("int32" !== e2[4].type || 1 !== e2[4].dims.length))
            throw new Error("Invalid input type.");
        };
      }, 815: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.softmaxV13 = t.parseSoftmaxAttributesV13 = t.parseSoftmaxAttributes = t.softmax = void 0;
        const r = n(4910), o = n(7273), i = n(6757), a = n(5639), s = n(5707), u = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] }, l = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, c = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked] };
        t.softmax = (e2, t2, n2) => {
          g(t2);
          const r2 = t2[0].dims.slice(), i2 = o.ShapeUtil.normalizeAxis(n2.axis, r2.length), a2 = o.ShapeUtil.sizeToDimension(r2, i2), s2 = o.ShapeUtil.sizeFromDimension(r2, i2);
          return p(e2, t2, n2, a2, s2);
        }, t.parseSoftmaxAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", 1) }), t.parseSoftmaxAttributesV13 = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", -1) }), t.softmaxV13 = (e2, t2, n2) => {
          g(t2);
          const i2 = t2[0].dims.slice(), a2 = o.ShapeUtil.normalizeAxis(n2.axis, i2.length), u2 = i2.length, l2 = a2 !== u2 - 1, c2 = [];
          let d2, f2 = [], h2 = [];
          l2 && (f2 = Array.from({ length: u2 }).map((e3, t3) => t3), f2[a2] = u2 - 1, f2[u2 - 1] = a2, f2.map((e3) => c2.push(i2[e3])), d2 = (0, r.createAttributeWithCacheKey)({ perm: f2 }), h2 = (0, s.transpose)(e2, t2, d2));
          const b = l2 ? o.ShapeUtil.sizeToDimension(c2, u2 - 1) : o.ShapeUtil.sizeToDimension(i2, u2 - 1), m = l2 ? o.ShapeUtil.sizeFromDimension(c2, u2 - 1) : o.ShapeUtil.sizeFromDimension(i2, u2 - 1), y = p(e2, l2 ? h2 : t2, n2, b, m);
          return l2 ? (0, s.transpose)(e2, y, d2) : y;
        };
        const p = (e2, t2, n2, r2, o2) => {
          const i2 = d(e2, t2[0], r2, o2, [r2]), a2 = e2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => i2 }), t2), s2 = f(e2, t2[0], r2, o2, i2.output.dims, [r2]), p2 = e2.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => s2 }), [t2[0], a2]), g2 = h(e2, t2[0], r2, o2, i2.output.dims, s2.output.dims);
          return [e2.run(Object.assign(Object.assign({}, c), { cacheHint: n2.cacheKey, get: () => g2 }), [t2[0], a2, p2])];
        }, d = (e2, t2, n2, r2, o2) => {
          const [s2, l2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), c2 = o2.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== o2.length)
            throw new Error("Dimensionality of the output should be 1");
          if (o2[0] !== n2)
            throw new Error("Shape of the output should be equal to logical row count");
          const p2 = (0, i.getGlsl)(e2.session.backend.glContext.version), d2 = `
      float process(int[${c2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float max = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s2},
        ${l2} )));
        for(int i=1; i<${r2}; ++i)
        {
          float current = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s2}, ${l2})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
          return Object.assign(Object.assign({}, u), { output: { dims: o2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d2 });
        }, f = (e2, t2, n2, r2, o2, s2) => {
          const [u2, c2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), p2 = s2.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== s2.length)
            throw new Error("Dimensionality of the output should be 1");
          if (s2[0] !== n2)
            throw new Error("Shape of the output should be equal to logical row count");
          if (1 !== o2.length)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (o2[0] !== n2)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          const d2 = `
      float process(int[${p2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r2}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, i.getGlsl)(e2.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u2}, ${c2}))) - max);
        }

        return norm_factor;
      }`;
          return Object.assign(Object.assign({}, l), { output: { dims: s2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d2 });
        }, h = (e2, t2, n2, r2, o2, i2) => {
          const [s2, u2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), l2 = t2.dims.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== o2.length || 1 !== i2.length)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (o2[0] !== n2 || i2[0] !== n2)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          const p2 = `
      float process(int[${l2}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s2}, ${u2});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r2};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
          return Object.assign(Object.assign({}, c), { output: { dims: t2.dims, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: p2 });
        }, g = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Softmax requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type");
        };
      }, 564: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSplitAttributes = t.split = void 0;
        const r = n(4910), o = n(7273), i = n(5639), a = { name: "Split", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
        t.split = (e2, t2, n2) => {
          l(t2);
          const r2 = o.ShapeUtil.normalizeAxis(n2.axis, t2[0].dims.length), i2 = s(e2, t2, r2, n2), c = [];
          for (let o2 = 0; o2 < i2; ++o2)
            c.push(e2.run(Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey};${o2}`, get: () => u(e2, t2[0], n2, r2, o2) }), t2));
          return c;
        }, t.parseSplitAttributes = (e2) => {
          const t2 = e2.attributes.getInt("axis", 0), n2 = e2.attributes.getInts("split", []), o2 = e2.outputs.length;
          return (0, r.createAttributeWithCacheKey)({ axis: t2, split: n2, numOutputs: o2 });
        };
        const s = (e2, t2, n2, r2) => {
          const [, i2] = o.SplitUtil.splitShape(t2[0].dims, n2, r2.split, r2.numOutputs);
          return i2.length;
        }, u = (e2, t2, n2, r2, s2) => {
          const [u2, l2] = o.SplitUtil.splitShape(t2.dims, r2, n2.split, n2.numOutputs), c = l2[s2], p = u2[s2], d = `
      float process(int indices[${p.length}]) {
        indices[${r2}] += ${c};
        return _A(indices);
      }
    `;
          return Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey}:${s2}`, output: { dims: p, type: t2.type, textureType: i.TextureType.unpacked }, shaderSource: d });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Split requires one input.");
          if ("int8" !== e2[0].type && "uint8" !== e2[0].type && "int16" !== e2[0].type && "uint16" !== e2[0].type && "int32" !== e2[0].type && "uint32" !== e2[0].type && "float32" !== e2[0].type && "float64" !== e2[0].type && "bool" !== e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 5416: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSqueezeAttributes = t.squeezeV13 = t.squeeze = void 0;
        const r = n(7273);
        t.squeeze = (e2, t2, n2) => {
          o(t2);
          const i2 = r.ShapeUtil.squeezeShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], i2)];
        }, t.squeezeV13 = (e2, n2) => (i(n2), (0, t.squeeze)(e2, [n2[0]], Array.from(n2[1].integerData))), t.parseSqueezeAttributes = (e2) => e2.attributes.getInts("axes");
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Squeeze requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("invalid input tensor types.");
        }, i = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Squeeze requires 2 inputs.");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
        };
      }, 1240: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.sum = void 0;
        const r = n(6757), o = n(5639);
        t.sum = (e2, t2) => {
          a(t2);
          const n2 = { name: "Sum", inputNames: t2.map((e3, t3) => `X${t3}`), inputTypes: new Array(t2.length).fill(o.TextureType.unpacked) };
          return [e2.run(Object.assign(Object.assign({}, n2), { get: () => i(e2, t2, n2) }), t2)];
        };
        const i = (e2, t2, n2) => {
          const i2 = (0, r.getGlsl)(e2.session.backend.glContext.version), a2 = t2[0].dims.slice(), s = `
      void main() {
        vec4 result = ${t2.map((e3, t3) => `${i2.texture2D}(X${t3},TexCoords)`).join(" + ")};
        ${i2.output} = result;
      }
    `;
          return Object.assign(Object.assign({}, n2), { output: { dims: a2, type: t2[0].type, textureType: o.TextureType.unpacked }, hasMain: true, shaderSource: s });
        }, a = (e2) => {
          if (!e2 || 0 === e2.length)
            throw new Error("Sum requires inputs.");
          const t2 = e2[0].dims.length;
          for (let n2 = 1; n2 < e2.length; n2++) {
            if (t2 !== e2[n2].dims.length)
              throw new Error("Input shapes are mismatched.");
            for (let r2 = 0; r2 < t2; r2++)
              if (e2[0].dims[r2] !== e2[n2].dims[r2])
                throw new Error("Input shapes are not matched.");
          }
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
          for (let t3 = 1; t3 < e2.length; t3++)
            if (e2[0].type !== e2[t3].type)
              throw new Error("Input types are not matched.");
        };
      }, 5944: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tile = void 0;
        const r = n(6145), o = n(5639);
        t.tile = (e2, t2) => {
          a(t2);
          const n2 = { name: "Tile", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
          return [e2.run(Object.assign(Object.assign({}, n2), { get: () => i(e2, t2, n2) }), t2)];
        };
        const i = (e2, t2, n2) => {
          const r2 = t2[0].dims.slice(), i2 = new Array(r2.length), a2 = [];
          for (let e3 = 0; e3 < r2.length; e3++)
            i2[e3] = r2[e3] * t2[1].numberData[e3], a2.push(`inputIdx[${e3}] = int(mod(float(outputIdx[${e3}]), ${r2[e3]}.));`);
          const s = i2.length, u = `
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${a2.join("\n")}
        return _A(inputIdx);
      }
    `;
          return Object.assign(Object.assign({}, n2), { output: { dims: i2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: u });
        }, a = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Tile requires 2 input.");
          if (1 !== e2[1].dims.length)
            throw new Error("The second input shape must 1 dimension.");
          if (e2[1].dims[0] !== e2[0].dims.length)
            throw new Error("Invalid input shape.");
          if (-1 === r.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
          if ("int32" !== e2[1].type && "int16" !== e2[1].type)
            throw new Error("Invalid repeat type.");
        };
      }, 5707: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseTransposeAttributes = t.transpose = void 0;
        const r = n(4910), o = n(7273), i = n(5639), a = { name: "Transpose", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
        t.transpose = (e2, t2, n2) => (p(t2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(e2, t2[0], n2.perm) }), t2)]), t.parseTransposeAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ perm: e2.attributes.getInts("perm", []) });
        const s = (e2, t2, n2) => {
          const r2 = t2.dims;
          n2 = u(r2, n2);
          const o2 = l(r2, n2), s2 = r2.length, p2 = `
      ${c("perm", n2, s2)}
      float process(int indices[${s2}]) {
        int a[${s2}];
        perm(a, indices);
        return _A(a);
      }`;
          return Object.assign(Object.assign({}, a), { output: { dims: o2, type: t2.type, textureType: i.TextureType.unpacked }, shaderSource: p2 });
        }, u = (e2, t2) => (t2 && t2.length !== e2.length && (t2 = [...e2.keys()].reverse()), t2), l = (e2, t2) => (t2 = u(e2, t2), o.ShapeUtil.sortBasedOnPerm(e2, t2)), c = (e2, t2, n2) => {
          const r2 = [];
          r2.push(`void ${e2}(out int a[${n2}], int src[${n2}]) {`);
          for (let e3 = 0; e3 < n2; ++e3)
            r2.push(`	a[${t2[e3]}]=src[${e3}];`);
          return r2.push("	}"), r2.join("\n");
        }, p = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Transpose requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("input should be float tensor");
        };
      }, 2488: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.encodeAsUint8 = void 0;
        const r = n(6757), o = n(5639);
        t.encodeAsUint8 = (e2, t2) => {
          const n2 = t2.shape, i = (0, r.getGlsl)(e2.session.backend.glContext.version), a = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${i.texture2D}(X,TexCoords).r;
      ${i.output} = encodeAsUint8(value);
    }`, s = { name: "Uint8Encode", inputTypes: [o.TextureType.unpacked], inputNames: ["X"], output: { dims: n2, type: t2.tensor.type, textureType: o.TextureType.downloadUint8AsFloat }, shaderSource: a, hasMain: true };
          return e2.executeProgram(s, [t2.tensor]);
        };
      }, 9087: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tanh = t.tan = t.sqrt = t.sin = t.sigmoid = t.relu = t.not = t.neg = t.log = t.parseLeakyReluAttributes = t.leakyRelu = t.identity = t.floor = t.exp = t.parseEluAttributes = t.elu = t.cos = t.ceil = t.clipV11 = t.parseClipAttributes = t.clip = t.atan = t.asin = t.acos = t.abs = t.glslTanh = t.glslTan = t.glslSqrt = t.glslSigmoid = t.glslRelu = t.glslSin = t.glslNot = t.glslNeg = t.glslLog = t.glslLeakyRelu = t.glslIdentity = t.glslClip = t.glslFloor = t.glslExp = t.glslElu = t.glslCos = t.glslCeil = t.glslAtan = t.glslAsin = t.glslAcos = t.glslAbs = void 0;
        const r = n(4910), o = n(7273), i = n(1997), a = n(6757), s = n(5639);
        function u() {
          return E("abs");
        }
        function l() {
          return E("acos");
        }
        function c() {
          return E("asin");
        }
        function p() {
          return E("atan");
        }
        function d() {
          return E("ceil");
        }
        function f() {
          return E("cos");
        }
        function h(e2) {
          const t2 = "elu";
          return { body: `
  const float alpha = float(${e2});

  float ${t2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
        }
        function g() {
          return E("exp");
        }
        function b() {
          return E("floor");
        }
        function m(e2, t2) {
          const n2 = "clip";
          return { body: `
  const float min = float(${e2});
  const float max = float(${t2});

  float ${n2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n2, type: i.FunctionType.ValueBased };
        }
        function y() {
          const e2 = "indentity";
          return { body: `
  float ${e2}_(float a) {
    return a;
  }
  vec4 ${e2}_(vec4 v) {
    return v;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function v(e2) {
          const t2 = "leakyRelu";
          return { body: `
  const float alpha = float(${e2});

  float ${t2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
        }
        function _() {
          return E("log");
        }
        function w() {
          const e2 = "neg";
          return { body: `
  float ${e2}_(float a) {
    return -a;
  }
  vec4 ${e2}_(vec4 v) {
    return -v;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function T() {
          const e2 = "not";
          return { body: `
  float ${e2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e2}_(bool a) {
    return !a;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function x() {
          return E("sin");
        }
        function O() {
          const e2 = "relu";
          return { body: `
  float ${e2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function S() {
          const e2 = "sigmoid";
          return { body: `
  float ${e2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function A() {
          return E("sqrt");
        }
        function P() {
          return E("tan");
        }
        function I() {
          const e2 = "tanh";
          return { body: `
  float ${e2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function E(e2) {
          return { body: `
  float ${e2}_(float a) {
    return ${e2}(a);
  }
  vec4 ${e2}_(vec4 v) {
    return ${e2}(v);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        t.glslAbs = u, t.glslAcos = l, t.glslAsin = c, t.glslAtan = p, t.glslCeil = d, t.glslCos = f, t.glslElu = h, t.glslExp = g, t.glslFloor = b, t.glslClip = m, t.glslIdentity = y, t.glslLeakyRelu = v, t.glslLog = _, t.glslNeg = w, t.glslNot = T, t.glslSin = x, t.glslRelu = O, t.glslSigmoid = S, t.glslSqrt = A, t.glslTan = P, t.glslTanh = I;
        const D = (e2, t2, n2, r2) => {
          const o2 = e2.session.pack ? s.TextureType.packed : s.TextureType.unpacked, i2 = { name: n2.name, inputTypes: [o2], inputNames: ["A"], cacheHint: r2 };
          return Object.assign(Object.assign({}, i2), { get: () => ((e3, t3, n3, r3) => {
            const o3 = e3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, i3 = (0, a.getGlsl)(e3.session.backend.glContext.version);
            return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: o3 }, shaderSource: `
     ${r3.body}
     void main() {
       vec4 v = ${i3.texture2D}(A, TexCoords);
       v = ${r3.name}_(v);
       ${i3.output} = v;
     }
     `, hasMain: true });
          })(e2, i2, t2, n2) });
        };
        t.abs = (e2, t2) => [e2.run(D(e2, t2[0], u()), t2)], t.acos = (e2, t2) => [e2.run(D(e2, t2[0], l()), t2)], t.asin = (e2, t2) => [e2.run(D(e2, t2[0], c()), t2)], t.atan = (e2, t2) => [e2.run(D(e2, t2[0], p()), t2)], t.clip = (e2, t2, n2) => [e2.run(D(e2, t2[0], m(n2.min, n2.max), n2.cacheKey), t2)], t.parseClipAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ min: e2.attributes.getFloat("min", o.MIN_CLIP), max: e2.attributes.getFloat("max", o.MAX_CLIP) }), t.clipV11 = (e2, n2) => {
          const r2 = $(e2, n2);
          return (0, t.clip)(e2, [n2[0]], r2);
        };
        const $ = (e2, t2) => {
          if (t2.length >= 3 && (!e2.session.isInitializer(t2[1].dataId) || !e2.session.isInitializer(t2[2].dataId)))
            throw new Error("dynamic clip attributes are not allowed");
          const n2 = t2.length >= 3 ? t2[1].numberData[0] : o.MIN_CLIP, i2 = t2.length >= 3 ? t2[2].numberData[0] : o.MAX_CLIP;
          return (0, r.createAttributeWithCacheKey)({ min: n2, max: i2 });
        };
        t.ceil = (e2, t2) => [e2.run(D(e2, t2[0], d()), t2)], t.cos = (e2, t2) => [e2.run(D(e2, t2[0], f()), t2)], t.elu = (e2, t2, n2) => [e2.run(D(e2, t2[0], h(n2.alpha), n2.cacheKey), t2)], t.parseEluAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ alpha: e2.attributes.getFloat("alpha", 1) }), t.exp = (e2, t2) => [e2.run(D(e2, t2[0], g()), t2)], t.floor = (e2, t2) => [e2.run(D(e2, t2[0], b()), t2)], t.identity = (e2, t2) => [e2.run(D(e2, t2[0], y()), t2)], t.leakyRelu = (e2, t2, n2) => [e2.run(D(e2, t2[0], v(n2.alpha), n2.cacheKey), t2)], t.parseLeakyReluAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ alpha: e2.attributes.getFloat("alpha", 0.01) }), t.log = (e2, t2) => [e2.run(D(e2, t2[0], _()), t2)], t.neg = (e2, t2) => [e2.run(D(e2, t2[0], w()), t2)], t.not = (e2, t2) => [e2.run(D(e2, t2[0], T()), t2)], t.relu = (e2, t2) => [e2.run(D(e2, t2[0], O()), t2)], t.sigmoid = (e2, t2) => [e2.run(D(e2, t2[0], S()), t2)], t.sin = (e2, t2) => [e2.run(D(e2, t2[0], x()), t2)], t.sqrt = (e2, t2) => [e2.run(D(e2, t2[0], A()), t2)], t.tan = (e2, t2) => [e2.run(D(e2, t2[0], P()), t2)], t.tanh = (e2, t2) => [e2.run(D(e2, t2[0], I()), t2)];
      }, 540: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackProgramInfoLoader = t.createUnpackProgramInfo = void 0;
        const r = n(6757), o = n(5639), i = n(432), a = n(5614), s = { name: "unpack", inputNames: ["A"], inputTypes: [o.TextureType.packed] };
        t.createUnpackProgramInfo = (e2, t2) => {
          const n2 = t2.dims.length, u = (0, a.getChannels)("rc", n2), l = u.slice(-2), c = (0, i.getCoordsDataType)(n2), p = (0, a.unpackFromChannel)(), d = 0 === t2.dims.length ? "" : function(e3, t3) {
            if (1 === e3)
              return "rc";
            let n3 = "";
            for (let r2 = 0; r2 < e3; r2++)
              n3 += t3[r2], r2 < e3 - 1 && (n3 += ",");
            return n3;
          }(n2, u), f = n2 <= 1 ? "rc" : `vec2(${l.join(",")})`, h = `
    ${p}
    void main() {
      ${c} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${d});

       ${(0, r.getGlsl)(e2.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f}), 0, 0, 0);
     }
   `;
          return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: t2.dims, type: t2.type, textureType: o.TextureType.unpacked }, shaderSource: h });
        }, t.createUnpackProgramInfoLoader = (e2, n2) => Object.assign(Object.assign({}, s), { get: () => (0, t.createUnpackProgramInfo)(e2, n2) });
      }, 7862: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseUnsqueezeAttributes = t.unsqueezeV13 = t.unsqueeze = void 0;
        const r = n(7273);
        t.unsqueeze = (e2, t2, n2) => {
          o(t2);
          const i2 = r.ShapeUtil.unsqueezeShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], i2)];
        }, t.unsqueezeV13 = (e2, n2) => (i(n2), (0, t.unsqueeze)(e2, [n2[0]], Array.from(n2[1].integerData))), t.parseUnsqueezeAttributes = (e2) => e2.attributes.getInts("axes");
        const o = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Unsqueeze requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("invalid input tensor types.");
        }, i = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Unsqueeze requires 2 inputs.");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
        };
      }, 3980: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.scalesValidation = t.validateInputs = t.parseUpsampleAttributes = t.parseUpsampleAttributesV9 = t.parseUpsampleAttributesV7 = t.upsample = void 0;
        const r = n(4910), o = n(6757), i = n(5639), a = { name: "Upsample", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] };
        t.upsample = (e2, n2, r2) => ((0, t.validateInputs)(n2, r2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: r2.cacheKey, get: () => s(e2, n2, r2) }), n2)]), t.parseUpsampleAttributesV7 = (e2) => (0, t.parseUpsampleAttributes)(e2, 7), t.parseUpsampleAttributesV9 = (e2) => (0, t.parseUpsampleAttributes)(e2, 9), t.parseUpsampleAttributes = (e2, n2) => {
          const o2 = n2 >= 10, i2 = e2.attributes.getString("mode", "nearest");
          if ("nearest" !== i2 && "linear" !== i2 && (n2 < 11 || "cubic" !== i2))
            throw new Error(`unrecognized mode: ${i2}`);
          let a2 = [];
          n2 < 9 && (a2 = e2.attributes.getFloats("scales"), (0, t.scalesValidation)(a2, i2, o2));
          const s2 = e2.attributes.getFloat("extrapolation_value", 0), u = n2 > 10 ? e2.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
          if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u))
            throw new Error(`coordinate_transform_mode '${u}' is not supported`);
          const l = "tf_crop_and_resize" === u, c = l, p = "nearest" === i2 && n2 >= 11 ? e2.attributes.getString("nearest_mode", "round_prefer_floor") : "";
          if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p))
            throw new Error(`nearest_mode '${p}' is not supported`);
          const d = e2.attributes.getFloat("cubic_coeff_a", -0.75), f = 0 !== e2.attributes.getInt("exclude_outside", 0);
          if (f && "cubic" !== i2)
            throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
          const h = n2 < 11 || "nearest" === i2 && "asymmetric" === u && "floor" === p;
          let g = 0, b = 0, m = 0;
          return n2 > 10 ? e2.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n2 && (b = 1), (0, r.createAttributeWithCacheKey)({ opset: n2, isResize: o2, mode: i2, scales: a2, extrapolationValue: s2, coordinateTransformMode: u, useExtrapolation: c, needRoiInput: l, nearestMode: p, cubicCoefficientA: d, excludeOutside: f, useNearest2xOptimization: h, roiInputIdx: g, scalesInputIdx: b, sizesInputIdx: m });
        };
        const s = (e2, t2, n2) => {
          const r2 = (0, o.getGlsl)(e2.session.backend.glContext.version), [s2, u] = e2.calculateTextureWidthAndHeight(t2[0].dims, i.TextureType.unpacked), l = t2[0].dims.map((e3, t3) => Math.floor(e3 * n2.scales[t3])), [c, p] = e2.calculateTextureWidthAndHeight(l, i.TextureType.unpacked), d = l.length, f = new Array(d), h = new Array(d);
          let g = `
      int output_pitches[${d}];
      int input_pitches[${d}];
      `;
          for (let e3 = d - 1; e3 >= 0; e3--)
            f[e3] = e3 === d - 1 ? 1 : f[e3 + 1] * l[e3 + 1], h[e3] = e3 === d - 1 ? 1 : h[e3 + 1] * t2[0].dims[e3 + 1], g += `
        output_pitches[${e3}] = ${f[e3]};
        input_pitches[${e3}] = ${h[e3]};
        `;
          const b = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s2}, ${u});
        float value = getColorAsFloat(${r2.texture2D}(X, coords));
        return value;
      }
      `, m = "nearest" === n2.mode ? `
    ${b}
    float process(int indices[${d}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int d, m;
      for (int dim = 0; dim < ${d}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === d ? `
    ${b}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${t2[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${b}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${t2[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
          return Object.assign(Object.assign({}, a), { output: { dims: l, type: t2[0].type, textureType: i.TextureType.unpacked }, shaderSource: m, variables: [{ name: "scales", type: "int", arrayLength: n2.scales.length, data: n2.scales.map((e3) => Math.ceil(e3)) }] });
        };
        t.validateInputs = (e2, t2) => {
          if (!e2 || t2.opset < 9 && 1 !== e2.length || t2.opset >= 9 && t2.opset < 11 && 2 !== e2.length || t2.opset >= 11 && e2.length < 2)
            throw new Error("invalid inputs.");
          if (t2.scales.length > 0 && e2[0].dims.length !== t2.scales.length)
            throw new Error("Invalid input shape.");
          if ("string" === e2[0].type)
            throw new Error("Invalid input tensor types.");
        }, t.scalesValidation = (e2, t2, n2) => {
          if (n2) {
            for (const t3 of e2)
              if (t3 <= 0)
                throw new Error("Scale value should be greater than 0.");
          } else
            for (const t3 of e2)
              if (t3 < 1)
                throw new Error("Scale value should be greater than or equal to 1.");
          if (!("linear" !== t2 && "cubic" !== t2 || 2 === e2.length || 4 === e2.length && 1 === e2[0] && 1 === e2[1]))
            throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n2 ? "Resize" : "Upsample"} opeartor.`);
        };
      }, 2757: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ProgramManager = void 0;
        const r = n(2235), o = n(1315), i = n(8897), a = n(6757);
        t.ProgramManager = class {
          constructor(e2, t2, n2) {
            this.profiler = e2, this.glContext = t2, this.textureLayoutStrategy = n2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
          }
          getArtifact(e2) {
            return this.repo.get(e2);
          }
          setArtifact(e2, t2) {
            this.repo.set(e2, t2);
          }
          run(e2, t2, n2) {
            var r2;
            this.profiler.event("op", `ProgramManager.run ${null !== (r2 = e2.programInfo.name) && void 0 !== r2 ? r2 : "unknown kernel"}`, () => {
              var r3;
              const i2 = this.glContext.gl, a2 = e2.program;
              i2.useProgram(a2);
              try {
                this.bindOutput(n2), this.attributesBound || this.bindAttributes(e2.attribLocations), this.bindUniforms(e2.uniformLocations, null !== (r3 = e2.programInfo.variables) && void 0 !== r3 ? r3 : [], t2);
              } catch (t3) {
                throw o.Logger.error("ProgramManager", e2.programInfo.shaderSource), t3;
              }
              this.profiler.event("backend", "GlContext.draw()", () => {
                this.glContext.draw();
              });
            }, this.glContext);
          }
          dispose() {
            this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((e2) => this.glContext.deleteProgram(e2.program));
          }
          build(e2, t2, n2) {
            return this.profiler.event("backend", "ProgramManager.build", () => {
              const r2 = new i.GlslPreprocessor(this.glContext, e2, t2, n2), o2 = r2.preprocess(), a2 = this.compile(o2);
              return { programInfo: e2, program: a2, uniformLocations: this.getUniformLocations(a2, r2.context.programInfo.inputNames, r2.context.programInfo.variables), attribLocations: this.getAttribLocations(a2) };
            });
          }
          compile(e2) {
            if (!this.vertexShader) {
              o.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
              const e3 = (0, a.getVertexShaderSource)(this.glContext.version);
              this.vertexShader = this.glContext.compileShader(e3, this.glContext.gl.VERTEX_SHADER);
            }
            r.env.debug && o.Logger.verbose("ProrgramManager", `FragShader:
${e2}
`);
            const t2 = this.glContext.compileShader(e2, this.glContext.gl.FRAGMENT_SHADER), n2 = this.glContext.createProgram(this.vertexShader, t2);
            return this.glContext.deleteShader(t2), n2;
          }
          bindOutput(e2) {
            const t2 = e2.width, n2 = e2.height;
            o.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${t2}/${n2}, shape=${e2.shape}, type=${e2.tensor.type}`), this.glContext.attachFramebuffer(e2.texture, t2, n2);
          }
          bindAttributes(e2) {
            const t2 = e2.position, n2 = e2.textureCoord;
            this.glContext.setVertexAttributes(t2, n2), this.attributesBound = true;
          }
          bindUniforms(e2, t2, n2) {
            var r2;
            const o2 = this.glContext.gl;
            let i2 = 0;
            for (const { name: a2, type: s, location: u, arrayLength: l } of e2) {
              const e3 = null === (r2 = t2.find((e4) => e4.name === a2)) || void 0 === r2 ? void 0 : r2.data;
              if ("sampler2D" !== s && !e3)
                throw new Error(`variable '${a2}' does not have data defined in program info`);
              switch (s) {
                case "sampler2D":
                  this.bindTexture(n2[i2], u, i2), i2++;
                  break;
                case "float":
                  l ? o2.uniform1fv(u, e3) : o2.uniform1f(u, e3);
                  break;
                case "int":
                  l ? o2.uniform1iv(u, e3) : o2.uniform1i(u, e3);
                  break;
                default:
                  throw new Error(`Uniform not implemented: ${s}`);
              }
            }
          }
          bindTexture(e2, t2, n2) {
            this.glContext.bindTextureToUniform(e2.texture, n2, t2);
          }
          getAttribLocations(e2) {
            return { position: this.getAttribLocation(e2, "position"), textureCoord: this.getAttribLocation(e2, "textureCoord") };
          }
          getUniformLocations(e2, t2, n2) {
            const r2 = [];
            if (t2)
              for (const n3 of t2)
                r2.push({ name: n3, type: "sampler2D", location: this.getUniformLocation(e2, n3) });
            if (n2)
              for (const t3 of n2)
                r2.push(Object.assign(Object.assign({}, t3), { location: this.getUniformLocation(e2, t3.name) }));
            return r2;
          }
          getUniformLocation(e2, t2) {
            const n2 = this.glContext.gl.getUniformLocation(e2, t2);
            if (null === n2)
              throw new Error(`Uniform ${t2} not found.`);
            return n2;
          }
          getAttribLocation(e2, t2) {
            return this.glContext.gl.getAttribLocation(e2, t2);
          }
        };
      }, 2171: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLSessionHandler = void 0;
        const r = n(1315), o = n(5881), i = n(7860), a = n(4110), s = n(2757), u = n(7618), l = n(5243);
        t.WebGLSessionHandler = class {
          constructor(e2, t2) {
            this.backend = e2, this.context = t2, this.layoutStrategy = new u.PreferLogicalStrategy(e2.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, e2.glContext, this.layoutStrategy), this.textureManager = new l.TextureManager(e2.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === e2.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = e2.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
          }
          createInferenceHandler() {
            return new i.WebGLInferenceHandler(this);
          }
          onGraphInitialized(e2) {
            const t2 = e2.getValues().filter((e3) => -1 === e3.from && e3.tensor).map((e3) => e3.tensor.dataId);
            this.initializers = new Set(t2);
          }
          isInitializer(e2) {
            return !!this.initializers && this.initializers.has(e2);
          }
          addInitializer(e2) {
            this.initializers.add(e2);
          }
          getTextureData(e2, t2) {
            return t2 ? this.packedTextureDataCache.get(e2) : this.unpackedTextureDataCache.get(e2);
          }
          setTextureData(e2, t2, n2 = false) {
            r.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n2 ? this.packedTextureDataCache.set(e2, t2) : this.unpackedTextureDataCache.set(e2, t2);
          }
          dispose() {
            this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e2) => this.textureManager.releaseTexture(e2, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((e2) => this.textureManager.releaseTexture(e2, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          resolve(e2, t2, n2) {
            const r2 = (0, o.resolveOperator)(e2, t2, a.WEBGL_OP_RESOLVE_RULES);
            return { impl: r2.opImpl, context: r2.opInit ? r2.opInit(e2, n2) : e2 };
          }
        };
      }, 9622: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Uint8DataEncoder = t.RGBAFloatDataEncoder = t.RedFloat32DataEncoder = void 0;
        const r = n(1315);
        t.RedFloat32DataEncoder = class {
          constructor(e2, t2 = 1) {
            if (1 === t2)
              this.internalFormat = e2.R32F, this.format = e2.RED, this.textureType = e2.FLOAT, this.channelSize = t2;
            else {
              if (4 !== t2)
                throw new Error(`Invalid number of channels: ${t2}`);
              this.internalFormat = e2.RGBA32F, this.format = e2.RGBA, this.textureType = e2.FLOAT, this.channelSize = t2;
            }
          }
          encode(e2, t2) {
            let n2, o;
            return e2.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), o = new Float32Array(e2)), t2 * this.channelSize > e2.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), o = e2, n2 = this.allocate(t2 * this.channelSize), o.forEach((e3, t3) => n2[t3] = e3)) : (o = e2, n2 = o), n2;
          }
          allocate(e2) {
            return new Float32Array(4 * e2);
          }
          decode(e2, t2) {
            return 1 === this.channelSize ? e2.filter((e3, t3) => t3 % 4 == 0).subarray(0, t2) : e2.subarray(0, t2);
          }
        }, t.RGBAFloatDataEncoder = class {
          constructor(e2, t2 = 1, n2) {
            if (1 !== t2 && 4 !== t2)
              throw new Error(`Invalid number of channels: ${t2}`);
            this.internalFormat = e2.RGBA, this.format = e2.RGBA, this.channelSize = t2, this.textureType = n2 || e2.FLOAT;
          }
          encode(e2, t2) {
            let n2 = e2;
            return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n2 = this.allocate(t2), e2.forEach((e3, t3) => n2[4 * t3] = e3)), n2;
          }
          allocate(e2) {
            return new Float32Array(4 * e2);
          }
          decode(e2, t2) {
            return 1 === this.channelSize ? e2.filter((e3, t3) => t3 % 4 == 0).subarray(0, t2) : e2.subarray(0, t2);
          }
        }, t.Uint8DataEncoder = class {
          constructor(e2, t2 = 1) {
            if (this.channelSize = 4, 1 === t2)
              this.internalFormat = e2.ALPHA, this.format = e2.ALPHA, this.textureType = e2.UNSIGNED_BYTE, this.channelSize = t2;
            else {
              if (4 !== t2)
                throw new Error(`Invalid number of channels: ${t2}`);
              this.internalFormat = e2.RGBA, this.format = e2.RGBA, this.textureType = e2.UNSIGNED_BYTE, this.channelSize = t2;
            }
          }
          encode(e2, t2) {
            return new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength);
          }
          allocate(e2) {
            return new Uint8Array(e2 * this.channelSize);
          }
          decode(e2, t2) {
            if (e2 instanceof Uint8Array)
              return e2.subarray(0, t2);
            throw new Error(`Invalid array type: ${e2.constructor}`);
          }
        };
      }, 7618: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getBatchDim = t.sizeToSquarishShape = t.getRowsCols = t.sizeFromShape = t.isInt = t.parseAxisParam = t.squeezeShape = t.PreferLogicalStrategy = t.AlwaysKeepOriginalSizeStrategy = void 0;
        const r = n(1315), o = n(7273);
        function i(e2, t2) {
          const n2 = [], r2 = [], o2 = null != t2 && Array.isArray(t2) && 0 === t2.length, i2 = null == t2 || o2 ? null : a(t2, e2).sort();
          let s2 = 0;
          for (let t3 = 0; t3 < e2.length; ++t3) {
            if (null != i2) {
              if (i2[s2] === t3 && 1 !== e2[t3])
                throw new Error(`Can't squeeze axis ${t3} since its dim '${e2[t3]}' is not 1`);
              (null == i2[s2] || i2[s2] > t3) && 1 === e2[t3] && (n2.push(e2[t3]), r2.push(t3)), i2[s2] <= t3 && s2++;
            }
            1 !== e2[t3] && (n2.push(e2[t3]), r2.push(t3));
          }
          return { newShape: n2, keptDims: r2 };
        }
        function a(e2, t2) {
          const n2 = t2.length;
          return e2 = null == e2 ? t2.map((e3, t3) => t3) : [].concat(e2), (0, o.assert)(e2.every((e3) => e3 >= -n2 && e3 < n2), () => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${e2}`), (0, o.assert)(e2.every(s), () => `All values in axis param must be integers but got axis ${e2}`), e2.map((e3) => e3 < 0 ? n2 + e3 : e3);
        }
        function s(e2) {
          return e2 % 1 == 0;
        }
        function u(e2) {
          if (0 === e2.length)
            return 1;
          let t2 = e2[0];
          for (let n2 = 1; n2 < e2.length; n2++)
            t2 *= e2[n2];
          return t2;
        }
        function l(e2) {
          const t2 = Math.ceil(Math.sqrt(e2));
          return [t2, Math.ceil(e2 / t2)];
        }
        t.AlwaysKeepOriginalSizeStrategy = class {
          constructor(e2) {
            this.maxTextureSize = e2;
          }
          computeTextureWH(e2, t2) {
            if (0 === e2.length)
              return [1, 1];
            const n2 = this.maxTextureSize;
            if (t2 && void 0 !== t2.breakAxis) {
              const o3 = t2.breakAxis >= e2.length ? 1 : e2.slice(t2.breakAxis).reduce((e3, t3) => e3 * t3), i3 = t2.breakAxis <= 0 ? 1 : e2.slice(0, t2.breakAxis).reduce((e3, t3) => e3 * t3);
              if (!(o3 > n2 || i3 > n2))
                return [o3, i3];
              r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e2}, breakAxis:${t2.breakAxis}`);
            }
            const o2 = e2.reduce((e3, t3) => e3 * t3);
            let i2 = Math.floor(Math.sqrt(o2));
            for (; i2 < n2 && i2 < o2 && o2 % i2 != 0; i2++)
              ;
            if (i2 >= n2 || o2 % i2 != 0)
              throw new Error(`The given dimensions are outside this GPU's boundaries: ${e2}`);
            return [i2, o2 / i2];
          }
        }, t.PreferLogicalStrategy = class {
          constructor(e2) {
            this.maxTextureSize = e2;
          }
          computeTextureWH(e2, t2) {
            const n2 = this.computeTexture(e2, t2);
            return t2 && t2.isPacked && (n2[0] /= 2, n2[1] /= 2), t2 && t2.reverseWH ? [n2[1], n2[0]] : n2;
          }
          computeTexture(e2, t2) {
            const n2 = t2 && t2.isPacked;
            if (0 === e2.length)
              return n2 ? [2, 2] : [1, 1];
            let o2 = this.maxTextureSize;
            if (t2 && void 0 !== t2.breakAxis) {
              const n3 = t2.breakAxis >= e2.length ? 1 : e2.slice(t2.breakAxis).reduce((e3, t3) => e3 * t3), i2 = t2.breakAxis <= 0 ? 1 : e2.slice(0, t2.breakAxis).reduce((e3, t3) => e3 * t3);
              if (!(n3 > o2 || i2 > o2))
                return [n3, i2];
              r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e2}, breakAxis:${t2.breakAxis}`);
            }
            let a2 = e2.slice(0);
            if (n2 && (o2 *= 2, a2 = a2.map((e3, t3) => t3 >= a2.length - 2 ? a2[t3] % 2 == 0 ? a2[t3] : a2[t3] + 1 : a2[t3]), 1 === a2.length && (a2 = [2, a2[0]])), 2 !== a2.length) {
              const e3 = i(a2);
              a2 = e3.newShape;
            }
            const s2 = u(a2);
            return a2.length <= 1 && s2 <= o2 ? [1, s2] : 2 === a2.length && a2[0] <= o2 && a2[1] <= o2 ? a2 : 3 === a2.length && a2[0] * a2[1] <= o2 && a2[2] <= o2 ? [a2[0] * a2[1], a2[2]] : 3 === a2.length && a2[0] <= o2 && a2[1] * a2[2] <= o2 ? [a2[0], a2[1] * a2[2]] : 4 === a2.length && a2[0] * a2[1] * a2[2] <= o2 && a2[3] <= o2 ? [a2[0] * a2[1] * a2[2], a2[3]] : 4 === a2.length && a2[0] <= o2 && a2[1] * a2[2] * a2[3] <= o2 ? [a2[0], a2[1] * a2[2] * a2[3]] : n2 ? l(s2 / 4).map((e3) => 2 * e3) : l(s2);
          }
        }, t.squeezeShape = i, t.parseAxisParam = a, t.isInt = s, t.sizeFromShape = u, t.getRowsCols = function(e2) {
          if (0 === e2.length)
            throw Error("Cannot get rows and columns of an empty shape array.");
          return [e2.length > 1 ? e2[e2.length - 2] : 1, e2[e2.length - 1]];
        }, t.sizeToSquarishShape = l, t.getBatchDim = function(e2, t2 = 2) {
          return u(e2.slice(0, e2.length - t2));
        };
      }, 3314: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createTextureLayoutFromShape = t.calculateTextureWidthAndHeight = t.createTextureLayoutFromTextureType = void 0;
        const r = n(7273), o = n(5639);
        t.createTextureLayoutFromTextureType = (e2, n2, r2) => {
          const i = r2 === o.TextureType.unpacked || r2 === o.TextureType.unpackedReversed ? 1 : 4, a = r2 === o.TextureType.packed, s = r2 === o.TextureType.unpackedReversed || r2 === o.TextureType.packed, u = r2 === o.TextureType.packedLastDimension ? n2.length - 1 : void 0, l = r2 === o.TextureType.packedLastDimension ? n2.map((e3, t2) => t2 === n2.length - 1 ? 4 * e3 : e3) : void 0;
          return (0, t.createTextureLayoutFromShape)(e2, n2, i, l, { isPacked: a, reverseWH: s, breakAxis: u });
        }, t.calculateTextureWidthAndHeight = (e2, n2, r2) => {
          const o2 = (0, t.createTextureLayoutFromTextureType)(e2, n2, r2);
          return [o2.width, o2.height];
        }, t.createTextureLayoutFromShape = (e2, t2, n2 = 1, o2, i) => {
          const a = !(!i || !i.isPacked), [s, u] = e2.computeTextureWH(a && o2 || t2, i), l = t2.length;
          let c = t2.slice(0);
          if (0 === l && (c = [1]), 1 === n2)
            o2 = t2;
          else if (a) {
            if (4 !== n2)
              throw new Error("a packed texture must be 4-channel");
            o2 = t2, l > 0 && (c[l - 1] = Math.ceil(c[l - 1] / 2)), l > 1 && (c[l - 2] = Math.ceil(c[l - 2] / 2));
          } else if (!o2)
            throw new Error("Unpacked shape is needed when using channels > 1");
          return { width: s, height: u, channels: n2, isPacked: a, shape: c, strides: r.ShapeUtil.computeStrides(c), unpackedShape: o2, reversedWH: i && i.reverseWH };
        };
      }, 5243: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.TextureManager = void 0;
        const r = n(1315);
        t.TextureManager = class {
          constructor(e2, t2, n2, r2) {
            this.glContext = e2, this.layoutStrategy = t2, this.profiler = n2, this.config = r2, this.pendingRead = /* @__PURE__ */ new Map(), r2.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
          }
          createTextureFromLayout(e2, t2, n2, o) {
            const i = this.toEncoderType(e2), a = this.glContext.getEncoder(i, t2.channels || 1, o);
            if (t2.isPacked && 1 === o)
              throw new Error("not implemented");
            const s = t2.width, u = t2.height;
            let l, c;
            if (this.config.reuseTextures) {
              l = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, c = this.inUseTextures.get(l), c || (c = [], this.inUseTextures.set(l, c));
              const t3 = this.idleTextures.get(l);
              if (t3 && t3.length > 0) {
                const r2 = t3.pop();
                return c.push(r2), 1 === o && this.glContext.updateTexture(r2, s, u, a, this.toTextureData(e2, n2)), r2;
              }
            }
            r.Logger.verbose("TextureManager", `Creating new texture of size ${t2.width}x${t2.height}`);
            const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(e2, n2));
            return this.config.reuseTextures && (c.push(p), this.textureLookup.set(p, l)), p;
          }
          readTexture(e2, t2, n2) {
            return n2 || (n2 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
              const r2 = e2.shape.reduce((e3, t3) => e3 * t3) * n2, o = this.glContext.readTexture(e2.texture, e2.width, e2.height, r2, this.toEncoderType(t2), n2);
              return this.toTensorData(t2, o);
            });
          }
          async readTextureAsync(e2, t2, n2) {
            const r2 = e2.tensor.dataId;
            if (n2 || (n2 = 1), this.pendingRead.has(r2)) {
              const e3 = this.pendingRead.get(r2);
              return new Promise((t3) => null == e3 ? void 0 : e3.push(t3));
            }
            return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
              this.pendingRead.set(r2, []);
              const o = e2.shape.reduce((e3, t3) => e3 * t3) * n2;
              await this.glContext.createAndWaitForFence();
              const i = this.glContext.readTexture(e2.texture, e2.width, e2.height, o, this.toEncoderType(t2), n2), a = this.toTensorData(t2, i), s = this.pendingRead.get(r2);
              return this.pendingRead.delete(r2), null == s || s.forEach((e3) => e3(a)), a;
            });
          }
          readUint8TextureAsFloat(e2) {
            return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
              const t2 = e2.shape.reduce((e3, t3) => e3 * t3), n2 = this.glContext.readTexture(e2.texture, e2.width, e2.height, 4 * t2, "byte", 4);
              return new Float32Array(n2.buffer, n2.byteOffset, t2);
            });
          }
          releaseTexture(e2, t2) {
            let n2;
            if (this.config.reuseTextures && (n2 = this.textureLookup.get(e2.texture), n2)) {
              t2 && this.textureLookup.delete(n2);
              const r2 = this.inUseTextures.get(n2);
              if (r2) {
                const t3 = r2.indexOf(e2.texture);
                if (-1 !== t3) {
                  r2.splice(t3, 1);
                  let o = this.idleTextures.get(n2);
                  o || (o = [], this.idleTextures.set(n2, o)), o.push(e2.texture);
                }
              }
            }
            n2 && !t2 || (r.Logger.verbose("TextureManager", `Deleting texture of size ${e2.width}x${e2.height}`), this.glContext.deleteTexture(e2.texture));
          }
          toTensorData(e2, t2) {
            switch (e2) {
              case "int16":
                return t2 instanceof Int16Array ? t2 : Int16Array.from(t2);
              case "int32":
                return t2 instanceof Int32Array ? t2 : Int32Array.from(t2);
              case "int8":
                return t2 instanceof Int8Array ? t2 : Int8Array.from(t2);
              case "uint16":
                return t2 instanceof Uint16Array ? t2 : Uint16Array.from(t2);
              case "uint32":
                return t2 instanceof Uint32Array ? t2 : Uint32Array.from(t2);
              case "uint8":
              case "bool":
                return t2 instanceof Uint8Array ? t2 : Uint8Array.from(t2);
              case "float32":
                return t2 instanceof Float32Array ? t2 : Float32Array.from(t2);
              case "float64":
                return t2 instanceof Float64Array ? t2 : Float64Array.from(t2);
              default:
                throw new Error(`TensorData type ${e2} is not supported`);
            }
          }
          toTextureData(e2, t2) {
            if (t2)
              return t2 instanceof Float32Array ? t2 : new Float32Array(t2);
          }
          toEncoderType(e2) {
            return "float";
          }
          clearActiveTextures() {
            this.glContext.clearActiveTextures();
          }
        };
      }, 5639: (e, t) => {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: true }), t.TextureType = void 0, (n = t.TextureType || (t.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
      }, 432: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getGlChannels = t.getCoordsDataType = t.getSqueezedParams = t.squeezeInputShape = t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = t.generateShaderFuncNameFromInputSamplerName = t.repeatedTry = t.getPackedShape = void 0;
        const r = n(7273);
        t.getPackedShape = function(e2) {
          const t2 = e2.length;
          return e2.slice(0, t2 - 1).concat(e2[t2 - 1] / 4);
        }, t.repeatedTry = async function(e2, t2 = (e3) => 0, n2) {
          return new Promise((r2, o) => {
            let i = 0;
            const a = () => {
              if (e2())
                return void r2();
              i++;
              const s = t2(i);
              null != n2 && i >= n2 ? o() : setTimeout(a, s);
            };
            a();
          });
        }, t.generateShaderFuncNameFromInputSamplerName = function(e2) {
          return (0, r.assert)(void 0 !== e2 && 0 !== e2.length, () => "empty string found for sampler name"), "get" + e2.charAt(0).toUpperCase() + e2.slice(1);
        }, t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(e2) {
          return (0, r.assert)(void 0 !== e2 && 0 !== e2.length, () => "empty string found for sampler name"), "get" + e2.charAt(0).toUpperCase() + e2.slice(1) + "AtOutCoords";
        }, t.squeezeInputShape = function(e2, t2) {
          let n2 = JSON.parse(JSON.stringify(e2));
          return n2 = t2, n2;
        }, t.getSqueezedParams = function(e2, t2) {
          return t2.map((t3) => e2[t3]).join(", ");
        }, t.getCoordsDataType = function(e2) {
          if (e2 <= 1)
            return "int";
          if (2 === e2)
            return "ivec2";
          if (3 === e2)
            return "ivec3";
          if (4 === e2)
            return "ivec4";
          if (5 === e2)
            return "ivec5";
          if (6 === e2)
            return "ivec6";
          throw Error(`GPU for rank ${e2} is not yet supported`);
        }, t.getGlChannels = function(e2 = 6) {
          return ["x", "y", "z", "w", "u", "v"].slice(0, e2);
        };
      }, 3389: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createNewWebGLContext = t.createWebGLContext = void 0;
        const r = n(1315), o = n(3524), i = {};
        function a(e2, t2) {
          let n2;
          const i2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
          if ((!t2 || "webgl2" === t2) && (n2 = e2.getContext("webgl2", i2), n2))
            try {
              return new o.WebGLContext(n2, 2);
            } catch (e3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${e3}`);
            }
          if ((!t2 || "webgl" === t2) && (n2 = e2.getContext("webgl", i2) || e2.getContext("experimental-webgl", i2), n2))
            try {
              return new o.WebGLContext(n2, 1);
            } catch (e3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e3}`);
            }
          throw new Error("WebGL is not supported");
        }
        t.createWebGLContext = function e2(t2) {
          let n2;
          if (t2 && "webgl2" !== t2 || !("webgl2" in i) ? t2 && "webgl" !== t2 || !("webgl" in i) || (n2 = i.webgl) : n2 = i.webgl2, !n2)
            try {
              n2 = a(function() {
                if ("undefined" == typeof OffscreenCanvas)
                  throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
                return new OffscreenCanvas(1, 1);
              }(), t2);
            } catch (e3) {
              n2 = a(function() {
                if ("undefined" == typeof document)
                  throw new TypeError("failed to create canvas: document is not supported");
                const e4 = document.createElement("canvas");
                return e4.width = 1, e4.height = 1, e4;
              }(), t2);
            }
          t2 = t2 || 1 === n2.version ? "webgl" : "webgl2";
          const r2 = n2.gl;
          return i[t2] = n2, r2.isContextLost() ? (delete i[t2], e2(t2)) : (r2.disable(r2.DEPTH_TEST), r2.disable(r2.STENCIL_TEST), r2.disable(r2.BLEND), r2.disable(r2.DITHER), r2.disable(r2.POLYGON_OFFSET_FILL), r2.disable(r2.SAMPLE_COVERAGE), r2.enable(r2.SCISSOR_TEST), r2.enable(r2.CULL_FACE), r2.cullFace(r2.BACK), n2);
        }, t.createNewWebGLContext = a;
      }, 3524: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), i = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return o(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLContext = t.linearSearchLastTrue = void 0;
        const a = n(2235), s = i(n(9622)), u = n(432);
        function l(e2) {
          let t2 = 0;
          for (; t2 < e2.length && e2[t2](); ++t2)
            ;
          return t2 - 1;
        }
        t.linearSearchLastTrue = l, t.WebGLContext = class {
          constructor(e2, t2) {
            this.frameBufferBound = false, this.itemsToPoll = [], this.gl = e2, this.version = t2, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
          }
          allocateTexture(e2, t2, n2, r2) {
            const o2 = this.gl, i2 = o2.createTexture();
            o2.bindTexture(o2.TEXTURE_2D, i2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.NEAREST), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.NEAREST), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE);
            const a2 = r2 ? n2.encode(r2, e2 * t2) : null;
            return o2.texImage2D(o2.TEXTURE_2D, 0, n2.internalFormat, e2, t2, 0, n2.format, n2.textureType, a2), this.checkError(), i2;
          }
          updateTexture(e2, t2, n2, r2, o2) {
            const i2 = this.gl;
            i2.bindTexture(i2.TEXTURE_2D, e2);
            const a2 = r2.encode(o2, t2 * n2);
            i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, t2, n2, r2.format, r2.textureType, a2), this.checkError();
          }
          attachFramebuffer(e2, t2, n2) {
            const r2 = this.gl;
            r2.bindTexture(r2.TEXTURE_2D, e2), r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer), r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.COLOR_ATTACHMENT0, r2.TEXTURE_2D, e2, 0), this.checkError(), r2.viewport(0, 0, t2, n2), r2.scissor(0, 0, t2, n2);
          }
          readTexture(e2, t2, n2, r2, o2, i2) {
            const a2 = this.gl;
            i2 || (i2 = 1), this.frameBufferBound || this.attachFramebuffer(e2, t2, n2);
            const s2 = this.getEncoder(o2, i2), u2 = s2.allocate(t2 * n2);
            return a2.bindTexture(a2.TEXTURE_2D, e2), a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_2D, e2, 0), a2.readPixels(0, 0, t2, n2, a2.RGBA, s2.textureType, u2), this.checkError(), s2.decode(u2, r2);
          }
          isFramebufferReady() {
            return true;
          }
          getActiveTexture() {
            const e2 = this.gl;
            return "TEXTURE" + (e2.getParameter(this.gl.ACTIVE_TEXTURE) - e2.TEXTURE0);
          }
          getTextureBinding() {
            return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
          }
          getFramebufferBinding() {
            return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
          }
          setVertexAttributes(e2, t2) {
            const n2 = this.gl;
            n2.vertexAttribPointer(e2, 3, n2.FLOAT, false, 20, 0), n2.enableVertexAttribArray(e2), -1 !== t2 && (n2.vertexAttribPointer(t2, 2, n2.FLOAT, false, 20, 12), n2.enableVertexAttribArray(t2)), this.checkError();
          }
          createProgram(e2, t2) {
            const n2 = this.gl, r2 = n2.createProgram();
            return n2.attachShader(r2, e2), n2.attachShader(r2, t2), n2.linkProgram(r2), r2;
          }
          compileShader(e2, t2) {
            const n2 = this.gl, r2 = n2.createShader(t2);
            if (!r2)
              throw new Error(`createShader() returned null with type ${t2}`);
            if (n2.shaderSource(r2, e2), n2.compileShader(r2), false === n2.getShaderParameter(r2, n2.COMPILE_STATUS))
              throw new Error(`Failed to compile shader: ${n2.getShaderInfoLog(r2)}
Shader source:
${e2}`);
            return r2;
          }
          deleteShader(e2) {
            this.gl.deleteShader(e2);
          }
          bindTextureToUniform(e2, t2, n2) {
            const r2 = this.gl;
            r2.activeTexture(r2.TEXTURE0 + t2), this.checkError(), r2.bindTexture(r2.TEXTURE_2D, e2), this.checkError(), r2.uniform1i(n2, t2), this.checkError();
          }
          draw() {
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
          }
          checkError() {
            if (a.env.debug) {
              const e2 = this.gl, t2 = e2.getError();
              let n2 = "";
              switch (t2) {
                case e2.NO_ERROR:
                  return;
                case e2.INVALID_ENUM:
                  n2 = "INVALID_ENUM";
                  break;
                case e2.INVALID_VALUE:
                  n2 = "INVALID_VALUE";
                  break;
                case e2.INVALID_OPERATION:
                  n2 = "INVALID_OPERATION";
                  break;
                case e2.INVALID_FRAMEBUFFER_OPERATION:
                  n2 = "INVALID_FRAMEBUFFER_OPERATION";
                  break;
                case e2.OUT_OF_MEMORY:
                  n2 = "OUT_OF_MEMORY";
                  break;
                case e2.CONTEXT_LOST_WEBGL:
                  n2 = "CONTEXT_LOST_WEBGL";
                  break;
                default:
                  n2 = `Unknown WebGL Error: ${t2.toString(16)}`;
              }
              throw new Error(n2);
            }
          }
          deleteTexture(e2) {
            this.gl.deleteTexture(e2);
          }
          deleteProgram(e2) {
            this.gl.deleteProgram(e2);
          }
          getEncoder(e2, t2, n2 = 0) {
            if (2 === this.version)
              return new s.RedFloat32DataEncoder(this.gl, t2);
            switch (e2) {
              case "float":
                return 1 === n2 || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, t2) : new s.RGBAFloatDataEncoder(this.gl, t2, this.textureHalfFloatExtension.HALF_FLOAT_OES);
              case "int":
                throw new Error("not implemented");
              case "byte":
                return new s.Uint8DataEncoder(this.gl, t2);
              default:
                throw new Error(`Invalid dataType: ${e2}`);
            }
          }
          clearActiveTextures() {
            const e2 = this.gl;
            for (let t2 = 0; t2 < this.maxTextureImageUnits; ++t2)
              e2.activeTexture(e2.TEXTURE0 + t2), e2.bindTexture(e2.TEXTURE_2D, null);
          }
          dispose() {
            if (this.disposed)
              return;
            const e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteFramebuffer(this.framebuffer), e2.bindBuffer(e2.ARRAY_BUFFER, null), e2.deleteBuffer(this.vertexbuffer), e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, null), e2.finish(), this.disposed = true;
          }
          createDefaultGeometry() {
            return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
          }
          createVertexbuffer() {
            const e2 = this.gl, t2 = e2.createBuffer();
            if (!t2)
              throw new Error("createBuffer() returned null");
            const n2 = this.createDefaultGeometry();
            return e2.bindBuffer(e2.ARRAY_BUFFER, t2), e2.bufferData(e2.ARRAY_BUFFER, n2, e2.STATIC_DRAW), this.checkError(), t2;
          }
          createFramebuffer() {
            const e2 = this.gl.createFramebuffer();
            if (!e2)
              throw new Error("createFramebuffer returned null");
            return e2;
          }
          queryVitalParameters() {
            const e2 = this.gl;
            if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported)
              throw new Error("both float32 and float16 TextureType are not supported");
            this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS), this.version;
          }
          getExtensions() {
            2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
          }
          checkFloatTextureAttachableToFrameBuffer() {
            const e2 = this.gl, t2 = e2.createTexture();
            e2.bindTexture(e2.TEXTURE_2D, t2);
            const n2 = 2 === this.version ? e2.RGBA32F : e2.RGBA;
            e2.texImage2D(e2.TEXTURE_2D, 0, n2, 1, 1, 0, e2.RGBA, e2.FLOAT, null);
            const r2 = e2.createFramebuffer();
            e2.bindFramebuffer(e2.FRAMEBUFFER, r2), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0);
            const o2 = e2.checkFramebufferStatus(e2.FRAMEBUFFER) === e2.FRAMEBUFFER_COMPLETE;
            return e2.bindTexture(e2.TEXTURE_2D, null), e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteTexture(t2), e2.deleteFramebuffer(r2), o2;
          }
          checkRenderFloat32() {
            if (2 === this.version) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else if (!this.textureFloatExtension)
              return false;
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Download() {
            if (2 === this.version) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else {
              if (!this.textureFloatExtension)
                return false;
              if (!this.gl.getExtension("WEBGL_color_buffer_float"))
                return false;
            }
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Blend() {
            const e2 = this.gl;
            let t2, n2, r2, o2, i2;
            try {
              t2 = e2.createTexture(), n2 = e2.createFramebuffer(), e2.bindTexture(e2.TEXTURE_2D, t2);
              const a2 = 2 === this.version ? e2.RGBA32F : e2.RGBA;
              return e2.texImage2D(e2.TEXTURE_2D, 0, a2, 1, 1, 0, e2.RGBA, e2.FLOAT, null), e2.bindFramebuffer(e2.FRAMEBUFFER, n2), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), e2.enable(e2.BLEND), r2 = e2.createShader(e2.VERTEX_SHADER), !!r2 && (e2.shaderSource(r2, "void main(){}"), e2.compileShader(r2), o2 = e2.createShader(e2.FRAGMENT_SHADER), !!o2 && (e2.shaderSource(o2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), e2.compileShader(o2), i2 = e2.createProgram(), !!i2 && (e2.attachShader(i2, r2), e2.attachShader(i2, o2), e2.linkProgram(i2), e2.useProgram(i2), e2.drawArrays(e2.POINTS, 0, 1), e2.getError() === e2.NO_ERROR)));
            } finally {
              e2.disable(e2.BLEND), i2 && e2.deleteProgram(i2), r2 && e2.deleteShader(r2), o2 && e2.deleteShader(o2), n2 && (e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteFramebuffer(n2)), t2 && (e2.bindTexture(e2.TEXTURE_2D, null), e2.deleteTexture(t2));
            }
          }
          beginTimer() {
            if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
              const e2 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension, n2 = e2.createQuery();
              return e2.beginQuery(t2.TIME_ELAPSED_EXT, n2), n2;
            }
            throw new Error("WebGL1 profiling currently not supported.");
          }
          endTimer() {
            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const e2 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension;
              e2.endQuery(t2.TIME_ELAPSED_EXT);
            }
          }
          isTimerResultAvailable(e2) {
            let t2 = false, n2 = false;
            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const r2 = this.gl, o2 = this.disjointTimerQueryWebgl2Extension;
              t2 = r2.getQueryParameter(e2, r2.QUERY_RESULT_AVAILABLE), n2 = r2.getParameter(o2.GPU_DISJOINT_EXT);
            }
            return t2 && !n2;
          }
          getTimerResult(e2) {
            let t2 = 0;
            if (2 !== this.version)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const n2 = this.gl;
              t2 = n2.getQueryParameter(e2, n2.QUERY_RESULT), n2.deleteQuery(e2);
            }
            return t2 / 1e6;
          }
          async waitForQueryAndGetTime(e2) {
            return await (0, u.repeatedTry)(() => this.isTimerResultAvailable(e2)), this.getTimerResult(e2);
          }
          async createAndWaitForFence() {
            const e2 = this.createFence(this.gl);
            return this.pollFence(e2);
          }
          createFence(e2) {
            let t2;
            const n2 = e2, r2 = n2.fenceSync(n2.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return e2.flush(), t2 = null === r2 ? () => true : () => {
              const e3 = n2.clientWaitSync(r2, 0, 0);
              return e3 === n2.ALREADY_SIGNALED || e3 === n2.CONDITION_SATISFIED;
            }, { query: r2, isFencePassed: t2 };
          }
          async pollFence(e2) {
            return new Promise((t2) => {
              this.addItemToPoll(() => e2.isFencePassed(), () => t2());
            });
          }
          pollItems() {
            const e2 = l(this.itemsToPoll.map((e3) => e3.isDoneFn));
            for (let t2 = 0; t2 <= e2; ++t2) {
              const { resolveFn: e3 } = this.itemsToPoll[t2];
              e3();
            }
            this.itemsToPoll = this.itemsToPoll.slice(e2 + 1);
          }
          async addItemToPoll(e2, t2) {
            this.itemsToPoll.push({ isDoneFn: e2, resolveFn: t2 }), this.itemsToPoll.length > 1 || await (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length));
          }
        };
      }, 6496: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ExecutionPlan = void 0;
        const r = n(1315);
        class o {
          constructor(e2, t2) {
            this.op = e2, this.node = t2;
          }
        }
        t.ExecutionPlan = class {
          constructor(e2, t2, n2) {
            this.graph = e2, this.profiler = n2, this.initialize(t2);
          }
          initialize(e2) {
            this.profiler.event("session", "ExecutionPlan.initialize", () => {
              const t2 = this.graph.getNodes();
              if (t2.length !== e2.length)
                throw new Error("The size of nodes and OPs do not match.");
              this._ops = e2.map((e3, n2) => new o(e3, t2[n2])), this.reset(), this._starter = [], this._ops.forEach((e3, t3) => {
                let n2 = true;
                for (const t4 of e3.node.inputs)
                  if (!this._values[t4] && -1 === this.graph.getInputIndices().indexOf(t4)) {
                    n2 = false;
                    break;
                  }
                n2 && this._starter.push(t3);
              });
            });
          }
          reset() {
            this._values = this.graph.getValues().map((e2) => e2.tensor);
          }
          async execute(e2, t2) {
            return this.profiler.event("session", "ExecutionPlan.execute", async () => {
              this.reset();
              const n2 = e2.createInferenceHandler(), o2 = this.graph.getInputIndices();
              if (t2.length !== o2.length)
                throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t2.length} expected: ${o2.length}`);
              t2.forEach((e3, t3) => {
                const n3 = o2[t3];
                this._values[n3] = e3;
              });
              const i = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();
              let u = 0;
              for (; u < i.length; ) {
                const e3 = i[u++], t3 = this._ops[e3], o3 = t3.node.inputs.map((e4) => this._values[e4]);
                if (-1 !== o3.indexOf(void 0))
                  throw new Error(`unresolved input detected: op: ${t3.node}`);
                const l2 = o3;
                r.Logger.verbose("ExecPlan", `Runing op:${t3.node.name} (${l2.map((e4, n3) => `'${t3.node.inputs[n3]}': ${e4.type}[${e4.dims.join(",")}]`).join(", ")})`);
                const c = await this.profiler.event("node", t3.node.name, async () => t3.op.impl(n2, l2, t3.op.context));
                if (c.length !== t3.node.outputs.length)
                  throw new Error("the size of output does not match model definition.");
                c.forEach((e4, n3) => {
                  const r2 = t3.node.outputs[n3];
                  if (this._values[r2])
                    throw new Error(`output [${r2}] already has value: op:${t3.node.name}`);
                  this._values[r2] = e4;
                });
                const p = /* @__PURE__ */ new Set();
                c.forEach((e4, n3) => {
                  const r2 = t3.node.outputs[n3];
                  for (const e5 of a[r2].to) {
                    const t4 = s[e5];
                    let n4 = true;
                    for (const e6 of t4.inputs)
                      if (!this._values[e6]) {
                        n4 = false;
                        break;
                      }
                    n4 && p.add(e5);
                  }
                }), i.push(...p);
              }
              const l = [];
              for (let e3 = 0; e3 < this.graph.getOutputIndices().length; e3++) {
                const t3 = this.graph.getOutputIndices()[e3], n3 = this._values[t3];
                if (void 0 === n3)
                  throw new Error(`required output [${t3}] does not have value`);
                0 === t3 ? await n3.getData() : n3.data, l.push(n3);
              }
              return r.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n2.dispose(), l;
            });
          }
        };
      }, 4662: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Graph = void 0;
        const r = n(6874), o = n(5127), i = n(2446), a = n(9240), s = n(7273);
        var u = o.onnxruntime.experimental.fbs;
        t.Graph = { from: (e2, t2) => new p(e2, t2) };
        class l {
          constructor(e2) {
            this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e2 && (this.type = s.ProtoUtil.tensorValueTypeFromProto(e2.type.tensorType));
          }
          get from() {
            return this._from;
          }
          get to() {
            return this._to;
          }
        }
        class c {
          constructor(e2, t2) {
            e2 instanceof i.onnx.NodeProto ? (this.name = e2.name, this.opType = e2.opType, this.attributes = new r.Attribute(e2.attribute)) : e2 instanceof u.Node && (this.name = null != t2 ? t2 : e2.name(), this.opType = e2.opType(), this.attributes = new r.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(e2))), this.inputs = [], this.outputs = [], this.executeNode = true;
          }
        }
        class p {
          constructor(e2, t2) {
            if (!e2)
              throw new TypeError("graph is empty");
            this.buildGraph(e2), this.transformGraph(t2), this.checkIsAcyclic();
          }
          getInputIndices() {
            return this._allInputIndices;
          }
          getInputNames() {
            return this._allInputNames;
          }
          getOutputIndices() {
            return this._allOutputIndices;
          }
          getOutputNames() {
            return this._allOutputNames;
          }
          getValues() {
            return this._allData;
          }
          getNodes() {
            return this._nodes;
          }
          buildGraph(e2) {
            if (e2 instanceof i.onnx.GraphProto)
              this.buildGraphFromOnnxFormat(e2);
            else {
              if (!(e2 instanceof u.Graph))
                throw new TypeError("Graph type is not supported.");
              this.buildGraphFromOrtFormat(e2);
            }
          }
          buildGraphFromOnnxFormat(e2) {
            const t2 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            const n2 = /* @__PURE__ */ new Map();
            if (!e2.input)
              throw new Error("missing information in graph: input");
            const r2 = [];
            for (const n3 of e2.input) {
              if (t2.has(n3.name))
                throw new Error(`duplicated input name: ${n3.name}`);
              const e3 = this._allData.push(new l(n3)) - 1;
              t2.set(n3.name, e3), r2.push(n3.name);
            }
            if (!e2.initializer)
              throw new Error("missing information in graph: initializer");
            for (const n3 of e2.initializer) {
              let e3 = t2.get(n3.name);
              if (void 0 === e3) {
                const r3 = new l();
                r3.type = { shape: { dims: s.ProtoUtil.tensorDimsFromProto(n3.dims) }, tensorType: s.ProtoUtil.tensorDataTypeFromProto(n3.dataType) }, e3 = this._allData.push(r3) - 1, t2.set(n3.name, e3);
              }
              this._allData[e3]._from = -1, this._allData[e3].tensor = a.Tensor.fromProto(n3);
            }
            for (let e3 = 0; e3 < this._allData.length; e3++)
              this._allData[e3].tensor || (this._allInputIndices.push(e3), this._allInputNames.push(r2[e3]));
            if (!e2.output)
              throw new Error("missing information in graph: output");
            for (const n3 of e2.output) {
              if (t2.has(n3.name))
                throw new Error(`duplicated output name: ${n3.name}`);
              const e3 = this._allData.push(new l(n3)) - 1;
              t2.set(n3.name, e3), this._allOutputIndices.push(e3), this._allOutputNames.push(n3.name);
            }
            if (!e2.node)
              throw new Error("missing information in graph: node");
            for (const t3 of e2.node) {
              if (!t3.name)
                for (let e4 = 0; ; e4++) {
                  const r3 = `unnamed_${t3.opType}_${e4}`;
                  if (!n2.has(r3)) {
                    t3.name = r3;
                    break;
                  }
                }
              if (n2.has(t3.name))
                throw new Error(`duplicated node name: ${t3.name}`);
              const e3 = this._nodes.push(new c(t3)) - 1;
              n2.set(t3.name, e3);
            }
            for (let n3 = 0; n3 < this._nodes.length; n3++) {
              const r3 = this._nodes[n3], o2 = e2.node[n3];
              if (!o2.output)
                throw new Error(`missing output for node: ${o2.name}`);
              for (const e3 of o2.output) {
                let i2 = t2.get(e3);
                if (void 0 === i2 && (i2 = this._allData.push(new l()) - 1, t2.set(e3, i2)), r3.outputs.push(i2), void 0 !== this._allData[i2]._from)
                  throw new Error(`multiple nodes output to one data value: ${i2}`);
                if (this._allData[i2]._from = n3, "Constant" === o2.opType) {
                  if (!o2.attribute || 1 !== o2.attribute.length || !o2.attribute[0].t)
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (!o2.output || 1 !== o2.output.length)
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  r3.outputs.pop(), r3.executeNode = false, this._allData[i2]._from = -1, this._allData[i2].tensor = a.Tensor.fromProto(o2.attribute[0].t);
                }
              }
            }
            for (let n3 = 0; n3 < this._nodes.length; n3++) {
              const r3 = this._nodes[n3], o2 = e2.node[n3];
              if (!o2.input)
                throw new Error(`missing input for node: ${o2.name}`);
              for (const e3 of o2.input) {
                const i2 = t2.get(e3);
                if (void 0 === i2) {
                  if ("" === e3 && (3 === o2.input.length || 4 === o2.input.length) && "Resize" === o2.opType)
                    continue;
                  throw new Error(`unrecognized input '${e3}' for node: ${o2.name}`);
                }
                r3.inputs.push(i2), this._allData[i2]._to.push(n3);
              }
            }
            return true;
          }
          buildGraphFromOrtFormat(e2) {
            var t2, n2, r2;
            const o2 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            const i2 = /* @__PURE__ */ new Map(), p2 = [];
            for (let i3 = 0; i3 < e2.inputsLength(); i3++) {
              const a2 = e2.inputs(i3);
              if (o2.has(a2))
                throw new Error(`duplicated input name: ${a2}`);
              for (let i4 = 0; i4 < e2.nodeArgsLength(); i4++)
                if ((null === (t2 = e2.nodeArgs(i4)) || void 0 === t2 ? void 0 : t2.name()) === a2) {
                  const t3 = new l();
                  if ((null === (r2 = null === (n2 = e2.nodeArgs(i4)) || void 0 === n2 ? void 0 : n2.type()) || void 0 === r2 ? void 0 : r2.valueType()) !== u.TypeInfoValue.tensor_type)
                    throw new Error("Unexpected value type for the nodeArg.");
                  const c2 = e2.nodeArgs(i4).type().value(new u.TensorTypeAndShape()), d = s.ProtoUtil.tensorDataTypeFromProto(c2.elemType()), f = c2.shape(), h = [];
                  for (let e3 = 0; e3 < f.dimLength(); e3++)
                    h.push(s.LongUtil.longToNumber(f.dim(e3).value().dimValue()));
                  t3.type = { shape: { dims: h }, tensorType: d };
                  const g = this._allData.push(t3) - 1;
                  o2.set(a2, g), p2.push(a2);
                }
            }
            for (let t3 = 0; t3 < e2.initializersLength(); t3++) {
              const n3 = e2.initializers(t3);
              let r3 = o2.get(n3.name());
              if (void 0 === r3) {
                const e3 = new l(), t4 = s.ProtoUtil.tensorDimsFromORTFormat(n3), i3 = s.ProtoUtil.tensorDataTypeFromProto(n3.dataType());
                e3.type = { shape: { dims: t4 }, tensorType: i3 }, r3 = this._allData.push(e3) - 1, o2.set(n3.name(), r3);
              }
              this._allData[r3]._from = -1, this._allData[r3].tensor = a.Tensor.fromOrtTensor(n3);
            }
            for (let e3 = 0; e3 < this._allData.length; e3++)
              this._allData[e3].tensor || (this._allInputIndices.push(e3), this._allInputNames.push(p2[e3]));
            for (let t3 = 0; t3 < e2.outputsLength(); t3++) {
              const n3 = e2.outputs(t3);
              if (o2.has(n3))
                throw new Error(`duplicated output name: ${n3}`);
              const r3 = this._allData.push(new l()) - 1;
              o2.set(n3, r3), this._allOutputIndices.push(r3), this._allOutputNames.push(n3);
            }
            if (!e2.nodes)
              throw new Error("missing information in graph: node");
            for (let t3 = 0; t3 < e2.nodesLength(); t3++) {
              const n3 = e2.nodes(t3);
              let r3 = n3.name();
              if (!r3)
                for (let e3 = 0; r3 = `unnamed_${n3.opType()}_${e3}`, i2.has(r3); e3++)
                  ;
              if (i2.has(r3))
                throw new Error(`duplicated node name: ${r3}`);
              const o3 = this._nodes.push(new c(n3, r3)) - 1;
              i2.set(r3, o3);
            }
            for (let t3 = 0; t3 < this._nodes.length; t3++) {
              const n3 = this._nodes[t3], r3 = e2.nodes(t3);
              if (null == r3)
                throw new Error(`No node exists at index ${t3}`);
              if (0 === (null == r3 ? void 0 : r3.outputsLength()))
                throw new Error(`missing output for node: ${r3.name}`);
              for (let e3 = 0; e3 < (null == r3 ? void 0 : r3.outputsLength()); e3++) {
                const i3 = null == r3 ? void 0 : r3.outputs(e3);
                let s2 = o2.get(i3);
                if (void 0 === s2 && (s2 = this._allData.push(new l()) - 1, o2.set(i3, s2)), n3.outputs.push(s2), void 0 !== this._allData[s2]._from)
                  throw new Error(`multiple nodes output to one data value: ${s2}`);
                if (this._allData[s2]._from = t3, "Constant" === r3.opType()) {
                  if (1 !== r3.attributesLength() || !r3.attributes(0).t())
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (1 !== r3.outputsLength())
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  n3.outputs.pop(), n3.executeNode = false, this._allData[s2]._from = -1, this._allData[s2].tensor = a.Tensor.fromOrtTensor(r3.attributes(0).t());
                }
              }
            }
            for (let t3 = 0; t3 < this._nodes.length; t3++) {
              const n3 = this._nodes[t3], r3 = e2.nodes(t3);
              if (0 === r3.inputsLength())
                throw new Error(`missing input for node: ${r3.name}`);
              for (let e3 = 0; e3 < r3.inputsLength(); e3++) {
                const i3 = r3.inputs(e3), a2 = o2.get(i3);
                if (void 0 === a2)
                  throw new Error(`unrecognized input '${i3}' for node: ${r3.name()}`);
                n3.inputs.push(a2), this._allData[a2]._to.push(t3);
              }
            }
          }
          checkIsAcyclic() {
            const e2 = /* @__PURE__ */ new Set();
            this._allInputIndices.forEach((t3) => {
              this._allData[t3]._to.forEach((t4) => {
                e2.add(t4);
              });
            });
            const t2 = Array.from(e2), n2 = new Array(this._nodes.length).fill("white");
            for (; t2.length > 0; ) {
              const e3 = t2.pop();
              "gray" === n2[e3] ? n2[e3] = "black" : (t2.push(e3), n2[e3] = "gray", this._nodes[e3].outputs.forEach((r2) => {
                const o2 = this._allData[r2];
                if (void 0 !== o2.tensor)
                  throw new Error("node outputs should not be initialized");
                if (o2._from !== e3)
                  throw new Error("from property of the Value object doesn't match index of Node being processed");
                o2._to.forEach((e4) => {
                  if ("gray" === n2[e4])
                    throw new Error("model graph is cyclic");
                  "white" === n2[e4] && t2.push(e4);
                });
              }));
            }
          }
          transformGraph(e2) {
            this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e2 && e2.transformGraph(this), this.finalizeGraph();
          }
          finalizeGraph() {
            let e2 = 0;
            const t2 = new Array(this._nodes.length, 0);
            let n2 = 0;
            for (let e3 = 0; e3 < this._nodes.length; e3++)
              t2[e3] = n2, this._nodes[e3].executeNode ? (n2 !== e3 && (this._nodes[n2] = this._nodes[e3]), n2++) : this._nodes[e3].outputs.forEach((e4) => {
                this._allData[e4]._from = -2;
              });
            this._nodes.splice(n2, this._nodes.length - n2);
            for (let e3 = 0; e3 < this._allData.length; e3++) {
              const n3 = this._allData[e3];
              void 0 !== n3._from && -1 !== n3._from && -2 !== n3._from && (n3._from = t2[n3._from]);
              for (let e4 = 0; e4 < n3._to.length; e4++) {
                if (!(n3._to[e4] >= 0))
                  throw new Error("Trying to update a removed node");
                n3._to[e4] = t2[n3._to[e4]];
              }
            }
            e2 = 0;
            for (let t3 = 0; t3 < this._allData.length; t3++)
              if (-2 !== this._allData[t3].from || -1 !== this._allOutputIndices.indexOf(t3 + e2)) {
                if (e2 > 0) {
                  let n3 = -1;
                  void 0 !== this._allData[t3].from && -1 !== this._allData[t3].from ? (n3 = this._nodes[this._allData[t3].from].outputs.indexOf(t3 + e2), -1 !== n3 && (this._nodes[this._allData[t3].from].outputs[n3] = t3)) : (n3 = this._allInputIndices.indexOf(t3 + e2), -1 !== n3 && (this._allInputIndices[n3] = t3)), this._allData[t3].to.forEach((r2) => {
                    n3 = this._nodes[r2].inputs.indexOf(t3 + e2), -1 !== n3 && (this._nodes[r2].inputs[n3] = t3);
                  }), 0 === this._allData[t3].to.length && (n3 = this._allOutputIndices.indexOf(t3 + e2), -1 !== n3 && (this._allOutputIndices[n3] = t3));
                }
              } else
                e2++, this._allData.splice(t3, 1), t3--;
          }
          deleteNode(e2) {
            const t2 = this._nodes[e2];
            if (t2.outputs.length > 1) {
              for (let e3 = 1; e3 < t2.outputs.length; e3++)
                if (this._allData[t2.outputs[e3]].to.length > 0)
                  throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
            }
            t2.executeNode = false;
            const n2 = t2.inputs[0], r2 = t2.outputs[0], o2 = this._allData[r2].to;
            for (let n3 = 0; n3 < t2.inputs.length; n3++) {
              const r3 = this._allData[t2.inputs[n3]].to.indexOf(e2);
              if (-1 === r3)
                throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
              this._allData[t2.inputs[n3]].to.splice(r3, 1);
            }
            this._allData[r2]._to = [];
            const i2 = this._allOutputIndices.indexOf(r2);
            if (-1 !== i2 && (this._allOutputIndices[i2] = n2), o2 && o2.length > 0)
              for (const e3 of o2) {
                const t3 = this._nodes[e3].inputs.indexOf(r2);
                if (-1 === t3)
                  throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                this._nodes[e3].inputs[t3] = n2, this._allData[n2].to.push(e3);
              }
          }
          removeAllDropoutNodes() {
            let e2 = 0;
            for (const t2 of this._nodes) {
              if ("Dropout" === t2.opType) {
                if (1 !== t2.inputs.length)
                  throw new Error("Dropout nodes should only contain one input. ");
                if (1 !== t2.outputs.length && 2 !== t2.outputs.length)
                  throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                if (2 === t2.outputs.length && 0 !== this._allData[t2.outputs[1]]._to.length)
                  throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                this.deleteNode(e2);
              }
              e2++;
            }
          }
          removeAllIdentityNodes() {
            let e2 = 0;
            for (const t2 of this._nodes)
              "Identity" === t2.opType && this.deleteNode(e2), e2++;
          }
          isActivation(e2) {
            switch (e2.opType) {
              case "Relu":
              case "Sigmoid":
              case "Clip":
                return true;
              default:
                return false;
            }
          }
          fuseConvActivationNodes() {
            for (const e2 of this._nodes)
              if ("Conv" === e2.opType) {
                const t2 = this._allData[e2.outputs[0]]._to;
                if (1 === t2.length && this.isActivation(this._nodes[t2[0]])) {
                  const n2 = this._nodes[t2[0]];
                  if ("Clip" === n2.opType)
                    if (1 === n2.inputs.length)
                      try {
                        e2.attributes.set("activation_params", "floats", [n2.attributes.getFloat("min"), n2.attributes.getFloat("max")]);
                      } catch (t3) {
                        e2.attributes.set("activation_params", "floats", [s.MIN_CLIP, s.MAX_CLIP]);
                      }
                    else {
                      if (!(n2.inputs.length >= 3 && void 0 !== this._allData[n2.inputs[1]].tensor && void 0 !== this._allData[n2.inputs[2]].tensor))
                        continue;
                      e2.attributes.set("activation_params", "floats", [this._allData[n2.inputs[1]].tensor.floatData[0], this._allData[n2.inputs[2]].tensor.floatData[0]]);
                    }
                  e2.attributes.set("activation", "string", n2.opType), this.deleteNode(t2[0]);
                }
              }
          }
        }
      }, 1315: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.now = t.Profiler = t.Logger = void 0;
        const n = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r = { none: new class {
          log(e2, t2, n2) {
          }
        }(), console: new class {
          log(e2, t2, n2) {
            console.log(`${this.color(e2)} ${n2 ? "\x1B[35m" + n2 + "\x1B[0m " : ""}${t2}`);
          }
          color(e2) {
            switch (e2) {
              case "verbose":
                return "\x1B[34;40mv\x1B[0m";
              case "info":
                return "\x1B[32mi\x1B[0m";
              case "warning":
                return "\x1B[30;43mw\x1B[0m";
              case "error":
                return "\x1B[31;40me\x1B[0m";
              case "fatal":
                return "\x1B[101mf\x1B[0m";
              default:
                throw new Error(`unsupported severity: ${e2}`);
            }
          }
        }() }, o = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
        let i = { "": o };
        function a(e2, t2, n2, r2) {
          if (void 0 === t2)
            return o2 = e2, { verbose: a.verbose.bind(null, o2), info: a.info.bind(null, o2), warning: a.warning.bind(null, o2), error: a.error.bind(null, o2), fatal: a.fatal.bind(null, o2) };
          if (void 0 === n2)
            s(e2, t2);
          else if ("number" == typeof n2 && void 0 === r2)
            s(e2, t2);
          else if ("string" == typeof n2 && void 0 === r2)
            s(e2, n2, 0, t2);
          else {
            if ("string" != typeof n2 || "number" != typeof r2)
              throw new TypeError("input is valid");
            s(e2, n2, 0, t2);
          }
          var o2;
        }
        function s(e2, t2, o2, a2) {
          const s2 = i[a2 || ""] || i[""];
          n[e2] < n[s2.minimalSeverity] || (s2.logDateTime && (t2 = `${(/* @__PURE__ */ new Date()).toISOString()}|${t2}`), s2.logSourceLocation, r[s2.provider].log(e2, t2, a2));
        }
        !function(e2) {
          function t2(e3) {
            i = {}, n2("", e3 || {});
          }
          function n2(e3, n3) {
            if ("*" === e3)
              t2(n3);
            else {
              const t3 = i[e3] || o;
              i[e3] = { provider: n3.provider || t3.provider, minimalSeverity: n3.minimalSeverity || t3.minimalSeverity, logDateTime: void 0 === n3.logDateTime ? t3.logDateTime : n3.logDateTime, logSourceLocation: void 0 === n3.logSourceLocation ? t3.logSourceLocation : n3.logSourceLocation };
            }
          }
          e2.verbose = function(t3, n3) {
            e2("verbose", t3, n3);
          }, e2.info = function(t3, n3) {
            e2("info", t3, n3);
          }, e2.warning = function(t3, n3) {
            e2("warning", t3, n3);
          }, e2.error = function(t3, n3) {
            e2("error", t3, n3);
          }, e2.fatal = function(t3, n3) {
            e2("fatal", t3, n3);
          }, e2.reset = t2, e2.set = n2, e2.setWithEnv = function(e3) {
            const t3 = {};
            e3.logLevel && (t3.minimalSeverity = e3.logLevel), n2("", t3);
          };
        }(a || (a = {})), t.Logger = a;
        class u {
          constructor(e2, t2, n2, r2, o2, i2) {
            this.category = e2, this.name = t2, this.startTime = n2, this.endCallback = r2, this.timer = o2, this.ctx = i2;
          }
          async end() {
            return this.endCallback(this);
          }
          async checkTimer() {
            if (void 0 === this.ctx || void 0 === this.timer)
              throw new Error("No webgl timer found");
            return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
          }
        }
        class l {
          constructor(e2, t2, n2, r2) {
            this.category = e2, this.name = t2, this.startTime = n2, this.endTime = r2;
          }
        }
        t.Profiler = class {
          static create(e2) {
            return void 0 === e2 ? new this() : new this(e2.maxNumberEvents, e2.flushBatchSize, e2.flushIntervalInMilliseconds);
          }
          constructor(e2, t2, n2) {
            this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === e2 ? 1e4 : e2, this._flushBatchSize = void 0 === t2 ? 10 : t2, this._flushIntervalInMilliseconds = void 0 === n2 ? 5e3 : n2;
          }
          start() {
            this._started = true, this._timingEvents = [], this._flushTime = (0, t.now)(), this._flushPointer = 0;
          }
          stop() {
            for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++)
              this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
          event(e2, t2, n2, r2) {
            const o2 = this._started ? this.begin(e2, t2, r2) : void 0;
            let i2 = false;
            const a2 = n2();
            if (a2 && "function" == typeof a2.then)
              return i2 = true, new Promise((e3, t3) => {
                a2.then(async (t4) => {
                  o2 && await o2.end(), e3(t4);
                }, async (e4) => {
                  o2 && await o2.end(), t3(e4);
                });
              });
            if (!i2 && o2) {
              const e3 = o2.end();
              if (e3 && "function" == typeof e3.then)
                return new Promise((t3, n3) => {
                  e3.then(() => {
                    t3(a2);
                  }, (e4) => {
                    n3(e4);
                  });
                });
            }
            return a2;
          }
          begin(e2, n2, r2) {
            if (!this._started)
              throw new Error("profiler is not started yet");
            if (void 0 === r2) {
              const r3 = (0, t.now)();
              return this.flush(r3), new u(e2, n2, r3, (e3) => this.endSync(e3));
            }
            {
              const t2 = r2.beginTimer();
              return new u(e2, n2, 0, async (e3) => this.end(e3), t2, r2);
            }
          }
          async end(e2) {
            const t2 = await e2.checkTimer();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e2.category, e2.name, e2.startTime, t2)), this.flush(t2));
          }
          endSync(e2) {
            const n2 = (0, t.now)();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e2.category, e2.name, e2.startTime, n2)), this.flush(n2));
          }
          logOneEvent(e2) {
            t.Logger.verbose(`Profiler.${e2.category}`, `${(e2.endTime - e2.startTime).toFixed(2)}ms on event '${e2.name}' at ${e2.endTime.toFixed(2)}`);
          }
          flush(e2) {
            if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e2 - this._flushTime >= this._flushIntervalInMilliseconds) {
              for (const e3 = this._flushPointer; this._flushPointer < e3 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)
                this.logOneEvent(this._timingEvents[this._flushPointer]);
              this._flushTime = (0, t.now)();
            }
          }
          get started() {
            return this._started;
          }
        }, t.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
      }, 1745: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Model = void 0;
        const r = n(5686), o = n(4662), i = n(5127), a = n(2446), s = n(7273);
        var u = i.onnxruntime.experimental.fbs;
        t.Model = class {
          constructor() {
          }
          load(e2, t2, n2) {
            if (!n2)
              try {
                return void this.loadFromOnnxFormat(e2, t2);
              } catch (e3) {
                if (void 0 !== n2)
                  throw e3;
              }
            this.loadFromOrtFormat(e2, t2);
          }
          loadFromOnnxFormat(e2, t2) {
            const n2 = a.onnx.ModelProto.decode(e2);
            if (s.LongUtil.longToNumber(n2.irVersion) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = n2.opsetImport.map((e3) => ({ domain: e3.domain, version: s.LongUtil.longToNumber(e3.version) })), this._graph = o.Graph.from(n2.graph, t2);
          }
          loadFromOrtFormat(e2, t2) {
            const n2 = new r.flatbuffers.ByteBuffer(e2), i2 = u.InferenceSession.getRootAsInferenceSession(n2).model();
            if (s.LongUtil.longToNumber(i2.irVersion()) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = [];
            for (let e3 = 0; e3 < i2.opsetImportLength(); e3++) {
              const t3 = i2.opsetImport(e3);
              this._opsets.push({ domain: null == t3 ? void 0 : t3.domain(), version: s.LongUtil.longToNumber(t3.version()) });
            }
            this._graph = o.Graph.from(i2.graph(), t2);
          }
          get graph() {
            return this._graph;
          }
          get opsets() {
            return this._opsets;
          }
        };
      }, 6145: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FLOAT_TYPES = t.INT_TYPES = t.NUMBER_TYPES = void 0, t.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], t.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], t.FLOAT_TYPES = ["float32", "float64"];
      }, 5881: (e, t) => {
        "use strict";
        function n(e2, t2) {
          if (t2.endsWith("+")) {
            const n2 = Number.parseInt(t2.substring(0, t2.length - 1), 10);
            return !isNaN(n2) && n2 <= e2;
          }
          if (2 === t2.split("-").length) {
            const n2 = t2.split("-"), r = Number.parseInt(n2[0], 10), o = Number.parseInt(n2[1], 10);
            return !isNaN(r) && !isNaN(o) && r <= e2 && e2 <= o;
          }
          return Number.parseInt(t2, 10) === e2;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveOperator = void 0, t.resolveOperator = function(e2, t2, r) {
          for (const o of r) {
            const r2 = o[0], i = o[1], a = o[2], s = o[3], u = o[4];
            if (e2.opType === r2) {
              for (const e3 of t2)
                if ((e3.domain === i || "ai.onnx" === e3.domain && "" === i) && n(e3.version, a))
                  return { opImpl: s, opInit: u };
            }
          }
          throw new TypeError(`cannot resolve operator '${e2.opType}' with opsets: ${t2.map((e3) => `${e3.domain || "ai.onnx"} v${e3.version}`).join(", ")}`);
        };
      }, 5127: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.onnxruntime = void 0;
        const r = n(5686);
        var o, i;
        o = t.onnxruntime || (t.onnxruntime = {}), function(e2) {
          let t2;
          !function(e3) {
            e3[e3.UNDEFINED = 0] = "UNDEFINED", e3[e3.FLOAT = 1] = "FLOAT", e3[e3.INT = 2] = "INT", e3[e3.STRING = 3] = "STRING", e3[e3.TENSOR = 4] = "TENSOR", e3[e3.GRAPH = 5] = "GRAPH", e3[e3.FLOATS = 6] = "FLOATS", e3[e3.INTS = 7] = "INTS", e3[e3.STRINGS = 8] = "STRINGS", e3[e3.TENSORS = 9] = "TENSORS", e3[e3.GRAPHS = 10] = "GRAPHS", e3[e3.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", e3[e3.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
          }(t2 = e2.AttributeType || (e2.AttributeType = {}));
        }((i = o.experimental || (o.experimental = {})).fbs || (i.fbs = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.UNKNOWN = 0] = "UNKNOWN", e5[e5.VALUE = 1] = "VALUE", e5[e5.PARAM = 2] = "PARAM";
              }(t2 = e4.DimensionValueType || (e4.DimensionValueType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.UNDEFINED = 0] = "UNDEFINED", e5[e5.FLOAT = 1] = "FLOAT", e5[e5.UINT8 = 2] = "UINT8", e5[e5.INT8 = 3] = "INT8", e5[e5.UINT16 = 4] = "UINT16", e5[e5.INT16 = 5] = "INT16", e5[e5.INT32 = 6] = "INT32", e5[e5.INT64 = 7] = "INT64", e5[e5.STRING = 8] = "STRING", e5[e5.BOOL = 9] = "BOOL", e5[e5.FLOAT16 = 10] = "FLOAT16", e5[e5.DOUBLE = 11] = "DOUBLE", e5[e5.UINT32 = 12] = "UINT32", e5[e5.UINT64 = 13] = "UINT64", e5[e5.COMPLEX64 = 14] = "COMPLEX64", e5[e5.COMPLEX128 = 15] = "COMPLEX128", e5[e5.BFLOAT16 = 16] = "BFLOAT16", e5[e5.FLOAT8E4M3FN = 17] = "FLOAT8E4M3FN", e5[e5.FLOAT8E4M3FNUZ = 18] = "FLOAT8E4M3FNUZ", e5[e5.FLOAT8E5M2 = 19] = "FLOAT8E5M2", e5[e5.FLOAT8E5M2FNUZ = 20] = "FLOAT8E5M2FNUZ";
              }(t2 = e4.TensorDataType || (e4.TensorDataType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.Primitive = 0] = "Primitive", e5[e5.Fused = 1] = "Fused";
              }(t2 = e4.NodeType || (e4.NodeType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.NONE = 0] = "NONE", e5[e5.tensor_type = 1] = "tensor_type", e5[e5.sequence_type = 2] = "sequence_type", e5[e5.map_type = 3] = "map_type";
              }(t2 = e4.TypeInfoValue || (e4.TypeInfoValue = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsShape(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsShape(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                dim(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 4);
                  return r2 ? (n3 || new e2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                dimLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startShape(e3) {
                  e3.startObject(1);
                }
                static addDim(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static createDimVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startDimVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endShape(e3) {
                  return e3.endObject();
                }
                static createShape(e3, t4) {
                  return n2.startShape(e3), n2.addDim(e3, t4), n2.endShape(e3);
                }
              }
              t3.Shape = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsDimension(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsDimension(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                value(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                denotation(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startDimension(e3) {
                  e3.startObject(2);
                }
                static addValue(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDenotation(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endDimension(e3) {
                  return e3.endObject();
                }
                static createDimension(e3, t4, r2) {
                  return n2.startDimension(e3), n2.addValue(e3, t4), n2.addDenotation(e3, r2), n2.endDimension(e3);
                }
              }
              t3.Dimension = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsDimensionValue(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsDimensionValue(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                dimType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt8(this.bb_pos + t4) : e2.experimental.fbs.DimensionValueType.UNKNOWN;
                }
                dimValue() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                dimParam(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startDimensionValue(e3) {
                  e3.startObject(3);
                }
                static addDimType(t4, n3) {
                  t4.addFieldInt8(0, n3, e2.experimental.fbs.DimensionValueType.UNKNOWN);
                }
                static addDimValue(e3, t4) {
                  e3.addFieldInt64(1, t4, e3.createLong(0, 0));
                }
                static addDimParam(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endDimensionValue(e3) {
                  return e3.endObject();
                }
                static createDimensionValue(e3, t4, r2, o2) {
                  return n2.startDimensionValue(e3), n2.addDimType(e3, t4), n2.addDimValue(e3, r2), n2.addDimParam(e3, o2), n2.endDimensionValue(e3);
                }
              }
              t3.DimensionValue = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTensorTypeAndShape(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTensorTypeAndShape(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                elemType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                shape(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startTensorTypeAndShape(e3) {
                  e3.startObject(2);
                }
                static addElemType(t4, n3) {
                  t4.addFieldInt32(0, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addShape(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endTensorTypeAndShape(e3) {
                  return e3.endObject();
                }
                static createTensorTypeAndShape(e3, t4, r2) {
                  return n2.startTensorTypeAndShape(e3), n2.addElemType(e3, t4), n2.addShape(e3, r2), n2.endTensorTypeAndShape(e3);
                }
              }
              t3.TensorTypeAndShape = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsMapType(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsMapType(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                keyType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                valueType(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startMapType(e3) {
                  e3.startObject(2);
                }
                static addKeyType(t4, n3) {
                  t4.addFieldInt32(0, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addValueType(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endMapType(e3) {
                  return e3.endObject();
                }
                static createMapType(e3, t4, r2) {
                  return n2.startMapType(e3), n2.addKeyType(e3, t4), n2.addValueType(e3, r2), n2.endMapType(e3);
                }
              }
              t3.MapType = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSequenceType(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSequenceType(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                elemType(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startSequenceType(e3) {
                  e3.startObject(1);
                }
                static addElemType(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static endSequenceType(e3) {
                  return e3.endObject();
                }
                static createSequenceType(e3, t4) {
                  return n2.startSequenceType(e3), n2.addElemType(e3, t4), n2.endSequenceType(e3);
                }
              }
              t3.SequenceType = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            (e3.fbs || (e3.fbs = {})).EdgeEnd = class {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(e4, t2) {
                return this.bb_pos = e4, this.bb = t2, this;
              }
              nodeIndex() {
                return this.bb.readUint32(this.bb_pos);
              }
              srcArgIndex() {
                return this.bb.readInt32(this.bb_pos + 4);
              }
              dstArgIndex() {
                return this.bb.readInt32(this.bb_pos + 8);
              }
              static createEdgeEnd(e4, t2, n2, r2) {
                return e4.prep(4, 12), e4.writeInt32(r2), e4.writeInt32(n2), e4.writeInt32(t2), e4.offset();
              }
            };
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsNodeEdge(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsNodeEdge(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                nodeIndex() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                inputEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                }
                inputEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 8);
                  return r2 ? (n3 || new e2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                }
                outputEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startNodeEdge(e3) {
                  e3.startObject(3);
                }
                static addNodeIndex(e3, t4) {
                  e3.addFieldInt32(0, t4, 0);
                }
                static addInputEdges(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static startInputEdgesVector(e3, t4) {
                  e3.startVector(12, t4, 4);
                }
                static addOutputEdges(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static startOutputEdgesVector(e3, t4) {
                  e3.startVector(12, t4, 4);
                }
                static endNodeEdge(e3) {
                  return e3.endObject();
                }
                static createNodeEdge(e3, t4, r2, o2) {
                  return n2.startNodeEdge(e3), n2.addNodeIndex(e3, t4), n2.addInputEdges(e3, r2), n2.addOutputEdges(e3, o2), n2.endNodeEdge(e3);
                }
              }
              t3.NodeEdge = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsNode(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsNode(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                domain(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                sinceVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readInt32(this.bb_pos + e3) : 0;
                }
                index() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                opType(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 14);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type() {
                  let t4 = this.bb.__offset(this.bb_pos, 16);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.NodeType.Primitive;
                }
                executionProviderType(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 18);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                inputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 20);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                inputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 22);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                outputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 22);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                attributes(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 24);
                  return r2 ? (n3 || new e2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                attributesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 24);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputArgCounts(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 26);
                  return t4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + t4) + 4 * e3) : 0;
                }
                inputArgCountsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputArgCountsArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                implicitInputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 28);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                implicitInputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 28);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startNode(e3) {
                  e3.startObject(13);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDomain(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static addSinceVersion(e3, t4) {
                  e3.addFieldInt32(3, t4, 0);
                }
                static addIndex(e3, t4) {
                  e3.addFieldInt32(4, t4, 0);
                }
                static addOpType(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static addType(t4, n3) {
                  t4.addFieldInt32(6, n3, e2.experimental.fbs.NodeType.Primitive);
                }
                static addExecutionProviderType(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addInputs(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static createInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addOutputs(e3, t4) {
                  e3.addFieldOffset(9, t4, 0);
                }
                static createOutputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOutputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addAttributes(e3, t4) {
                  e3.addFieldOffset(10, t4, 0);
                }
                static createAttributesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startAttributesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInputArgCounts(e3, t4) {
                  e3.addFieldOffset(11, t4, 0);
                }
                static createInputArgCountsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt32(t4[n3]);
                  return e3.endVector();
                }
                static startInputArgCountsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addImplicitInputs(e3, t4) {
                  e3.addFieldOffset(12, t4, 0);
                }
                static createImplicitInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startImplicitInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endNode(e3) {
                  return e3.endObject();
                }
                static createNode(e3, t4, r2, o2, i2, a, s, u, l, c, p, d, f, h) {
                  return n2.startNode(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addDomain(e3, o2), n2.addSinceVersion(e3, i2), n2.addIndex(e3, a), n2.addOpType(e3, s), n2.addType(e3, u), n2.addExecutionProviderType(e3, l), n2.addInputs(e3, c), n2.addOutputs(e3, p), n2.addAttributes(e3, d), n2.addInputArgCounts(e3, f), n2.addImplicitInputs(e3, h), n2.endNode(e3);
                }
              }
              t3.Node = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsValueInfo(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsValueInfo(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 8);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startValueInfo(e3) {
                  e3.startObject(3);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addType(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endValueInfo(e3) {
                  return e3.endObject();
                }
                static createValueInfo(e3, t4, r2, o2) {
                  return n2.startValueInfo(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addType(e3, o2), n2.endValueInfo(e3);
                }
              }
              t3.ValueInfo = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTypeInfo(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTypeInfo(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                denotation(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                valueType() {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.readUint8(this.bb_pos + t4) : e2.experimental.fbs.TypeInfoValue.NONE;
                }
                value(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__union(e3, this.bb_pos + t4) : null;
                }
                static startTypeInfo(e3) {
                  e3.startObject(3);
                }
                static addDenotation(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addValueType(t4, n3) {
                  t4.addFieldInt8(1, n3, e2.experimental.fbs.TypeInfoValue.NONE);
                }
                static addValue(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endTypeInfo(e3) {
                  return e3.endObject();
                }
                static createTypeInfo(e3, t4, r2, o2) {
                  return n2.startTypeInfo(e3), n2.addDenotation(e3, t4), n2.addValueType(e3, r2), n2.addValue(e3, o2), n2.endTypeInfo(e3);
                }
              }
              t3.TypeInfo = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              class t2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e5, t3) {
                  return this.bb_pos = e5, this.bb = t3, this;
                }
                static getRootAsOperatorSetId(e5, n2) {
                  return (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                static getSizePrefixedRootAsOperatorSetId(e5, n2) {
                  return e5.setPosition(e5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                domain(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 4);
                  return t3 ? this.bb.__string(this.bb_pos + t3, e5) : null;
                }
                version() {
                  let e5 = this.bb.__offset(this.bb_pos, 6);
                  return e5 ? this.bb.readInt64(this.bb_pos + e5) : this.bb.createLong(0, 0);
                }
                static startOperatorSetId(e5) {
                  e5.startObject(2);
                }
                static addDomain(e5, t3) {
                  e5.addFieldOffset(0, t3, 0);
                }
                static addVersion(e5, t3) {
                  e5.addFieldInt64(1, t3, e5.createLong(0, 0));
                }
                static endOperatorSetId(e5) {
                  return e5.endObject();
                }
                static createOperatorSetId(e5, n2, r2) {
                  return t2.startOperatorSetId(e5), t2.addDomain(e5, n2), t2.addVersion(e5, r2), t2.endOperatorSetId(e5);
                }
              }
              e4.OperatorSetId = t2;
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTensor(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTensor(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                dims(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                dataType() {
                  let t4 = this.bb.__offset(this.bb_pos, 10);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                rawData(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 12);
                  return t4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t4) + e3) : 0;
                }
                rawDataLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                rawDataArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                stringData(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 14);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                stringDataLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startTensor(e3) {
                  e3.startObject(6);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDims(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createDimsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startDimsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static addDataType(t4, n3) {
                  t4.addFieldInt32(3, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addRawData(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static createRawDataVector(e3, t4) {
                  e3.startVector(1, t4.length, 1);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt8(t4[n3]);
                  return e3.endVector();
                }
                static startRawDataVector(e3, t4) {
                  e3.startVector(1, t4, 1);
                }
                static addStringData(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static createStringDataVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startStringDataVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endTensor(e3) {
                  return e3.endObject();
                }
                static createTensor(e3, t4, r2, o2, i2, a, s) {
                  return n2.startTensor(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addDims(e3, o2), n2.addDataType(e3, i2), n2.addRawData(e3, a), n2.addStringData(e3, s), n2.endTensor(e3);
                }
              }
              t3.Tensor = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSparseTensor(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSparseTensor(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                values(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                indices(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                dims(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startSparseTensor(e3) {
                  e3.startObject(3);
                }
                static addValues(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addIndices(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDims(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createDimsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startDimsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static endSparseTensor(e3) {
                  return e3.endObject();
                }
                static createSparseTensor(e3, t4, r2, o2) {
                  return n2.startSparseTensor(e3), n2.addValues(e3, t4), n2.addIndices(e3, r2), n2.addDims(e3, o2), n2.endSparseTensor(e3);
                }
              }
              t3.SparseTensor = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsAttribute(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsAttribute(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type() {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.AttributeType.UNDEFINED;
                }
                f() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readFloat32(this.bb_pos + e3) : 0;
                }
                i() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                s(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 14);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                t(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 16);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                g(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 18);
                  return n3 ? (t4 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                floats(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 20);
                  return t4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + t4) + 4 * e3) : 0;
                }
                floatsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                floatsArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                ints(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 22);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                intsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 22);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                strings(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 24);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                stringsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 24);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                tensors(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 26);
                  return r2 ? (n3 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                tensorsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                graphs(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 28);
                  return r2 ? (n3 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                graphsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 28);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startAttribute(e3) {
                  e3.startObject(13);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addType(t4, n3) {
                  t4.addFieldInt32(2, n3, e2.experimental.fbs.AttributeType.UNDEFINED);
                }
                static addF(e3, t4) {
                  e3.addFieldFloat32(3, t4, 0);
                }
                static addI(e3, t4) {
                  e3.addFieldInt64(4, t4, e3.createLong(0, 0));
                }
                static addS(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static addT(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static addG(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addFloats(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static createFloatsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addFloat32(t4[n3]);
                  return e3.endVector();
                }
                static startFloatsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInts(e3, t4) {
                  e3.addFieldOffset(9, t4, 0);
                }
                static createIntsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startIntsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static addStrings(e3, t4) {
                  e3.addFieldOffset(10, t4, 0);
                }
                static createStringsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startStringsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addTensors(e3, t4) {
                  e3.addFieldOffset(11, t4, 0);
                }
                static createTensorsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startTensorsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addGraphs(e3, t4) {
                  e3.addFieldOffset(12, t4, 0);
                }
                static createGraphsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startGraphsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endAttribute(e3) {
                  return e3.endObject();
                }
                static createAttribute(e3, t4, r2, o2, i2, a, s, u, l, c, p, d, f, h) {
                  return n2.startAttribute(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addType(e3, o2), n2.addF(e3, i2), n2.addI(e3, a), n2.addS(e3, s), n2.addT(e3, u), n2.addG(e3, l), n2.addFloats(e3, c), n2.addInts(e3, p), n2.addStrings(e3, d), n2.addTensors(e3, f), n2.addGraphs(e3, h), n2.endAttribute(e3);
                }
              }
              t3.Attribute = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsGraph(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsGraph(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                initializers(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 4);
                  return r2 ? (n3 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                initializersLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                nodeArgs(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodeArgsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                nodes(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 8);
                  return r2 ? (n3 || new e2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                maxNodeIndex() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                nodeEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 12);
                  return r2 ? (n3 || new e2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodeEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 14);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                inputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 16);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                outputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 16);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                sparseInitializers(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 18);
                  return r2 ? (n3 || new e2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                sparseInitializersLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 18);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startGraph(e3) {
                  e3.startObject(8);
                }
                static addInitializers(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static createInitializersVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInitializersVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addNodeArgs(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createNodeArgsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodeArgsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addNodes(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createNodesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addMaxNodeIndex(e3, t4) {
                  e3.addFieldInt32(3, t4, 0);
                }
                static addNodeEdges(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static createNodeEdgesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodeEdgesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInputs(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static createInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addOutputs(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static createOutputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOutputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addSparseInitializers(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static createSparseInitializersVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startSparseInitializersVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endGraph(e3) {
                  return e3.endObject();
                }
                static createGraph(e3, t4, r2, o2, i2, a, s, u, l) {
                  return n2.startGraph(e3), n2.addInitializers(e3, t4), n2.addNodeArgs(e3, r2), n2.addNodes(e3, o2), n2.addMaxNodeIndex(e3, i2), n2.addNodeEdges(e3, a), n2.addInputs(e3, s), n2.addOutputs(e3, u), n2.addSparseInitializers(e3, l), n2.endGraph(e3);
                }
              }
              t3.Graph = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsModel(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsModel(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                irVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                opsetImport(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                opsetImportLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                producerName(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                producerVersion(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 10);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                domain(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 12);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                modelVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 16);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                graph(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 18);
                  return n3 ? (t4 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                graphDocString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 20);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startModel(e3) {
                  e3.startObject(9);
                }
                static addIrVersion(e3, t4) {
                  e3.addFieldInt64(0, t4, e3.createLong(0, 0));
                }
                static addOpsetImport(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createOpsetImportVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOpsetImportVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addProducerName(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static addProducerVersion(e3, t4) {
                  e3.addFieldOffset(3, t4, 0);
                }
                static addDomain(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static addModelVersion(e3, t4) {
                  e3.addFieldInt64(5, t4, e3.createLong(0, 0));
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static addGraph(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addGraphDocString(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static endModel(e3) {
                  return e3.endObject();
                }
                static createModel(e3, t4, r2, o2, i2, a, s, u, l, c) {
                  return n2.startModel(e3), n2.addIrVersion(e3, t4), n2.addOpsetImport(e3, r2), n2.addProducerName(e3, o2), n2.addProducerVersion(e3, i2), n2.addDomain(e3, a), n2.addModelVersion(e3, s), n2.addDocString(e3, u), n2.addGraph(e3, l), n2.addGraphDocString(e3, c), n2.endModel(e3);
                }
              }
              t3.Model = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              class t2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e5, t3) {
                  return this.bb_pos = e5, this.bb = t3, this;
                }
                static getRootAsKernelCreateInfos(e5, n2) {
                  return (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                static getSizePrefixedRootAsKernelCreateInfos(e5, n2) {
                  return e5.setPosition(e5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                nodeIndices(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 4);
                  return t3 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t3) + 4 * e5) : 0;
                }
                nodeIndicesLength() {
                  let e5 = this.bb.__offset(this.bb_pos, 4);
                  return e5 ? this.bb.__vector_len(this.bb_pos + e5) : 0;
                }
                nodeIndicesArray() {
                  let e5 = this.bb.__offset(this.bb_pos, 4);
                  return e5 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e5), this.bb.__vector_len(this.bb_pos + e5)) : null;
                }
                kernelDefHashes(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 6);
                  return t3 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t3) + 8 * e5) : this.bb.createLong(0, 0);
                }
                kernelDefHashesLength() {
                  let e5 = this.bb.__offset(this.bb_pos, 6);
                  return e5 ? this.bb.__vector_len(this.bb_pos + e5) : 0;
                }
                static startKernelCreateInfos(e5) {
                  e5.startObject(2);
                }
                static addNodeIndices(e5, t3) {
                  e5.addFieldOffset(0, t3, 0);
                }
                static createNodeIndicesVector(e5, t3) {
                  e5.startVector(4, t3.length, 4);
                  for (let n2 = t3.length - 1; n2 >= 0; n2--)
                    e5.addInt32(t3[n2]);
                  return e5.endVector();
                }
                static startNodeIndicesVector(e5, t3) {
                  e5.startVector(4, t3, 4);
                }
                static addKernelDefHashes(e5, t3) {
                  e5.addFieldOffset(1, t3, 0);
                }
                static createKernelDefHashesVector(e5, t3) {
                  e5.startVector(8, t3.length, 8);
                  for (let n2 = t3.length - 1; n2 >= 0; n2--)
                    e5.addInt64(t3[n2]);
                  return e5.endVector();
                }
                static startKernelDefHashesVector(e5, t3) {
                  e5.startVector(8, t3, 8);
                }
                static endKernelCreateInfos(e5) {
                  return e5.endObject();
                }
                static createKernelCreateInfos(e5, n2, r2) {
                  return t2.startKernelCreateInfos(e5), t2.addNodeIndices(e5, n2), t2.addKernelDefHashes(e5, r2), t2.endKernelCreateInfos(e5);
                }
              }
              e4.KernelCreateInfos = t2;
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSubGraphSessionState(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSubGraphSessionState(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                graphId(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                sessionState(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startSubGraphSessionState(e3) {
                  e3.startObject(2);
                }
                static addGraphId(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addSessionState(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endSubGraphSessionState(e3) {
                  let t4 = e3.endObject();
                  return e3.requiredField(t4, 4), t4;
                }
                static createSubGraphSessionState(e3, t4, r2) {
                  return n2.startSubGraphSessionState(e3), n2.addGraphId(e3, t4), n2.addSessionState(e3, r2), n2.endSubGraphSessionState(e3);
                }
              }
              t3.SubGraphSessionState = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSessionState(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSessionState(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                kernels(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                subGraphSessionStates(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                subGraphSessionStatesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startSessionState(e3) {
                  e3.startObject(2);
                }
                static addKernels(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addSubGraphSessionStates(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createSubGraphSessionStatesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startSubGraphSessionStatesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endSessionState(e3) {
                  return e3.endObject();
                }
                static createSessionState(e3, t4, r2) {
                  return n2.startSessionState(e3), n2.addKernels(e3, t4), n2.addSubGraphSessionStates(e3, r2), n2.endSessionState(e3);
                }
              }
              t3.SessionState = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsInferenceSession(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsInferenceSession(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static bufferHasIdentifier(e3) {
                  return e3.__has_identifier("ORTM");
                }
                ortVersion(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                model(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                sessionState(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 8);
                  return n3 ? (t4 || new e2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startInferenceSession(e3) {
                  e3.startObject(3);
                }
                static addOrtVersion(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addModel(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addSessionState(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endInferenceSession(e3) {
                  return e3.endObject();
                }
                static finishInferenceSessionBuffer(e3, t4) {
                  e3.finish(t4, "ORTM");
                }
                static finishSizePrefixedInferenceSessionBuffer(e3, t4) {
                  e3.finish(t4, "ORTM", true);
                }
                static createInferenceSession(e3, t4, r2, o2) {
                  return n2.startInferenceSession(e3), n2.addOrtVersion(e3, t4), n2.addModel(e3, r2), n2.addSessionState(e3, o2), n2.endInferenceSession(e3);
                }
              }
              t3.InferenceSession = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {}));
      }, 1723: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.OnnxjsSessionHandler = void 0;
        const r = n(2235), o = n(9240);
        t.OnnxjsSessionHandler = class {
          constructor(e2) {
            this.session = e2, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
          }
          async dispose() {
          }
          async run(e2, t2, n2) {
            const i = /* @__PURE__ */ new Map();
            for (const t3 in e2)
              if (Object.hasOwnProperty.call(e2, t3)) {
                const n3 = e2[t3];
                i.set(t3, new o.Tensor(n3.dims, n3.type, void 0, void 0, n3.data));
              }
            const a = await this.session.run(i), s = {};
            return a.forEach((e3, t3) => {
              s[t3] = new r.Tensor(e3.type, e3.data, e3.dims);
            }), s;
          }
          startProfiling() {
            this.session.startProfiling();
          }
          endProfiling() {
            this.session.endProfiling();
          }
        };
      }, 6027: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Session = void 0;
        const r = n(7067), o = n(1296), i = n(1975), a = n(6496), s = n(1315), u = n(1745);
        t.Session = class {
          constructor(e2 = {}) {
            this._initialized = false, this.backendHint = e2.backendHint, this.profiler = s.Profiler.create(e2.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
          }
          get inputNames() {
            return this._model.graph.getInputNames();
          }
          get outputNames() {
            return this._model.graph.getOutputNames();
          }
          startProfiling() {
            this.profiler.start();
          }
          endProfiling() {
            this.profiler.stop();
          }
          async loadModel(e2, t2, n2) {
            await this.profiler.event("session", "Session.loadModel", async () => {
              const a2 = await (0, i.resolveBackend)(this.backendHint);
              if (this.sessionHandler = a2.createSessionHandler(this.context), this._model = new u.Model(), "string" == typeof e2) {
                const t3 = e2.endsWith(".ort");
                if ("undefined" != typeof process && process.versions && process.versions.node) {
                  const n3 = await (0, o.promisify)(r.readFile)(e2);
                  this.initialize(n3, t3);
                } else {
                  const n3 = await fetch(e2), r2 = await n3.arrayBuffer();
                  this.initialize(new Uint8Array(r2), t3);
                }
              } else if (ArrayBuffer.isView(e2))
                this.initialize(e2);
              else {
                const r2 = new Uint8Array(e2, t2 || 0, n2 || e2.byteLength);
                this.initialize(r2);
              }
            });
          }
          initialize(e2, t2) {
            if (this._initialized)
              throw new Error("already initialized");
            this.profiler.event("session", "Session.initialize", () => {
              const n2 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
              this._model.load(e2, n2, t2), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);
            }), this._initialized = true;
          }
          async run(e2) {
            if (!this._initialized)
              throw new Error("session not initialized yet");
            return this.profiler.event("session", "Session.run", async () => {
              const t2 = this.normalizeAndValidateInputs(e2), n2 = await this._executionPlan.execute(this.sessionHandler, t2);
              return this.createOutput(n2);
            });
          }
          normalizeAndValidateInputs(e2) {
            const t2 = this._model.graph.getInputNames();
            if (Array.isArray(e2)) {
              if (e2.length !== t2.length)
                throw new Error(`incorrect input array length: expected ${t2.length} but got ${e2.length}`);
            } else {
              if (e2.size !== t2.length)
                throw new Error(`incorrect input map size: expected ${t2.length} but got ${e2.size}`);
              const n2 = new Array(e2.size);
              let r2 = 0;
              for (let o2 = 0; o2 < t2.length; ++o2) {
                const i2 = e2.get(t2[o2]);
                if (!i2)
                  throw new Error(`missing input tensor for: '${name}'`);
                n2[r2++] = i2;
              }
              e2 = n2;
            }
            if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length)
              this.validateInputTensorDims(this.context.graphInputDims, e2, false);
            else {
              const t3 = this._model.graph.getInputIndices(), n2 = this._model.graph.getValues(), r2 = new Array(t3.length);
              for (let o2 = 0; o2 < t3.length; ++o2) {
                const i2 = n2[t3[o2]];
                r2[o2] = i2.type.shape.dims, this.context.graphInputTypes.push(i2.type.tensorType), this.context.graphInputDims.push(e2[o2].dims);
              }
              this.validateInputTensorDims(r2, e2, true);
            }
            return this.validateInputTensorTypes(this.context.graphInputTypes, e2), e2;
          }
          validateInputTensorTypes(e2, t2) {
            for (let n2 = 0; n2 < t2.length; n2++) {
              const r2 = e2[n2], o2 = t2[n2].type;
              if (r2 !== o2)
                throw new Error(`input tensor[${n2}] check failed: expected type '${r2}' but got ${o2}`);
            }
          }
          validateInputTensorDims(e2, t2, n2) {
            for (let r2 = 0; r2 < t2.length; r2++) {
              const o2 = e2[r2], i2 = t2[r2].dims;
              if (!this.compareTensorDims(o2, i2, n2))
                throw new Error(`input tensor[${r2}] check failed: expected shape '[${o2.join(",")}]' but got [${i2.join(",")}]`);
            }
          }
          compareTensorDims(e2, t2, n2) {
            if (e2.length !== t2.length)
              return false;
            for (let r2 = 0; r2 < e2.length; ++r2)
              if (e2[r2] !== t2[r2] && (!n2 || 0 !== e2[r2]))
                return false;
            return true;
          }
          createOutput(e2) {
            const t2 = this._model.graph.getOutputNames();
            if (e2.length !== t2.length)
              throw new Error("expected number of outputs do not match number of generated outputs");
            const n2 = /* @__PURE__ */ new Map();
            for (let r2 = 0; r2 < t2.length; ++r2)
              n2.set(t2[r2], e2[r2]);
            return n2;
          }
          initializeOps(e2) {
            const t2 = e2.getNodes();
            this._ops = new Array(t2.length);
            for (let n2 = 0; n2 < t2.length; n2++)
              this._ops[n2] = this.sessionHandler.resolve(t2[n2], this._model.opsets, e2);
          }
        };
      }, 9240: function(e, t, n) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const o = n(3442), i = r(n(1583)), a = n(5127), s = n(2446), u = n(7273);
        var l = a.onnxruntime.experimental.fbs;
        class c {
          get data() {
            if (void 0 === this.cache) {
              const e2 = this.dataProvider(this.dataId);
              if (e2.length !== this.size)
                throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
              this.cache = e2;
            }
            return this.cache;
          }
          get stringData() {
            if ("string" !== this.type)
              throw new TypeError("data type is not string");
            return this.data;
          }
          get integerData() {
            switch (this.type) {
              case "uint8":
              case "int8":
              case "uint16":
              case "int16":
              case "int32":
              case "uint32":
              case "bool":
                return this.data;
              default:
                throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
            }
          }
          get floatData() {
            switch (this.type) {
              case "float32":
              case "float64":
                return this.data;
              default:
                throw new TypeError("data type is not float (float32, float64)");
            }
          }
          get numberData() {
            if ("string" !== this.type)
              return this.data;
            throw new TypeError("type cannot be non-number (string)");
          }
          get(e2) {
            return this.data[u.ShapeUtil.indicesToOffset(e2, this.strides)];
          }
          set(e2, t2) {
            this.data[u.ShapeUtil.indicesToOffset(e2, this.strides)] = t2;
          }
          async getData() {
            return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
          }
          get strides() {
            return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;
          }
          constructor(e2, t2, n2, r2, i2, a2 = o.Guid.create()) {
            this.dims = e2, this.type = t2, this.dataProvider = n2, this.asyncDataProvider = r2, this.cache = i2, this.dataId = a2, this.size = u.ShapeUtil.validateDimsAndCalcSize(e2);
            const s2 = this.size, l2 = void 0 === n2 && void 0 === r2 && void 0 === i2;
            if (void 0 !== i2 && i2.length !== s2)
              throw new RangeError("Input dims doesn't match data length.");
            if ("string" === t2) {
              if (!(void 0 === i2 || Array.isArray(i2) && i2.every((e3) => "string" == typeof e3)))
                throw new TypeError("cache should be a string array");
              l2 && (this.cache = new Array(s2));
            } else {
              if (void 0 !== i2) {
                const e3 = d(t2);
                if (!(i2 instanceof e3))
                  throw new TypeError(`cache should be type ${e3.name}`);
              }
              if (l2) {
                const e3 = new ArrayBuffer(s2 * function(e4) {
                  switch (e4) {
                    case "bool":
                    case "int8":
                    case "uint8":
                      return 1;
                    case "int16":
                    case "uint16":
                      return 2;
                    case "int32":
                    case "uint32":
                    case "float32":
                      return 4;
                    case "float64":
                      return 8;
                    default:
                      throw new Error(`cannot calculate sizeof() on type ${e4}`);
                  }
                }(t2));
                this.cache = function(e4, t3) {
                  return new (d(t3))(e4);
                }(e3, t2);
              }
            }
          }
          static fromProto(e2) {
            if (!e2)
              throw new Error("cannot construct Value from an empty tensor");
            const t2 = u.ProtoUtil.tensorDataTypeFromProto(e2.dataType), n2 = u.ProtoUtil.tensorDimsFromProto(e2.dims), r2 = new c(n2, t2);
            if ("string" === t2)
              e2.stringData.forEach((e3, t3) => {
                r2.data[t3] = (0, u.decodeUtf8String)(e3);
              });
            else if (e2.rawData && "number" == typeof e2.rawData.byteLength && e2.rawData.byteLength > 0) {
              const t3 = r2.data, n3 = new DataView(e2.rawData.buffer, e2.rawData.byteOffset, e2.rawData.byteLength), o2 = p(e2.dataType), i2 = e2.rawData.byteLength / o2;
              if (e2.rawData.byteLength % o2 != 0)
                throw new Error("invalid buffer length");
              if (t3.length !== i2)
                throw new Error("buffer length mismatch");
              for (let r3 = 0; r3 < i2; r3++) {
                const i3 = h(n3, e2.dataType, r3 * o2);
                t3[r3] = i3;
              }
            } else {
              let t3;
              switch (e2.dataType) {
                case s.onnx.TensorProto.DataType.FLOAT:
                  t3 = e2.floatData;
                  break;
                case s.onnx.TensorProto.DataType.INT32:
                case s.onnx.TensorProto.DataType.INT16:
                case s.onnx.TensorProto.DataType.UINT16:
                case s.onnx.TensorProto.DataType.INT8:
                case s.onnx.TensorProto.DataType.UINT8:
                case s.onnx.TensorProto.DataType.BOOL:
                  t3 = e2.int32Data;
                  break;
                case s.onnx.TensorProto.DataType.INT64:
                  t3 = e2.int64Data;
                  break;
                case s.onnx.TensorProto.DataType.DOUBLE:
                  t3 = e2.doubleData;
                  break;
                case s.onnx.TensorProto.DataType.UINT32:
                case s.onnx.TensorProto.DataType.UINT64:
                  t3 = e2.uint64Data;
                  break;
                default:
                  throw new Error("unspecific error");
              }
              if (null == t3)
                throw new Error("failed to populate data from a tensorproto value");
              const n3 = r2.data;
              if (n3.length !== t3.length)
                throw new Error("array length mismatch");
              for (let r3 = 0; r3 < t3.length; r3++) {
                const o2 = t3[r3];
                i.default.isLong(o2) ? n3[r3] = f(o2, e2.dataType) : n3[r3] = o2;
              }
            }
            return r2;
          }
          static fromData(e2, t2, n2) {
            return new c(t2, n2, void 0, void 0, e2);
          }
          static fromOrtTensor(e2) {
            if (!e2)
              throw new Error("cannot construct Value from an empty tensor");
            const t2 = u.ProtoUtil.tensorDimsFromORTFormat(e2), n2 = u.ProtoUtil.tensorDataTypeFromProto(e2.dataType()), r2 = new c(t2, n2);
            if ("string" === n2)
              for (let t3 = 0; t3 < e2.stringDataLength(); t3++)
                r2.data[t3] = e2.stringData(t3);
            else if (e2.rawDataArray() && "number" == typeof e2.rawDataLength() && e2.rawDataLength() > 0) {
              const t3 = r2.data, n3 = new DataView(e2.rawDataArray().buffer, e2.rawDataArray().byteOffset, e2.rawDataLength()), o2 = p(e2.dataType()), i2 = e2.rawDataLength() / o2;
              if (e2.rawDataLength() % o2 != 0)
                throw new Error("invalid buffer length");
              if (t3.length !== i2)
                throw new Error("buffer length mismatch");
              for (let r3 = 0; r3 < i2; r3++) {
                const i3 = h(n3, e2.dataType(), r3 * o2);
                t3[r3] = i3;
              }
            }
            return r2;
          }
        }
        function p(e2) {
          switch (e2) {
            case s.onnx.TensorProto.DataType.UINT8:
            case s.onnx.TensorProto.DataType.INT8:
            case s.onnx.TensorProto.DataType.BOOL:
              return 1;
            case s.onnx.TensorProto.DataType.UINT16:
            case s.onnx.TensorProto.DataType.INT16:
              return 2;
            case s.onnx.TensorProto.DataType.FLOAT:
            case s.onnx.TensorProto.DataType.INT32:
            case s.onnx.TensorProto.DataType.UINT32:
              return 4;
            case s.onnx.TensorProto.DataType.INT64:
            case s.onnx.TensorProto.DataType.DOUBLE:
            case s.onnx.TensorProto.DataType.UINT64:
              return 8;
            default:
              throw new Error(`cannot calculate sizeof() on type ${s.onnx.TensorProto.DataType[e2]}`);
          }
        }
        function d(e2) {
          switch (e2) {
            case "bool":
            case "uint8":
              return Uint8Array;
            case "int8":
              return Int8Array;
            case "int16":
              return Int16Array;
            case "uint16":
              return Uint16Array;
            case "int32":
              return Int32Array;
            case "uint32":
              return Uint32Array;
            case "int64":
              return BigInt64Array;
            case "float32":
              return Float32Array;
            case "float64":
              return Float64Array;
            default:
              throw new Error("unspecified error");
          }
        }
        function f(e2, t2) {
          if (t2 === s.onnx.TensorProto.DataType.INT64 || t2 === l.TensorDataType.INT64) {
            if (e2.greaterThanOrEqual(2147483648) || e2.lessThan(-2147483648))
              throw new TypeError("int64 is not supported");
          } else {
            if (t2 !== s.onnx.TensorProto.DataType.UINT32 && t2 !== l.TensorDataType.UINT32 && t2 !== s.onnx.TensorProto.DataType.UINT64 && t2 !== l.TensorDataType.UINT64)
              throw new TypeError(`not a LONG type: ${s.onnx.TensorProto.DataType[t2]}`);
            if (e2.greaterThanOrEqual(4294967296) || e2.lessThan(0))
              throw new TypeError("uint64 is not supported");
          }
          return e2.toNumber();
        }
        function h(e2, t2, n2) {
          switch (t2) {
            case s.onnx.TensorProto.DataType.BOOL:
            case s.onnx.TensorProto.DataType.UINT8:
              return e2.getUint8(n2);
            case s.onnx.TensorProto.DataType.INT8:
              return e2.getInt8(n2);
            case s.onnx.TensorProto.DataType.UINT16:
              return e2.getUint16(n2, true);
            case s.onnx.TensorProto.DataType.INT16:
              return e2.getInt16(n2, true);
            case s.onnx.TensorProto.DataType.FLOAT:
              return e2.getFloat32(n2, true);
            case s.onnx.TensorProto.DataType.INT32:
              return e2.getInt32(n2, true);
            case s.onnx.TensorProto.DataType.UINT32:
              return e2.getUint32(n2, true);
            case s.onnx.TensorProto.DataType.INT64:
              return f(i.default.fromBits(e2.getUint32(n2, true), e2.getUint32(n2 + 4, true), false), t2);
            case s.onnx.TensorProto.DataType.DOUBLE:
              return e2.getFloat64(n2, true);
            case s.onnx.TensorProto.DataType.UINT64:
              return f(i.default.fromBits(e2.getUint32(n2, true), e2.getUint32(n2 + 4, true), true), t2);
            default:
              throw new Error(`cannot read from DataView for type ${s.onnx.TensorProto.DataType[t2]}`);
          }
        }
        t.Tensor = c;
      }, 7273: function(e, t, n) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.decodeUtf8String = t.MAX_CLIP = t.MIN_CLIP = t.PoolConvUtil = t.ReduceUtil = t.SplitUtil = t.MathUtil = t.ShapeUtil = t.LongUtil = t.ProtoUtil = t.GemmUtil = t.arrayCopyHelper = t.BroadcastUtil = t.MatMulUtil = t.ArrayUtil = t.assert = t.checkInputsShape = void 0;
        const o = n(5686), i = r(n(1583)), a = n(2446), s = n(9240);
        t.checkInputsShape = function(e2, ...t2) {
          if (!e2 || e2.length !== t2.length)
            return false;
          for (let n2 = 0; n2 < e2.length; n2++)
            if (!e2[n2].dims || e2[n2].dims.length !== t2[n2])
              return false;
          return true;
        }, t.assert = function(e2, t2) {
          if (!e2)
            throw new Error("string" == typeof t2 ? t2 : t2());
        }, t.ArrayUtil = class {
          static arraysEqual(e2, t2) {
            if (e2.length !== t2.length)
              return false;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (e2[n2] !== t2[n2])
                return false;
            return true;
          }
        };
        class u {
          static preprocessInputShapes(e2, t2) {
            return [1 === e2.length ? [1, e2[0]] : e2, 1 === t2.length ? [t2[0], 1] : t2];
          }
          static postprocessOutputShape(e2, t2, n2) {
            1 === t2 && e2.splice(e2.length - 2, 1), 1 === n2 && e2.pop();
          }
          static calcMatMulShape(e2, t2) {
            return e2[1] !== t2[0] ? void 0 : [e2[0], t2[1]];
          }
        }
        t.MatMulUtil = u;
        class l {
          static calcShape(e2, t2, n2 = false) {
            const r2 = e2.length, o2 = t2.length;
            if (0 === r2)
              return t2;
            if (0 === o2)
              return e2;
            const i2 = Math.max(e2.length, t2.length), a2 = new Array(i2);
            if (n2) {
              if (r2 < 2 || o2 < 2)
                return;
              const n3 = u.calcMatMulShape([e2[r2 - 2], e2[r2 - 1]], [t2[o2 - 2], t2[o2 - 1]]);
              if (void 0 === n3)
                return;
              [a2[i2 - 2], a2[i2 - 1]] = n3;
            }
            for (let s2 = n2 ? 3 : 1; s2 <= i2; s2++) {
              const n3 = r2 - s2 < 0 ? 1 : e2[r2 - s2], u2 = o2 - s2 < 0 ? 1 : t2[o2 - s2];
              if (n3 !== u2 && n3 > 1 && u2 > 1)
                return;
              a2[i2 - s2] = Math.max(n3, u2);
            }
            return a2;
          }
          static index(e2, t2) {
            const n2 = new Array(t2.length);
            return l.fillIndex(e2, t2, n2), n2;
          }
          static fillIndex(e2, t2, n2) {
            const r2 = e2.length - t2.length;
            for (let o2 = 0; o2 < t2.length; o2++)
              n2[o2] = e2[r2 + o2] % t2[o2];
          }
          static calc(e2, t2, n2, r2, o2) {
            const i2 = l.calcShape(e2.dims, t2.dims);
            if (i2) {
              if (r2 && !d.areEqual(i2, e2.dims))
                return;
              const a2 = d.size(i2), u2 = r2 ? e2 : new s.Tensor(i2, o2 || e2.type);
              if (0 === i2.length)
                u2.set([], n2(e2.get([]), t2.get([])));
              else {
                const r3 = new Array(i2.length), o3 = new Array(e2.dims.length), s2 = new Array(t2.dims.length);
                let c2, p2 = 0, d2 = 0, f2 = false, h2 = false;
                0 === e2.dims.length && (p2 = e2.get([]), f2 = true), 0 === t2.dims.length && (d2 = t2.get([]), h2 = true);
                for (let g2 = 0; g2 < a2; g2++) {
                  c2 = g2;
                  for (let e3 = i2.length - 1; e3 >= 0; e3--)
                    r3[e3] = c2 % i2[e3], c2 = Math.floor(c2 / i2[e3]);
                  f2 || (l.fillIndex(r3, e2.dims, o3), p2 = e2.get(o3)), h2 || (l.fillIndex(r3, t2.dims, s2), d2 = t2.get(s2)), u2.set(r3, n2(p2, d2));
                }
              }
              return u2;
            }
          }
          static isValidBroadcast(e2, t2) {
            const n2 = e2.length, r2 = t2.length;
            if (n2 > r2)
              return false;
            for (let o2 = 1; o2 <= n2; o2++)
              if (1 !== e2[n2 - o2] && e2[n2 - o2] !== t2[r2 - o2])
                return false;
            return true;
          }
          static getBroadcastDims(e2, t2) {
            const n2 = e2.length, r2 = [];
            for (let o2 = 0; o2 < n2; o2++) {
              const i2 = n2 - 1 - o2, a2 = e2[i2] || 1;
              (t2[t2.length - 1 - o2] || 1) > 1 && 1 === a2 && r2.unshift(i2);
            }
            return r2;
          }
        }
        t.BroadcastUtil = l, t.arrayCopyHelper = function(e2, t2, n2, r2, o2) {
          if (r2 < 0 || r2 >= t2.length)
            throw new Error("sourceIndex out of bounds");
          if (n2 < 0 || n2 >= e2.length)
            throw new Error("targetIndex out of bounds");
          if (r2 + o2 > t2.length)
            throw new Error("source indices to be copied are outside bounds");
          if (n2 + o2 > e2.length)
            throw new Error("target array is too small to hold result");
          for (let i2 = 0; i2 < o2; i2++)
            e2[n2 + i2] = t2[r2 + i2];
        }, t.GemmUtil = class {
          static getShapeOfGemmResult(e2, t2, n2, r2, o2) {
            if (2 !== e2.length || 2 !== n2.length)
              throw new Error("shape need to be of size 2");
            let i2, a2, s2;
            t2 ? (i2 = e2[1], a2 = e2[0]) : (i2 = e2[0], a2 = e2[1]);
            let u2 = -1;
            if (r2 ? (s2 = n2[0], u2 = 1) : (s2 = n2[1], u2 = 0), n2[u2] !== a2)
              throw new Error("dimension mismatch");
            if (i2 <= 0 || s2 <= 0 || a2 <= 0)
              throw new Error("invalid shape specified");
            if (o2 && !l.isValidBroadcast(o2, [i2, s2]))
              throw new Error("gemm: invalid bias shape for broadcast");
            return [i2, s2, a2];
          }
        };
        class c {
          static tensorDataTypeFromProto(e2) {
            switch (e2) {
              case a.onnx.TensorProto.DataType.INT8:
                return "int8";
              case a.onnx.TensorProto.DataType.UINT8:
                return "uint8";
              case a.onnx.TensorProto.DataType.BOOL:
                return "bool";
              case a.onnx.TensorProto.DataType.INT16:
                return "int16";
              case a.onnx.TensorProto.DataType.UINT16:
                return "uint16";
              case a.onnx.TensorProto.DataType.INT32:
                return "int32";
              case a.onnx.TensorProto.DataType.UINT32:
                return "uint32";
              case a.onnx.TensorProto.DataType.FLOAT:
                return "float32";
              case a.onnx.TensorProto.DataType.DOUBLE:
                return "float64";
              case a.onnx.TensorProto.DataType.STRING:
                return "string";
              case a.onnx.TensorProto.DataType.INT64:
                return "int32";
              case a.onnx.TensorProto.DataType.UINT64:
                return "uint32";
              default:
                throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[e2]}`);
            }
          }
          static tensorDataTypeStringToEnum(e2) {
            switch (e2) {
              case "int8":
                return a.onnx.TensorProto.DataType.INT8;
              case "uint8":
                return a.onnx.TensorProto.DataType.UINT8;
              case "bool":
                return a.onnx.TensorProto.DataType.BOOL;
              case "int16":
                return a.onnx.TensorProto.DataType.INT16;
              case "uint16":
                return a.onnx.TensorProto.DataType.UINT16;
              case "int32":
                return a.onnx.TensorProto.DataType.INT32;
              case "uint32":
                return a.onnx.TensorProto.DataType.UINT32;
              case "float32":
                return a.onnx.TensorProto.DataType.FLOAT;
              case "float64":
                return a.onnx.TensorProto.DataType.DOUBLE;
              case "string":
                return a.onnx.TensorProto.DataType.STRING;
              case "int64":
                return a.onnx.TensorProto.DataType.INT64;
              case "uint64":
                return a.onnx.TensorProto.DataType.UINT64;
              default:
                throw new Error(`unsupported data type: ${e2}`);
            }
          }
          static tensorDimsFromProto(e2) {
            return e2.map((e3) => i.default.isLong(e3) ? e3.toNumber() : e3);
          }
          static tensorValueTypeFromProto(e2) {
            return { tensorType: c.tensorDataTypeFromProto(e2.elemType), shape: { dims: c.tensorDimsFromProto(e2.shape.dim.map((e3) => e3.dimValue)) } };
          }
          static tensorDimsFromORTFormat(e2) {
            const t2 = [];
            for (let n2 = 0; n2 < e2.dimsLength(); n2++)
              t2.push(p.longToNumber(e2.dims(n2)));
            return t2;
          }
          static tensorAttributesFromORTFormat(e2) {
            const t2 = [];
            for (let n2 = 0; n2 < e2.attributesLength(); n2++)
              t2.push(e2.attributes(n2));
            return t2;
          }
        }
        t.ProtoUtil = c;
        class p {
          static longToNumber(e2, t2) {
            return i.default.isLong(e2) ? e2.toNumber() : e2 instanceof o.flatbuffers.Long ? i.default.fromValue({ low: e2.low, high: e2.high, unsigned: null != t2 && t2 }).toNumber() : e2;
          }
          static isLong(e2) {
            return i.default.isLong(e2) || e2 instanceof o.flatbuffers.Long;
          }
        }
        t.LongUtil = p;
        class d {
          static size(e2) {
            return d.getSizeFromDimensionRange(e2, 0, e2.length);
          }
          static sizeFromDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeFromDimension as Tensor has ${e2.length} dimensions.`);
            return d.getSizeFromDimensionRange(e2, t2, e2.length);
          }
          static sizeToDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeToDimension as Tensor has ${e2.length} dimensions.`);
            return d.getSizeFromDimensionRange(e2, 0, t2);
          }
          static getSizeFromDimensionRange(e2, t2, n2) {
            let r2 = 1;
            for (let o2 = t2; o2 < n2; o2++) {
              if (e2[o2] <= 0)
                throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
              r2 *= e2[o2];
            }
            return r2;
          }
          static computeStrides(e2) {
            const t2 = e2.length;
            if (0 === t2)
              return [];
            if (1 === t2)
              return [1];
            const n2 = new Array(t2);
            n2[t2 - 1] = 1, n2[t2 - 2] = e2[t2 - 1];
            for (let r2 = t2 - 3; r2 >= 0; --r2)
              n2[r2] = n2[r2 + 1] * e2[r2 + 1];
            return n2;
          }
          static transpose(e2) {
            return e2.slice().reverse();
          }
          static indicesToOffset(e2, t2, n2) {
            void 0 === n2 && (n2 = e2.length);
            let r2 = 0;
            for (let o2 = 0; o2 < n2; ++o2)
              r2 += t2[o2] * e2[o2];
            return r2;
          }
          static offsetToIndices(e2, t2) {
            const n2 = t2.length;
            if (0 === n2)
              return [];
            if (1 === n2)
              return [e2 * t2[0]];
            const r2 = new Array(t2.length);
            for (let n3 = 0; n3 < r2.length - 1; ++n3)
              r2[n3] = Math.floor(e2 / t2[n3]), e2 -= r2[n3] * t2[n3];
            return r2[r2.length - 1] = e2, r2;
          }
          static normalizeAxis(e2, t2) {
            if (e2 < -t2 && e2 >= t2)
              throw new Error("unsupported axis for this operation.");
            return e2 < 0 ? e2 + t2 : e2;
          }
          static normalizeAxes(e2, t2) {
            return e2.map((e3) => this.normalizeAxis(e3, t2));
          }
          static incrementIndex(e2, t2, n2) {
            if (0 === t2.length || 0 === e2.length)
              throw new Error("Index incrementing unsupported for scalar Tensor");
            if (void 0 === n2)
              n2 = t2.length;
            else if (n2 <= 0 || n2 > t2.length)
              throw new Error("Incorrect axis to increment on");
            for (let r2 = n2 - 1; r2 >= 0 && (e2[r2]++, !(e2[r2] < t2[r2])); --r2)
              e2[r2] = 0;
          }
          static calculateReshapedDims(e2, t2) {
            if (0 === t2.length) {
              if (0 === e2.length || 1 === d.size(e2))
                return [];
              throw new Error("cannot reshape to a scalar Tensor");
            }
            const n2 = t2.length, r2 = new Array(n2);
            let o2 = -1, i2 = 1;
            for (let a3 = 0; a3 < n2; a3++) {
              if (t2[a3] < -1)
                throw new Error("a dimension in shape hints cannot be less than -1");
              if (-1 === t2[a3]) {
                if (-1 !== o2)
                  throw new Error("at most one dimension in shape hints can be -1");
                o2 = a3;
              } else {
                if (0 === t2[a3]) {
                  if (a3 >= e2.length)
                    throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                  r2[a3] = e2[a3];
                } else
                  r2[a3] = t2[a3];
                i2 *= r2[a3];
              }
            }
            const a2 = d.size(e2);
            if (-1 !== o2) {
              if (a2 % i2 != 0)
                throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e2}] Output shape: [${t2}]`);
              r2[o2] = a2 / i2;
            } else if (i2 !== a2)
              throw new Error("reshapedDims and originalDims don't have matching sizes");
            return r2;
          }
          static sortBasedOnPerm(e2, t2) {
            return t2 ? t2.map((t3) => e2[t3]) : e2.slice().reverse();
          }
          static padShape(e2, t2) {
            const n2 = e2.length;
            return e2.map((e3, r2) => e3 + t2[r2] + t2[r2 + n2]);
          }
          static areEqual(e2, t2) {
            return e2.length === t2.length && e2.every((e3, n2) => e3 === t2[n2]);
          }
          static validateDimsAndCalcSize(e2) {
            if (e2.length > 6)
              throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
            let t2 = 1;
            for (const n2 of e2) {
              if (!Number.isInteger(n2))
                throw new TypeError(`Invalid shape: ${n2} is not an integer`);
              if (n2 < 0 || n2 > 2147483647)
                throw new TypeError(`Invalid shape: length ${n2} is not allowed`);
              t2 *= n2;
            }
            return t2;
          }
          static flattenShape(e2, t2) {
            t2 < 0 && (t2 += e2.length);
            const n2 = e2.reduce((e3, t3) => e3 * t3, 1), r2 = e2.slice(t2).reduce((e3, t3) => e3 * t3, 1);
            return [n2 / r2, r2];
          }
          static squeezeShape(e2, t2) {
            const n2 = new Array();
            t2 = d.normalizeAxes(t2, e2.length);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const o2 = t2.indexOf(r2) >= 0;
              if (o2 && 1 !== e2[r2])
                throw new Error("squeeze an axis of size different than 1");
              (0 === t2.length && e2[r2] > 1 || t2.length > 0 && !o2) && n2.push(e2[r2]);
            }
            return n2;
          }
          static unsqueezeShape(e2, t2) {
            const n2 = new Array(e2.length + t2.length);
            n2.fill(0);
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r3 = d.normalizeAxis(t2[e3], n2.length);
              if (r3 >= n2.length)
                throw new Error("'axes' has an out of range axis");
              if (0 !== n2[r3])
                throw new Error("'axes' has a duplicate axis");
              n2[r3] = 1;
            }
            let r2 = 0;
            for (let t3 = 0; t3 < n2.length; t3++)
              0 === n2[t3] && (n2[t3] = e2[r2++]);
            if (r2 !== e2.length)
              throw new Error("the unsqueezed dimension could not be established");
            return n2;
          }
        }
        t.ShapeUtil = d, t.MathUtil = class {
          static sqr(e2, t2, n2, r2, o2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let i2 = 0; i2 < o2; i2++)
              e2[n2 + i2] += Math.pow(t2[r2 + i2], 2);
          }
          static axpy(e2, t2, n2, r2, o2, i2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let a2 = 0; a2 < o2; a2++)
              e2[n2 + a2] += i2 * t2[r2 + a2];
          }
          static powx(e2, t2, n2, r2, o2, i2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let a2 = 0; a2 < o2; a2++)
              e2[n2 + a2] = Math.pow(t2[r2 + a2], i2);
          }
          static mul(e2, t2, n2, r2, o2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + o2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + o2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let i2 = 0; i2 < o2; i2++)
              e2[n2 + i2] = t2[r2 + i2] * e2[n2 + i2];
          }
        };
        class f {
          static splitShape(e2, t2, n2, r2) {
            if (0 === n2.length) {
              if (!r2)
                throw new Error("need to know number of outputs when the 'split' attribute is not specified");
              f.determineSplit(e2[t2], r2, n2);
            }
            const o2 = [], i2 = [0];
            for (let r3 = 0; r3 < n2.length; ++r3) {
              0 !== r3 && i2.push(i2[r3 - 1] + n2[r3 - 1]);
              const a2 = e2.slice();
              a2[t2] = n2[r3], o2.push(a2);
            }
            return [o2, i2];
          }
          static determineSplit(e2, t2, n2) {
            if (e2 % t2 != 0)
              throw new Error("cannot split tensor to equal sized parts");
            for (let r2 = 0; r2 < t2; ++r2)
              n2.push(e2 / t2);
          }
        }
        t.SplitUtil = f;
        class h {
          static calcReduce(e2, t2, n2, r2, o2) {
            const i2 = e2.dims.slice(0);
            0 === t2.length && i2.forEach((e3, n3) => t2.push(n3));
            const a2 = h.calcReduceShape(i2, t2, true), u2 = d.size(a2), c2 = new s.Tensor(a2, e2.type), p2 = d.computeStrides(a2), f2 = d.computeStrides(i2), g2 = new Array(i2.length);
            for (let n3 = 0; n3 < u2; n3++) {
              const a3 = d.offsetToIndices(n3, p2);
              l.fillIndex(a3, i2, g2), c2.set(a3, h.calcReduceByAxis(e2.numberData, t2, i2, 0, d.indicesToOffset(g2, f2), r2, o2));
            }
            return n2 ? c2 : new s.Tensor(h.calcReduceShape(i2, t2, n2), c2.type, void 0, void 0, c2.data, c2.dataId);
          }
          static calcReduceByAxis(e2, t2, n2, r2, o2, i2, a2) {
            let s2 = 0;
            if (r2 >= t2.length)
              return i2(e2[o2]);
            const u2 = t2[r2], l2 = u2 >= n2.length ? 1 : d.size(n2.slice(u2 + 1));
            for (let c2 = 0; c2 < n2[u2]; c2++)
              s2 = 0 === c2 ? h.calcReduceByAxis(e2, t2, n2, r2 + 1, o2, i2, a2) : a2(s2, h.calcReduceByAxis(e2, t2, n2, r2 + 1, o2, i2, a2)), o2 += l2;
            return s2;
          }
          static calcReduceShape(e2, t2, n2) {
            const r2 = e2.slice();
            for (let e3 = 0; e3 < t2.length; e3++)
              r2[t2[e3]] = n2 ? 1 : 0;
            return r2.filter((e3) => 0 !== e3);
          }
        }
        t.ReduceUtil = h;
        class g {
          static adjustPoolAttributes(e2, t2, n2, r2, o2, i2) {
            if (!e2 && n2.length !== t2.length - 2)
              throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                e3 >= n2.length ? n2.push(t2[e3 + 2]) : n2[e3] = t2[e3 + 2];
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < r2.length) {
                if (r2[e3] < 0)
                  throw new Error("strides should be greater than or equal to 1");
              } else
                r2.push(1);
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < o2.length) {
                if (o2[e3] < 0)
                  throw new Error("dilations should be greater than or equal to 1");
              } else
                o2.push(1);
            for (let e3 = 0; e3 < 2 * n2.length; e3++)
              if (e3 < i2.length) {
                if (i2[e3] < 0)
                  throw new Error("pad should be greater than or equal to 1");
              } else
                i2.push(0);
            for (let e3 = 0; e3 < n2.length; e3++) {
              if (n2[e3] <= 0)
                throw new Error("kernel shapes need to be greater than 0");
              if (i2[e3] >= n2[e3] || i2[e3 + n2.length] >= n2[e3])
                throw new Error("pads should be smaller than kernel");
            }
          }
          static adjustPadsBasedOnAutoPad(e2, t2, n2, r2, o2, i2) {
            if (i2) {
              if (o2.length !== 2 * (e2.length - 2))
                throw new Error("length of pads should be twice the length of data dimensions");
              if (t2.length !== e2.length - 2)
                throw new Error("length of strides should be the length of data dimensions");
              if (r2.length !== e2.length - 2)
                throw new Error("length of kernel shapes should be the length of data dimensions");
              for (let a2 = 0; a2 < e2.length - 2; a2++)
                g.adjustPadAndReturnShape(e2[a2 + 2], t2[a2], n2[a2], r2[a2], o2, a2, a2 + e2.length - 2, i2);
            }
          }
          static computePoolOutputShape(e2, t2, n2, r2, o2, i2, a2) {
            if (t2.length <= 0)
              throw new Error("input shape must be of size greater than 0");
            const s2 = [t2[0], t2[1]];
            return g.computeShapeHelper(e2, t2, s2, n2, r2, o2, i2, a2), s2;
          }
          static computeConvOutputShape(e2, t2, n2, r2, o2, i2, a2) {
            if (e2.length <= 0 || t2.length <= 0)
              throw new Error("invalid input tensor dims or invalid filter tensor dims");
            const s2 = [e2[0], t2[0]];
            return g.computeShapeHelper(false, e2, s2, n2, r2, o2, i2, a2), s2;
          }
          static computeShapeHelper(e2, t2, n2, r2, o2, i2, a2, s2) {
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(1);
            else
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(g.adjustPadAndReturnShape(t2[e3 + 2], r2[e3], o2[e3], i2[e3], a2, e3, e3 + t2.length - 2, s2));
          }
          static adjustPadAndReturnShape(e2, t2, n2, r2, o2, i2, a2, s2) {
            const u2 = n2 * (r2 - 1) + 1;
            if (!s2 || "NOTSET" === s2)
              return Math.floor((e2 + o2[i2] + o2[a2] - u2) / t2 + 1);
            switch (s2) {
              case "VALID":
                return o2[i2] = 0, o2[a2] = 0, Math.floor((e2 - u2) / t2 + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (1 !== n2)
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                {
                  const n3 = ((e2 + t2 - 1) / t2 - 1) * t2 + r2 - e2;
                  return o2[i2] = "SAME_LOWER" === s2 ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), o2[a2] = n3 - o2[i2], Math.floor((e2 + n3 - r2) / t2 + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          }
        }
        t.PoolConvUtil = g, t.MIN_CLIP = -34028234663852886e22, t.MAX_CLIP = 34028234663852886e22, t.decodeUtf8String = function(e2) {
          return new TextDecoder().decode(e2);
        };
      }, 8408: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.version = void 0, t.version = "1.16.3";
      }, 9544: function(e, t, n) {
        "use strict";
        var r, o = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && o(t2, e2, n2);
          return i(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initializeRuntime = t.initializeWebAssemblyInstance = void 0;
        const s = n(2235), u = a(n(1259)), l = n(263), c = () => !!s.env.wasm.proxy && "undefined" != typeof document;
        let p, d, f, h = false, g = false, b = false;
        const m = [], y = [], v = [], _ = [], w = [], T = [], x = () => {
          if (h || !g || b || !p)
            throw new Error("worker not ready");
        }, O = (e2) => {
          switch (e2.data.type) {
            case "init-wasm":
              h = false, e2.data.err ? (b = true, d[1](e2.data.err)) : (g = true, d[0]());
              break;
            case "init-ort":
              e2.data.err ? f[1](e2.data.err) : f[0]();
              break;
            case "create_allocate":
              e2.data.err ? m.shift()[1](e2.data.err) : m.shift()[0](e2.data.out);
              break;
            case "create_finalize":
              e2.data.err ? y.shift()[1](e2.data.err) : y.shift()[0](e2.data.out);
              break;
            case "create":
              e2.data.err ? v.shift()[1](e2.data.err) : v.shift()[0](e2.data.out);
              break;
            case "release":
              e2.data.err ? _.shift()[1](e2.data.err) : _.shift()[0]();
              break;
            case "run":
              e2.data.err ? w.shift()[1](e2.data.err) : w.shift()[0](e2.data.out);
              break;
            case "end-profiling":
              e2.data.err ? T.shift()[1](e2.data.err) : T.shift()[0]();
          }
        }, S = "undefined" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;
        t.initializeWebAssemblyInstance = async () => {
          if (c()) {
            if (g)
              return;
            if (h)
              throw new Error("multiple calls to 'initWasm()' detected.");
            if (b)
              throw new Error("previous call to 'initWasm()' failed.");
            return h = true, void 0 === s.env.wasm.wasmPaths && S && 0 !== S.indexOf("blob:") && (s.env.wasm.wasmPaths = S.substr(0, +S.lastIndexOf("/") + 1)), new Promise((e2, t2) => {
              null == p || p.terminate(), p = n(8050).Z(), p.onmessage = O, d = [e2, t2];
              const r2 = { type: "init-wasm", in: s.env.wasm };
              p.postMessage(r2);
            });
          }
          return (0, l.initializeWebAssembly)(s.env.wasm);
        }, t.initializeRuntime = async (e2) => {
          if (c())
            return x(), new Promise((t2, n2) => {
              f = [t2, n2];
              const r2 = { type: "init-ort", in: e2 };
              p.postMessage(r2);
            });
          await u.initRuntime(e2);
        }, t.createSessionAllocate = async (e2) => c() ? (x(), new Promise((t2, n2) => {
          m.push([t2, n2]);
          const r2 = { type: "create_allocate", in: { model: e2 } };
          p.postMessage(r2, [e2.buffer]);
        })) : u.createSessionAllocate(e2), t.createSessionFinalize = async (e2, t2) => c() ? (x(), new Promise((n2, r2) => {
          y.push([n2, r2]);
          const o2 = { type: "create_finalize", in: { modeldata: e2, options: t2 } };
          p.postMessage(o2);
        })) : u.createSessionFinalize(e2, t2), t.createSession = async (e2, t2) => c() ? (x(), new Promise((n2, r2) => {
          v.push([n2, r2]);
          const o2 = { type: "create", in: { model: e2, options: t2 } };
          p.postMessage(o2, [e2.buffer]);
        })) : u.createSession(e2, t2), t.releaseSession = async (e2) => {
          if (c())
            return x(), new Promise((t2, n2) => {
              _.push([t2, n2]);
              const r2 = { type: "release", in: e2 };
              p.postMessage(r2);
            });
          u.releaseSession(e2);
        }, t.run = async (e2, t2, n2, r2, o2) => c() ? (x(), new Promise((i2, a2) => {
          w.push([i2, a2]);
          const s2 = { type: "run", in: { sessionId: e2, inputIndices: t2, inputs: n2, outputIndices: r2, options: o2 } };
          p.postMessage(s2, u.extractTransferableBuffers(n2));
        })) : u.run(e2, t2, n2, r2, o2), t.endProfiling = async (e2) => {
          if (c())
            return x(), new Promise((t2, n2) => {
              T.push([t2, n2]);
              const r2 = { type: "end-profiling", in: e2 };
              p.postMessage(r2);
            });
          u.endProfiling(e2);
        };
      }, 7918: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.setRunOptions = void 0;
        const r = n(263), o = n(1497);
        t.setRunOptions = (e2) => {
          const t2 = (0, r.getInstance)();
          let n2 = 0;
          const i = [], a = e2 || {};
          try {
            if (void 0 === (null == e2 ? void 0 : e2.logSeverityLevel))
              a.logSeverityLevel = 2;
            else if ("number" != typeof e2.logSeverityLevel || !Number.isInteger(e2.logSeverityLevel) || e2.logSeverityLevel < 0 || e2.logSeverityLevel > 4)
              throw new Error(`log serverity level is not valid: ${e2.logSeverityLevel}`);
            if (void 0 === (null == e2 ? void 0 : e2.logVerbosityLevel))
              a.logVerbosityLevel = 0;
            else if ("number" != typeof e2.logVerbosityLevel || !Number.isInteger(e2.logVerbosityLevel))
              throw new Error(`log verbosity level is not valid: ${e2.logVerbosityLevel}`);
            void 0 === (null == e2 ? void 0 : e2.terminate) && (a.terminate = false);
            let r2 = 0;
            return void 0 !== (null == e2 ? void 0 : e2.tag) && (r2 = (0, o.allocWasmString)(e2.tag, i)), n2 = t2._OrtCreateRunOptions(a.logSeverityLevel, a.logVerbosityLevel, !!a.terminate, r2), 0 === n2 && (0, o.checkLastError)("Can't create run options."), void 0 !== (null == e2 ? void 0 : e2.extra) && (0, o.iterateExtraOptions)(e2.extra, "", /* @__PURE__ */ new WeakSet(), (e3, r3) => {
              const a2 = (0, o.allocWasmString)(e3, i), s = (0, o.allocWasmString)(r3, i);
              0 !== t2._OrtAddRunConfigEntry(n2, a2, s) && (0, o.checkLastError)(`Can't set a run config entry: ${e3} - ${r3}.`);
            }), [n2, i];
          } catch (e3) {
            throw 0 !== n2 && t2._OrtReleaseRunOptions(n2), i.forEach((e4) => t2._free(e4)), e3;
          }
        };
      }, 6640: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.OnnxruntimeWebAssemblySessionHandler = void 0;
        const r = n(2806), o = n(2235), i = n(2850), a = n(9544);
        let s;
        t.OnnxruntimeWebAssemblySessionHandler = class {
          async createSessionAllocate(e2) {
            const t2 = await fetch(e2);
            if (200 !== t2.status)
              throw new Error(`failed to load model: ${e2}`);
            const n2 = await t2.arrayBuffer();
            return (0, a.createSessionAllocate)(new Uint8Array(n2));
          }
          async loadModel(e2, t2) {
            if (s || (await (0, a.initializeRuntime)(o.env), s = true), "string" == typeof e2)
              if ("undefined" != typeof process && process.versions && process.versions.node) {
                const n2 = await (0, i.promisify)(r.readFile)(e2);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n2, t2);
              } else {
                const n2 = await this.createSessionAllocate(e2);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n2, t2);
              }
            else
              [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(e2, t2);
          }
          async dispose() {
            return (0, a.releaseSession)(this.sessionId);
          }
          async run(e2, t2, n2) {
            const r2 = [], i2 = [];
            Object.entries(e2).forEach((e3) => {
              const t3 = e3[0], n3 = e3[1], o2 = this.inputNames.indexOf(t3);
              if (-1 === o2)
                throw new Error(`invalid input '${t3}'`);
              r2.push(n3), i2.push(o2);
            });
            const s2 = [];
            Object.entries(t2).forEach((e3) => {
              const t3 = e3[0], n3 = this.outputNames.indexOf(t3);
              if (-1 === n3)
                throw new Error(`invalid output '${t3}'`);
              s2.push(n3);
            });
            const u = await (0, a.run)(this.sessionId, i2, r2.map((e3) => [e3.type, e3.dims, e3.data]), s2, n2), l = {};
            for (let e3 = 0; e3 < u.length; e3++)
              l[this.outputNames[s2[e3]]] = new o.Tensor(u[e3][0], u[e3][2], u[e3][1]);
            return l;
          }
          startProfiling() {
          }
          endProfiling() {
            (0, a.endProfiling)(this.sessionId);
          }
        };
      }, 7622: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.setSessionOptions = void 0;
        const r = n(263), o = n(1497);
        t.setSessionOptions = (e2) => {
          var t2, n2, i, a;
          const s = (0, r.getInstance)();
          let u = 0;
          const l = [], c = e2 || {};
          ((e3) => {
            e3.extra || (e3.extra = {}), e3.extra.session || (e3.extra.session = {});
            const t3 = e3.extra.session;
            t3.use_ort_model_bytes_directly || (t3.use_ort_model_bytes_directly = "1"), e3.executionProviders && e3.executionProviders.some((e4) => "webgpu" === ("string" == typeof e4 ? e4 : e4.name)) && (e3.enableMemPattern = false);
          })(c);
          try {
            const e3 = ((e4) => {
              switch (e4) {
                case "disabled":
                  return 0;
                case "basic":
                  return 1;
                case "extended":
                  return 2;
                case "all":
                  return 99;
                default:
                  throw new Error(`unsupported graph optimization level: ${e4}`);
              }
            })(null !== (t2 = c.graphOptimizationLevel) && void 0 !== t2 ? t2 : "all"), p = ((e4) => {
              switch (e4) {
                case "sequential":
                  return 0;
                case "parallel":
                  return 1;
                default:
                  throw new Error(`unsupported execution mode: ${e4}`);
              }
            })(null !== (n2 = c.executionMode) && void 0 !== n2 ? n2 : "sequential"), d = "string" == typeof c.logId ? (0, o.allocWasmString)(c.logId, l) : 0, f = null !== (i = c.logSeverityLevel) && void 0 !== i ? i : 2;
            if (!Number.isInteger(f) || f < 0 || f > 4)
              throw new Error(`log serverity level is not valid: ${f}`);
            const h = null !== (a = c.logVerbosityLevel) && void 0 !== a ? a : 0;
            if (!Number.isInteger(h) || h < 0 || h > 4)
              throw new Error(`log verbosity level is not valid: ${h}`);
            const g = "string" == typeof c.optimizedModelFilePath ? (0, o.allocWasmString)(c.optimizedModelFilePath, l) : 0;
            return u = s._OrtCreateSessionOptions(e3, !!c.enableCpuMemArena, !!c.enableMemPattern, p, !!c.enableProfiling, 0, d, f, h, g), 0 === u && (0, o.checkLastError)("Can't create session options."), c.executionProviders && ((e4, t3, n3) => {
              for (const i2 of t3) {
                let t4 = "string" == typeof i2 ? i2 : i2.name;
                switch (t4) {
                  case "xnnpack":
                    t4 = "XNNPACK";
                    break;
                  case "webnn":
                    if (t4 = "WEBNN", "string" != typeof i2) {
                      const t5 = i2;
                      if (null == t5 ? void 0 : t5.deviceType) {
                        const i3 = (0, o.allocWasmString)("deviceType", n3), a3 = (0, o.allocWasmString)(t5.deviceType, n3);
                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e4, i3, a3) && (0, o.checkLastError)(`Can't set a session config entry: 'deviceType' - ${t5.deviceType}.`);
                      }
                      if (null == t5 ? void 0 : t5.powerPreference) {
                        const i3 = (0, o.allocWasmString)("powerPreference", n3), a3 = (0, o.allocWasmString)(t5.powerPreference, n3);
                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e4, i3, a3) && (0, o.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${t5.powerPreference}.`);
                      }
                    }
                    break;
                  case "webgpu":
                    t4 = "JS";
                    break;
                  case "wasm":
                  case "cpu":
                    continue;
                  default:
                    throw new Error(`not supported execution provider: ${t4}`);
                }
                const a2 = (0, o.allocWasmString)(t4, n3);
                0 !== (0, r.getInstance)()._OrtAppendExecutionProvider(e4, a2) && (0, o.checkLastError)(`Can't append execution provider: ${t4}.`);
              }
            })(u, c.executionProviders, l), void 0 !== c.extra && (0, o.iterateExtraOptions)(c.extra, "", /* @__PURE__ */ new WeakSet(), (e4, t3) => {
              const n3 = (0, o.allocWasmString)(e4, l), r2 = (0, o.allocWasmString)(t3, l);
              0 !== s._OrtAddSessionConfigEntry(u, n3, r2) && (0, o.checkLastError)(`Can't set a session config entry: ${e4} - ${t3}.`);
            }), [u, l];
          } catch (e3) {
            throw 0 !== u && s._OrtReleaseSessionOptions(u), l.forEach((e4) => s._free(e4)), e3;
          }
        };
      }, 7917: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.logLevelStringToEnum = t.tensorTypeToTypedArrayConstructor = t.getTensorElementSize = t.tensorDataTypeEnumToString = t.tensorDataTypeStringToEnum = void 0, t.tensorDataTypeStringToEnum = (e2) => {
          switch (e2) {
            case "int8":
              return 3;
            case "uint8":
              return 2;
            case "bool":
              return 9;
            case "int16":
              return 5;
            case "uint16":
              return 4;
            case "int32":
              return 6;
            case "uint32":
              return 12;
            case "float16":
              return 10;
            case "float32":
              return 1;
            case "float64":
              return 11;
            case "string":
              return 8;
            case "int64":
              return 7;
            case "uint64":
              return 13;
            default:
              throw new Error(`unsupported data type: ${e2}`);
          }
        }, t.tensorDataTypeEnumToString = (e2) => {
          switch (e2) {
            case 3:
              return "int8";
            case 2:
              return "uint8";
            case 9:
              return "bool";
            case 5:
              return "int16";
            case 4:
              return "uint16";
            case 6:
              return "int32";
            case 12:
              return "uint32";
            case 10:
              return "float16";
            case 1:
              return "float32";
            case 11:
              return "float64";
            case 8:
              return "string";
            case 7:
              return "int64";
            case 13:
              return "uint64";
            default:
              throw new Error(`unsupported data type: ${e2}`);
          }
        }, t.getTensorElementSize = (e2) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][e2], t.tensorTypeToTypedArrayConstructor = (e2) => {
          switch (e2) {
            case "float16":
            case "uint16":
              return Uint16Array;
            case "float32":
              return Float32Array;
            case "uint8":
            case "bool":
              return Uint8Array;
            case "int8":
              return Int8Array;
            case "int16":
              return Int16Array;
            case "int32":
              return Int32Array;
            case "float64":
              return Float64Array;
            case "uint32":
              return Uint32Array;
            case "int64":
              return BigInt64Array;
            case "uint64":
              return BigUint64Array;
            default:
              throw new Error(`unsupported type: ${e2}`);
          }
        }, t.logLevelStringToEnum = (e2) => {
          switch (e2) {
            case "verbose":
              return 0;
            case "info":
              return 1;
            case "warning":
              return 2;
            case "error":
              return 3;
            case "fatal":
              return 4;
            default:
              throw new Error(`unsupported logging level: ${e2}`);
          }
        };
      }, 1259: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.extractTransferableBuffers = t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initRuntime = void 0;
        const r = n(7918), o = n(7622), i = n(7917), a = n(263), s = n(1497);
        t.initRuntime = async (e2) => {
          var t2, n2;
          t2 = e2.wasm.numThreads, n2 = (0, i.logLevelStringToEnum)(e2.logLevel), 0 !== (0, a.getInstance)()._OrtInit(t2, n2) && (0, s.checkLastError)("Can't initialize onnxruntime.");
        };
        const u = /* @__PURE__ */ new Map();
        t.createSessionAllocate = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = t2._malloc(e2.byteLength);
          if (0 === n2)
            throw new Error(`Can't create a session. failed to allocate a buffer of size ${e2.byteLength}.`);
          return t2.HEAPU8.set(e2, n2), [n2, e2.byteLength];
        }, t.createSessionFinalize = (e2, t2) => {
          const n2 = (0, a.getInstance)();
          let r2 = 0, i2 = 0, l = [];
          const c = [], p = [];
          try {
            [i2, l] = (0, o.setSessionOptions)(t2), r2 = n2._OrtCreateSession(e2[0], e2[1], i2), 0 === r2 && (0, s.checkLastError)("Can't create a session.");
            const [d, f] = ((e3) => {
              const t3 = (0, a.getInstance)(), n3 = t3.stackSave();
              try {
                const n4 = t3.stackAlloc(8);
                return 0 !== t3._OrtGetInputOutputCount(e3, n4, n4 + 4) && (0, s.checkLastError)("Can't get session input/output count."), [t3.HEAP32[n4 / 4], t3.HEAP32[n4 / 4 + 1]];
              } finally {
                t3.stackRestore(n3);
              }
            })(r2), h = [], g = [];
            for (let e3 = 0; e3 < d; e3++) {
              const t3 = n2._OrtGetInputName(r2, e3);
              0 === t3 && (0, s.checkLastError)("Can't get an input name."), c.push(t3), h.push(n2.UTF8ToString(t3));
            }
            for (let e3 = 0; e3 < f; e3++) {
              const t3 = n2._OrtGetOutputName(r2, e3);
              0 === t3 && (0, s.checkLastError)("Can't get an output name."), p.push(t3), g.push(n2.UTF8ToString(t3));
            }
            return u.set(r2, [r2, c, p]), [r2, h, g];
          } catch (e3) {
            throw c.forEach((e4) => n2._OrtFree(e4)), p.forEach((e4) => n2._OrtFree(e4)), 0 !== r2 && n2._OrtReleaseSession(r2), e3;
          } finally {
            n2._free(e2[0]), 0 !== i2 && n2._OrtReleaseSessionOptions(i2), l.forEach((e3) => n2._free(e3));
          }
        }, t.createSession = (e2, n2) => {
          const r2 = (0, t.createSessionAllocate)(e2);
          return (0, t.createSessionFinalize)(r2, n2);
        }, t.releaseSession = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = u.get(e2);
          if (!n2)
            throw new Error(`cannot release session. invalid session id: ${e2}`);
          const [r2, o2, i2] = n2;
          o2.forEach((e3) => t2._OrtFree(e3)), i2.forEach((e3) => t2._OrtFree(e3)), t2._OrtReleaseSession(r2), u.delete(e2);
        }, t.run = async (e2, t2, n2, o2, l) => {
          const c = (0, a.getInstance)(), p = u.get(e2);
          if (!p)
            throw new Error(`cannot run inference. invalid session id: ${e2}`);
          const [d, f, h] = p, g = t2.length, b = o2.length;
          let m = 0, y = [];
          const v = [], _ = [];
          try {
            [m, y] = (0, r.setRunOptions)(l);
            for (let e4 = 0; e4 < g; e4++) {
              const t3 = n2[e4][0], r2 = n2[e4][1], o3 = n2[e4][2];
              let a3, u3;
              if (Array.isArray(o3)) {
                u3 = 4 * o3.length, a3 = c._malloc(u3), _.push(a3);
                let e5 = a3 / 4;
                for (let t4 = 0; t4 < o3.length; t4++) {
                  if ("string" != typeof o3[t4])
                    throw new TypeError(`tensor data at index ${t4} is not a string`);
                  c.HEAPU32[e5++] = (0, s.allocWasmString)(o3[t4], _);
                }
              } else
                u3 = o3.byteLength, a3 = c._malloc(u3), _.push(a3), c.HEAPU8.set(new Uint8Array(o3.buffer, o3.byteOffset, u3), a3);
              const l2 = c.stackSave(), p3 = c.stackAlloc(4 * r2.length);
              try {
                let n3 = p3 / 4;
                r2.forEach((e5) => c.HEAP32[n3++] = e5);
                const o4 = c._OrtCreateTensor((0, i.tensorDataTypeStringToEnum)(t3), a3, u3, p3, r2.length);
                0 === o4 && (0, s.checkLastError)(`Can't create tensor for input[${e4}].`), v.push(o4);
              } finally {
                c.stackRestore(l2);
              }
            }
            const e3 = c.stackSave(), a2 = c.stackAlloc(4 * g), u2 = c.stackAlloc(4 * g), p2 = c.stackAlloc(4 * b), w = c.stackAlloc(4 * b);
            try {
              let e4 = a2 / 4, n3 = u2 / 4, r2 = p2 / 4, l2 = w / 4;
              for (let r3 = 0; r3 < g; r3++)
                c.HEAPU32[e4++] = v[r3], c.HEAPU32[n3++] = f[t2[r3]];
              for (let e5 = 0; e5 < b; e5++)
                c.HEAPU32[r2++] = 0, c.HEAPU32[l2++] = h[o2[e5]];
              let y2 = c._OrtRun(d, u2, a2, g, w, b, p2, m);
              const _2 = c.jsepRunPromise;
              _2 && void 0 !== _2.then && (y2 = await _2);
              const T = [];
              0 !== y2 && (0, s.checkLastError)("failed to call OrtRun().");
              for (let e5 = 0; e5 < b; e5++) {
                const t3 = c.HEAPU32[p2 / 4 + e5], n4 = c.stackSave(), r3 = c.stackAlloc(16);
                let o3, a3 = 0;
                try {
                  y2 = c._OrtGetTensorData(t3, r3, r3 + 4, r3 + 8, r3 + 12), 0 !== y2 && (0, s.checkLastError)(`Can't access output tensor data on index ${e5}.`);
                  let n5 = r3 / 4;
                  const u3 = c.HEAPU32[n5++];
                  a3 = c.HEAPU32[n5++];
                  const l3 = c.HEAPU32[n5++], p3 = c.HEAPU32[n5++], d2 = [];
                  for (let e6 = 0; e6 < p3; e6++)
                    d2.push(c.HEAPU32[l3 / 4 + e6]);
                  c._OrtFree(l3);
                  const f2 = 0 === d2.length ? 1 : d2.reduce((e6, t4) => e6 * t4);
                  if (o3 = (0, i.tensorDataTypeEnumToString)(u3), "string" === o3) {
                    const e6 = [];
                    let t4 = a3 / 4;
                    for (let n6 = 0; n6 < f2; n6++) {
                      const r4 = c.HEAPU32[t4++], o4 = n6 === f2 - 1 ? void 0 : c.HEAPU32[t4] - r4;
                      e6.push(c.UTF8ToString(r4, o4));
                    }
                    T.push([o3, d2, e6]);
                  } else {
                    const e6 = new ((0, i.tensorTypeToTypedArrayConstructor)(o3))(f2);
                    new Uint8Array(e6.buffer, e6.byteOffset, e6.byteLength).set(c.HEAPU8.subarray(a3, a3 + e6.byteLength)), T.push([o3, d2, e6]);
                  }
                } finally {
                  c.stackRestore(n4), "string" === o3 && a3 && c._free(a3), c._OrtReleaseTensor(t3);
                }
              }
              return T;
            } finally {
              c.stackRestore(e3);
            }
          } finally {
            v.forEach((e3) => c._OrtReleaseTensor(e3)), _.forEach((e3) => c._free(e3)), 0 !== m && c._OrtReleaseRunOptions(m), y.forEach((e3) => c._free(e3));
          }
        }, t.endProfiling = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = u.get(e2);
          if (!n2)
            throw new Error("invalid session id");
          const r2 = n2[0], o2 = t2._OrtEndProfiling(r2);
          0 === o2 && (0, s.checkLastError)("Can't get an profile file name."), t2._OrtFree(o2);
        }, t.extractTransferableBuffers = (e2) => {
          const t2 = [];
          for (const n2 of e2) {
            const e3 = n2[2];
            !Array.isArray(e3) && e3.buffer && t2.push(e3.buffer);
          }
          return t2;
        };
      }, 263: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), i = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return o(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.dispose = t.getInstance = t.initializeWebAssembly = void 0;
        const a = i(n(6449)), s = n(932), u = n(3474);
        let l, c = false, p = false, d = false;
        t.initializeWebAssembly = async (e2) => {
          if (c)
            return Promise.resolve();
          if (p)
            throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
          if (d)
            throw new Error("previous call to 'initializeWebAssembly()' failed.");
          p = true;
          const t2 = e2.initTimeout, r2 = e2.numThreads, o2 = e2.simd, i2 = r2 > 1 && (() => {
            try {
              return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
            } catch (e3) {
              return false;
            }
          })(), f = o2 && (() => {
            try {
              return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
            } catch (e3) {
              return false;
            }
          })(), h = e2.wasmPaths, g = "string" == typeof h ? h : void 0, b = /* @__PURE__ */ ((e3, t3) => t3 ? e3 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : e3 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm")(f, i2), m = "object" == typeof h ? h[b] : void 0;
          let y = false;
          const v = [];
          if (t2 > 0 && v.push(new Promise((e3) => {
            setTimeout(() => {
              y = true, e3();
            }, t2);
          })), v.push(new Promise((e3, t3) => {
            const r3 = i2 ? u : s, o3 = { locateFile: (e4, t4) => i2 && e4.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], { type: "text/javascript" })) : e4.endsWith(".wasm") ? m || (null != g ? g : t4) + b : t4 + e4 };
            if (i2)
              if ("undefined" == typeof Blob)
                o3.mainScriptUrlOrBlob = a.join(__dirname, "ort-wasm-threaded.js");
              else {
                const e4 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r3.toString()}})();`;
                o3.mainScriptUrlOrBlob = new Blob([e4], { type: "text/javascript" });
              }
            r3(o3).then((t4) => {
              p = false, c = true, l = t4, e3();
            }, (e4) => {
              p = false, d = true, t3(e4);
            });
          })), await Promise.race(v), y)
            throw new Error(`WebAssembly backend initializing failed due to timeout: ${t2}ms`);
        }, t.getInstance = () => {
          if (c && l)
            return l;
          throw new Error("WebAssembly is not initialized yet.");
        }, t.dispose = () => {
          var e2;
          !c || p || d || (p = true, null === (e2 = l.PThread) || void 0 === e2 || e2.terminateAllThreads(), l = void 0, p = false, c = false, d = true);
        };
      }, 1497: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.checkLastError = t.iterateExtraOptions = t.allocWasmString = void 0;
        const r = n(263);
        t.allocWasmString = (e2, t2) => {
          const n2 = (0, r.getInstance)(), o = n2.lengthBytesUTF8(e2) + 1, i = n2._malloc(o);
          return n2.stringToUTF8(e2, i, o), t2.push(i), i;
        }, t.iterateExtraOptions = (e2, n2, r2, o) => {
          if ("object" == typeof e2 && null !== e2) {
            if (r2.has(e2))
              throw new Error("Circular reference in options");
            r2.add(e2);
          }
          Object.entries(e2).forEach(([e3, i]) => {
            const a = n2 ? n2 + e3 : e3;
            if ("object" == typeof i)
              (0, t.iterateExtraOptions)(i, a + ".", r2, o);
            else if ("string" == typeof i || "number" == typeof i)
              o(a, i.toString());
            else {
              if ("boolean" != typeof i)
                throw new Error("Can't handle extra config type: " + typeof i);
              o(a, i ? "1" : "0");
            }
          });
        }, t.checkLastError = (e2) => {
          const t2 = (0, r.getInstance)(), n2 = t2.stackSave();
          try {
            const n3 = t2.stackAlloc(8);
            t2._OrtGetLastError(n3, n3 + 4);
            const r2 = t2.HEAP32[n3 / 4], o = t2.HEAPU32[n3 / 4 + 1], i = o ? t2.UTF8ToString(o) : "";
            throw new Error(`${e2} ERROR_CODE: ${r2}, ERROR_MESSAGE: ${i}`);
          } finally {
            t2.stackRestore(n2);
          }
        };
      }, 8050: (e, t, n) => {
        "use strict";
        n.d(t, { Z: () => i });
        var r = n(6614), o = n.n(r);
        function i() {
          return o()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:"all"),f=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:"sequential"),d="string"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)("Can\'t create session options."),l.executionProviders&&((e,t,r)=>{for(const o of t){let t="string"==typeof o?o:o.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)("deviceType",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)("powerPreference",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,"",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)("Can\'t create a session.");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),"string"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(d)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h="string"==typeof g?g:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(p,o),y="object"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=h?h:t)+m:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g="./this.program",h=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+"/":__dirname+"/",l=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:"utf8")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{t=r(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&"undefined"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>O.writeSync(2,e.join(" ")+"\\n"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&te("no native wasm support detected");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te("INITIAL_MEMORY should be larger than STACK_SIZE, was "+j+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e="Aborted("+e+")"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function re(e){return e.startsWith("data:application/octet-stream;base64,")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R("failed to asynchronously prepare wasm: "+e),te(e)}))}function oe(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:"run",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V="ort-wasm-threaded.wasm")||(V=_(V));var ce="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):"";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),"unwind";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:["$terminateWorker"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\'Internal error! Worker sent a message "\'+n+\'" to target pthread \'+r.targetThread+", but that thread no longer exists!")}else"checkMailbox"===n?He():"spawnThread"===n?ue(r):"cleanupThread"===n?se(r.thread):"killThread"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):"cancelThread"===n?ge.Fa[r.thread].postMessage({cmd:"cancel"}):"loaded"===n?(e.loaded=!0,t(e)):"alert"===n?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===n?c[r.handler](...r.args):n&&R("worker sent an unknown command "+n)},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var r,n=[];for(r of["onExit","onAbort","print","printErr"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:"load",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_("ort-wasm-threaded.worker.js");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,"undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob="spawnThread",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||"unwind"==e||h(1,e)}}catch(e){e instanceof oe||"unwind"==e||h(1,e)}};function We(e){e>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te("initRandomDevice")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,"0")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):""},r=fe(r),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),l[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(f in l={"%a":e=>d[e.Ga].substring(0,3),"%A":e=>d[e.Ga],"%b":e=>p[e.Na].substring(0,3),"%B":e=>p[e.Na],"%C":e=>i((e.Ka+1900)/100|0,2),"%d":e=>i(e.Qa,2),"%e":e=>o(e.Qa,2," "),"%g":e=>c(e).toString().substring(2),"%G":e=>c(e),"%H":e=>i(e.Ma,2),"%I":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},"%m":e=>i(e.Na+1,2),"%M":e=>i(e.jb,2),"%n":()=>"\\n","%p":e=>0<=e.Ma&&12>e.Ma?"AM":"PM","%S":e=>i(e.kb,2),"%t":()=>"\\t","%u":e=>e.Ga||7,"%U":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),"%V":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},"%w":e=>e.Ga,"%W":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),"%y":e=>(e.Ka+1900).toString().substring(2),"%Y":e=>e.Ka+1900,"%z":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.lb,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),l)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=ge.Fa[e])&&e.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te("")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var r=V;return T||"function"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith("file://")||v||"function"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R("wasm streaming compile failed: "+n),R("falling back to ArrayBuffer instantiation"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c="./this.program",l=(e,t)=>{throw t},f="object"==typeof window,d="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+"/":__dirname+"/",o=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:"utf8")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(f||d)&&(d?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e="Aborted("+e+")"),M=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function H(e){return e.startsWith("data:application/octet-stream;base64,")}if(!H(D="ort-wasm.wasm")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function z(e,t,r){return function(e){if(!y&&(f||d)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b("failed to asynchronously prepare wasm: "+e),W(e)}))}function G(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):"",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):""},r=J(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(l in c={"%a":e=>f[e.ha].substring(0,3),"%A":e=>f[e.ha],"%b":e=>d[e.pa].substring(0,3),"%B":e=>d[e.pa],"%C":e=>o((e.na+1900)/100|0,2),"%d":e=>o(e.ra,2),"%e":e=>a(e.ra,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>o(e.oa,2),"%I":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},"%m":e=>o(e.pa+1,2),"%M":e=>o(e.xa,2),"%n":()=>"\\n","%p":e=>0<=e.oa&&12>e.oa?"AM":"PM","%S":e=>o(e.ya,2),"%t":()=>"\\t","%u":e=>e.ha||7,"%U":e=>o(Math.floor((e.ma+7-e.ha)/7),2),"%V":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},"%w":e=>e.ha,"%W":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),"%y":e=>(e.na+1900).toString().substring(2),"%Y":e=>e.na+1900,"%z":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.za,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),c)r.includes(l)&&(r=r.replace(new RegExp(l,"g"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var r=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith("file://")||p||"function"!=typeof fetch?z(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b("wasm streaming compile failed: "+n),b("falling back to ArrayBuffer instantiation"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{"use strict";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:n})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n', "Worker", void 0, void 0);
        }
      }, 6614: (e) => {
        "use strict";
        e.exports = function(e2, t, n, r) {
          var o = self || window;
          try {
            try {
              var i;
              try {
                i = new o.Blob([e2]);
              } catch (t2) {
                (i = new (o.BlobBuilder || o.WebKitBlobBuilder || o.MozBlobBuilder || o.MSBlobBuilder)()).append(e2), i = i.getBlob();
              }
              var a = o.URL || o.webkitURL, s = a.createObjectURL(i), u = new o[t](s, n);
              return a.revokeObjectURL(s), u;
            } catch (r2) {
              return new o[t]("data:application/javascript,".concat(encodeURIComponent(e2)), n);
            }
          } catch (e3) {
            if (!r)
              throw Error("Inline worker is not supported");
            return new o[t](r, n);
          }
        };
      }, 2446: (e, t, n) => {
        "use strict";
        var r, o, i, a = n(2100), s = a.Reader, u = a.Writer, l = a.util, c = a.roots.default || (a.roots.default = {});
        c.onnx = ((i = {}).Version = (r = {}, (o = Object.create(r))[r[0] = "_START_VERSION"] = 0, o[r[1] = "IR_VERSION_2017_10_10"] = 1, o[r[2] = "IR_VERSION_2017_10_30"] = 2, o[r[3] = "IR_VERSION_2017_11_3"] = 3, o[r[4] = "IR_VERSION_2019_1_22"] = 4, o[r[5] = "IR_VERSION_2019_3_18"] = 5, o[r[6] = "IR_VERSION_2019_9_19"] = 6, o[r[7] = "IR_VERSION_2020_5_8"] = 7, o[r[8] = "IR_VERSION_2021_7_30"] = 8, o[r[9] = "IR_VERSION"] = 9, o), i.AttributeProto = function() {
          function e2(e3) {
            if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.refAttrName = "", e2.prototype.docString = "", e2.prototype.type = 0, e2.prototype.f = 0, e2.prototype.i = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.s = l.newBuffer([]), e2.prototype.t = null, e2.prototype.g = null, e2.prototype.sparseTensor = null, e2.prototype.tp = null, e2.prototype.floats = l.emptyArray, e2.prototype.ints = l.emptyArray, e2.prototype.strings = l.emptyArray, e2.prototype.tensors = l.emptyArray, e2.prototype.graphs = l.emptyArray, e2.prototype.sparseTensors = l.emptyArray, e2.prototype.typeProtos = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.f && Object.hasOwnProperty.call(e3, "f") && t2.uint32(21).float(e3.f), null != e3.i && Object.hasOwnProperty.call(e3, "i") && t2.uint32(24).int64(e3.i), null != e3.s && Object.hasOwnProperty.call(e3, "s") && t2.uint32(34).bytes(e3.s), null != e3.t && Object.hasOwnProperty.call(e3, "t") && c.onnx.TensorProto.encode(e3.t, t2.uint32(42).fork()).ldelim(), null != e3.g && Object.hasOwnProperty.call(e3, "g") && c.onnx.GraphProto.encode(e3.g, t2.uint32(50).fork()).ldelim(), null != e3.floats && e3.floats.length) {
              t2.uint32(58).fork();
              for (var n2 = 0; n2 < e3.floats.length; ++n2)
                t2.float(e3.floats[n2]);
              t2.ldelim();
            }
            if (null != e3.ints && e3.ints.length) {
              for (t2.uint32(66).fork(), n2 = 0; n2 < e3.ints.length; ++n2)
                t2.int64(e3.ints[n2]);
              t2.ldelim();
            }
            if (null != e3.strings && e3.strings.length)
              for (n2 = 0; n2 < e3.strings.length; ++n2)
                t2.uint32(74).bytes(e3.strings[n2]);
            if (null != e3.tensors && e3.tensors.length)
              for (n2 = 0; n2 < e3.tensors.length; ++n2)
                c.onnx.TensorProto.encode(e3.tensors[n2], t2.uint32(82).fork()).ldelim();
            if (null != e3.graphs && e3.graphs.length)
              for (n2 = 0; n2 < e3.graphs.length; ++n2)
                c.onnx.GraphProto.encode(e3.graphs[n2], t2.uint32(90).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(106).string(e3.docString), null != e3.tp && Object.hasOwnProperty.call(e3, "tp") && c.onnx.TypeProto.encode(e3.tp, t2.uint32(114).fork()).ldelim(), null != e3.typeProtos && e3.typeProtos.length)
              for (n2 = 0; n2 < e3.typeProtos.length; ++n2)
                c.onnx.TypeProto.encode(e3.typeProtos[n2], t2.uint32(122).fork()).ldelim();
            if (null != e3.type && Object.hasOwnProperty.call(e3, "type") && t2.uint32(160).int32(e3.type), null != e3.refAttrName && Object.hasOwnProperty.call(e3, "refAttrName") && t2.uint32(170).string(e3.refAttrName), null != e3.sparseTensor && Object.hasOwnProperty.call(e3, "sparseTensor") && c.onnx.SparseTensorProto.encode(e3.sparseTensor, t2.uint32(178).fork()).ldelim(), null != e3.sparseTensors && e3.sparseTensors.length)
              for (n2 = 0; n2 < e3.sparseTensors.length; ++n2)
                c.onnx.SparseTensorProto.encode(e3.sparseTensors[n2], t2.uint32(186).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.AttributeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 21:
                  r2.refAttrName = e3.string();
                  break;
                case 13:
                  r2.docString = e3.string();
                  break;
                case 20:
                  r2.type = e3.int32();
                  break;
                case 2:
                  r2.f = e3.float();
                  break;
                case 3:
                  r2.i = e3.int64();
                  break;
                case 4:
                  r2.s = e3.bytes();
                  break;
                case 5:
                  r2.t = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 6:
                  r2.g = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 22:
                  r2.sparseTensor = c.onnx.SparseTensorProto.decode(e3, e3.uint32());
                  break;
                case 14:
                  r2.tp = c.onnx.TypeProto.decode(e3, e3.uint32());
                  break;
                case 7:
                  if (r2.floats && r2.floats.length || (r2.floats = []), 2 == (7 & o2))
                    for (var i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.floats.push(e3.float());
                  else
                    r2.floats.push(e3.float());
                  break;
                case 8:
                  if (r2.ints && r2.ints.length || (r2.ints = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.ints.push(e3.int64());
                  else
                    r2.ints.push(e3.int64());
                  break;
                case 9:
                  r2.strings && r2.strings.length || (r2.strings = []), r2.strings.push(e3.bytes());
                  break;
                case 10:
                  r2.tensors && r2.tensors.length || (r2.tensors = []), r2.tensors.push(c.onnx.TensorProto.decode(e3, e3.uint32()));
                  break;
                case 11:
                  r2.graphs && r2.graphs.length || (r2.graphs = []), r2.graphs.push(c.onnx.GraphProto.decode(e3, e3.uint32()));
                  break;
                case 23:
                  r2.sparseTensors && r2.sparseTensors.length || (r2.sparseTensors = []), r2.sparseTensors.push(c.onnx.SparseTensorProto.decode(e3, e3.uint32()));
                  break;
                case 15:
                  r2.typeProtos && r2.typeProtos.length || (r2.typeProtos = []), r2.typeProtos.push(c.onnx.TypeProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.refAttrName && e3.hasOwnProperty("refAttrName") && !l.isString(e3.refAttrName))
              return "refAttrName: string expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.type && e3.hasOwnProperty("type"))
              switch (e3.type) {
                default:
                  return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 11:
                case 13:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 14:
              }
            if (null != e3.f && e3.hasOwnProperty("f") && "number" != typeof e3.f)
              return "f: number expected";
            if (null != e3.i && e3.hasOwnProperty("i") && !(l.isInteger(e3.i) || e3.i && l.isInteger(e3.i.low) && l.isInteger(e3.i.high)))
              return "i: integer|Long expected";
            if (null != e3.s && e3.hasOwnProperty("s") && !(e3.s && "number" == typeof e3.s.length || l.isString(e3.s)))
              return "s: buffer expected";
            if (null != e3.t && e3.hasOwnProperty("t") && (n2 = c.onnx.TensorProto.verify(e3.t)))
              return "t." + n2;
            if (null != e3.g && e3.hasOwnProperty("g") && (n2 = c.onnx.GraphProto.verify(e3.g)))
              return "g." + n2;
            if (null != e3.sparseTensor && e3.hasOwnProperty("sparseTensor") && (n2 = c.onnx.SparseTensorProto.verify(e3.sparseTensor)))
              return "sparseTensor." + n2;
            if (null != e3.tp && e3.hasOwnProperty("tp") && (n2 = c.onnx.TypeProto.verify(e3.tp)))
              return "tp." + n2;
            if (null != e3.floats && e3.hasOwnProperty("floats")) {
              if (!Array.isArray(e3.floats))
                return "floats: array expected";
              for (var t2 = 0; t2 < e3.floats.length; ++t2)
                if ("number" != typeof e3.floats[t2])
                  return "floats: number[] expected";
            }
            if (null != e3.ints && e3.hasOwnProperty("ints")) {
              if (!Array.isArray(e3.ints))
                return "ints: array expected";
              for (t2 = 0; t2 < e3.ints.length; ++t2)
                if (!(l.isInteger(e3.ints[t2]) || e3.ints[t2] && l.isInteger(e3.ints[t2].low) && l.isInteger(e3.ints[t2].high)))
                  return "ints: integer|Long[] expected";
            }
            if (null != e3.strings && e3.hasOwnProperty("strings")) {
              if (!Array.isArray(e3.strings))
                return "strings: array expected";
              for (t2 = 0; t2 < e3.strings.length; ++t2)
                if (!(e3.strings[t2] && "number" == typeof e3.strings[t2].length || l.isString(e3.strings[t2])))
                  return "strings: buffer[] expected";
            }
            if (null != e3.tensors && e3.hasOwnProperty("tensors")) {
              if (!Array.isArray(e3.tensors))
                return "tensors: array expected";
              for (t2 = 0; t2 < e3.tensors.length; ++t2)
                if (n2 = c.onnx.TensorProto.verify(e3.tensors[t2]))
                  return "tensors." + n2;
            }
            if (null != e3.graphs && e3.hasOwnProperty("graphs")) {
              if (!Array.isArray(e3.graphs))
                return "graphs: array expected";
              for (t2 = 0; t2 < e3.graphs.length; ++t2)
                if (n2 = c.onnx.GraphProto.verify(e3.graphs[t2]))
                  return "graphs." + n2;
            }
            if (null != e3.sparseTensors && e3.hasOwnProperty("sparseTensors")) {
              if (!Array.isArray(e3.sparseTensors))
                return "sparseTensors: array expected";
              for (t2 = 0; t2 < e3.sparseTensors.length; ++t2)
                if (n2 = c.onnx.SparseTensorProto.verify(e3.sparseTensors[t2]))
                  return "sparseTensors." + n2;
            }
            if (null != e3.typeProtos && e3.hasOwnProperty("typeProtos")) {
              if (!Array.isArray(e3.typeProtos))
                return "typeProtos: array expected";
              for (t2 = 0; t2 < e3.typeProtos.length; ++t2) {
                var n2;
                if (n2 = c.onnx.TypeProto.verify(e3.typeProtos[t2]))
                  return "typeProtos." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.AttributeProto)
              return e3;
            var t2 = new c.onnx.AttributeProto();
            switch (null != e3.name && (t2.name = String(e3.name)), null != e3.refAttrName && (t2.refAttrName = String(e3.refAttrName)), null != e3.docString && (t2.docString = String(e3.docString)), e3.type) {
              default:
                if ("number" == typeof e3.type) {
                  t2.type = e3.type;
                  break;
                }
                break;
              case "UNDEFINED":
              case 0:
                t2.type = 0;
                break;
              case "FLOAT":
              case 1:
                t2.type = 1;
                break;
              case "INT":
              case 2:
                t2.type = 2;
                break;
              case "STRING":
              case 3:
                t2.type = 3;
                break;
              case "TENSOR":
              case 4:
                t2.type = 4;
                break;
              case "GRAPH":
              case 5:
                t2.type = 5;
                break;
              case "SPARSE_TENSOR":
              case 11:
                t2.type = 11;
                break;
              case "TYPE_PROTO":
              case 13:
                t2.type = 13;
                break;
              case "FLOATS":
              case 6:
                t2.type = 6;
                break;
              case "INTS":
              case 7:
                t2.type = 7;
                break;
              case "STRINGS":
              case 8:
                t2.type = 8;
                break;
              case "TENSORS":
              case 9:
                t2.type = 9;
                break;
              case "GRAPHS":
              case 10:
                t2.type = 10;
                break;
              case "SPARSE_TENSORS":
              case 12:
                t2.type = 12;
                break;
              case "TYPE_PROTOS":
              case 14:
                t2.type = 14;
            }
            if (null != e3.f && (t2.f = Number(e3.f)), null != e3.i && (l.Long ? (t2.i = l.Long.fromValue(e3.i)).unsigned = false : "string" == typeof e3.i ? t2.i = parseInt(e3.i, 10) : "number" == typeof e3.i ? t2.i = e3.i : "object" == typeof e3.i && (t2.i = new l.LongBits(e3.i.low >>> 0, e3.i.high >>> 0).toNumber())), null != e3.s && ("string" == typeof e3.s ? l.base64.decode(e3.s, t2.s = l.newBuffer(l.base64.length(e3.s)), 0) : e3.s.length >= 0 && (t2.s = e3.s)), null != e3.t) {
              if ("object" != typeof e3.t)
                throw TypeError(".onnx.AttributeProto.t: object expected");
              t2.t = c.onnx.TensorProto.fromObject(e3.t);
            }
            if (null != e3.g) {
              if ("object" != typeof e3.g)
                throw TypeError(".onnx.AttributeProto.g: object expected");
              t2.g = c.onnx.GraphProto.fromObject(e3.g);
            }
            if (null != e3.sparseTensor) {
              if ("object" != typeof e3.sparseTensor)
                throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
              t2.sparseTensor = c.onnx.SparseTensorProto.fromObject(e3.sparseTensor);
            }
            if (null != e3.tp) {
              if ("object" != typeof e3.tp)
                throw TypeError(".onnx.AttributeProto.tp: object expected");
              t2.tp = c.onnx.TypeProto.fromObject(e3.tp);
            }
            if (e3.floats) {
              if (!Array.isArray(e3.floats))
                throw TypeError(".onnx.AttributeProto.floats: array expected");
              t2.floats = [];
              for (var n2 = 0; n2 < e3.floats.length; ++n2)
                t2.floats[n2] = Number(e3.floats[n2]);
            }
            if (e3.ints) {
              if (!Array.isArray(e3.ints))
                throw TypeError(".onnx.AttributeProto.ints: array expected");
              for (t2.ints = [], n2 = 0; n2 < e3.ints.length; ++n2)
                l.Long ? (t2.ints[n2] = l.Long.fromValue(e3.ints[n2])).unsigned = false : "string" == typeof e3.ints[n2] ? t2.ints[n2] = parseInt(e3.ints[n2], 10) : "number" == typeof e3.ints[n2] ? t2.ints[n2] = e3.ints[n2] : "object" == typeof e3.ints[n2] && (t2.ints[n2] = new l.LongBits(e3.ints[n2].low >>> 0, e3.ints[n2].high >>> 0).toNumber());
            }
            if (e3.strings) {
              if (!Array.isArray(e3.strings))
                throw TypeError(".onnx.AttributeProto.strings: array expected");
              for (t2.strings = [], n2 = 0; n2 < e3.strings.length; ++n2)
                "string" == typeof e3.strings[n2] ? l.base64.decode(e3.strings[n2], t2.strings[n2] = l.newBuffer(l.base64.length(e3.strings[n2])), 0) : e3.strings[n2].length >= 0 && (t2.strings[n2] = e3.strings[n2]);
            }
            if (e3.tensors) {
              if (!Array.isArray(e3.tensors))
                throw TypeError(".onnx.AttributeProto.tensors: array expected");
              for (t2.tensors = [], n2 = 0; n2 < e3.tensors.length; ++n2) {
                if ("object" != typeof e3.tensors[n2])
                  throw TypeError(".onnx.AttributeProto.tensors: object expected");
                t2.tensors[n2] = c.onnx.TensorProto.fromObject(e3.tensors[n2]);
              }
            }
            if (e3.graphs) {
              if (!Array.isArray(e3.graphs))
                throw TypeError(".onnx.AttributeProto.graphs: array expected");
              for (t2.graphs = [], n2 = 0; n2 < e3.graphs.length; ++n2) {
                if ("object" != typeof e3.graphs[n2])
                  throw TypeError(".onnx.AttributeProto.graphs: object expected");
                t2.graphs[n2] = c.onnx.GraphProto.fromObject(e3.graphs[n2]);
              }
            }
            if (e3.sparseTensors) {
              if (!Array.isArray(e3.sparseTensors))
                throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
              for (t2.sparseTensors = [], n2 = 0; n2 < e3.sparseTensors.length; ++n2) {
                if ("object" != typeof e3.sparseTensors[n2])
                  throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
                t2.sparseTensors[n2] = c.onnx.SparseTensorProto.fromObject(e3.sparseTensors[n2]);
              }
            }
            if (e3.typeProtos) {
              if (!Array.isArray(e3.typeProtos))
                throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
              for (t2.typeProtos = [], n2 = 0; n2 < e3.typeProtos.length; ++n2) {
                if ("object" != typeof e3.typeProtos[n2])
                  throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
                t2.typeProtos[n2] = c.onnx.TypeProto.fromObject(e3.typeProtos[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.floats = [], n2.ints = [], n2.strings = [], n2.tensors = [], n2.graphs = [], n2.typeProtos = [], n2.sparseTensors = []), t2.defaults) {
              if (n2.name = "", n2.f = 0, l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.i = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.i = t2.longs === String ? "0" : 0;
              t2.bytes === String ? n2.s = "" : (n2.s = [], t2.bytes !== Array && (n2.s = l.newBuffer(n2.s))), n2.t = null, n2.g = null, n2.docString = "", n2.tp = null, n2.type = t2.enums === String ? "UNDEFINED" : 0, n2.refAttrName = "", n2.sparseTensor = null;
            }
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.f && e3.hasOwnProperty("f") && (n2.f = t2.json && !isFinite(e3.f) ? String(e3.f) : e3.f), null != e3.i && e3.hasOwnProperty("i") && ("number" == typeof e3.i ? n2.i = t2.longs === String ? String(e3.i) : e3.i : n2.i = t2.longs === String ? l.Long.prototype.toString.call(e3.i) : t2.longs === Number ? new l.LongBits(e3.i.low >>> 0, e3.i.high >>> 0).toNumber() : e3.i), null != e3.s && e3.hasOwnProperty("s") && (n2.s = t2.bytes === String ? l.base64.encode(e3.s, 0, e3.s.length) : t2.bytes === Array ? Array.prototype.slice.call(e3.s) : e3.s), null != e3.t && e3.hasOwnProperty("t") && (n2.t = c.onnx.TensorProto.toObject(e3.t, t2)), null != e3.g && e3.hasOwnProperty("g") && (n2.g = c.onnx.GraphProto.toObject(e3.g, t2)), e3.floats && e3.floats.length) {
              n2.floats = [];
              for (var o2 = 0; o2 < e3.floats.length; ++o2)
                n2.floats[o2] = t2.json && !isFinite(e3.floats[o2]) ? String(e3.floats[o2]) : e3.floats[o2];
            }
            if (e3.ints && e3.ints.length)
              for (n2.ints = [], o2 = 0; o2 < e3.ints.length; ++o2)
                "number" == typeof e3.ints[o2] ? n2.ints[o2] = t2.longs === String ? String(e3.ints[o2]) : e3.ints[o2] : n2.ints[o2] = t2.longs === String ? l.Long.prototype.toString.call(e3.ints[o2]) : t2.longs === Number ? new l.LongBits(e3.ints[o2].low >>> 0, e3.ints[o2].high >>> 0).toNumber() : e3.ints[o2];
            if (e3.strings && e3.strings.length)
              for (n2.strings = [], o2 = 0; o2 < e3.strings.length; ++o2)
                n2.strings[o2] = t2.bytes === String ? l.base64.encode(e3.strings[o2], 0, e3.strings[o2].length) : t2.bytes === Array ? Array.prototype.slice.call(e3.strings[o2]) : e3.strings[o2];
            if (e3.tensors && e3.tensors.length)
              for (n2.tensors = [], o2 = 0; o2 < e3.tensors.length; ++o2)
                n2.tensors[o2] = c.onnx.TensorProto.toObject(e3.tensors[o2], t2);
            if (e3.graphs && e3.graphs.length)
              for (n2.graphs = [], o2 = 0; o2 < e3.graphs.length; ++o2)
                n2.graphs[o2] = c.onnx.GraphProto.toObject(e3.graphs[o2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.tp && e3.hasOwnProperty("tp") && (n2.tp = c.onnx.TypeProto.toObject(e3.tp, t2)), e3.typeProtos && e3.typeProtos.length)
              for (n2.typeProtos = [], o2 = 0; o2 < e3.typeProtos.length; ++o2)
                n2.typeProtos[o2] = c.onnx.TypeProto.toObject(e3.typeProtos[o2], t2);
            if (null != e3.type && e3.hasOwnProperty("type") && (n2.type = t2.enums === String ? void 0 === c.onnx.AttributeProto.AttributeType[e3.type] ? e3.type : c.onnx.AttributeProto.AttributeType[e3.type] : e3.type), null != e3.refAttrName && e3.hasOwnProperty("refAttrName") && (n2.refAttrName = e3.refAttrName), null != e3.sparseTensor && e3.hasOwnProperty("sparseTensor") && (n2.sparseTensor = c.onnx.SparseTensorProto.toObject(e3.sparseTensor, t2)), e3.sparseTensors && e3.sparseTensors.length)
              for (n2.sparseTensors = [], o2 = 0; o2 < e3.sparseTensors.length; ++o2)
                n2.sparseTensors[o2] = c.onnx.SparseTensorProto.toObject(e3.sparseTensors[o2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.AttributeProto";
          }, e2.AttributeType = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "UNDEFINED"] = 0, t2[e3[1] = "FLOAT"] = 1, t2[e3[2] = "INT"] = 2, t2[e3[3] = "STRING"] = 3, t2[e3[4] = "TENSOR"] = 4, t2[e3[5] = "GRAPH"] = 5, t2[e3[11] = "SPARSE_TENSOR"] = 11, t2[e3[13] = "TYPE_PROTO"] = 13, t2[e3[6] = "FLOATS"] = 6, t2[e3[7] = "INTS"] = 7, t2[e3[8] = "STRINGS"] = 8, t2[e3[9] = "TENSORS"] = 9, t2[e3[10] = "GRAPHS"] = 10, t2[e3[12] = "SPARSE_TENSORS"] = 12, t2[e3[14] = "TYPE_PROTOS"] = 14, t2;
          }(), e2;
        }(), i.ValueInfoProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.type = null, e2.prototype.docString = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.type && Object.hasOwnProperty.call(e3, "type") && c.onnx.TypeProto.encode(e3.type, t2.uint32(18).fork()).ldelim(), null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(26).string(e3.docString), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.ValueInfoProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 2:
                  r2.type = c.onnx.TypeProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  r2.docString = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.type && e3.hasOwnProperty("type")) {
              var t2 = c.onnx.TypeProto.verify(e3.type);
              if (t2)
                return "type." + t2;
            }
            return null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString) ? "docString: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.ValueInfoProto)
              return e3;
            var t2 = new c.onnx.ValueInfoProto();
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.type) {
              if ("object" != typeof e3.type)
                throw TypeError(".onnx.ValueInfoProto.type: object expected");
              t2.type = c.onnx.TypeProto.fromObject(e3.type);
            }
            return null != e3.docString && (t2.docString = String(e3.docString)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            return t2.defaults && (n2.name = "", n2.type = null, n2.docString = ""), null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.type && e3.hasOwnProperty("type") && (n2.type = c.onnx.TypeProto.toObject(e3.type, t2)), null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.ValueInfoProto";
          }, e2;
        }(), i.NodeProto = function() {
          function e2(e3) {
            if (this.input = [], this.output = [], this.attribute = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.name = "", e2.prototype.opType = "", e2.prototype.domain = "", e2.prototype.attribute = l.emptyArray, e2.prototype.docString = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.input && e3.input.length)
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.uint32(10).string(e3.input[n2]);
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                t2.uint32(18).string(e3.output[n2]);
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(26).string(e3.name), null != e3.opType && Object.hasOwnProperty.call(e3, "opType") && t2.uint32(34).string(e3.opType), null != e3.attribute && e3.attribute.length)
              for (n2 = 0; n2 < e3.attribute.length; ++n2)
                c.onnx.AttributeProto.encode(e3.attribute[n2], t2.uint32(42).fork()).ldelim();
            return null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(50).string(e3.docString), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(58).string(e3.domain), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.NodeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(e3.string());
                  break;
                case 2:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(e3.string());
                  break;
                case 3:
                  r2.name = e3.string();
                  break;
                case 4:
                  r2.opType = e3.string();
                  break;
                case 7:
                  r2.domain = e3.string();
                  break;
                case 5:
                  r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(c.onnx.AttributeProto.decode(e3, e3.uint32()));
                  break;
                case 6:
                  r2.docString = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (var t2 = 0; t2 < e3.input.length; ++t2)
                if (!l.isString(e3.input[t2]))
                  return "input: string[] expected";
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (!l.isString(e3.output[t2]))
                  return "output: string[] expected";
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.opType && e3.hasOwnProperty("opType") && !l.isString(e3.opType))
              return "opType: string expected";
            if (null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain))
              return "domain: string expected";
            if (null != e3.attribute && e3.hasOwnProperty("attribute")) {
              if (!Array.isArray(e3.attribute))
                return "attribute: array expected";
              for (t2 = 0; t2 < e3.attribute.length; ++t2) {
                var n2 = c.onnx.AttributeProto.verify(e3.attribute[t2]);
                if (n2)
                  return "attribute." + n2;
              }
            }
            return null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString) ? "docString: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.NodeProto)
              return e3;
            var t2 = new c.onnx.NodeProto();
            if (e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.NodeProto.input: array expected");
              t2.input = [];
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.input[n2] = String(e3.input[n2]);
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.NodeProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2)
                t2.output[n2] = String(e3.output[n2]);
            }
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.opType && (t2.opType = String(e3.opType)), null != e3.domain && (t2.domain = String(e3.domain)), e3.attribute) {
              if (!Array.isArray(e3.attribute))
                throw TypeError(".onnx.NodeProto.attribute: array expected");
              for (t2.attribute = [], n2 = 0; n2 < e3.attribute.length; ++n2) {
                if ("object" != typeof e3.attribute[n2])
                  throw TypeError(".onnx.NodeProto.attribute: object expected");
                t2.attribute[n2] = c.onnx.AttributeProto.fromObject(e3.attribute[n2]);
              }
            }
            return null != e3.docString && (t2.docString = String(e3.docString)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.input = [], n2.output = [], n2.attribute = []), t2.defaults && (n2.name = "", n2.opType = "", n2.docString = "", n2.domain = ""), e3.input && e3.input.length) {
              n2.input = [];
              for (var r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = e3.input[r2];
            }
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = e3.output[r2];
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.opType && e3.hasOwnProperty("opType") && (n2.opType = e3.opType), e3.attribute && e3.attribute.length)
              for (n2.attribute = [], r2 = 0; r2 < e3.attribute.length; ++r2)
                n2.attribute[r2] = c.onnx.AttributeProto.toObject(e3.attribute[r2], t2);
            return null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.NodeProto";
          }, e2;
        }(), i.TrainingInfoProto = function() {
          function e2(e3) {
            if (this.initializationBinding = [], this.updateBinding = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.initialization = null, e2.prototype.algorithm = null, e2.prototype.initializationBinding = l.emptyArray, e2.prototype.updateBinding = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.initialization && Object.hasOwnProperty.call(e3, "initialization") && c.onnx.GraphProto.encode(e3.initialization, t2.uint32(10).fork()).ldelim(), null != e3.algorithm && Object.hasOwnProperty.call(e3, "algorithm") && c.onnx.GraphProto.encode(e3.algorithm, t2.uint32(18).fork()).ldelim(), null != e3.initializationBinding && e3.initializationBinding.length)
              for (var n2 = 0; n2 < e3.initializationBinding.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.initializationBinding[n2], t2.uint32(26).fork()).ldelim();
            if (null != e3.updateBinding && e3.updateBinding.length)
              for (n2 = 0; n2 < e3.updateBinding.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.updateBinding[n2], t2.uint32(34).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TrainingInfoProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.initialization = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 2:
                  r2.algorithm = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  r2.initializationBinding && r2.initializationBinding.length || (r2.initializationBinding = []), r2.initializationBinding.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 4:
                  r2.updateBinding && r2.updateBinding.length || (r2.updateBinding = []), r2.updateBinding.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.initialization && e3.hasOwnProperty("initialization") && (n2 = c.onnx.GraphProto.verify(e3.initialization)))
              return "initialization." + n2;
            if (null != e3.algorithm && e3.hasOwnProperty("algorithm") && (n2 = c.onnx.GraphProto.verify(e3.algorithm)))
              return "algorithm." + n2;
            if (null != e3.initializationBinding && e3.hasOwnProperty("initializationBinding")) {
              if (!Array.isArray(e3.initializationBinding))
                return "initializationBinding: array expected";
              for (var t2 = 0; t2 < e3.initializationBinding.length; ++t2)
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.initializationBinding[t2]))
                  return "initializationBinding." + n2;
            }
            if (null != e3.updateBinding && e3.hasOwnProperty("updateBinding")) {
              if (!Array.isArray(e3.updateBinding))
                return "updateBinding: array expected";
              for (t2 = 0; t2 < e3.updateBinding.length; ++t2) {
                var n2;
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.updateBinding[t2]))
                  return "updateBinding." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TrainingInfoProto)
              return e3;
            var t2 = new c.onnx.TrainingInfoProto();
            if (null != e3.initialization) {
              if ("object" != typeof e3.initialization)
                throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
              t2.initialization = c.onnx.GraphProto.fromObject(e3.initialization);
            }
            if (null != e3.algorithm) {
              if ("object" != typeof e3.algorithm)
                throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
              t2.algorithm = c.onnx.GraphProto.fromObject(e3.algorithm);
            }
            if (e3.initializationBinding) {
              if (!Array.isArray(e3.initializationBinding))
                throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
              t2.initializationBinding = [];
              for (var n2 = 0; n2 < e3.initializationBinding.length; ++n2) {
                if ("object" != typeof e3.initializationBinding[n2])
                  throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
                t2.initializationBinding[n2] = c.onnx.StringStringEntryProto.fromObject(e3.initializationBinding[n2]);
              }
            }
            if (e3.updateBinding) {
              if (!Array.isArray(e3.updateBinding))
                throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
              for (t2.updateBinding = [], n2 = 0; n2 < e3.updateBinding.length; ++n2) {
                if ("object" != typeof e3.updateBinding[n2])
                  throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
                t2.updateBinding[n2] = c.onnx.StringStringEntryProto.fromObject(e3.updateBinding[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.initializationBinding = [], n2.updateBinding = []), t2.defaults && (n2.initialization = null, n2.algorithm = null), null != e3.initialization && e3.hasOwnProperty("initialization") && (n2.initialization = c.onnx.GraphProto.toObject(e3.initialization, t2)), null != e3.algorithm && e3.hasOwnProperty("algorithm") && (n2.algorithm = c.onnx.GraphProto.toObject(e3.algorithm, t2)), e3.initializationBinding && e3.initializationBinding.length) {
              n2.initializationBinding = [];
              for (var r2 = 0; r2 < e3.initializationBinding.length; ++r2)
                n2.initializationBinding[r2] = c.onnx.StringStringEntryProto.toObject(e3.initializationBinding[r2], t2);
            }
            if (e3.updateBinding && e3.updateBinding.length)
              for (n2.updateBinding = [], r2 = 0; r2 < e3.updateBinding.length; ++r2)
                n2.updateBinding[r2] = c.onnx.StringStringEntryProto.toObject(e3.updateBinding[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TrainingInfoProto";
          }, e2;
        }(), i.ModelProto = function() {
          function e2(e3) {
            if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.irVersion = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.opsetImport = l.emptyArray, e2.prototype.producerName = "", e2.prototype.producerVersion = "", e2.prototype.domain = "", e2.prototype.modelVersion = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.docString = "", e2.prototype.graph = null, e2.prototype.metadataProps = l.emptyArray, e2.prototype.trainingInfo = l.emptyArray, e2.prototype.functions = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.irVersion && Object.hasOwnProperty.call(e3, "irVersion") && t2.uint32(8).int64(e3.irVersion), null != e3.producerName && Object.hasOwnProperty.call(e3, "producerName") && t2.uint32(18).string(e3.producerName), null != e3.producerVersion && Object.hasOwnProperty.call(e3, "producerVersion") && t2.uint32(26).string(e3.producerVersion), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(34).string(e3.domain), null != e3.modelVersion && Object.hasOwnProperty.call(e3, "modelVersion") && t2.uint32(40).int64(e3.modelVersion), null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(50).string(e3.docString), null != e3.graph && Object.hasOwnProperty.call(e3, "graph") && c.onnx.GraphProto.encode(e3.graph, t2.uint32(58).fork()).ldelim(), null != e3.opsetImport && e3.opsetImport.length)
              for (var n2 = 0; n2 < e3.opsetImport.length; ++n2)
                c.onnx.OperatorSetIdProto.encode(e3.opsetImport[n2], t2.uint32(66).fork()).ldelim();
            if (null != e3.metadataProps && e3.metadataProps.length)
              for (n2 = 0; n2 < e3.metadataProps.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.metadataProps[n2], t2.uint32(114).fork()).ldelim();
            if (null != e3.trainingInfo && e3.trainingInfo.length)
              for (n2 = 0; n2 < e3.trainingInfo.length; ++n2)
                c.onnx.TrainingInfoProto.encode(e3.trainingInfo[n2], t2.uint32(162).fork()).ldelim();
            if (null != e3.functions && e3.functions.length)
              for (n2 = 0; n2 < e3.functions.length; ++n2)
                c.onnx.FunctionProto.encode(e3.functions[n2], t2.uint32(202).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.ModelProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.irVersion = e3.int64();
                  break;
                case 8:
                  r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e3, e3.uint32()));
                  break;
                case 2:
                  r2.producerName = e3.string();
                  break;
                case 3:
                  r2.producerVersion = e3.string();
                  break;
                case 4:
                  r2.domain = e3.string();
                  break;
                case 5:
                  r2.modelVersion = e3.int64();
                  break;
                case 6:
                  r2.docString = e3.string();
                  break;
                case 7:
                  r2.graph = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 14:
                  r2.metadataProps && r2.metadataProps.length || (r2.metadataProps = []), r2.metadataProps.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 20:
                  r2.trainingInfo && r2.trainingInfo.length || (r2.trainingInfo = []), r2.trainingInfo.push(c.onnx.TrainingInfoProto.decode(e3, e3.uint32()));
                  break;
                case 25:
                  r2.functions && r2.functions.length || (r2.functions = []), r2.functions.push(c.onnx.FunctionProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.irVersion && e3.hasOwnProperty("irVersion") && !(l.isInteger(e3.irVersion) || e3.irVersion && l.isInteger(e3.irVersion.low) && l.isInteger(e3.irVersion.high)))
              return "irVersion: integer|Long expected";
            if (null != e3.opsetImport && e3.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(e3.opsetImport))
                return "opsetImport: array expected";
              for (var t2 = 0; t2 < e3.opsetImport.length; ++t2)
                if (n2 = c.onnx.OperatorSetIdProto.verify(e3.opsetImport[t2]))
                  return "opsetImport." + n2;
            }
            if (null != e3.producerName && e3.hasOwnProperty("producerName") && !l.isString(e3.producerName))
              return "producerName: string expected";
            if (null != e3.producerVersion && e3.hasOwnProperty("producerVersion") && !l.isString(e3.producerVersion))
              return "producerVersion: string expected";
            if (null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain))
              return "domain: string expected";
            if (null != e3.modelVersion && e3.hasOwnProperty("modelVersion") && !(l.isInteger(e3.modelVersion) || e3.modelVersion && l.isInteger(e3.modelVersion.low) && l.isInteger(e3.modelVersion.high)))
              return "modelVersion: integer|Long expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.graph && e3.hasOwnProperty("graph") && (n2 = c.onnx.GraphProto.verify(e3.graph)))
              return "graph." + n2;
            if (null != e3.metadataProps && e3.hasOwnProperty("metadataProps")) {
              if (!Array.isArray(e3.metadataProps))
                return "metadataProps: array expected";
              for (t2 = 0; t2 < e3.metadataProps.length; ++t2)
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.metadataProps[t2]))
                  return "metadataProps." + n2;
            }
            if (null != e3.trainingInfo && e3.hasOwnProperty("trainingInfo")) {
              if (!Array.isArray(e3.trainingInfo))
                return "trainingInfo: array expected";
              for (t2 = 0; t2 < e3.trainingInfo.length; ++t2)
                if (n2 = c.onnx.TrainingInfoProto.verify(e3.trainingInfo[t2]))
                  return "trainingInfo." + n2;
            }
            if (null != e3.functions && e3.hasOwnProperty("functions")) {
              if (!Array.isArray(e3.functions))
                return "functions: array expected";
              for (t2 = 0; t2 < e3.functions.length; ++t2) {
                var n2;
                if (n2 = c.onnx.FunctionProto.verify(e3.functions[t2]))
                  return "functions." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.ModelProto)
              return e3;
            var t2 = new c.onnx.ModelProto();
            if (null != e3.irVersion && (l.Long ? (t2.irVersion = l.Long.fromValue(e3.irVersion)).unsigned = false : "string" == typeof e3.irVersion ? t2.irVersion = parseInt(e3.irVersion, 10) : "number" == typeof e3.irVersion ? t2.irVersion = e3.irVersion : "object" == typeof e3.irVersion && (t2.irVersion = new l.LongBits(e3.irVersion.low >>> 0, e3.irVersion.high >>> 0).toNumber())), e3.opsetImport) {
              if (!Array.isArray(e3.opsetImport))
                throw TypeError(".onnx.ModelProto.opsetImport: array expected");
              t2.opsetImport = [];
              for (var n2 = 0; n2 < e3.opsetImport.length; ++n2) {
                if ("object" != typeof e3.opsetImport[n2])
                  throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                t2.opsetImport[n2] = c.onnx.OperatorSetIdProto.fromObject(e3.opsetImport[n2]);
              }
            }
            if (null != e3.producerName && (t2.producerName = String(e3.producerName)), null != e3.producerVersion && (t2.producerVersion = String(e3.producerVersion)), null != e3.domain && (t2.domain = String(e3.domain)), null != e3.modelVersion && (l.Long ? (t2.modelVersion = l.Long.fromValue(e3.modelVersion)).unsigned = false : "string" == typeof e3.modelVersion ? t2.modelVersion = parseInt(e3.modelVersion, 10) : "number" == typeof e3.modelVersion ? t2.modelVersion = e3.modelVersion : "object" == typeof e3.modelVersion && (t2.modelVersion = new l.LongBits(e3.modelVersion.low >>> 0, e3.modelVersion.high >>> 0).toNumber())), null != e3.docString && (t2.docString = String(e3.docString)), null != e3.graph) {
              if ("object" != typeof e3.graph)
                throw TypeError(".onnx.ModelProto.graph: object expected");
              t2.graph = c.onnx.GraphProto.fromObject(e3.graph);
            }
            if (e3.metadataProps) {
              if (!Array.isArray(e3.metadataProps))
                throw TypeError(".onnx.ModelProto.metadataProps: array expected");
              for (t2.metadataProps = [], n2 = 0; n2 < e3.metadataProps.length; ++n2) {
                if ("object" != typeof e3.metadataProps[n2])
                  throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                t2.metadataProps[n2] = c.onnx.StringStringEntryProto.fromObject(e3.metadataProps[n2]);
              }
            }
            if (e3.trainingInfo) {
              if (!Array.isArray(e3.trainingInfo))
                throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
              for (t2.trainingInfo = [], n2 = 0; n2 < e3.trainingInfo.length; ++n2) {
                if ("object" != typeof e3.trainingInfo[n2])
                  throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
                t2.trainingInfo[n2] = c.onnx.TrainingInfoProto.fromObject(e3.trainingInfo[n2]);
              }
            }
            if (e3.functions) {
              if (!Array.isArray(e3.functions))
                throw TypeError(".onnx.ModelProto.functions: array expected");
              for (t2.functions = [], n2 = 0; n2 < e3.functions.length; ++n2) {
                if ("object" != typeof e3.functions[n2])
                  throw TypeError(".onnx.ModelProto.functions: object expected");
                t2.functions[n2] = c.onnx.FunctionProto.fromObject(e3.functions[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.opsetImport = [], n2.metadataProps = [], n2.trainingInfo = [], n2.functions = []), t2.defaults) {
              if (l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.irVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.irVersion = t2.longs === String ? "0" : 0;
              n2.producerName = "", n2.producerVersion = "", n2.domain = "", l.Long ? (r2 = new l.Long(0, 0, false), n2.modelVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.modelVersion = t2.longs === String ? "0" : 0, n2.docString = "", n2.graph = null;
            }
            if (null != e3.irVersion && e3.hasOwnProperty("irVersion") && ("number" == typeof e3.irVersion ? n2.irVersion = t2.longs === String ? String(e3.irVersion) : e3.irVersion : n2.irVersion = t2.longs === String ? l.Long.prototype.toString.call(e3.irVersion) : t2.longs === Number ? new l.LongBits(e3.irVersion.low >>> 0, e3.irVersion.high >>> 0).toNumber() : e3.irVersion), null != e3.producerName && e3.hasOwnProperty("producerName") && (n2.producerName = e3.producerName), null != e3.producerVersion && e3.hasOwnProperty("producerVersion") && (n2.producerVersion = e3.producerVersion), null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), null != e3.modelVersion && e3.hasOwnProperty("modelVersion") && ("number" == typeof e3.modelVersion ? n2.modelVersion = t2.longs === String ? String(e3.modelVersion) : e3.modelVersion : n2.modelVersion = t2.longs === String ? l.Long.prototype.toString.call(e3.modelVersion) : t2.longs === Number ? new l.LongBits(e3.modelVersion.low >>> 0, e3.modelVersion.high >>> 0).toNumber() : e3.modelVersion), null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.graph && e3.hasOwnProperty("graph") && (n2.graph = c.onnx.GraphProto.toObject(e3.graph, t2)), e3.opsetImport && e3.opsetImport.length) {
              n2.opsetImport = [];
              for (var o2 = 0; o2 < e3.opsetImport.length; ++o2)
                n2.opsetImport[o2] = c.onnx.OperatorSetIdProto.toObject(e3.opsetImport[o2], t2);
            }
            if (e3.metadataProps && e3.metadataProps.length)
              for (n2.metadataProps = [], o2 = 0; o2 < e3.metadataProps.length; ++o2)
                n2.metadataProps[o2] = c.onnx.StringStringEntryProto.toObject(e3.metadataProps[o2], t2);
            if (e3.trainingInfo && e3.trainingInfo.length)
              for (n2.trainingInfo = [], o2 = 0; o2 < e3.trainingInfo.length; ++o2)
                n2.trainingInfo[o2] = c.onnx.TrainingInfoProto.toObject(e3.trainingInfo[o2], t2);
            if (e3.functions && e3.functions.length)
              for (n2.functions = [], o2 = 0; o2 < e3.functions.length; ++o2)
                n2.functions[o2] = c.onnx.FunctionProto.toObject(e3.functions[o2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.ModelProto";
          }, e2;
        }(), i.StringStringEntryProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.StringStringEntryProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.key = e3.string();
                  break;
                case 2:
                  r2.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            return "object" != typeof e3 || null === e3 ? "object expected" : null != e3.key && e3.hasOwnProperty("key") && !l.isString(e3.key) ? "key: string expected" : null != e3.value && e3.hasOwnProperty("value") && !l.isString(e3.value) ? "value: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.StringStringEntryProto)
              return e3;
            var t2 = new c.onnx.StringStringEntryProto();
            return null != e3.key && (t2.key = String(e3.key)), null != e3.value && (t2.value = String(e3.value)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            return t2.defaults && (n2.key = "", n2.value = ""), null != e3.key && e3.hasOwnProperty("key") && (n2.key = e3.key), null != e3.value && e3.hasOwnProperty("value") && (n2.value = e3.value), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.StringStringEntryProto";
          }, e2;
        }(), i.TensorAnnotation = function() {
          function e2(e3) {
            if (this.quantParameterTensorNames = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.tensorName = "", e2.prototype.quantParameterTensorNames = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.tensorName && Object.hasOwnProperty.call(e3, "tensorName") && t2.uint32(10).string(e3.tensorName), null != e3.quantParameterTensorNames && e3.quantParameterTensorNames.length)
              for (var n2 = 0; n2 < e3.quantParameterTensorNames.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.quantParameterTensorNames[n2], t2.uint32(18).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorAnnotation(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.tensorName = e3.string();
                  break;
                case 2:
                  r2.quantParameterTensorNames && r2.quantParameterTensorNames.length || (r2.quantParameterTensorNames = []), r2.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.tensorName && e3.hasOwnProperty("tensorName") && !l.isString(e3.tensorName))
              return "tensorName: string expected";
            if (null != e3.quantParameterTensorNames && e3.hasOwnProperty("quantParameterTensorNames")) {
              if (!Array.isArray(e3.quantParameterTensorNames))
                return "quantParameterTensorNames: array expected";
              for (var t2 = 0; t2 < e3.quantParameterTensorNames.length; ++t2) {
                var n2 = c.onnx.StringStringEntryProto.verify(e3.quantParameterTensorNames[t2]);
                if (n2)
                  return "quantParameterTensorNames." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorAnnotation)
              return e3;
            var t2 = new c.onnx.TensorAnnotation();
            if (null != e3.tensorName && (t2.tensorName = String(e3.tensorName)), e3.quantParameterTensorNames) {
              if (!Array.isArray(e3.quantParameterTensorNames))
                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
              t2.quantParameterTensorNames = [];
              for (var n2 = 0; n2 < e3.quantParameterTensorNames.length; ++n2) {
                if ("object" != typeof e3.quantParameterTensorNames[n2])
                  throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                t2.quantParameterTensorNames[n2] = c.onnx.StringStringEntryProto.fromObject(e3.quantParameterTensorNames[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.quantParameterTensorNames = []), t2.defaults && (n2.tensorName = ""), null != e3.tensorName && e3.hasOwnProperty("tensorName") && (n2.tensorName = e3.tensorName), e3.quantParameterTensorNames && e3.quantParameterTensorNames.length) {
              n2.quantParameterTensorNames = [];
              for (var r2 = 0; r2 < e3.quantParameterTensorNames.length; ++r2)
                n2.quantParameterTensorNames[r2] = c.onnx.StringStringEntryProto.toObject(e3.quantParameterTensorNames[r2], t2);
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorAnnotation";
          }, e2;
        }(), i.GraphProto = function() {
          function e2(e3) {
            if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.node = l.emptyArray, e2.prototype.name = "", e2.prototype.initializer = l.emptyArray, e2.prototype.sparseInitializer = l.emptyArray, e2.prototype.docString = "", e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.valueInfo = l.emptyArray, e2.prototype.quantizationAnnotation = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.node && e3.node.length)
              for (var n2 = 0; n2 < e3.node.length; ++n2)
                c.onnx.NodeProto.encode(e3.node[n2], t2.uint32(10).fork()).ldelim();
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(18).string(e3.name), null != e3.initializer && e3.initializer.length)
              for (n2 = 0; n2 < e3.initializer.length; ++n2)
                c.onnx.TensorProto.encode(e3.initializer[n2], t2.uint32(42).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(82).string(e3.docString), null != e3.input && e3.input.length)
              for (n2 = 0; n2 < e3.input.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.input[n2], t2.uint32(90).fork()).ldelim();
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.output[n2], t2.uint32(98).fork()).ldelim();
            if (null != e3.valueInfo && e3.valueInfo.length)
              for (n2 = 0; n2 < e3.valueInfo.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.valueInfo[n2], t2.uint32(106).fork()).ldelim();
            if (null != e3.quantizationAnnotation && e3.quantizationAnnotation.length)
              for (n2 = 0; n2 < e3.quantizationAnnotation.length; ++n2)
                c.onnx.TensorAnnotation.encode(e3.quantizationAnnotation[n2], t2.uint32(114).fork()).ldelim();
            if (null != e3.sparseInitializer && e3.sparseInitializer.length)
              for (n2 = 0; n2 < e3.sparseInitializer.length; ++n2)
                c.onnx.SparseTensorProto.encode(e3.sparseInitializer[n2], t2.uint32(122).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.GraphProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.node && r2.node.length || (r2.node = []), r2.node.push(c.onnx.NodeProto.decode(e3, e3.uint32()));
                  break;
                case 2:
                  r2.name = e3.string();
                  break;
                case 5:
                  r2.initializer && r2.initializer.length || (r2.initializer = []), r2.initializer.push(c.onnx.TensorProto.decode(e3, e3.uint32()));
                  break;
                case 15:
                  r2.sparseInitializer && r2.sparseInitializer.length || (r2.sparseInitializer = []), r2.sparseInitializer.push(c.onnx.SparseTensorProto.decode(e3, e3.uint32()));
                  break;
                case 10:
                  r2.docString = e3.string();
                  break;
                case 11:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 12:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 13:
                  r2.valueInfo && r2.valueInfo.length || (r2.valueInfo = []), r2.valueInfo.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 14:
                  r2.quantizationAnnotation && r2.quantizationAnnotation.length || (r2.quantizationAnnotation = []), r2.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.node && e3.hasOwnProperty("node")) {
              if (!Array.isArray(e3.node))
                return "node: array expected";
              for (var t2 = 0; t2 < e3.node.length; ++t2)
                if (n2 = c.onnx.NodeProto.verify(e3.node[t2]))
                  return "node." + n2;
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.initializer && e3.hasOwnProperty("initializer")) {
              if (!Array.isArray(e3.initializer))
                return "initializer: array expected";
              for (t2 = 0; t2 < e3.initializer.length; ++t2)
                if (n2 = c.onnx.TensorProto.verify(e3.initializer[t2]))
                  return "initializer." + n2;
            }
            if (null != e3.sparseInitializer && e3.hasOwnProperty("sparseInitializer")) {
              if (!Array.isArray(e3.sparseInitializer))
                return "sparseInitializer: array expected";
              for (t2 = 0; t2 < e3.sparseInitializer.length; ++t2)
                if (n2 = c.onnx.SparseTensorProto.verify(e3.sparseInitializer[t2]))
                  return "sparseInitializer." + n2;
            }
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (t2 = 0; t2 < e3.input.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.input[t2]))
                  return "input." + n2;
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.output[t2]))
                  return "output." + n2;
            }
            if (null != e3.valueInfo && e3.hasOwnProperty("valueInfo")) {
              if (!Array.isArray(e3.valueInfo))
                return "valueInfo: array expected";
              for (t2 = 0; t2 < e3.valueInfo.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.valueInfo[t2]))
                  return "valueInfo." + n2;
            }
            if (null != e3.quantizationAnnotation && e3.hasOwnProperty("quantizationAnnotation")) {
              if (!Array.isArray(e3.quantizationAnnotation))
                return "quantizationAnnotation: array expected";
              for (t2 = 0; t2 < e3.quantizationAnnotation.length; ++t2) {
                var n2;
                if (n2 = c.onnx.TensorAnnotation.verify(e3.quantizationAnnotation[t2]))
                  return "quantizationAnnotation." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.GraphProto)
              return e3;
            var t2 = new c.onnx.GraphProto();
            if (e3.node) {
              if (!Array.isArray(e3.node))
                throw TypeError(".onnx.GraphProto.node: array expected");
              t2.node = [];
              for (var n2 = 0; n2 < e3.node.length; ++n2) {
                if ("object" != typeof e3.node[n2])
                  throw TypeError(".onnx.GraphProto.node: object expected");
                t2.node[n2] = c.onnx.NodeProto.fromObject(e3.node[n2]);
              }
            }
            if (null != e3.name && (t2.name = String(e3.name)), e3.initializer) {
              if (!Array.isArray(e3.initializer))
                throw TypeError(".onnx.GraphProto.initializer: array expected");
              for (t2.initializer = [], n2 = 0; n2 < e3.initializer.length; ++n2) {
                if ("object" != typeof e3.initializer[n2])
                  throw TypeError(".onnx.GraphProto.initializer: object expected");
                t2.initializer[n2] = c.onnx.TensorProto.fromObject(e3.initializer[n2]);
              }
            }
            if (e3.sparseInitializer) {
              if (!Array.isArray(e3.sparseInitializer))
                throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
              for (t2.sparseInitializer = [], n2 = 0; n2 < e3.sparseInitializer.length; ++n2) {
                if ("object" != typeof e3.sparseInitializer[n2])
                  throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
                t2.sparseInitializer[n2] = c.onnx.SparseTensorProto.fromObject(e3.sparseInitializer[n2]);
              }
            }
            if (null != e3.docString && (t2.docString = String(e3.docString)), e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.GraphProto.input: array expected");
              for (t2.input = [], n2 = 0; n2 < e3.input.length; ++n2) {
                if ("object" != typeof e3.input[n2])
                  throw TypeError(".onnx.GraphProto.input: object expected");
                t2.input[n2] = c.onnx.ValueInfoProto.fromObject(e3.input[n2]);
              }
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.GraphProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2) {
                if ("object" != typeof e3.output[n2])
                  throw TypeError(".onnx.GraphProto.output: object expected");
                t2.output[n2] = c.onnx.ValueInfoProto.fromObject(e3.output[n2]);
              }
            }
            if (e3.valueInfo) {
              if (!Array.isArray(e3.valueInfo))
                throw TypeError(".onnx.GraphProto.valueInfo: array expected");
              for (t2.valueInfo = [], n2 = 0; n2 < e3.valueInfo.length; ++n2) {
                if ("object" != typeof e3.valueInfo[n2])
                  throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                t2.valueInfo[n2] = c.onnx.ValueInfoProto.fromObject(e3.valueInfo[n2]);
              }
            }
            if (e3.quantizationAnnotation) {
              if (!Array.isArray(e3.quantizationAnnotation))
                throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
              for (t2.quantizationAnnotation = [], n2 = 0; n2 < e3.quantizationAnnotation.length; ++n2) {
                if ("object" != typeof e3.quantizationAnnotation[n2])
                  throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                t2.quantizationAnnotation[n2] = c.onnx.TensorAnnotation.fromObject(e3.quantizationAnnotation[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.node = [], n2.initializer = [], n2.input = [], n2.output = [], n2.valueInfo = [], n2.quantizationAnnotation = [], n2.sparseInitializer = []), t2.defaults && (n2.name = "", n2.docString = ""), e3.node && e3.node.length) {
              n2.node = [];
              for (var r2 = 0; r2 < e3.node.length; ++r2)
                n2.node[r2] = c.onnx.NodeProto.toObject(e3.node[r2], t2);
            }
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), e3.initializer && e3.initializer.length)
              for (n2.initializer = [], r2 = 0; r2 < e3.initializer.length; ++r2)
                n2.initializer[r2] = c.onnx.TensorProto.toObject(e3.initializer[r2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.input && e3.input.length)
              for (n2.input = [], r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = c.onnx.ValueInfoProto.toObject(e3.input[r2], t2);
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = c.onnx.ValueInfoProto.toObject(e3.output[r2], t2);
            if (e3.valueInfo && e3.valueInfo.length)
              for (n2.valueInfo = [], r2 = 0; r2 < e3.valueInfo.length; ++r2)
                n2.valueInfo[r2] = c.onnx.ValueInfoProto.toObject(e3.valueInfo[r2], t2);
            if (e3.quantizationAnnotation && e3.quantizationAnnotation.length)
              for (n2.quantizationAnnotation = [], r2 = 0; r2 < e3.quantizationAnnotation.length; ++r2)
                n2.quantizationAnnotation[r2] = c.onnx.TensorAnnotation.toObject(e3.quantizationAnnotation[r2], t2);
            if (e3.sparseInitializer && e3.sparseInitializer.length)
              for (n2.sparseInitializer = [], r2 = 0; r2 < e3.sparseInitializer.length; ++r2)
                n2.sparseInitializer[r2] = c.onnx.SparseTensorProto.toObject(e3.sparseInitializer[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.GraphProto";
          }, e2;
        }(), i.TensorProto = function() {
          function e2(e3) {
            if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.dims = l.emptyArray, e2.prototype.dataType = 0, e2.prototype.segment = null, e2.prototype.floatData = l.emptyArray, e2.prototype.int32Data = l.emptyArray, e2.prototype.stringData = l.emptyArray, e2.prototype.int64Data = l.emptyArray, e2.prototype.name = "", e2.prototype.docString = "", e2.prototype.rawData = l.newBuffer([]), e2.prototype.externalData = l.emptyArray, e2.prototype.dataLocation = 0, e2.prototype.doubleData = l.emptyArray, e2.prototype.uint64Data = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.dims && e3.dims.length) {
              t2.uint32(10).fork();
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                t2.int64(e3.dims[n2]);
              t2.ldelim();
            }
            if (null != e3.dataType && Object.hasOwnProperty.call(e3, "dataType") && t2.uint32(16).int32(e3.dataType), null != e3.segment && Object.hasOwnProperty.call(e3, "segment") && c.onnx.TensorProto.Segment.encode(e3.segment, t2.uint32(26).fork()).ldelim(), null != e3.floatData && e3.floatData.length) {
              for (t2.uint32(34).fork(), n2 = 0; n2 < e3.floatData.length; ++n2)
                t2.float(e3.floatData[n2]);
              t2.ldelim();
            }
            if (null != e3.int32Data && e3.int32Data.length) {
              for (t2.uint32(42).fork(), n2 = 0; n2 < e3.int32Data.length; ++n2)
                t2.int32(e3.int32Data[n2]);
              t2.ldelim();
            }
            if (null != e3.stringData && e3.stringData.length)
              for (n2 = 0; n2 < e3.stringData.length; ++n2)
                t2.uint32(50).bytes(e3.stringData[n2]);
            if (null != e3.int64Data && e3.int64Data.length) {
              for (t2.uint32(58).fork(), n2 = 0; n2 < e3.int64Data.length; ++n2)
                t2.int64(e3.int64Data[n2]);
              t2.ldelim();
            }
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(66).string(e3.name), null != e3.rawData && Object.hasOwnProperty.call(e3, "rawData") && t2.uint32(74).bytes(e3.rawData), null != e3.doubleData && e3.doubleData.length) {
              for (t2.uint32(82).fork(), n2 = 0; n2 < e3.doubleData.length; ++n2)
                t2.double(e3.doubleData[n2]);
              t2.ldelim();
            }
            if (null != e3.uint64Data && e3.uint64Data.length) {
              for (t2.uint32(90).fork(), n2 = 0; n2 < e3.uint64Data.length; ++n2)
                t2.uint64(e3.uint64Data[n2]);
              t2.ldelim();
            }
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(98).string(e3.docString), null != e3.externalData && e3.externalData.length)
              for (n2 = 0; n2 < e3.externalData.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.externalData[n2], t2.uint32(106).fork()).ldelim();
            return null != e3.dataLocation && Object.hasOwnProperty.call(e3, "dataLocation") && t2.uint32(112).int32(e3.dataLocation), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & o2))
                    for (var i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.dims.push(e3.int64());
                  else
                    r2.dims.push(e3.int64());
                  break;
                case 2:
                  r2.dataType = e3.int32();
                  break;
                case 3:
                  r2.segment = c.onnx.TensorProto.Segment.decode(e3, e3.uint32());
                  break;
                case 4:
                  if (r2.floatData && r2.floatData.length || (r2.floatData = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.floatData.push(e3.float());
                  else
                    r2.floatData.push(e3.float());
                  break;
                case 5:
                  if (r2.int32Data && r2.int32Data.length || (r2.int32Data = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.int32Data.push(e3.int32());
                  else
                    r2.int32Data.push(e3.int32());
                  break;
                case 6:
                  r2.stringData && r2.stringData.length || (r2.stringData = []), r2.stringData.push(e3.bytes());
                  break;
                case 7:
                  if (r2.int64Data && r2.int64Data.length || (r2.int64Data = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.int64Data.push(e3.int64());
                  else
                    r2.int64Data.push(e3.int64());
                  break;
                case 8:
                  r2.name = e3.string();
                  break;
                case 12:
                  r2.docString = e3.string();
                  break;
                case 9:
                  r2.rawData = e3.bytes();
                  break;
                case 13:
                  r2.externalData && r2.externalData.length || (r2.externalData = []), r2.externalData.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 14:
                  r2.dataLocation = e3.int32();
                  break;
                case 10:
                  if (r2.doubleData && r2.doubleData.length || (r2.doubleData = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.doubleData.push(e3.double());
                  else
                    r2.doubleData.push(e3.double());
                  break;
                case 11:
                  if (r2.uint64Data && r2.uint64Data.length || (r2.uint64Data = []), 2 == (7 & o2))
                    for (i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.uint64Data.push(e3.uint64());
                  else
                    r2.uint64Data.push(e3.uint64());
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.dims && e3.hasOwnProperty("dims")) {
              if (!Array.isArray(e3.dims))
                return "dims: array expected";
              for (var t2 = 0; t2 < e3.dims.length; ++t2)
                if (!(l.isInteger(e3.dims[t2]) || e3.dims[t2] && l.isInteger(e3.dims[t2].low) && l.isInteger(e3.dims[t2].high)))
                  return "dims: integer|Long[] expected";
            }
            if (null != e3.dataType && e3.hasOwnProperty("dataType") && !l.isInteger(e3.dataType))
              return "dataType: integer expected";
            if (null != e3.segment && e3.hasOwnProperty("segment") && (n2 = c.onnx.TensorProto.Segment.verify(e3.segment)))
              return "segment." + n2;
            if (null != e3.floatData && e3.hasOwnProperty("floatData")) {
              if (!Array.isArray(e3.floatData))
                return "floatData: array expected";
              for (t2 = 0; t2 < e3.floatData.length; ++t2)
                if ("number" != typeof e3.floatData[t2])
                  return "floatData: number[] expected";
            }
            if (null != e3.int32Data && e3.hasOwnProperty("int32Data")) {
              if (!Array.isArray(e3.int32Data))
                return "int32Data: array expected";
              for (t2 = 0; t2 < e3.int32Data.length; ++t2)
                if (!l.isInteger(e3.int32Data[t2]))
                  return "int32Data: integer[] expected";
            }
            if (null != e3.stringData && e3.hasOwnProperty("stringData")) {
              if (!Array.isArray(e3.stringData))
                return "stringData: array expected";
              for (t2 = 0; t2 < e3.stringData.length; ++t2)
                if (!(e3.stringData[t2] && "number" == typeof e3.stringData[t2].length || l.isString(e3.stringData[t2])))
                  return "stringData: buffer[] expected";
            }
            if (null != e3.int64Data && e3.hasOwnProperty("int64Data")) {
              if (!Array.isArray(e3.int64Data))
                return "int64Data: array expected";
              for (t2 = 0; t2 < e3.int64Data.length; ++t2)
                if (!(l.isInteger(e3.int64Data[t2]) || e3.int64Data[t2] && l.isInteger(e3.int64Data[t2].low) && l.isInteger(e3.int64Data[t2].high)))
                  return "int64Data: integer|Long[] expected";
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.rawData && e3.hasOwnProperty("rawData") && !(e3.rawData && "number" == typeof e3.rawData.length || l.isString(e3.rawData)))
              return "rawData: buffer expected";
            if (null != e3.externalData && e3.hasOwnProperty("externalData")) {
              if (!Array.isArray(e3.externalData))
                return "externalData: array expected";
              for (t2 = 0; t2 < e3.externalData.length; ++t2) {
                var n2;
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.externalData[t2]))
                  return "externalData." + n2;
              }
            }
            if (null != e3.dataLocation && e3.hasOwnProperty("dataLocation"))
              switch (e3.dataLocation) {
                default:
                  return "dataLocation: enum value expected";
                case 0:
                case 1:
              }
            if (null != e3.doubleData && e3.hasOwnProperty("doubleData")) {
              if (!Array.isArray(e3.doubleData))
                return "doubleData: array expected";
              for (t2 = 0; t2 < e3.doubleData.length; ++t2)
                if ("number" != typeof e3.doubleData[t2])
                  return "doubleData: number[] expected";
            }
            if (null != e3.uint64Data && e3.hasOwnProperty("uint64Data")) {
              if (!Array.isArray(e3.uint64Data))
                return "uint64Data: array expected";
              for (t2 = 0; t2 < e3.uint64Data.length; ++t2)
                if (!(l.isInteger(e3.uint64Data[t2]) || e3.uint64Data[t2] && l.isInteger(e3.uint64Data[t2].low) && l.isInteger(e3.uint64Data[t2].high)))
                  return "uint64Data: integer|Long[] expected";
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorProto)
              return e3;
            var t2 = new c.onnx.TensorProto();
            if (e3.dims) {
              if (!Array.isArray(e3.dims))
                throw TypeError(".onnx.TensorProto.dims: array expected");
              t2.dims = [];
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                l.Long ? (t2.dims[n2] = l.Long.fromValue(e3.dims[n2])).unsigned = false : "string" == typeof e3.dims[n2] ? t2.dims[n2] = parseInt(e3.dims[n2], 10) : "number" == typeof e3.dims[n2] ? t2.dims[n2] = e3.dims[n2] : "object" == typeof e3.dims[n2] && (t2.dims[n2] = new l.LongBits(e3.dims[n2].low >>> 0, e3.dims[n2].high >>> 0).toNumber());
            }
            if (null != e3.dataType && (t2.dataType = 0 | e3.dataType), null != e3.segment) {
              if ("object" != typeof e3.segment)
                throw TypeError(".onnx.TensorProto.segment: object expected");
              t2.segment = c.onnx.TensorProto.Segment.fromObject(e3.segment);
            }
            if (e3.floatData) {
              if (!Array.isArray(e3.floatData))
                throw TypeError(".onnx.TensorProto.floatData: array expected");
              for (t2.floatData = [], n2 = 0; n2 < e3.floatData.length; ++n2)
                t2.floatData[n2] = Number(e3.floatData[n2]);
            }
            if (e3.int32Data) {
              if (!Array.isArray(e3.int32Data))
                throw TypeError(".onnx.TensorProto.int32Data: array expected");
              for (t2.int32Data = [], n2 = 0; n2 < e3.int32Data.length; ++n2)
                t2.int32Data[n2] = 0 | e3.int32Data[n2];
            }
            if (e3.stringData) {
              if (!Array.isArray(e3.stringData))
                throw TypeError(".onnx.TensorProto.stringData: array expected");
              for (t2.stringData = [], n2 = 0; n2 < e3.stringData.length; ++n2)
                "string" == typeof e3.stringData[n2] ? l.base64.decode(e3.stringData[n2], t2.stringData[n2] = l.newBuffer(l.base64.length(e3.stringData[n2])), 0) : e3.stringData[n2].length >= 0 && (t2.stringData[n2] = e3.stringData[n2]);
            }
            if (e3.int64Data) {
              if (!Array.isArray(e3.int64Data))
                throw TypeError(".onnx.TensorProto.int64Data: array expected");
              for (t2.int64Data = [], n2 = 0; n2 < e3.int64Data.length; ++n2)
                l.Long ? (t2.int64Data[n2] = l.Long.fromValue(e3.int64Data[n2])).unsigned = false : "string" == typeof e3.int64Data[n2] ? t2.int64Data[n2] = parseInt(e3.int64Data[n2], 10) : "number" == typeof e3.int64Data[n2] ? t2.int64Data[n2] = e3.int64Data[n2] : "object" == typeof e3.int64Data[n2] && (t2.int64Data[n2] = new l.LongBits(e3.int64Data[n2].low >>> 0, e3.int64Data[n2].high >>> 0).toNumber());
            }
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.docString && (t2.docString = String(e3.docString)), null != e3.rawData && ("string" == typeof e3.rawData ? l.base64.decode(e3.rawData, t2.rawData = l.newBuffer(l.base64.length(e3.rawData)), 0) : e3.rawData.length >= 0 && (t2.rawData = e3.rawData)), e3.externalData) {
              if (!Array.isArray(e3.externalData))
                throw TypeError(".onnx.TensorProto.externalData: array expected");
              for (t2.externalData = [], n2 = 0; n2 < e3.externalData.length; ++n2) {
                if ("object" != typeof e3.externalData[n2])
                  throw TypeError(".onnx.TensorProto.externalData: object expected");
                t2.externalData[n2] = c.onnx.StringStringEntryProto.fromObject(e3.externalData[n2]);
              }
            }
            switch (e3.dataLocation) {
              default:
                if ("number" == typeof e3.dataLocation) {
                  t2.dataLocation = e3.dataLocation;
                  break;
                }
                break;
              case "DEFAULT":
              case 0:
                t2.dataLocation = 0;
                break;
              case "EXTERNAL":
              case 1:
                t2.dataLocation = 1;
            }
            if (e3.doubleData) {
              if (!Array.isArray(e3.doubleData))
                throw TypeError(".onnx.TensorProto.doubleData: array expected");
              for (t2.doubleData = [], n2 = 0; n2 < e3.doubleData.length; ++n2)
                t2.doubleData[n2] = Number(e3.doubleData[n2]);
            }
            if (e3.uint64Data) {
              if (!Array.isArray(e3.uint64Data))
                throw TypeError(".onnx.TensorProto.uint64Data: array expected");
              for (t2.uint64Data = [], n2 = 0; n2 < e3.uint64Data.length; ++n2)
                l.Long ? (t2.uint64Data[n2] = l.Long.fromValue(e3.uint64Data[n2])).unsigned = true : "string" == typeof e3.uint64Data[n2] ? t2.uint64Data[n2] = parseInt(e3.uint64Data[n2], 10) : "number" == typeof e3.uint64Data[n2] ? t2.uint64Data[n2] = e3.uint64Data[n2] : "object" == typeof e3.uint64Data[n2] && (t2.uint64Data[n2] = new l.LongBits(e3.uint64Data[n2].low >>> 0, e3.uint64Data[n2].high >>> 0).toNumber(true));
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dims = [], n2.floatData = [], n2.int32Data = [], n2.stringData = [], n2.int64Data = [], n2.doubleData = [], n2.uint64Data = [], n2.externalData = []), t2.defaults && (n2.dataType = 0, n2.segment = null, n2.name = "", t2.bytes === String ? n2.rawData = "" : (n2.rawData = [], t2.bytes !== Array && (n2.rawData = l.newBuffer(n2.rawData))), n2.docString = "", n2.dataLocation = t2.enums === String ? "DEFAULT" : 0), e3.dims && e3.dims.length) {
              n2.dims = [];
              for (var r2 = 0; r2 < e3.dims.length; ++r2)
                "number" == typeof e3.dims[r2] ? n2.dims[r2] = t2.longs === String ? String(e3.dims[r2]) : e3.dims[r2] : n2.dims[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.dims[r2]) : t2.longs === Number ? new l.LongBits(e3.dims[r2].low >>> 0, e3.dims[r2].high >>> 0).toNumber() : e3.dims[r2];
            }
            if (null != e3.dataType && e3.hasOwnProperty("dataType") && (n2.dataType = e3.dataType), null != e3.segment && e3.hasOwnProperty("segment") && (n2.segment = c.onnx.TensorProto.Segment.toObject(e3.segment, t2)), e3.floatData && e3.floatData.length)
              for (n2.floatData = [], r2 = 0; r2 < e3.floatData.length; ++r2)
                n2.floatData[r2] = t2.json && !isFinite(e3.floatData[r2]) ? String(e3.floatData[r2]) : e3.floatData[r2];
            if (e3.int32Data && e3.int32Data.length)
              for (n2.int32Data = [], r2 = 0; r2 < e3.int32Data.length; ++r2)
                n2.int32Data[r2] = e3.int32Data[r2];
            if (e3.stringData && e3.stringData.length)
              for (n2.stringData = [], r2 = 0; r2 < e3.stringData.length; ++r2)
                n2.stringData[r2] = t2.bytes === String ? l.base64.encode(e3.stringData[r2], 0, e3.stringData[r2].length) : t2.bytes === Array ? Array.prototype.slice.call(e3.stringData[r2]) : e3.stringData[r2];
            if (e3.int64Data && e3.int64Data.length)
              for (n2.int64Data = [], r2 = 0; r2 < e3.int64Data.length; ++r2)
                "number" == typeof e3.int64Data[r2] ? n2.int64Data[r2] = t2.longs === String ? String(e3.int64Data[r2]) : e3.int64Data[r2] : n2.int64Data[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.int64Data[r2]) : t2.longs === Number ? new l.LongBits(e3.int64Data[r2].low >>> 0, e3.int64Data[r2].high >>> 0).toNumber() : e3.int64Data[r2];
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.rawData && e3.hasOwnProperty("rawData") && (n2.rawData = t2.bytes === String ? l.base64.encode(e3.rawData, 0, e3.rawData.length) : t2.bytes === Array ? Array.prototype.slice.call(e3.rawData) : e3.rawData), e3.doubleData && e3.doubleData.length)
              for (n2.doubleData = [], r2 = 0; r2 < e3.doubleData.length; ++r2)
                n2.doubleData[r2] = t2.json && !isFinite(e3.doubleData[r2]) ? String(e3.doubleData[r2]) : e3.doubleData[r2];
            if (e3.uint64Data && e3.uint64Data.length)
              for (n2.uint64Data = [], r2 = 0; r2 < e3.uint64Data.length; ++r2)
                "number" == typeof e3.uint64Data[r2] ? n2.uint64Data[r2] = t2.longs === String ? String(e3.uint64Data[r2]) : e3.uint64Data[r2] : n2.uint64Data[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.uint64Data[r2]) : t2.longs === Number ? new l.LongBits(e3.uint64Data[r2].low >>> 0, e3.uint64Data[r2].high >>> 0).toNumber(true) : e3.uint64Data[r2];
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.externalData && e3.externalData.length)
              for (n2.externalData = [], r2 = 0; r2 < e3.externalData.length; ++r2)
                n2.externalData[r2] = c.onnx.StringStringEntryProto.toObject(e3.externalData[r2], t2);
            return null != e3.dataLocation && e3.hasOwnProperty("dataLocation") && (n2.dataLocation = t2.enums === String ? void 0 === c.onnx.TensorProto.DataLocation[e3.dataLocation] ? e3.dataLocation : c.onnx.TensorProto.DataLocation[e3.dataLocation] : e3.dataLocation), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorProto";
          }, e2.DataType = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "UNDEFINED"] = 0, t2[e3[1] = "FLOAT"] = 1, t2[e3[2] = "UINT8"] = 2, t2[e3[3] = "INT8"] = 3, t2[e3[4] = "UINT16"] = 4, t2[e3[5] = "INT16"] = 5, t2[e3[6] = "INT32"] = 6, t2[e3[7] = "INT64"] = 7, t2[e3[8] = "STRING"] = 8, t2[e3[9] = "BOOL"] = 9, t2[e3[10] = "FLOAT16"] = 10, t2[e3[11] = "DOUBLE"] = 11, t2[e3[12] = "UINT32"] = 12, t2[e3[13] = "UINT64"] = 13, t2[e3[14] = "COMPLEX64"] = 14, t2[e3[15] = "COMPLEX128"] = 15, t2[e3[16] = "BFLOAT16"] = 16, t2[e3[17] = "FLOAT8E4M3FN"] = 17, t2[e3[18] = "FLOAT8E4M3FNUZ"] = 18, t2[e3[19] = "FLOAT8E5M2"] = 19, t2[e3[20] = "FLOAT8E5M2FNUZ"] = 20, t2;
          }(), e2.Segment = function() {
            function e3(e4) {
              if (e4)
                for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2)
                  null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.begin = l.Long ? l.Long.fromBits(0, 0, false) : 0, e3.prototype.end = l.Long ? l.Long.fromBits(0, 0, false) : 0, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              return t2 || (t2 = u.create()), null != e4.begin && Object.hasOwnProperty.call(e4, "begin") && t2.uint32(8).int64(e4.begin), null != e4.end && Object.hasOwnProperty.call(e4, "end") && t2.uint32(16).int64(e4.end), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new c.onnx.TensorProto.Segment(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.begin = e4.int64();
                    break;
                  case 2:
                    r2.end = e4.int64();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              return "object" != typeof e4 || null === e4 ? "object expected" : null != e4.begin && e4.hasOwnProperty("begin") && !(l.isInteger(e4.begin) || e4.begin && l.isInteger(e4.begin.low) && l.isInteger(e4.begin.high)) ? "begin: integer|Long expected" : null != e4.end && e4.hasOwnProperty("end") && !(l.isInteger(e4.end) || e4.end && l.isInteger(e4.end.low) && l.isInteger(e4.end.high)) ? "end: integer|Long expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TensorProto.Segment)
                return e4;
              var t2 = new c.onnx.TensorProto.Segment();
              return null != e4.begin && (l.Long ? (t2.begin = l.Long.fromValue(e4.begin)).unsigned = false : "string" == typeof e4.begin ? t2.begin = parseInt(e4.begin, 10) : "number" == typeof e4.begin ? t2.begin = e4.begin : "object" == typeof e4.begin && (t2.begin = new l.LongBits(e4.begin.low >>> 0, e4.begin.high >>> 0).toNumber())), null != e4.end && (l.Long ? (t2.end = l.Long.fromValue(e4.end)).unsigned = false : "string" == typeof e4.end ? t2.end = parseInt(e4.end, 10) : "number" == typeof e4.end ? t2.end = e4.end : "object" == typeof e4.end && (t2.end = new l.LongBits(e4.end.low >>> 0, e4.end.high >>> 0).toNumber())), t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if (t2.defaults) {
                if (l.Long) {
                  var r2 = new l.Long(0, 0, false);
                  n2.begin = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
                } else
                  n2.begin = t2.longs === String ? "0" : 0;
                l.Long ? (r2 = new l.Long(0, 0, false), n2.end = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.end = t2.longs === String ? "0" : 0;
              }
              return null != e4.begin && e4.hasOwnProperty("begin") && ("number" == typeof e4.begin ? n2.begin = t2.longs === String ? String(e4.begin) : e4.begin : n2.begin = t2.longs === String ? l.Long.prototype.toString.call(e4.begin) : t2.longs === Number ? new l.LongBits(e4.begin.low >>> 0, e4.begin.high >>> 0).toNumber() : e4.begin), null != e4.end && e4.hasOwnProperty("end") && ("number" == typeof e4.end ? n2.end = t2.longs === String ? String(e4.end) : e4.end : n2.end = t2.longs === String ? l.Long.prototype.toString.call(e4.end) : t2.longs === Number ? new l.LongBits(e4.end.low >>> 0, e4.end.high >>> 0).toNumber() : e4.end), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorProto.Segment";
            }, e3;
          }(), e2.DataLocation = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "DEFAULT"] = 0, t2[e3[1] = "EXTERNAL"] = 1, t2;
          }(), e2;
        }(), i.SparseTensorProto = function() {
          function e2(e3) {
            if (this.dims = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.values = null, e2.prototype.indices = null, e2.prototype.dims = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.values && Object.hasOwnProperty.call(e3, "values") && c.onnx.TensorProto.encode(e3.values, t2.uint32(10).fork()).ldelim(), null != e3.indices && Object.hasOwnProperty.call(e3, "indices") && c.onnx.TensorProto.encode(e3.indices, t2.uint32(18).fork()).ldelim(), null != e3.dims && e3.dims.length) {
              t2.uint32(26).fork();
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                t2.int64(e3.dims[n2]);
              t2.ldelim();
            }
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.SparseTensorProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.values = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 2:
                  r2.indices = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & o2))
                    for (var i2 = e3.uint32() + e3.pos; e3.pos < i2; )
                      r2.dims.push(e3.int64());
                  else
                    r2.dims.push(e3.int64());
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            var t2;
            if (null != e3.values && e3.hasOwnProperty("values") && (t2 = c.onnx.TensorProto.verify(e3.values)))
              return "values." + t2;
            if (null != e3.indices && e3.hasOwnProperty("indices") && (t2 = c.onnx.TensorProto.verify(e3.indices)))
              return "indices." + t2;
            if (null != e3.dims && e3.hasOwnProperty("dims")) {
              if (!Array.isArray(e3.dims))
                return "dims: array expected";
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                if (!(l.isInteger(e3.dims[n2]) || e3.dims[n2] && l.isInteger(e3.dims[n2].low) && l.isInteger(e3.dims[n2].high)))
                  return "dims: integer|Long[] expected";
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.SparseTensorProto)
              return e3;
            var t2 = new c.onnx.SparseTensorProto();
            if (null != e3.values) {
              if ("object" != typeof e3.values)
                throw TypeError(".onnx.SparseTensorProto.values: object expected");
              t2.values = c.onnx.TensorProto.fromObject(e3.values);
            }
            if (null != e3.indices) {
              if ("object" != typeof e3.indices)
                throw TypeError(".onnx.SparseTensorProto.indices: object expected");
              t2.indices = c.onnx.TensorProto.fromObject(e3.indices);
            }
            if (e3.dims) {
              if (!Array.isArray(e3.dims))
                throw TypeError(".onnx.SparseTensorProto.dims: array expected");
              t2.dims = [];
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                l.Long ? (t2.dims[n2] = l.Long.fromValue(e3.dims[n2])).unsigned = false : "string" == typeof e3.dims[n2] ? t2.dims[n2] = parseInt(e3.dims[n2], 10) : "number" == typeof e3.dims[n2] ? t2.dims[n2] = e3.dims[n2] : "object" == typeof e3.dims[n2] && (t2.dims[n2] = new l.LongBits(e3.dims[n2].low >>> 0, e3.dims[n2].high >>> 0).toNumber());
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dims = []), t2.defaults && (n2.values = null, n2.indices = null), null != e3.values && e3.hasOwnProperty("values") && (n2.values = c.onnx.TensorProto.toObject(e3.values, t2)), null != e3.indices && e3.hasOwnProperty("indices") && (n2.indices = c.onnx.TensorProto.toObject(e3.indices, t2)), e3.dims && e3.dims.length) {
              n2.dims = [];
              for (var r2 = 0; r2 < e3.dims.length; ++r2)
                "number" == typeof e3.dims[r2] ? n2.dims[r2] = t2.longs === String ? String(e3.dims[r2]) : e3.dims[r2] : n2.dims[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.dims[r2]) : t2.longs === Number ? new l.LongBits(e3.dims[r2].low >>> 0, e3.dims[r2].high >>> 0).toNumber() : e3.dims[r2];
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.SparseTensorProto";
          }, e2;
        }(), i.TensorShapeProto = function() {
          function e2(e3) {
            if (this.dim = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.dim = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.dim && e3.dim.length)
              for (var n2 = 0; n2 < e3.dim.length; ++n2)
                c.onnx.TensorShapeProto.Dimension.encode(e3.dim[n2], t2.uint32(10).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorShapeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              o2 >>> 3 == 1 ? (r2.dim && r2.dim.length || (r2.dim = []), r2.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e3, e3.uint32()))) : e3.skipType(7 & o2);
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.dim && e3.hasOwnProperty("dim")) {
              if (!Array.isArray(e3.dim))
                return "dim: array expected";
              for (var t2 = 0; t2 < e3.dim.length; ++t2) {
                var n2 = c.onnx.TensorShapeProto.Dimension.verify(e3.dim[t2]);
                if (n2)
                  return "dim." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorShapeProto)
              return e3;
            var t2 = new c.onnx.TensorShapeProto();
            if (e3.dim) {
              if (!Array.isArray(e3.dim))
                throw TypeError(".onnx.TensorShapeProto.dim: array expected");
              t2.dim = [];
              for (var n2 = 0; n2 < e3.dim.length; ++n2) {
                if ("object" != typeof e3.dim[n2])
                  throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                t2.dim[n2] = c.onnx.TensorShapeProto.Dimension.fromObject(e3.dim[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dim = []), e3.dim && e3.dim.length) {
              n2.dim = [];
              for (var r2 = 0; r2 < e3.dim.length; ++r2)
                n2.dim[r2] = c.onnx.TensorShapeProto.Dimension.toObject(e3.dim[r2], t2);
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorShapeProto";
          }, e2.Dimension = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            var t2;
            return e3.prototype.dimValue = null, e3.prototype.dimParam = null, e3.prototype.denotation = "", Object.defineProperty(e3.prototype, "value", { get: l.oneOfGetter(t2 = ["dimValue", "dimParam"]), set: l.oneOfSetter(t2) }), e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.dimValue && Object.hasOwnProperty.call(e4, "dimValue") && t3.uint32(8).int64(e4.dimValue), null != e4.dimParam && Object.hasOwnProperty.call(e4, "dimParam") && t3.uint32(18).string(e4.dimParam), null != e4.denotation && Object.hasOwnProperty.call(e4, "denotation") && t3.uint32(26).string(e4.denotation), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TensorShapeProto.Dimension(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.dimValue = e4.int64();
                    break;
                  case 2:
                    r2.dimParam = e4.string();
                    break;
                  case 3:
                    r2.denotation = e4.string();
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              var t3 = {};
              if (null != e4.dimValue && e4.hasOwnProperty("dimValue") && (t3.value = 1, !(l.isInteger(e4.dimValue) || e4.dimValue && l.isInteger(e4.dimValue.low) && l.isInteger(e4.dimValue.high))))
                return "dimValue: integer|Long expected";
              if (null != e4.dimParam && e4.hasOwnProperty("dimParam")) {
                if (1 === t3.value)
                  return "value: multiple values";
                if (t3.value = 1, !l.isString(e4.dimParam))
                  return "dimParam: string expected";
              }
              return null != e4.denotation && e4.hasOwnProperty("denotation") && !l.isString(e4.denotation) ? "denotation: string expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TensorShapeProto.Dimension)
                return e4;
              var t3 = new c.onnx.TensorShapeProto.Dimension();
              return null != e4.dimValue && (l.Long ? (t3.dimValue = l.Long.fromValue(e4.dimValue)).unsigned = false : "string" == typeof e4.dimValue ? t3.dimValue = parseInt(e4.dimValue, 10) : "number" == typeof e4.dimValue ? t3.dimValue = e4.dimValue : "object" == typeof e4.dimValue && (t3.dimValue = new l.LongBits(e4.dimValue.low >>> 0, e4.dimValue.high >>> 0).toNumber())), null != e4.dimParam && (t3.dimParam = String(e4.dimParam)), null != e4.denotation && (t3.denotation = String(e4.denotation)), t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.denotation = ""), null != e4.dimValue && e4.hasOwnProperty("dimValue") && ("number" == typeof e4.dimValue ? n2.dimValue = t3.longs === String ? String(e4.dimValue) : e4.dimValue : n2.dimValue = t3.longs === String ? l.Long.prototype.toString.call(e4.dimValue) : t3.longs === Number ? new l.LongBits(e4.dimValue.low >>> 0, e4.dimValue.high >>> 0).toNumber() : e4.dimValue, t3.oneofs && (n2.value = "dimValue")), null != e4.dimParam && e4.hasOwnProperty("dimParam") && (n2.dimParam = e4.dimParam, t3.oneofs && (n2.value = "dimParam")), null != e4.denotation && e4.hasOwnProperty("denotation") && (n2.denotation = e4.denotation), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorShapeProto.Dimension";
            }, e3;
          }(), e2;
        }(), i.TypeProto = function() {
          function e2(e3) {
            if (e3)
              for (var t3 = Object.keys(e3), n2 = 0; n2 < t3.length; ++n2)
                null != e3[t3[n2]] && (this[t3[n2]] = e3[t3[n2]]);
          }
          var t2;
          return e2.prototype.tensorType = null, e2.prototype.sequenceType = null, e2.prototype.mapType = null, e2.prototype.optionalType = null, e2.prototype.sparseTensorType = null, e2.prototype.denotation = "", Object.defineProperty(e2.prototype, "value", { get: l.oneOfGetter(t2 = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]), set: l.oneOfSetter(t2) }), e2.create = function(t3) {
            return new e2(t3);
          }, e2.encode = function(e3, t3) {
            return t3 || (t3 = u.create()), null != e3.tensorType && Object.hasOwnProperty.call(e3, "tensorType") && c.onnx.TypeProto.Tensor.encode(e3.tensorType, t3.uint32(10).fork()).ldelim(), null != e3.sequenceType && Object.hasOwnProperty.call(e3, "sequenceType") && c.onnx.TypeProto.Sequence.encode(e3.sequenceType, t3.uint32(34).fork()).ldelim(), null != e3.mapType && Object.hasOwnProperty.call(e3, "mapType") && c.onnx.TypeProto.Map.encode(e3.mapType, t3.uint32(42).fork()).ldelim(), null != e3.denotation && Object.hasOwnProperty.call(e3, "denotation") && t3.uint32(50).string(e3.denotation), null != e3.sparseTensorType && Object.hasOwnProperty.call(e3, "sparseTensorType") && c.onnx.TypeProto.SparseTensor.encode(e3.sparseTensorType, t3.uint32(66).fork()).ldelim(), null != e3.optionalType && Object.hasOwnProperty.call(e3, "optionalType") && c.onnx.TypeProto.Optional.encode(e3.optionalType, t3.uint32(74).fork()).ldelim(), t3;
          }, e2.encodeDelimited = function(e3, t3) {
            return this.encode(e3, t3).ldelim();
          }, e2.decode = function(e3, t3) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t3 ? e3.len : e3.pos + t3, r2 = new c.onnx.TypeProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.tensorType = c.onnx.TypeProto.Tensor.decode(e3, e3.uint32());
                  break;
                case 4:
                  r2.sequenceType = c.onnx.TypeProto.Sequence.decode(e3, e3.uint32());
                  break;
                case 5:
                  r2.mapType = c.onnx.TypeProto.Map.decode(e3, e3.uint32());
                  break;
                case 9:
                  r2.optionalType = c.onnx.TypeProto.Optional.decode(e3, e3.uint32());
                  break;
                case 8:
                  r2.sparseTensorType = c.onnx.TypeProto.SparseTensor.decode(e3, e3.uint32());
                  break;
                case 6:
                  r2.denotation = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            var t3 = {};
            if (null != e3.tensorType && e3.hasOwnProperty("tensorType") && (t3.value = 1, n2 = c.onnx.TypeProto.Tensor.verify(e3.tensorType)))
              return "tensorType." + n2;
            if (null != e3.sequenceType && e3.hasOwnProperty("sequenceType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Sequence.verify(e3.sequenceType))
                return "sequenceType." + n2;
            }
            if (null != e3.mapType && e3.hasOwnProperty("mapType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Map.verify(e3.mapType))
                return "mapType." + n2;
            }
            if (null != e3.optionalType && e3.hasOwnProperty("optionalType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Optional.verify(e3.optionalType))
                return "optionalType." + n2;
            }
            if (null != e3.sparseTensorType && e3.hasOwnProperty("sparseTensorType")) {
              if (1 === t3.value)
                return "value: multiple values";
              var n2;
              if (t3.value = 1, n2 = c.onnx.TypeProto.SparseTensor.verify(e3.sparseTensorType))
                return "sparseTensorType." + n2;
            }
            return null != e3.denotation && e3.hasOwnProperty("denotation") && !l.isString(e3.denotation) ? "denotation: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TypeProto)
              return e3;
            var t3 = new c.onnx.TypeProto();
            if (null != e3.tensorType) {
              if ("object" != typeof e3.tensorType)
                throw TypeError(".onnx.TypeProto.tensorType: object expected");
              t3.tensorType = c.onnx.TypeProto.Tensor.fromObject(e3.tensorType);
            }
            if (null != e3.sequenceType) {
              if ("object" != typeof e3.sequenceType)
                throw TypeError(".onnx.TypeProto.sequenceType: object expected");
              t3.sequenceType = c.onnx.TypeProto.Sequence.fromObject(e3.sequenceType);
            }
            if (null != e3.mapType) {
              if ("object" != typeof e3.mapType)
                throw TypeError(".onnx.TypeProto.mapType: object expected");
              t3.mapType = c.onnx.TypeProto.Map.fromObject(e3.mapType);
            }
            if (null != e3.optionalType) {
              if ("object" != typeof e3.optionalType)
                throw TypeError(".onnx.TypeProto.optionalType: object expected");
              t3.optionalType = c.onnx.TypeProto.Optional.fromObject(e3.optionalType);
            }
            if (null != e3.sparseTensorType) {
              if ("object" != typeof e3.sparseTensorType)
                throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
              t3.sparseTensorType = c.onnx.TypeProto.SparseTensor.fromObject(e3.sparseTensorType);
            }
            return null != e3.denotation && (t3.denotation = String(e3.denotation)), t3;
          }, e2.toObject = function(e3, t3) {
            t3 || (t3 = {});
            var n2 = {};
            return t3.defaults && (n2.denotation = ""), null != e3.tensorType && e3.hasOwnProperty("tensorType") && (n2.tensorType = c.onnx.TypeProto.Tensor.toObject(e3.tensorType, t3), t3.oneofs && (n2.value = "tensorType")), null != e3.sequenceType && e3.hasOwnProperty("sequenceType") && (n2.sequenceType = c.onnx.TypeProto.Sequence.toObject(e3.sequenceType, t3), t3.oneofs && (n2.value = "sequenceType")), null != e3.mapType && e3.hasOwnProperty("mapType") && (n2.mapType = c.onnx.TypeProto.Map.toObject(e3.mapType, t3), t3.oneofs && (n2.value = "mapType")), null != e3.denotation && e3.hasOwnProperty("denotation") && (n2.denotation = e3.denotation), null != e3.sparseTensorType && e3.hasOwnProperty("sparseTensorType") && (n2.sparseTensorType = c.onnx.TypeProto.SparseTensor.toObject(e3.sparseTensorType, t3), t3.oneofs && (n2.value = "sparseTensorType")), null != e3.optionalType && e3.hasOwnProperty("optionalType") && (n2.optionalType = c.onnx.TypeProto.Optional.toObject(e3.optionalType, t3), t3.oneofs && (n2.value = "optionalType")), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TypeProto";
          }, e2.Tensor = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = 0, e3.prototype.shape = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && t3.uint32(8).int32(e4.elemType), null != e4.shape && Object.hasOwnProperty.call(e4, "shape") && c.onnx.TensorShapeProto.encode(e4.shape, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Tensor(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.elemType = e4.int32();
                    break;
                  case 2:
                    r2.shape = c.onnx.TensorShapeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType") && !l.isInteger(e4.elemType))
                return "elemType: integer expected";
              if (null != e4.shape && e4.hasOwnProperty("shape")) {
                var t3 = c.onnx.TensorShapeProto.verify(e4.shape);
                if (t3)
                  return "shape." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Tensor)
                return e4;
              var t3 = new c.onnx.TypeProto.Tensor();
              if (null != e4.elemType && (t3.elemType = 0 | e4.elemType), null != e4.shape) {
                if ("object" != typeof e4.shape)
                  throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                t3.shape = c.onnx.TensorShapeProto.fromObject(e4.shape);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = 0, n2.shape = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = e4.elemType), null != e4.shape && e4.hasOwnProperty("shape") && (n2.shape = c.onnx.TensorShapeProto.toObject(e4.shape, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Tensor";
            }, e3;
          }(), e2.Sequence = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && c.onnx.TypeProto.encode(e4.elemType, t3.uint32(10).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Sequence(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                o2 >>> 3 == 1 ? r2.elemType = c.onnx.TypeProto.decode(e4, e4.uint32()) : e4.skipType(7 & o2);
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType")) {
                var t3 = c.onnx.TypeProto.verify(e4.elemType);
                if (t3)
                  return "elemType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Sequence)
                return e4;
              var t3 = new c.onnx.TypeProto.Sequence();
              if (null != e4.elemType) {
                if ("object" != typeof e4.elemType)
                  throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
                t3.elemType = c.onnx.TypeProto.fromObject(e4.elemType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = c.onnx.TypeProto.toObject(e4.elemType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Sequence";
            }, e3;
          }(), e2.Map = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.keyType = 0, e3.prototype.valueType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.keyType && Object.hasOwnProperty.call(e4, "keyType") && t3.uint32(8).int32(e4.keyType), null != e4.valueType && Object.hasOwnProperty.call(e4, "valueType") && c.onnx.TypeProto.encode(e4.valueType, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Map(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.keyType = e4.int32();
                    break;
                  case 2:
                    r2.valueType = c.onnx.TypeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.keyType && e4.hasOwnProperty("keyType") && !l.isInteger(e4.keyType))
                return "keyType: integer expected";
              if (null != e4.valueType && e4.hasOwnProperty("valueType")) {
                var t3 = c.onnx.TypeProto.verify(e4.valueType);
                if (t3)
                  return "valueType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Map)
                return e4;
              var t3 = new c.onnx.TypeProto.Map();
              if (null != e4.keyType && (t3.keyType = 0 | e4.keyType), null != e4.valueType) {
                if ("object" != typeof e4.valueType)
                  throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
                t3.valueType = c.onnx.TypeProto.fromObject(e4.valueType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.keyType = 0, n2.valueType = null), null != e4.keyType && e4.hasOwnProperty("keyType") && (n2.keyType = e4.keyType), null != e4.valueType && e4.hasOwnProperty("valueType") && (n2.valueType = c.onnx.TypeProto.toObject(e4.valueType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Map";
            }, e3;
          }(), e2.Optional = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && c.onnx.TypeProto.encode(e4.elemType, t3.uint32(10).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Optional(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                o2 >>> 3 == 1 ? r2.elemType = c.onnx.TypeProto.decode(e4, e4.uint32()) : e4.skipType(7 & o2);
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType")) {
                var t3 = c.onnx.TypeProto.verify(e4.elemType);
                if (t3)
                  return "elemType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Optional)
                return e4;
              var t3 = new c.onnx.TypeProto.Optional();
              if (null != e4.elemType) {
                if ("object" != typeof e4.elemType)
                  throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
                t3.elemType = c.onnx.TypeProto.fromObject(e4.elemType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = c.onnx.TypeProto.toObject(e4.elemType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Optional";
            }, e3;
          }(), e2.SparseTensor = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = 0, e3.prototype.shape = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && t3.uint32(8).int32(e4.elemType), null != e4.shape && Object.hasOwnProperty.call(e4, "shape") && c.onnx.TensorShapeProto.encode(e4.shape, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.SparseTensor(); e4.pos < n2; ) {
                var o2 = e4.uint32();
                switch (o2 >>> 3) {
                  case 1:
                    r2.elemType = e4.int32();
                    break;
                  case 2:
                    r2.shape = c.onnx.TensorShapeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & o2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType") && !l.isInteger(e4.elemType))
                return "elemType: integer expected";
              if (null != e4.shape && e4.hasOwnProperty("shape")) {
                var t3 = c.onnx.TensorShapeProto.verify(e4.shape);
                if (t3)
                  return "shape." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.SparseTensor)
                return e4;
              var t3 = new c.onnx.TypeProto.SparseTensor();
              if (null != e4.elemType && (t3.elemType = 0 | e4.elemType), null != e4.shape) {
                if ("object" != typeof e4.shape)
                  throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
                t3.shape = c.onnx.TensorShapeProto.fromObject(e4.shape);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = 0, n2.shape = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = e4.elemType), null != e4.shape && e4.hasOwnProperty("shape") && (n2.shape = c.onnx.TensorShapeProto.toObject(e4.shape, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.SparseTensor";
            }, e3;
          }(), e2;
        }(), i.OperatorSetIdProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.domain = "", e2.prototype.version = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(10).string(e3.domain), null != e3.version && Object.hasOwnProperty.call(e3, "version") && t2.uint32(16).int64(e3.version), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.OperatorSetIdProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.domain = e3.string();
                  break;
                case 2:
                  r2.version = e3.int64();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            return "object" != typeof e3 || null === e3 ? "object expected" : null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain) ? "domain: string expected" : null != e3.version && e3.hasOwnProperty("version") && !(l.isInteger(e3.version) || e3.version && l.isInteger(e3.version.low) && l.isInteger(e3.version.high)) ? "version: integer|Long expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.OperatorSetIdProto)
              return e3;
            var t2 = new c.onnx.OperatorSetIdProto();
            return null != e3.domain && (t2.domain = String(e3.domain)), null != e3.version && (l.Long ? (t2.version = l.Long.fromValue(e3.version)).unsigned = false : "string" == typeof e3.version ? t2.version = parseInt(e3.version, 10) : "number" == typeof e3.version ? t2.version = e3.version : "object" == typeof e3.version && (t2.version = new l.LongBits(e3.version.low >>> 0, e3.version.high >>> 0).toNumber())), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if (t2.defaults)
              if (n2.domain = "", l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.version = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.version = t2.longs === String ? "0" : 0;
            return null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), null != e3.version && e3.hasOwnProperty("version") && ("number" == typeof e3.version ? n2.version = t2.longs === String ? String(e3.version) : e3.version : n2.version = t2.longs === String ? l.Long.prototype.toString.call(e3.version) : t2.longs === Number ? new l.LongBits(e3.version.low >>> 0, e3.version.high >>> 0).toNumber() : e3.version), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.OperatorSetIdProto";
          }, e2;
        }(), i.OperatorStatus = function() {
          var e2 = {}, t2 = Object.create(e2);
          return t2[e2[0] = "EXPERIMENTAL"] = 0, t2[e2[1] = "STABLE"] = 1, t2;
        }(), i.FunctionProto = function() {
          function e2(e3) {
            if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.attribute = l.emptyArray, e2.prototype.attributeProto = l.emptyArray, e2.prototype.node = l.emptyArray, e2.prototype.docString = "", e2.prototype.opsetImport = l.emptyArray, e2.prototype.domain = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.input && e3.input.length)
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.uint32(34).string(e3.input[n2]);
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                t2.uint32(42).string(e3.output[n2]);
            if (null != e3.attribute && e3.attribute.length)
              for (n2 = 0; n2 < e3.attribute.length; ++n2)
                t2.uint32(50).string(e3.attribute[n2]);
            if (null != e3.node && e3.node.length)
              for (n2 = 0; n2 < e3.node.length; ++n2)
                c.onnx.NodeProto.encode(e3.node[n2], t2.uint32(58).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(66).string(e3.docString), null != e3.opsetImport && e3.opsetImport.length)
              for (n2 = 0; n2 < e3.opsetImport.length; ++n2)
                c.onnx.OperatorSetIdProto.encode(e3.opsetImport[n2], t2.uint32(74).fork()).ldelim();
            if (null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(82).string(e3.domain), null != e3.attributeProto && e3.attributeProto.length)
              for (n2 = 0; n2 < e3.attributeProto.length; ++n2)
                c.onnx.AttributeProto.encode(e3.attributeProto[n2], t2.uint32(90).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.FunctionProto(); e3.pos < n2; ) {
              var o2 = e3.uint32();
              switch (o2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 4:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(e3.string());
                  break;
                case 5:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(e3.string());
                  break;
                case 6:
                  r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(e3.string());
                  break;
                case 11:
                  r2.attributeProto && r2.attributeProto.length || (r2.attributeProto = []), r2.attributeProto.push(c.onnx.AttributeProto.decode(e3, e3.uint32()));
                  break;
                case 7:
                  r2.node && r2.node.length || (r2.node = []), r2.node.push(c.onnx.NodeProto.decode(e3, e3.uint32()));
                  break;
                case 8:
                  r2.docString = e3.string();
                  break;
                case 9:
                  r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e3, e3.uint32()));
                  break;
                case 10:
                  r2.domain = e3.string();
                  break;
                default:
                  e3.skipType(7 & o2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (var t2 = 0; t2 < e3.input.length; ++t2)
                if (!l.isString(e3.input[t2]))
                  return "input: string[] expected";
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (!l.isString(e3.output[t2]))
                  return "output: string[] expected";
            }
            if (null != e3.attribute && e3.hasOwnProperty("attribute")) {
              if (!Array.isArray(e3.attribute))
                return "attribute: array expected";
              for (t2 = 0; t2 < e3.attribute.length; ++t2)
                if (!l.isString(e3.attribute[t2]))
                  return "attribute: string[] expected";
            }
            if (null != e3.attributeProto && e3.hasOwnProperty("attributeProto")) {
              if (!Array.isArray(e3.attributeProto))
                return "attributeProto: array expected";
              for (t2 = 0; t2 < e3.attributeProto.length; ++t2)
                if (n2 = c.onnx.AttributeProto.verify(e3.attributeProto[t2]))
                  return "attributeProto." + n2;
            }
            if (null != e3.node && e3.hasOwnProperty("node")) {
              if (!Array.isArray(e3.node))
                return "node: array expected";
              for (t2 = 0; t2 < e3.node.length; ++t2)
                if (n2 = c.onnx.NodeProto.verify(e3.node[t2]))
                  return "node." + n2;
            }
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.opsetImport && e3.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(e3.opsetImport))
                return "opsetImport: array expected";
              for (t2 = 0; t2 < e3.opsetImport.length; ++t2) {
                var n2;
                if (n2 = c.onnx.OperatorSetIdProto.verify(e3.opsetImport[t2]))
                  return "opsetImport." + n2;
              }
            }
            return null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain) ? "domain: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.FunctionProto)
              return e3;
            var t2 = new c.onnx.FunctionProto();
            if (null != e3.name && (t2.name = String(e3.name)), e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.FunctionProto.input: array expected");
              t2.input = [];
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.input[n2] = String(e3.input[n2]);
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.FunctionProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2)
                t2.output[n2] = String(e3.output[n2]);
            }
            if (e3.attribute) {
              if (!Array.isArray(e3.attribute))
                throw TypeError(".onnx.FunctionProto.attribute: array expected");
              for (t2.attribute = [], n2 = 0; n2 < e3.attribute.length; ++n2)
                t2.attribute[n2] = String(e3.attribute[n2]);
            }
            if (e3.attributeProto) {
              if (!Array.isArray(e3.attributeProto))
                throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
              for (t2.attributeProto = [], n2 = 0; n2 < e3.attributeProto.length; ++n2) {
                if ("object" != typeof e3.attributeProto[n2])
                  throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
                t2.attributeProto[n2] = c.onnx.AttributeProto.fromObject(e3.attributeProto[n2]);
              }
            }
            if (e3.node) {
              if (!Array.isArray(e3.node))
                throw TypeError(".onnx.FunctionProto.node: array expected");
              for (t2.node = [], n2 = 0; n2 < e3.node.length; ++n2) {
                if ("object" != typeof e3.node[n2])
                  throw TypeError(".onnx.FunctionProto.node: object expected");
                t2.node[n2] = c.onnx.NodeProto.fromObject(e3.node[n2]);
              }
            }
            if (null != e3.docString && (t2.docString = String(e3.docString)), e3.opsetImport) {
              if (!Array.isArray(e3.opsetImport))
                throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
              for (t2.opsetImport = [], n2 = 0; n2 < e3.opsetImport.length; ++n2) {
                if ("object" != typeof e3.opsetImport[n2])
                  throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
                t2.opsetImport[n2] = c.onnx.OperatorSetIdProto.fromObject(e3.opsetImport[n2]);
              }
            }
            return null != e3.domain && (t2.domain = String(e3.domain)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.input = [], n2.output = [], n2.attribute = [], n2.node = [], n2.opsetImport = [], n2.attributeProto = []), t2.defaults && (n2.name = "", n2.docString = "", n2.domain = ""), null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), e3.input && e3.input.length) {
              n2.input = [];
              for (var r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = e3.input[r2];
            }
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = e3.output[r2];
            if (e3.attribute && e3.attribute.length)
              for (n2.attribute = [], r2 = 0; r2 < e3.attribute.length; ++r2)
                n2.attribute[r2] = e3.attribute[r2];
            if (e3.node && e3.node.length)
              for (n2.node = [], r2 = 0; r2 < e3.node.length; ++r2)
                n2.node[r2] = c.onnx.NodeProto.toObject(e3.node[r2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.opsetImport && e3.opsetImport.length)
              for (n2.opsetImport = [], r2 = 0; r2 < e3.opsetImport.length; ++r2)
                n2.opsetImport[r2] = c.onnx.OperatorSetIdProto.toObject(e3.opsetImport[r2], t2);
            if (null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), e3.attributeProto && e3.attributeProto.length)
              for (n2.attributeProto = [], r2 = 0; r2 < e3.attributeProto.length; ++r2)
                n2.attributeProto[r2] = c.onnx.AttributeProto.toObject(e3.attributeProto[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.FunctionProto";
          }, e2;
        }(), i), e.exports = c;
      }, 3474: (e, t, n) => {
        var _scriptDir, r = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (_scriptDir = _scriptDir || __filename), function(e2 = {}) {
          function t2() {
            return D.buffer != N3.buffer && U(), N3;
          }
          function r2() {
            return D.buffer != N3.buffer && U(), R;
          }
          function o() {
            return D.buffer != N3.buffer && U(), L3;
          }
          function i() {
            return D.buffer != N3.buffer && U(), C2;
          }
          function a() {
            return D.buffer != N3.buffer && U(), j;
          }
          var s, u, l = e2;
          l.ready = new Promise((e3, t3) => {
            s = e3, u = t3;
          });
          var c, p, d, f = Object.assign({}, l), h = "./this.program", g = (e3, t3) => {
            throw t3;
          }, b = "object" == typeof window, m = "function" == typeof importScripts, y = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, v = l.ENVIRONMENT_IS_PTHREAD || false, _ = "";
          function w(e3) {
            return l.locateFile ? l.locateFile(e3, _) : _ + e3;
          }
          if (y) {
            var T = n(1384), x = n(908);
            let t3;
            _ = m ? x.dirname(_) + "/" : __dirname + "/", c = (e3, t4) => (e3 = e3.startsWith("file://") ? new URL(e3) : x.normalize(e3), T.readFileSync(e3, t4 ? void 0 : "utf8")), d = (e3) => ((e3 = c(e3, true)).buffer || (e3 = new Uint8Array(e3)), e3), p = (e3, t4, n2, r3 = true) => {
              e3 = e3.startsWith("file://") ? new URL(e3) : x.normalize(e3), T.readFile(e3, r3 ? void 0 : "utf8", (e4, o2) => {
                e4 ? n2(e4) : t4(r3 ? o2.buffer : o2);
              });
            }, !l.thisProgram && 1 < process.argv.length && (h = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), g = (e3, t4) => {
              throw process.exitCode = e3, t4;
            }, l.inspect = () => "[Emscripten Module object]";
            try {
              t3 = n(9925);
            } catch (e3) {
              throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), e3;
            }
            global.Worker = t3.Worker;
          } else
            (b || m) && (m ? _ = self.location.href : "undefined" != typeof document && document.currentScript && (_ = document.currentScript.src), _scriptDir && (_ = _scriptDir), _ = 0 !== _.indexOf("blob:") ? _.substr(0, _.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", y || (c = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.send(null), t3.responseText;
            }, m && (d = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), p = (e3, t3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", e3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? t3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            }));
          y && "undefined" == typeof performance && (global.performance = n(6953).performance);
          var O = console.log.bind(console), S = console.error.bind(console);
          y && (O = (...e3) => T.writeSync(1, e3.join(" ") + "\n"), S = (...e3) => T.writeSync(2, e3.join(" ") + "\n"));
          var A, P = l.print || O, I = l.printErr || S;
          Object.assign(l, f), f = null, l.thisProgram && (h = l.thisProgram), l.quit && (g = l.quit), l.wasmBinary && (A = l.wasmBinary);
          var E = l.noExitRuntime || true;
          "object" != typeof WebAssembly && te("no native wasm support detected");
          var D, $, k, F, N3, R, L3, C2, j, M = false;
          function U() {
            var e3 = D.buffer;
            l.HEAP8 = N3 = new Int8Array(e3), l.HEAP16 = new Int16Array(e3), l.HEAP32 = L3 = new Int32Array(e3), l.HEAPU8 = R = new Uint8Array(e3), l.HEAPU16 = new Uint16Array(e3), l.HEAPU32 = C2 = new Uint32Array(e3), l.HEAPF32 = new Float32Array(e3), l.HEAPF64 = j = new Float64Array(e3);
          }
          var B = l.INITIAL_MEMORY || 16777216;
          if (5242880 <= B || te("INITIAL_MEMORY should be larger than STACK_SIZE, was " + B + "! (STACK_SIZE=5242880)"), v)
            D = l.wasmMemory;
          else if (l.wasmMemory)
            D = l.wasmMemory;
          else if (!((D = new WebAssembly.Memory({ initial: B / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer))
            throw I("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), y && I("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
          U(), B = D.buffer.byteLength;
          var V, z = [], G = [], H = [], W = 0;
          function q() {
            return E || 0 < W;
          }
          var X, Y, K = 0, J = null, Z = null;
          function Q() {
            K++, l.monitorRunDependencies && l.monitorRunDependencies(K);
          }
          function ee() {
            if (K--, l.monitorRunDependencies && l.monitorRunDependencies(K), 0 == K && (null !== J && (clearInterval(J), J = null), Z)) {
              var e3 = Z;
              Z = null, e3();
            }
          }
          function te(e3) {
            throw l.onAbort && l.onAbort(e3), I(e3 = "Aborted(" + e3 + ")"), M = true, F = 1, e3 = new WebAssembly.RuntimeError(e3 + ". Build with -sASSERTIONS for more info."), u(e3), e3;
          }
          function ne(e3) {
            return e3.startsWith("data:application/octet-stream;base64,");
          }
          function re(e3) {
            if (e3 == X && A)
              return new Uint8Array(A);
            if (d)
              return d(e3);
            throw "both async and sync fetching of the wasm failed";
          }
          function oe(e3, t3, n2) {
            return function(e4) {
              if (!A && (b || m)) {
                if ("function" == typeof fetch && !e4.startsWith("file://"))
                  return fetch(e4, { credentials: "same-origin" }).then((t4) => {
                    if (!t4.ok)
                      throw "failed to load wasm binary file at '" + e4 + "'";
                    return t4.arrayBuffer();
                  }).catch(() => re(e4));
                if (p)
                  return new Promise((t4, n3) => {
                    p(e4, (e5) => t4(new Uint8Array(e5)), n3);
                  });
              }
              return Promise.resolve().then(() => re(e4));
            }(e3).then((e4) => WebAssembly.instantiate(e4, t3)).then((e4) => e4).then(n2, (e4) => {
              I("failed to asynchronously prepare wasm: " + e4), te(e4);
            });
          }
          function ie(e3) {
            this.name = "ExitStatus", this.message = `Program terminated with exit(${e3})`, this.status = e3;
          }
          function ae(e3) {
            e3.terminate(), e3.onmessage = () => {
            };
          }
          function se(e3) {
            (e3 = he.Fa[e3]) || te(), he.fb(e3);
          }
          function ue(e3) {
            var t3 = he.Za();
            if (!t3)
              return 6;
            he.Ia.push(t3), he.Fa[e3.Ha] = t3, t3.Ha = e3.Ha;
            var n2 = { cmd: "run", start_routine: e3.gb, arg: e3.Ya, pthread_ptr: e3.Ha };
            return y && t3.unref(), t3.postMessage(n2, e3.mb), 0;
          }
          ne(X = "ort-wasm-threaded.wasm") || (X = w(X));
          var le = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, ce = (e3, t3, n2) => {
            var r3 = (t3 >>>= 0) + n2;
            for (n2 = t3; e3[n2] && !(n2 >= r3); )
              ++n2;
            if (16 < n2 - t3 && e3.buffer && le)
              return le.decode(e3.buffer instanceof SharedArrayBuffer ? e3.slice(t3, n2) : e3.subarray(t3, n2));
            for (r3 = ""; t3 < n2; ) {
              var o2 = e3[t3++];
              if (128 & o2) {
                var i2 = 63 & e3[t3++];
                if (192 == (224 & o2))
                  r3 += String.fromCharCode((31 & o2) << 6 | i2);
                else {
                  var a2 = 63 & e3[t3++];
                  65536 > (o2 = 224 == (240 & o2) ? (15 & o2) << 12 | i2 << 6 | a2 : (7 & o2) << 18 | i2 << 12 | a2 << 6 | 63 & e3[t3++]) ? r3 += String.fromCharCode(o2) : (o2 -= 65536, r3 += String.fromCharCode(55296 | o2 >> 10, 56320 | 1023 & o2));
                }
              } else
                r3 += String.fromCharCode(o2);
            }
            return r3;
          }, pe = (e3, t3) => (e3 >>>= 0) ? ce(r2(), e3, t3) : "";
          function de(e3) {
            if (v)
              return qe(1, 1, e3);
            F = e3, q() || (he.hb(), l.onExit && l.onExit(e3), M = true), g(e3, new ie(e3));
          }
          var fe = (e3) => {
            if (F = e3, v)
              throw be(e3), "unwind";
            de(e3);
          }, he = { La: [], Ia: [], Ta: [], Fa: {}, Pa: function() {
            v ? he.ab() : he.$a();
          }, $a: function() {
            z.unshift(() => {
              Q(), he.bb(() => ee());
            });
          }, ab: function() {
            he.receiveObjectTransfer = he.eb, he.threadInitTLS = he.Sa, he.setExitStatus = he.Ra, E = false;
          }, Ra: function(e3) {
            F = e3;
          }, rb: ["$terminateWorker"], hb: function() {
            for (var e3 of he.Ia)
              ae(e3);
            for (e3 of he.La)
              ae(e3);
            he.La = [], he.Ia = [], he.Fa = [];
          }, fb: function(e3) {
            var t3 = e3.Ha;
            delete he.Fa[t3], he.La.push(e3), he.Ia.splice(he.Ia.indexOf(e3), 1), e3.Ha = 0, mt(t3);
          }, eb: function() {
          }, Sa: function() {
            he.Ta.forEach((e3) => e3());
          }, cb: (e3) => new Promise((t3) => {
            e3.onmessage = (n3) => {
              var r4 = (n3 = n3.data).cmd;
              if (n3.targetThread && n3.targetThread != dt()) {
                var o2 = he.Fa[n3.qb];
                o2 ? o2.postMessage(n3, n3.transferList) : I('Internal error! Worker sent a message "' + r4 + '" to target pthread ' + n3.targetThread + ", but that thread no longer exists!");
              } else
                "checkMailbox" === r4 ? Me() : "spawnThread" === r4 ? ue(n3) : "cleanupThread" === r4 ? se(n3.thread) : "killThread" === r4 ? (n3 = n3.thread, r4 = he.Fa[n3], delete he.Fa[n3], ae(r4), mt(n3), he.Ia.splice(he.Ia.indexOf(r4), 1), r4.Ha = 0) : "cancelThread" === r4 ? he.Fa[n3.thread].postMessage({ cmd: "cancel" }) : "loaded" === r4 ? (e3.loaded = true, t3(e3)) : "alert" === r4 ? alert("Thread " + n3.threadId + ": " + n3.text) : "setimmediate" === n3.target ? e3.postMessage(n3) : "callHandler" === r4 ? l[n3.handler](...n3.args) : r4 && I("worker sent an unknown command " + r4);
            }, e3.onerror = (e4) => {
              throw I("worker sent an error! " + e4.filename + ":" + e4.lineno + ": " + e4.message), e4;
            }, y && (e3.on("message", function(t4) {
              e3.onmessage({ data: t4 });
            }), e3.on("error", function(t4) {
              e3.onerror(t4);
            }));
            var n2, r3 = [];
            for (n2 of ["onExit", "onAbort", "print", "printErr"])
              l.hasOwnProperty(n2) && r3.push(n2);
            e3.postMessage({ cmd: "load", handlers: r3, urlOrBlob: l.mainScriptUrlOrBlob || _scriptDir, wasmMemory: D, wasmModule: k });
          }), bb: function(e3) {
            e3();
          }, Xa: function() {
            var e3 = w("ort-wasm-threaded.worker.js");
            e3 = new Worker(e3), he.La.push(e3);
          }, Za: function() {
            return 0 == he.La.length && (he.Xa(), he.cb(he.La[0])), he.La.pop();
          } };
          l.PThread = he;
          var ge = (e3) => {
            for (; 0 < e3.length; )
              e3.shift()(l);
          };
          function be(e3) {
            if (v)
              return qe(2, 0, e3);
            fe(e3);
          }
          l.establishStackSpace = function() {
            var e3 = dt(), t3 = o()[e3 + 52 >> 2 >>> 0];
            e3 = o()[e3 + 56 >> 2 >>> 0], wt(t3, t3 - e3), xt(t3);
          };
          var me = [];
          function ye(e3) {
            this.Oa = e3 - 24, this.Wa = function(e4) {
              i()[this.Oa + 4 >> 2 >>> 0] = e4;
            }, this.Va = function(e4) {
              i()[this.Oa + 8 >> 2 >>> 0] = e4;
            }, this.Pa = function(e4, t3) {
              this.Ua(), this.Wa(e4), this.Va(t3);
            }, this.Ua = function() {
              i()[this.Oa + 16 >> 2 >>> 0] = 0;
            };
          }
          function ve(e3, t3, n2, r3) {
            return v ? qe(3, 1, e3, t3, n2, r3) : _e(e3, t3, n2, r3);
          }
          function _e(e3, t3, n2, r3) {
            if (e3 >>>= 0, t3 >>>= 0, n2 >>>= 0, r3 >>>= 0, "undefined" == typeof SharedArrayBuffer)
              return I("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
            var o2 = [];
            return v && 0 === o2.length ? ve(e3, t3, n2, r3) : (e3 = { gb: n2, Ha: e3, Ya: r3, mb: o2 }, v ? (e3.ob = "spawnThread", postMessage(e3, o2), 0) : ue(e3));
          }
          function we(e3, t3, n2) {
            return v ? qe(4, 1, e3, t3, n2) : 0;
          }
          function Te(e3, t3) {
            if (v)
              return qe(5, 1, e3, t3);
          }
          l.invokeEntryPoint = function(e3, t3) {
            var n2 = me[e3];
            n2 || (e3 >= me.length && (me.length = e3 + 1), me[e3] = n2 = V.get(e3)), e3 = n2(t3), q() ? he.Ra(e3) : yt(e3);
          };
          var xe = (e3) => {
            for (var t3 = 0, n2 = 0; n2 < e3.length; ++n2) {
              var r3 = e3.charCodeAt(n2);
              127 >= r3 ? t3++ : 2047 >= r3 ? t3 += 2 : 55296 <= r3 && 57343 >= r3 ? (t3 += 4, ++n2) : t3 += 3;
            }
            return t3;
          }, Oe = (e3, t3, n2, r3) => {
            if (!(0 < r3))
              return 0;
            var o2 = n2 >>>= 0;
            r3 = n2 + r3 - 1;
            for (var i2 = 0; i2 < e3.length; ++i2) {
              var a2 = e3.charCodeAt(i2);
              if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++i2)), 127 >= a2) {
                if (n2 >= r3)
                  break;
                t3[n2++ >>> 0] = a2;
              } else {
                if (2047 >= a2) {
                  if (n2 + 1 >= r3)
                    break;
                  t3[n2++ >>> 0] = 192 | a2 >> 6;
                } else {
                  if (65535 >= a2) {
                    if (n2 + 2 >= r3)
                      break;
                    t3[n2++ >>> 0] = 224 | a2 >> 12;
                  } else {
                    if (n2 + 3 >= r3)
                      break;
                    t3[n2++ >>> 0] = 240 | a2 >> 18, t3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                }
                t3[n2++ >>> 0] = 128 | 63 & a2;
              }
            }
            return t3[n2 >>> 0] = 0, n2 - o2;
          }, Se = (e3, t3, n2) => Oe(e3, r2(), t3, n2);
          function Ae(e3, t3) {
            if (v)
              return qe(6, 1, e3, t3);
          }
          function Pe(e3, t3, n2) {
            if (v)
              return qe(7, 1, e3, t3, n2);
          }
          function Ie(e3, t3, n2) {
            return v ? qe(8, 1, e3, t3, n2) : 0;
          }
          function Ee(e3, t3) {
            if (v)
              return qe(9, 1, e3, t3);
          }
          function De(e3, t3, n2) {
            if (v)
              return qe(10, 1, e3, t3, n2);
          }
          function $e(e3, t3, n2, r3) {
            if (v)
              return qe(11, 1, e3, t3, n2, r3);
          }
          function ke(e3, t3, n2, r3) {
            if (v)
              return qe(12, 1, e3, t3, n2, r3);
          }
          function Fe(e3, t3, n2, r3) {
            if (v)
              return qe(13, 1, e3, t3, n2, r3);
          }
          function Ne(e3) {
            if (v)
              return qe(14, 1, e3);
          }
          function Re(e3, t3) {
            if (v)
              return qe(15, 1, e3, t3);
          }
          function Le(e3, t3, n2) {
            if (v)
              return qe(16, 1, e3, t3, n2);
          }
          var Ce = (e3) => {
            if (!M)
              try {
                if (e3(), !q())
                  try {
                    v ? yt(F) : fe(F);
                  } catch (e4) {
                    e4 instanceof ie || "unwind" == e4 || g(1, e4);
                  }
              } catch (e4) {
                e4 instanceof ie || "unwind" == e4 || g(1, e4);
              }
          };
          function je(e3) {
            e3 >>>= 0, "function" == typeof Atomics.nb && (Atomics.nb(o(), e3 >> 2, e3).value.then(Me), e3 += 128, Atomics.store(o(), e3 >> 2, 1));
          }
          function Me() {
            var e3 = dt();
            e3 && (je(e3), Ce(() => vt()));
          }
          l.__emscripten_thread_mailbox_await = je, l.checkMailbox = Me;
          var Ue = (e3) => 0 == e3 % 4 && (0 != e3 % 100 || 0 == e3 % 400), Be = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Ve = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
          function ze(e3, t3, n2, r3, o2, i2, a2, s2) {
            return v ? qe(17, 1, e3, t3, n2, r3, o2, i2, a2, s2) : -52;
          }
          function Ge(e3, t3, n2, r3, o2, i2, a2) {
            if (v)
              return qe(18, 1, e3, t3, n2, r3, o2, i2, a2);
          }
          var He = (e3) => {
            var t3 = xe(e3) + 1, n2 = ft(t3);
            return n2 && Se(e3, n2, t3), n2;
          }, We = (e3) => {
            var t3 = Tt();
            return e3 = e3(), xt(t3), e3;
          };
          function qe(e3, t3) {
            var n2 = arguments.length - 2, r3 = arguments;
            return We(() => {
              for (var o2 = Ot(8 * n2), i2 = o2 >> 3, s2 = 0; s2 < n2; s2++) {
                var u2 = r3[2 + s2];
                a()[i2 + s2 >>> 0] = u2;
              }
              return bt(e3, n2, o2, t3);
            });
          }
          var Xe, Ye = [], Ke = {}, Je = () => {
            if (!Xe) {
              var e3, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: h || "./this.program" };
              for (e3 in Ke)
                void 0 === Ke[e3] ? delete t3[e3] : t3[e3] = Ke[e3];
              var n2 = [];
              for (e3 in t3)
                n2.push(`${e3}=${t3[e3]}`);
              Xe = n2;
            }
            return Xe;
          };
          function Ze(e3, n2) {
            if (v)
              return qe(19, 1, e3, n2);
            e3 >>>= 0, n2 >>>= 0;
            var r3 = 0;
            return Je().forEach(function(o2, a2) {
              var s2 = n2 + r3;
              for (a2 = i()[e3 + 4 * a2 >> 2 >>> 0] = s2, s2 = 0; s2 < o2.length; ++s2)
                t2()[a2++ >> 0 >>> 0] = o2.charCodeAt(s2);
              t2()[a2 >> 0 >>> 0] = 0, r3 += o2.length + 1;
            }), 0;
          }
          function Qe(e3, t3) {
            if (v)
              return qe(20, 1, e3, t3);
            e3 >>>= 0, t3 >>>= 0;
            var n2 = Je();
            i()[e3 >> 2 >>> 0] = n2.length;
            var r3 = 0;
            return n2.forEach(function(e4) {
              r3 += e4.length + 1;
            }), i()[t3 >> 2 >>> 0] = r3, 0;
          }
          function et(e3) {
            return v ? qe(21, 1, e3) : 52;
          }
          function tt(e3, t3, n2, r3) {
            return v ? qe(22, 1, e3, t3, n2, r3) : 52;
          }
          function nt(e3, t3, n2, r3, o2) {
            return v ? qe(23, 1, e3, t3, n2, r3, o2) : 70;
          }
          var rt = [null, [], []];
          function ot(e3, t3, n2, o2) {
            if (v)
              return qe(24, 1, e3, t3, n2, o2);
            t3 >>>= 0, n2 >>>= 0, o2 >>>= 0;
            for (var a2 = 0, s2 = 0; s2 < n2; s2++) {
              var u2 = i()[t3 >> 2 >>> 0], l2 = i()[t3 + 4 >> 2 >>> 0];
              t3 += 8;
              for (var c2 = 0; c2 < l2; c2++) {
                var p2 = r2()[u2 + c2 >>> 0], d2 = rt[e3];
                0 === p2 || 10 === p2 ? ((1 === e3 ? P : I)(ce(d2, 0)), d2.length = 0) : d2.push(p2);
              }
              a2 += l2;
            }
            return i()[o2 >> 2 >>> 0] = a2, 0;
          }
          var it = (e3) => (it = (() => {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
              return (e5) => (e5.set(crypto.getRandomValues(new Uint8Array(e5.byteLength))), e5);
            if (y)
              try {
                var e4 = n(760);
                if (e4.randomFillSync)
                  return (t4) => e4.randomFillSync(t4);
                var t3 = e4.randomBytes;
                return (e5) => (e5.set(t3(e5.byteLength)), e5);
              } catch (e5) {
              }
            te("initRandomDevice");
          })())(e3), at = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], st = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ut = (e3, n2) => {
            t2().set(e3, n2 >>> 0);
          };
          function lt(e3, t3, n2, r3) {
            function i2(e4, t4, n3) {
              for (e4 = "number" == typeof e4 ? e4.toString() : e4 || ""; e4.length < t4; )
                e4 = n3[0] + e4;
              return e4;
            }
            function a2(e4, t4) {
              return i2(e4, t4, "0");
            }
            function s2(e4, t4) {
              function n3(e5) {
                return 0 > e5 ? -1 : 0 < e5 ? 1 : 0;
              }
              var r4;
              return 0 === (r4 = n3(e4.getFullYear() - t4.getFullYear())) && 0 === (r4 = n3(e4.getMonth() - t4.getMonth())) && (r4 = n3(e4.getDate() - t4.getDate())), r4;
            }
            function u2(e4) {
              switch (e4.getDay()) {
                case 0:
                  return new Date(e4.getFullYear() - 1, 11, 29);
                case 1:
                  return e4;
                case 2:
                  return new Date(e4.getFullYear(), 0, 3);
                case 3:
                  return new Date(e4.getFullYear(), 0, 2);
                case 4:
                  return new Date(e4.getFullYear(), 0, 1);
                case 5:
                  return new Date(e4.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(e4.getFullYear() - 1, 11, 30);
              }
            }
            function l2(e4) {
              var t4 = e4.Ja;
              for (e4 = new Date(new Date(e4.Ka + 1900, 0, 1).getTime()); 0 < t4; ) {
                var n3 = e4.getMonth(), r4 = (Ue(e4.getFullYear()) ? at : st)[n3];
                if (!(t4 > r4 - e4.getDate())) {
                  e4.setDate(e4.getDate() + t4);
                  break;
                }
                t4 -= r4 - e4.getDate() + 1, e4.setDate(1), 11 > n3 ? e4.setMonth(n3 + 1) : (e4.setMonth(0), e4.setFullYear(e4.getFullYear() + 1));
              }
              return n3 = new Date(e4.getFullYear() + 1, 0, 4), t4 = u2(new Date(e4.getFullYear(), 0, 4)), n3 = u2(n3), 0 >= s2(t4, e4) ? 0 >= s2(n3, e4) ? e4.getFullYear() + 1 : e4.getFullYear() : e4.getFullYear() - 1;
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0, r3 >>>= 0;
            var c2 = o()[r3 + 40 >> 2 >>> 0];
            for (var p2 in r3 = { kb: o()[r3 >> 2 >>> 0], jb: o()[r3 + 4 >> 2 >>> 0], Ma: o()[r3 + 8 >> 2 >>> 0], Qa: o()[r3 + 12 >> 2 >>> 0], Na: o()[r3 + 16 >> 2 >>> 0], Ka: o()[r3 + 20 >> 2 >>> 0], Ga: o()[r3 + 24 >> 2 >>> 0], Ja: o()[r3 + 28 >> 2 >>> 0], sb: o()[r3 + 32 >> 2 >>> 0], ib: o()[r3 + 36 >> 2 >>> 0], lb: c2 ? pe(c2) : "" }, n2 = pe(n2), c2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
              n2 = n2.replace(new RegExp(p2, "g"), c2[p2]);
            var d2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f2 = "January February March April May June July August September October November December".split(" ");
            for (p2 in c2 = { "%a": (e4) => d2[e4.Ga].substring(0, 3), "%A": (e4) => d2[e4.Ga], "%b": (e4) => f2[e4.Na].substring(0, 3), "%B": (e4) => f2[e4.Na], "%C": (e4) => a2((e4.Ka + 1900) / 100 | 0, 2), "%d": (e4) => a2(e4.Qa, 2), "%e": (e4) => i2(e4.Qa, 2, " "), "%g": (e4) => l2(e4).toString().substring(2), "%G": (e4) => l2(e4), "%H": (e4) => a2(e4.Ma, 2), "%I": (e4) => (0 == (e4 = e4.Ma) ? e4 = 12 : 12 < e4 && (e4 -= 12), a2(e4, 2)), "%j": (e4) => {
              for (var t4 = 0, n3 = 0; n3 <= e4.Na - 1; t4 += (Ue(e4.Ka + 1900) ? at : st)[n3++])
                ;
              return a2(e4.Qa + t4, 3);
            }, "%m": (e4) => a2(e4.Na + 1, 2), "%M": (e4) => a2(e4.jb, 2), "%n": () => "\n", "%p": (e4) => 0 <= e4.Ma && 12 > e4.Ma ? "AM" : "PM", "%S": (e4) => a2(e4.kb, 2), "%t": () => "	", "%u": (e4) => e4.Ga || 7, "%U": (e4) => a2(Math.floor((e4.Ja + 7 - e4.Ga) / 7), 2), "%V": (e4) => {
              var t4 = Math.floor((e4.Ja + 7 - (e4.Ga + 6) % 7) / 7);
              if (2 >= (e4.Ga + 371 - e4.Ja - 2) % 7 && t4++, t4)
                53 == t4 && (4 == (n3 = (e4.Ga + 371 - e4.Ja) % 7) || 3 == n3 && Ue(e4.Ka) || (t4 = 1));
              else {
                t4 = 52;
                var n3 = (e4.Ga + 7 - e4.Ja - 1) % 7;
                (4 == n3 || 5 == n3 && Ue(e4.Ka % 400 - 1)) && t4++;
              }
              return a2(t4, 2);
            }, "%w": (e4) => e4.Ga, "%W": (e4) => a2(Math.floor((e4.Ja + 7 - (e4.Ga + 6) % 7) / 7), 2), "%y": (e4) => (e4.Ka + 1900).toString().substring(2), "%Y": (e4) => e4.Ka + 1900, "%z": (e4) => {
              var t4 = 0 <= (e4 = e4.ib);
              return e4 = Math.abs(e4) / 60, (t4 ? "+" : "-") + String("0000" + (e4 / 60 * 100 + e4 % 60)).slice(-4);
            }, "%Z": (e4) => e4.lb, "%%": () => "%" }, n2 = n2.replace(/%%/g, "\0\0"), c2)
              n2.includes(p2) && (n2 = n2.replace(new RegExp(p2, "g"), c2[p2](r3)));
            return p2 = function(e4) {
              var t4 = Array(xe(e4) + 1);
              return Oe(e4, t4, 0, t4.length), t4;
            }(n2 = n2.replace(/\0\0/g, "%")), p2.length > t3 ? 0 : (ut(p2, e3), p2.length - 1);
          }
          he.Pa();
          var ct = [null, de, be, ve, we, Te, Ae, Pe, Ie, Ee, De, $e, ke, Fe, Ne, Re, Le, ze, Ge, Ze, Qe, et, tt, nt, ot], pt = { b: function(e3, t3, n2) {
            throw new ye(e3 >>>= 0).Pa(t3 >>> 0, n2 >>> 0), e3;
          }, N: function(e3) {
            ht(e3 >>> 0, !m, 1, !b, 131072, false), he.Sa();
          }, k: function(e3) {
            e3 >>>= 0, v ? postMessage({ cmd: "cleanupThread", thread: e3 }) : se(e3);
          }, I: _e, h: we, T: Te, E: Ae, G: Pe, U: Ie, R: Ee, J: De, Q: $e, o: ke, F: Fe, C: Ne, S: Re, D: Le, q: () => true, A: function(e3, t3) {
            (e3 >>>= 0) == t3 >>> 0 ? setTimeout(() => Me()) : v ? postMessage({ targetThread: e3, cmd: "checkMailbox" }) : (e3 = he.Fa[e3]) && e3.postMessage({ cmd: "checkMailbox" });
          }, L: function() {
            return -1;
          }, M: je, p: function(e3) {
            y && he.Fa[e3 >>> 0].ref();
          }, t: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), o()[n2 >> 2 >>> 0] = e3.getUTCSeconds(), o()[n2 + 4 >> 2 >>> 0] = e3.getUTCMinutes(), o()[n2 + 8 >> 2 >>> 0] = e3.getUTCHours(), o()[n2 + 12 >> 2 >>> 0] = e3.getUTCDate(), o()[n2 + 16 >> 2 >>> 0] = e3.getUTCMonth(), o()[n2 + 20 >> 2 >>> 0] = e3.getUTCFullYear() - 1900, o()[n2 + 24 >> 2 >>> 0] = e3.getUTCDay(), e3 = (e3.getTime() - Date.UTC(e3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, o()[n2 + 28 >> 2 >>> 0] = e3;
          }, u: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), o()[n2 >> 2 >>> 0] = e3.getSeconds(), o()[n2 + 4 >> 2 >>> 0] = e3.getMinutes(), o()[n2 + 8 >> 2 >>> 0] = e3.getHours(), o()[n2 + 12 >> 2 >>> 0] = e3.getDate(), o()[n2 + 16 >> 2 >>> 0] = e3.getMonth(), o()[n2 + 20 >> 2 >>> 0] = e3.getFullYear() - 1900, o()[n2 + 24 >> 2 >>> 0] = e3.getDay(), t3 = (Ue(e3.getFullYear()) ? Be : Ve)[e3.getMonth()] + e3.getDate() - 1 | 0, o()[n2 + 28 >> 2 >>> 0] = t3, o()[n2 + 36 >> 2 >>> 0] = -60 * e3.getTimezoneOffset(), t3 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset();
            var r3 = new Date(e3.getFullYear(), 0, 1).getTimezoneOffset();
            e3 = 0 | (t3 != r3 && e3.getTimezoneOffset() == Math.min(r3, t3)), o()[n2 + 32 >> 2 >>> 0] = e3;
          }, v: function(e3) {
            e3 >>>= 0;
            var t3 = new Date(o()[e3 + 20 >> 2 >>> 0] + 1900, o()[e3 + 16 >> 2 >>> 0], o()[e3 + 12 >> 2 >>> 0], o()[e3 + 8 >> 2 >>> 0], o()[e3 + 4 >> 2 >>> 0], o()[e3 >> 2 >>> 0], 0), n2 = o()[e3 + 32 >> 2 >>> 0], r3 = t3.getTimezoneOffset(), i2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), a2 = new Date(t3.getFullYear(), 0, 1).getTimezoneOffset(), s2 = Math.min(a2, i2);
            return 0 > n2 ? o()[e3 + 32 >> 2 >>> 0] = Number(i2 != a2 && s2 == r3) : 0 < n2 != (s2 == r3) && (i2 = Math.max(a2, i2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? s2 : i2) - r3))), o()[e3 + 24 >> 2 >>> 0] = t3.getDay(), n2 = (Ue(t3.getFullYear()) ? Be : Ve)[t3.getMonth()] + t3.getDate() - 1 | 0, o()[e3 + 28 >> 2 >>> 0] = n2, o()[e3 >> 2 >>> 0] = t3.getSeconds(), o()[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), o()[e3 + 8 >> 2 >>> 0] = t3.getHours(), o()[e3 + 12 >> 2 >>> 0] = t3.getDate(), o()[e3 + 16 >> 2 >>> 0] = t3.getMonth(), o()[e3 + 20 >> 2 >>> 0] = t3.getYear(), e3 = t3.getTime() / 1e3, _t((Y = e3, 1 <= +Math.abs(Y) ? 0 < Y ? +Math.floor(Y / 4294967296) >>> 0 : ~~+Math.ceil((Y - +(~~Y >>> 0)) / 4294967296) >>> 0 : 0)), e3 >>> 0;
          }, r: ze, s: Ge, z: function(e3, t3, n2) {
            function r3(e4) {
              return (e4 = e4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e4[1] : "GMT";
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0;
            var a2 = (/* @__PURE__ */ new Date()).getFullYear(), s2 = new Date(a2, 0, 1), u2 = new Date(a2, 6, 1);
            a2 = s2.getTimezoneOffset();
            var l2 = u2.getTimezoneOffset(), c2 = Math.max(a2, l2);
            i()[e3 >> 2 >>> 0] = 60 * c2, o()[t3 >> 2 >>> 0] = Number(a2 != l2), e3 = r3(s2), t3 = r3(u2), e3 = He(e3), t3 = He(t3), l2 < a2 ? (i()[n2 >> 2 >>> 0] = e3, i()[n2 + 4 >> 2 >>> 0] = t3) : (i()[n2 >> 2 >>> 0] = t3, i()[n2 + 4 >> 2 >>> 0] = e3);
          }, c: () => {
            te("");
          }, l: function() {
          }, i: function() {
            return Date.now();
          }, V: () => {
            throw W += 1, "unwind";
          }, B: function() {
            return 4294901760;
          }, e: () => performance.timeOrigin + performance.now(), f: function() {
            return y ? n(3993).cpus().length : navigator.hardwareConcurrency;
          }, K: function(e3, t3, n2, r3) {
            for (he.pb = t3 >>> 0, Ye.length = n2, t3 = r3 >>> 0 >> 3, r3 = 0; r3 < n2; r3++)
              Ye[r3] = a()[t3 + r3 >>> 0];
            return ct[e3].apply(null, Ye);
          }, y: function(e3) {
            e3 >>>= 0;
            var t3 = r2().length;
            if (e3 <= t3 || 4294901760 < e3)
              return false;
            for (var n2 = 1; 4 >= n2; n2 *= 2) {
              var o2 = t3 * (1 + 0.2 / n2);
              o2 = Math.min(o2, e3 + 100663296);
              var i2 = Math;
              o2 = Math.max(e3, o2);
              e: {
                i2 = i2.min.call(i2, 4294901760, o2 + (65536 - o2 % 65536) % 65536) - D.buffer.byteLength + 65535 >>> 16;
                try {
                  D.grow(i2), U();
                  var a2 = 1;
                  break e;
                } catch (e4) {
                }
                a2 = void 0;
              }
              if (a2)
                return true;
            }
            return false;
          }, O: Ze, P: Qe, j: fe, g: et, n: tt, w: nt, m: ot, x: function(e3, t3) {
            return e3 >>>= 0, t3 >>>= 0, it(r2().subarray(e3 >>> 0, e3 + t3 >>> 0)), 0;
          }, a: D || l.wasmMemory, H: lt, d: function(e3, t3, n2, r3) {
            return lt(e3 >>> 0, t3 >>> 0, n2 >>> 0, r3 >>> 0);
          } };
          !function() {
            function e3(e4, t4) {
              return e4 = e4.exports, $ = e4 = function(e5) {
                var t5 = (e6) => () => e6() >>> 0, n2 = (e6) => (t6) => e6(t6) >>> 0;
                return (e5 = Object.assign({}, e5)).__errno_location = t5(e5.__errno_location), e5.pthread_self = t5(e5.pthread_self), e5.malloc = n2(e5.malloc), e5.stackSave = t5(e5.stackSave), e5.stackAlloc = n2(e5.stackAlloc), e5;
              }(e4), he.Ta.push($.sa), V = $.ta, G.unshift($.W), k = t4, ee(), e4;
            }
            var t3 = { a: pt };
            if (Q(), l.instantiateWasm)
              try {
                return l.instantiateWasm(t3, e3);
              } catch (e4) {
                I("Module.instantiateWasm callback failed with error: " + e4), u(e4);
              }
            (function(e4, t4) {
              var n2 = X;
              return A || "function" != typeof WebAssembly.instantiateStreaming || ne(n2) || n2.startsWith("file://") || y || "function" != typeof fetch ? oe(n2, e4, t4) : fetch(n2, { credentials: "same-origin" }).then((r3) => WebAssembly.instantiateStreaming(r3, e4).then(t4, function(r4) {
                return I("wasm streaming compile failed: " + r4), I("falling back to ArrayBuffer instantiation"), oe(n2, e4, t4);
              }));
            })(t3, function(t4) {
              e3(t4.instance, t4.module);
            }).catch(u);
          }(), l._OrtInit = (e3, t3) => (l._OrtInit = $.X)(e3, t3), l._OrtGetLastError = (e3, t3) => (l._OrtGetLastError = $.Y)(e3, t3), l._OrtCreateSessionOptions = (e3, t3, n2, r3, o2, i2, a2, s2, u2, c2) => (l._OrtCreateSessionOptions = $.Z)(e3, t3, n2, r3, o2, i2, a2, s2, u2, c2), l._OrtAppendExecutionProvider = (e3, t3) => (l._OrtAppendExecutionProvider = $._)(e3, t3), l._OrtAddSessionConfigEntry = (e3, t3, n2) => (l._OrtAddSessionConfigEntry = $.$)(e3, t3, n2), l._OrtReleaseSessionOptions = (e3) => (l._OrtReleaseSessionOptions = $.aa)(e3), l._OrtCreateSession = (e3, t3, n2) => (l._OrtCreateSession = $.ba)(e3, t3, n2), l._OrtReleaseSession = (e3) => (l._OrtReleaseSession = $.ca)(e3), l._OrtGetInputOutputCount = (e3, t3, n2) => (l._OrtGetInputOutputCount = $.da)(e3, t3, n2), l._OrtGetInputName = (e3, t3) => (l._OrtGetInputName = $.ea)(e3, t3), l._OrtGetOutputName = (e3, t3) => (l._OrtGetOutputName = $.fa)(e3, t3), l._OrtFree = (e3) => (l._OrtFree = $.ga)(e3), l._OrtCreateTensor = (e3, t3, n2, r3, o2) => (l._OrtCreateTensor = $.ha)(e3, t3, n2, r3, o2), l._OrtGetTensorData = (e3, t3, n2, r3, o2) => (l._OrtGetTensorData = $.ia)(e3, t3, n2, r3, o2), l._OrtReleaseTensor = (e3) => (l._OrtReleaseTensor = $.ja)(e3), l._OrtCreateRunOptions = (e3, t3, n2, r3) => (l._OrtCreateRunOptions = $.ka)(e3, t3, n2, r3), l._OrtAddRunConfigEntry = (e3, t3, n2) => (l._OrtAddRunConfigEntry = $.la)(e3, t3, n2), l._OrtReleaseRunOptions = (e3) => (l._OrtReleaseRunOptions = $.ma)(e3), l._OrtRun = (e3, t3, n2, r3, o2, i2, a2, s2) => (l._OrtRun = $.na)(e3, t3, n2, r3, o2, i2, a2, s2), l._OrtEndProfiling = (e3) => (l._OrtEndProfiling = $.oa)(e3);
          var dt = l._pthread_self = () => (dt = l._pthread_self = $.pa)(), ft = l._malloc = (e3) => (ft = l._malloc = $.qa)(e3);
          l._free = (e3) => (l._free = $.ra)(e3), l.__emscripten_tls_init = () => (l.__emscripten_tls_init = $.sa)();
          var ht = l.__emscripten_thread_init = (e3, t3, n2, r3, o2, i2) => (ht = l.__emscripten_thread_init = $.ua)(e3, t3, n2, r3, o2, i2);
          l.__emscripten_thread_crashed = () => (l.__emscripten_thread_crashed = $.va)();
          var gt, bt = (e3, t3, n2, r3) => (bt = $.wa)(e3, t3, n2, r3), mt = (e3) => (mt = $.xa)(e3), yt = l.__emscripten_thread_exit = (e3) => (yt = l.__emscripten_thread_exit = $.ya)(e3), vt = l.__emscripten_check_mailbox = () => (vt = l.__emscripten_check_mailbox = $.za)(), _t = (e3) => (_t = $.Aa)(e3), wt = (e3, t3) => (wt = $.Ba)(e3, t3), Tt = () => (Tt = $.Ca)(), xt = (e3) => (xt = $.Da)(e3), Ot = (e3) => (Ot = $.Ea)(e3);
          function St() {
            function e3() {
              if (!gt && (gt = true, l.calledRun = true, !M) && (v || ge(G), s(l), l.onRuntimeInitialized && l.onRuntimeInitialized(), !v)) {
                if (l.postRun)
                  for ("function" == typeof l.postRun && (l.postRun = [l.postRun]); l.postRun.length; ) {
                    var e4 = l.postRun.shift();
                    H.unshift(e4);
                  }
                ge(H);
              }
            }
            if (!(0 < K))
              if (v)
                s(l), v || ge(G), startWorker(l);
              else {
                if (l.preRun)
                  for ("function" == typeof l.preRun && (l.preRun = [l.preRun]); l.preRun.length; )
                    z.unshift(l.preRun.shift());
                ge(z), 0 < K || (l.setStatus ? (l.setStatus("Running..."), setTimeout(function() {
                  setTimeout(function() {
                    l.setStatus("");
                  }, 1), e3();
                }, 1)) : e3());
              }
          }
          if (l.keepRuntimeAlive = q, l.wasmMemory = D, l.stackAlloc = Ot, l.stackSave = Tt, l.stackRestore = xt, l.UTF8ToString = pe, l.stringToUTF8 = Se, l.lengthBytesUTF8 = xe, l.ExitStatus = ie, l.PThread = he, Z = function e3() {
            gt || St(), gt || (Z = e3);
          }, l.preInit)
            for ("function" == typeof l.preInit && (l.preInit = [l.preInit]); 0 < l.preInit.length; )
              l.preInit.pop()();
          return St(), e2.ready;
        });
        e.exports = r;
      }, 932: (e, t, n) => {
        var _scriptDir, r = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (_scriptDir = _scriptDir || __filename), function(e2 = {}) {
          var t2, r2, o = e2;
          o.ready = new Promise((e3, n2) => {
            t2 = e3, r2 = n2;
          });
          var i, a, s, u = Object.assign({}, o), l = "./this.program", c = (e3, t3) => {
            throw t3;
          }, p = "object" == typeof window, d = "function" == typeof importScripts, f = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, h = "";
          if (f) {
            var g = n(1384), b = n(908);
            h = d ? b.dirname(h) + "/" : __dirname + "/", i = (e3, t3) => (e3 = e3.startsWith("file://") ? new URL(e3) : b.normalize(e3), g.readFileSync(e3, t3 ? void 0 : "utf8")), s = (e3) => ((e3 = i(e3, true)).buffer || (e3 = new Uint8Array(e3)), e3), a = (e3, t3, n2, r3 = true) => {
              e3 = e3.startsWith("file://") ? new URL(e3) : b.normalize(e3), g.readFile(e3, r3 ? void 0 : "utf8", (e4, o2) => {
                e4 ? n2(e4) : t3(r3 ? o2.buffer : o2);
              });
            }, !o.thisProgram && 1 < process.argv.length && (l = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), c = (e3, t3) => {
              throw process.exitCode = e3, t3;
            }, o.inspect = () => "[Emscripten Module object]";
          } else
            (p || d) && (d ? h = self.location.href : "undefined" != typeof document && document.currentScript && (h = document.currentScript.src), _scriptDir && (h = _scriptDir), h = 0 !== h.indexOf("blob:") ? h.substr(0, h.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", i = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.send(null), t3.responseText;
            }, d && (s = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), a = (e3, t3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", e3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? t3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            });
          var m, y = o.print || console.log.bind(console), v = o.printErr || console.error.bind(console);
          Object.assign(o, u), u = null, o.thisProgram && (l = o.thisProgram), o.quit && (c = o.quit), o.wasmBinary && (m = o.wasmBinary);
          var _ = o.noExitRuntime || true;
          "object" != typeof WebAssembly && j("no native wasm support detected");
          var w, T, x, O, S, A, P = false;
          function I() {
            var e3 = w.buffer;
            o.HEAP8 = x = new Int8Array(e3), o.HEAP16 = new Int16Array(e3), o.HEAP32 = S = new Int32Array(e3), o.HEAPU8 = O = new Uint8Array(e3), o.HEAPU16 = new Uint16Array(e3), o.HEAPU32 = A = new Uint32Array(e3), o.HEAPF32 = new Float32Array(e3), o.HEAPF64 = new Float64Array(e3);
          }
          var E = [], D = [], $ = [];
          function k() {
            var e3 = o.preRun.shift();
            E.unshift(e3);
          }
          var F, N3, R = 0, L3 = null, C2 = null;
          function j(e3) {
            throw o.onAbort && o.onAbort(e3), v(e3 = "Aborted(" + e3 + ")"), P = true, e3 = new WebAssembly.RuntimeError(e3 + ". Build with -sASSERTIONS for more info."), r2(e3), e3;
          }
          function M(e3) {
            return e3.startsWith("data:application/octet-stream;base64,");
          }
          if (!M(F = "ort-wasm.wasm")) {
            var U = F;
            F = o.locateFile ? o.locateFile(U, h) : h + U;
          }
          function B(e3) {
            if (e3 == F && m)
              return new Uint8Array(m);
            if (s)
              return s(e3);
            throw "both async and sync fetching of the wasm failed";
          }
          function V(e3, t3, n2) {
            return function(e4) {
              if (!m && (p || d)) {
                if ("function" == typeof fetch && !e4.startsWith("file://"))
                  return fetch(e4, { credentials: "same-origin" }).then((t4) => {
                    if (!t4.ok)
                      throw "failed to load wasm binary file at '" + e4 + "'";
                    return t4.arrayBuffer();
                  }).catch(() => B(e4));
                if (a)
                  return new Promise((t4, n3) => {
                    a(e4, (e5) => t4(new Uint8Array(e5)), n3);
                  });
              }
              return Promise.resolve().then(() => B(e4));
            }(e3).then((e4) => WebAssembly.instantiate(e4, t3)).then((e4) => e4).then(n2, (e4) => {
              v("failed to asynchronously prepare wasm: " + e4), j(e4);
            });
          }
          function z(e3) {
            this.name = "ExitStatus", this.message = `Program terminated with exit(${e3})`, this.status = e3;
          }
          var G = (e3) => {
            for (; 0 < e3.length; )
              e3.shift()(o);
          };
          function H(e3) {
            this.qa = e3 - 24, this.va = function(e4) {
              A[this.qa + 4 >> 2 >>> 0] = e4;
            }, this.ua = function(e4) {
              A[this.qa + 8 >> 2 >>> 0] = e4;
            }, this.sa = function(e4, t3) {
              this.ta(), this.va(e4), this.ua(t3);
            }, this.ta = function() {
              A[this.qa + 16 >> 2 >>> 0] = 0;
            };
          }
          var W, q = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, X = (e3, t3, n2) => {
            var r3 = (t3 >>>= 0) + n2;
            for (n2 = t3; e3[n2] && !(n2 >= r3); )
              ++n2;
            if (16 < n2 - t3 && e3.buffer && q)
              return q.decode(e3.subarray(t3, n2));
            for (r3 = ""; t3 < n2; ) {
              var o2 = e3[t3++];
              if (128 & o2) {
                var i2 = 63 & e3[t3++];
                if (192 == (224 & o2))
                  r3 += String.fromCharCode((31 & o2) << 6 | i2);
                else {
                  var a2 = 63 & e3[t3++];
                  65536 > (o2 = 224 == (240 & o2) ? (15 & o2) << 12 | i2 << 6 | a2 : (7 & o2) << 18 | i2 << 12 | a2 << 6 | 63 & e3[t3++]) ? r3 += String.fromCharCode(o2) : (o2 -= 65536, r3 += String.fromCharCode(55296 | o2 >> 10, 56320 | 1023 & o2));
                }
              } else
                r3 += String.fromCharCode(o2);
            }
            return r3;
          }, Y = (e3, t3) => (e3 >>>= 0) ? X(O, e3, t3) : "", K = (e3) => {
            for (var t3 = 0, n2 = 0; n2 < e3.length; ++n2) {
              var r3 = e3.charCodeAt(n2);
              127 >= r3 ? t3++ : 2047 >= r3 ? t3 += 2 : 55296 <= r3 && 57343 >= r3 ? (t3 += 4, ++n2) : t3 += 3;
            }
            return t3;
          }, J = (e3, t3, n2, r3) => {
            if (!(0 < r3))
              return 0;
            var o2 = n2 >>>= 0;
            r3 = n2 + r3 - 1;
            for (var i2 = 0; i2 < e3.length; ++i2) {
              var a2 = e3.charCodeAt(i2);
              if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++i2)), 127 >= a2) {
                if (n2 >= r3)
                  break;
                t3[n2++ >>> 0] = a2;
              } else {
                if (2047 >= a2) {
                  if (n2 + 1 >= r3)
                    break;
                  t3[n2++ >>> 0] = 192 | a2 >> 6;
                } else {
                  if (65535 >= a2) {
                    if (n2 + 2 >= r3)
                      break;
                    t3[n2++ >>> 0] = 224 | a2 >> 12;
                  } else {
                    if (n2 + 3 >= r3)
                      break;
                    t3[n2++ >>> 0] = 240 | a2 >> 18, t3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                }
                t3[n2++ >>> 0] = 128 | 63 & a2;
              }
            }
            return t3[n2 >>> 0] = 0, n2 - o2;
          }, Z = (e3) => 0 == e3 % 4 && (0 != e3 % 100 || 0 == e3 % 400), Q = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], ee = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], te = (e3) => {
            var t3 = K(e3) + 1, n2 = ce(t3);
            return n2 && J(e3, O, n2, t3), n2;
          }, ne = {}, re = () => {
            if (!W) {
              var e3, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: l || "./this.program" };
              for (e3 in ne)
                void 0 === ne[e3] ? delete t3[e3] : t3[e3] = ne[e3];
              var n2 = [];
              for (e3 in t3)
                n2.push(`${e3}=${t3[e3]}`);
              W = n2;
            }
            return W;
          }, oe = [null, [], []], ie = (e3) => (ie = (() => {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
              return (e5) => crypto.getRandomValues(e5);
            if (f)
              try {
                var e4 = n(760);
                if (e4.randomFillSync)
                  return (t4) => e4.randomFillSync(t4);
                var t3 = e4.randomBytes;
                return (e5) => (e5.set(t3(e5.byteLength)), e5);
              } catch (e5) {
              }
            j("initRandomDevice");
          })())(e3), ae = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], se = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function ue(e3, t3, n2, r3) {
            function o2(e4, t4, n3) {
              for (e4 = "number" == typeof e4 ? e4.toString() : e4 || ""; e4.length < t4; )
                e4 = n3[0] + e4;
              return e4;
            }
            function i2(e4, t4) {
              return o2(e4, t4, "0");
            }
            function a2(e4, t4) {
              function n3(e5) {
                return 0 > e5 ? -1 : 0 < e5 ? 1 : 0;
              }
              var r4;
              return 0 === (r4 = n3(e4.getFullYear() - t4.getFullYear())) && 0 === (r4 = n3(e4.getMonth() - t4.getMonth())) && (r4 = n3(e4.getDate() - t4.getDate())), r4;
            }
            function s2(e4) {
              switch (e4.getDay()) {
                case 0:
                  return new Date(e4.getFullYear() - 1, 11, 29);
                case 1:
                  return e4;
                case 2:
                  return new Date(e4.getFullYear(), 0, 3);
                case 3:
                  return new Date(e4.getFullYear(), 0, 2);
                case 4:
                  return new Date(e4.getFullYear(), 0, 1);
                case 5:
                  return new Date(e4.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(e4.getFullYear() - 1, 11, 30);
              }
            }
            function u2(e4) {
              var t4 = e4.ma;
              for (e4 = new Date(new Date(e4.na + 1900, 0, 1).getTime()); 0 < t4; ) {
                var n3 = e4.getMonth(), r4 = (Z(e4.getFullYear()) ? ae : se)[n3];
                if (!(t4 > r4 - e4.getDate())) {
                  e4.setDate(e4.getDate() + t4);
                  break;
                }
                t4 -= r4 - e4.getDate() + 1, e4.setDate(1), 11 > n3 ? e4.setMonth(n3 + 1) : (e4.setMonth(0), e4.setFullYear(e4.getFullYear() + 1));
              }
              return n3 = new Date(e4.getFullYear() + 1, 0, 4), t4 = s2(new Date(e4.getFullYear(), 0, 4)), n3 = s2(n3), 0 >= a2(t4, e4) ? 0 >= a2(n3, e4) ? e4.getFullYear() + 1 : e4.getFullYear() : e4.getFullYear() - 1;
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0;
            var l2 = S[40 + (r3 >>>= 0) >> 2 >>> 0];
            for (var c2 in r3 = { ya: S[r3 >> 2 >>> 0], xa: S[r3 + 4 >> 2 >>> 0], oa: S[r3 + 8 >> 2 >>> 0], ra: S[r3 + 12 >> 2 >>> 0], pa: S[r3 + 16 >> 2 >>> 0], na: S[r3 + 20 >> 2 >>> 0], ha: S[r3 + 24 >> 2 >>> 0], ma: S[r3 + 28 >> 2 >>> 0], Aa: S[r3 + 32 >> 2 >>> 0], wa: S[r3 + 36 >> 2 >>> 0], za: l2 ? Y(l2) : "" }, n2 = Y(n2), l2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
              n2 = n2.replace(new RegExp(c2, "g"), l2[c2]);
            var p2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), d2 = "January February March April May June July August September October November December".split(" ");
            for (c2 in l2 = { "%a": (e4) => p2[e4.ha].substring(0, 3), "%A": (e4) => p2[e4.ha], "%b": (e4) => d2[e4.pa].substring(0, 3), "%B": (e4) => d2[e4.pa], "%C": (e4) => i2((e4.na + 1900) / 100 | 0, 2), "%d": (e4) => i2(e4.ra, 2), "%e": (e4) => o2(e4.ra, 2, " "), "%g": (e4) => u2(e4).toString().substring(2), "%G": (e4) => u2(e4), "%H": (e4) => i2(e4.oa, 2), "%I": (e4) => (0 == (e4 = e4.oa) ? e4 = 12 : 12 < e4 && (e4 -= 12), i2(e4, 2)), "%j": (e4) => {
              for (var t4 = 0, n3 = 0; n3 <= e4.pa - 1; t4 += (Z(e4.na + 1900) ? ae : se)[n3++])
                ;
              return i2(e4.ra + t4, 3);
            }, "%m": (e4) => i2(e4.pa + 1, 2), "%M": (e4) => i2(e4.xa, 2), "%n": () => "\n", "%p": (e4) => 0 <= e4.oa && 12 > e4.oa ? "AM" : "PM", "%S": (e4) => i2(e4.ya, 2), "%t": () => "	", "%u": (e4) => e4.ha || 7, "%U": (e4) => i2(Math.floor((e4.ma + 7 - e4.ha) / 7), 2), "%V": (e4) => {
              var t4 = Math.floor((e4.ma + 7 - (e4.ha + 6) % 7) / 7);
              if (2 >= (e4.ha + 371 - e4.ma - 2) % 7 && t4++, t4)
                53 == t4 && (4 == (n3 = (e4.ha + 371 - e4.ma) % 7) || 3 == n3 && Z(e4.na) || (t4 = 1));
              else {
                t4 = 52;
                var n3 = (e4.ha + 7 - e4.ma - 1) % 7;
                (4 == n3 || 5 == n3 && Z(e4.na % 400 - 1)) && t4++;
              }
              return i2(t4, 2);
            }, "%w": (e4) => e4.ha, "%W": (e4) => i2(Math.floor((e4.ma + 7 - (e4.ha + 6) % 7) / 7), 2), "%y": (e4) => (e4.na + 1900).toString().substring(2), "%Y": (e4) => e4.na + 1900, "%z": (e4) => {
              var t4 = 0 <= (e4 = e4.wa);
              return e4 = Math.abs(e4) / 60, (t4 ? "+" : "-") + String("0000" + (e4 / 60 * 100 + e4 % 60)).slice(-4);
            }, "%Z": (e4) => e4.za, "%%": () => "%" }, n2 = n2.replace(/%%/g, "\0\0"), l2)
              n2.includes(c2) && (n2 = n2.replace(new RegExp(c2, "g"), l2[c2](r3)));
            return c2 = function(e4) {
              var t4 = Array(K(e4) + 1);
              return J(e4, t4, 0, t4.length), t4;
            }(n2 = n2.replace(/\0\0/g, "%")), c2.length > t3 ? 0 : (x.set(c2, e3 >>> 0), c2.length - 1);
          }
          var le = { a: function(e3, t3, n2) {
            throw new H(e3 >>>= 0).sa(t3 >>> 0, n2 >>> 0), e3;
          }, e: function() {
            return 0;
          }, I: function() {
          }, y: function() {
          }, A: function() {
          }, K: function() {
            return 0;
          }, G: function() {
          }, B: function() {
          }, F: function() {
          }, g: function() {
          }, z: function() {
          }, w: function() {
          }, H: function() {
          }, x: function() {
          }, k: () => true, n: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), S[n2 >> 2 >>> 0] = e3.getUTCSeconds(), S[n2 + 4 >> 2 >>> 0] = e3.getUTCMinutes(), S[n2 + 8 >> 2 >>> 0] = e3.getUTCHours(), S[n2 + 12 >> 2 >>> 0] = e3.getUTCDate(), S[n2 + 16 >> 2 >>> 0] = e3.getUTCMonth(), S[n2 + 20 >> 2 >>> 0] = e3.getUTCFullYear() - 1900, S[n2 + 24 >> 2 >>> 0] = e3.getUTCDay(), S[n2 + 28 >> 2 >>> 0] = (e3.getTime() - Date.UTC(e3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
          }, o: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), S[n2 >> 2 >>> 0] = e3.getSeconds(), S[n2 + 4 >> 2 >>> 0] = e3.getMinutes(), S[n2 + 8 >> 2 >>> 0] = e3.getHours(), S[n2 + 12 >> 2 >>> 0] = e3.getDate(), S[n2 + 16 >> 2 >>> 0] = e3.getMonth(), S[n2 + 20 >> 2 >>> 0] = e3.getFullYear() - 1900, S[n2 + 24 >> 2 >>> 0] = e3.getDay(), S[n2 + 28 >> 2 >>> 0] = (Z(e3.getFullYear()) ? Q : ee)[e3.getMonth()] + e3.getDate() - 1 | 0, S[n2 + 36 >> 2 >>> 0] = -60 * e3.getTimezoneOffset(), t3 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset();
            var r3 = new Date(e3.getFullYear(), 0, 1).getTimezoneOffset();
            S[n2 + 32 >> 2 >>> 0] = 0 | (t3 != r3 && e3.getTimezoneOffset() == Math.min(r3, t3));
          }, p: function(e3) {
            e3 >>>= 0;
            var t3 = new Date(S[e3 + 20 >> 2 >>> 0] + 1900, S[e3 + 16 >> 2 >>> 0], S[e3 + 12 >> 2 >>> 0], S[e3 + 8 >> 2 >>> 0], S[e3 + 4 >> 2 >>> 0], S[e3 >> 2 >>> 0], 0), n2 = S[e3 + 32 >> 2 >>> 0], r3 = t3.getTimezoneOffset(), o2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), i2 = new Date(t3.getFullYear(), 0, 1).getTimezoneOffset(), a2 = Math.min(i2, o2);
            return 0 > n2 ? S[e3 + 32 >> 2 >>> 0] = Number(o2 != i2 && a2 == r3) : 0 < n2 != (a2 == r3) && (o2 = Math.max(i2, o2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? a2 : o2) - r3))), S[e3 + 24 >> 2 >>> 0] = t3.getDay(), S[e3 + 28 >> 2 >>> 0] = (Z(t3.getFullYear()) ? Q : ee)[t3.getMonth()] + t3.getDate() - 1 | 0, S[e3 >> 2 >>> 0] = t3.getSeconds(), S[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), S[e3 + 8 >> 2 >>> 0] = t3.getHours(), S[e3 + 12 >> 2 >>> 0] = t3.getDate(), S[e3 + 16 >> 2 >>> 0] = t3.getMonth(), S[e3 + 20 >> 2 >>> 0] = t3.getYear(), e3 = t3.getTime() / 1e3, de((N3 = e3, 1 <= +Math.abs(N3) ? 0 < N3 ? +Math.floor(N3 / 4294967296) >>> 0 : ~~+Math.ceil((N3 - +(~~N3 >>> 0)) / 4294967296) >>> 0 : 0)), e3 >>> 0;
          }, l: function() {
            return -52;
          }, m: function() {
          }, u: function(e3, t3, n2) {
            function r3(e4) {
              return (e4 = e4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e4[1] : "GMT";
            }
            n2 >>>= 0;
            var o2 = (/* @__PURE__ */ new Date()).getFullYear(), i2 = new Date(o2, 0, 1), a2 = new Date(o2, 6, 1);
            o2 = i2.getTimezoneOffset();
            var s2 = a2.getTimezoneOffset();
            A[e3 >>> 0 >> 2 >>> 0] = 60 * Math.max(o2, s2), S[t3 >>> 0 >> 2 >>> 0] = Number(o2 != s2), e3 = r3(i2), t3 = r3(a2), e3 = te(e3), t3 = te(t3), s2 < o2 ? (A[n2 >> 2 >>> 0] = e3, A[n2 + 4 >> 2 >>> 0] = t3) : (A[n2 >> 2 >>> 0] = t3, A[n2 + 4 >> 2 >>> 0] = e3);
          }, d: () => {
            j("");
          }, h: function() {
            return Date.now();
          }, v: function() {
            return 4294901760;
          }, b: () => performance.now(), J: function(e3, t3, n2) {
            return t3 >>>= 0, O.copyWithin(e3 >>> 0 >>> 0, t3 >>> 0, t3 + (n2 >>> 0) >>> 0);
          }, t: function(e3) {
            e3 >>>= 0;
            var t3 = O.length;
            if (4294901760 < e3)
              return false;
            for (var n2 = 1; 4 >= n2; n2 *= 2) {
              var r3 = t3 * (1 + 0.2 / n2);
              r3 = Math.min(r3, e3 + 100663296);
              var o2 = Math;
              r3 = Math.max(e3, r3);
              e: {
                o2 = o2.min.call(o2, 4294901760, r3 + (65536 - r3 % 65536) % 65536) - w.buffer.byteLength + 65535 >>> 16;
                try {
                  w.grow(o2), I();
                  var i2 = 1;
                  break e;
                } catch (e4) {
                }
                i2 = void 0;
              }
              if (i2)
                return true;
            }
            return false;
          }, D: function(e3, t3) {
            e3 >>>= 0, t3 >>>= 0;
            var n2 = 0;
            return re().forEach(function(r3, o2) {
              var i2 = t3 + n2;
              for (o2 = A[e3 + 4 * o2 >> 2 >>> 0] = i2, i2 = 0; i2 < r3.length; ++i2)
                x[o2++ >> 0 >>> 0] = r3.charCodeAt(i2);
              x[o2 >> 0 >>> 0] = 0, n2 += r3.length + 1;
            }), 0;
          }, E: function(e3, t3) {
            e3 >>>= 0, t3 >>>= 0;
            var n2 = re();
            A[e3 >> 2 >>> 0] = n2.length;
            var r3 = 0;
            return n2.forEach(function(e4) {
              r3 += e4.length + 1;
            }), A[t3 >> 2 >>> 0] = r3, 0;
          }, s: (e3) => {
            _ || (o.onExit && o.onExit(e3), P = true), c(e3, new z(e3));
          }, f: () => 52, j: function() {
            return 52;
          }, q: function() {
            return 70;
          }, i: function(e3, t3, n2, r3) {
            t3 >>>= 0, n2 >>>= 0, r3 >>>= 0;
            for (var o2 = 0, i2 = 0; i2 < n2; i2++) {
              var a2 = A[t3 >> 2 >>> 0], s2 = A[t3 + 4 >> 2 >>> 0];
              t3 += 8;
              for (var u2 = 0; u2 < s2; u2++) {
                var l2 = O[a2 + u2 >>> 0], c2 = oe[e3];
                0 === l2 || 10 === l2 ? ((1 === e3 ? y : v)(X(c2, 0)), c2.length = 0) : c2.push(l2);
              }
              o2 += s2;
            }
            return A[r3 >> 2 >>> 0] = o2, 0;
          }, r: function(e3, t3) {
            return e3 >>>= 0, ie(O.subarray(e3 >>> 0, e3 + (t3 >>> 0) >>> 0)), 0;
          }, C: ue, c: function(e3, t3, n2, r3) {
            return ue(e3 >>> 0, t3 >>> 0, n2 >>> 0, r3 >>> 0);
          } };
          !function() {
            function e3(e4) {
              if (e4 = e4.exports, T = e4 = function(e5) {
                var t5 = (e6) => () => e6() >>> 0, n2 = (e6) => (t6) => e6(t6) >>> 0;
                return (e5 = Object.assign({}, e5)).__errno_location = t5(e5.__errno_location), e5.malloc = n2(e5.malloc), e5.stackSave = t5(e5.stackSave), e5.stackAlloc = n2(e5.stackAlloc), e5;
              }(e4), w = T.L, I(), D.unshift(T.M), R--, o.monitorRunDependencies && o.monitorRunDependencies(R), 0 == R && (null !== L3 && (clearInterval(L3), L3 = null), C2)) {
                var t4 = C2;
                C2 = null, t4();
              }
              return e4;
            }
            var t3 = { a: le };
            if (R++, o.monitorRunDependencies && o.monitorRunDependencies(R), o.instantiateWasm)
              try {
                return o.instantiateWasm(t3, e3);
              } catch (e4) {
                v("Module.instantiateWasm callback failed with error: " + e4), r2(e4);
              }
            (function(e4, t4) {
              var n2 = F;
              return m || "function" != typeof WebAssembly.instantiateStreaming || M(n2) || n2.startsWith("file://") || f || "function" != typeof fetch ? V(n2, e4, t4) : fetch(n2, { credentials: "same-origin" }).then((r3) => WebAssembly.instantiateStreaming(r3, e4).then(t4, function(r4) {
                return v("wasm streaming compile failed: " + r4), v("falling back to ArrayBuffer instantiation"), V(n2, e4, t4);
              }));
            })(t3, function(t4) {
              e3(t4.instance);
            }).catch(r2);
          }(), o._OrtInit = (e3, t3) => (o._OrtInit = T.N)(e3, t3), o._OrtGetLastError = (e3, t3) => (o._OrtGetLastError = T.O)(e3, t3), o._OrtCreateSessionOptions = (e3, t3, n2, r3, i2, a2, s2, u2, l2, c2) => (o._OrtCreateSessionOptions = T.P)(e3, t3, n2, r3, i2, a2, s2, u2, l2, c2), o._OrtAppendExecutionProvider = (e3, t3) => (o._OrtAppendExecutionProvider = T.Q)(e3, t3), o._OrtAddSessionConfigEntry = (e3, t3, n2) => (o._OrtAddSessionConfigEntry = T.R)(e3, t3, n2), o._OrtReleaseSessionOptions = (e3) => (o._OrtReleaseSessionOptions = T.S)(e3), o._OrtCreateSession = (e3, t3, n2) => (o._OrtCreateSession = T.T)(e3, t3, n2), o._OrtReleaseSession = (e3) => (o._OrtReleaseSession = T.U)(e3), o._OrtGetInputOutputCount = (e3, t3, n2) => (o._OrtGetInputOutputCount = T.V)(e3, t3, n2), o._OrtGetInputName = (e3, t3) => (o._OrtGetInputName = T.W)(e3, t3), o._OrtGetOutputName = (e3, t3) => (o._OrtGetOutputName = T.X)(e3, t3), o._OrtFree = (e3) => (o._OrtFree = T.Y)(e3), o._OrtCreateTensor = (e3, t3, n2, r3, i2) => (o._OrtCreateTensor = T.Z)(e3, t3, n2, r3, i2), o._OrtGetTensorData = (e3, t3, n2, r3, i2) => (o._OrtGetTensorData = T._)(e3, t3, n2, r3, i2), o._OrtReleaseTensor = (e3) => (o._OrtReleaseTensor = T.$)(e3), o._OrtCreateRunOptions = (e3, t3, n2, r3) => (o._OrtCreateRunOptions = T.aa)(e3, t3, n2, r3), o._OrtAddRunConfigEntry = (e3, t3, n2) => (o._OrtAddRunConfigEntry = T.ba)(e3, t3, n2), o._OrtReleaseRunOptions = (e3) => (o._OrtReleaseRunOptions = T.ca)(e3), o._OrtRun = (e3, t3, n2, r3, i2, a2, s2, u2) => (o._OrtRun = T.da)(e3, t3, n2, r3, i2, a2, s2, u2), o._OrtEndProfiling = (e3) => (o._OrtEndProfiling = T.ea)(e3);
          var ce = o._malloc = (e3) => (ce = o._malloc = T.fa)(e3);
          o._free = (e3) => (o._free = T.ga)(e3);
          var pe, de = (e3) => (de = T.ia)(e3), fe = () => (fe = T.ja)(), he = (e3) => (he = T.ka)(e3), ge = (e3) => (ge = T.la)(e3);
          function be() {
            function e3() {
              if (!pe && (pe = true, o.calledRun = true, !P)) {
                if (G(D), t2(o), o.onRuntimeInitialized && o.onRuntimeInitialized(), o.postRun)
                  for ("function" == typeof o.postRun && (o.postRun = [o.postRun]); o.postRun.length; ) {
                    var e4 = o.postRun.shift();
                    $.unshift(e4);
                  }
                G($);
              }
            }
            if (!(0 < R)) {
              if (o.preRun)
                for ("function" == typeof o.preRun && (o.preRun = [o.preRun]); o.preRun.length; )
                  k();
              G(E), 0 < R || (o.setStatus ? (o.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  o.setStatus("");
                }, 1), e3();
              }, 1)) : e3());
            }
          }
          if (o.stackAlloc = ge, o.stackSave = fe, o.stackRestore = he, o.UTF8ToString = Y, o.stringToUTF8 = (e3, t3, n2) => J(e3, O, t3, n2), o.lengthBytesUTF8 = K, C2 = function e3() {
            pe || be(), pe || (C2 = e3);
          }, o.preInit)
            for ("function" == typeof o.preInit && (o.preInit = [o.preInit]); 0 < o.preInit.length; )
              o.preInit.pop()();
          return be(), e2.ready;
        });
        e.exports = r;
      }, 4537: (e) => {
        "use strict";
        e.exports = function(e2, t) {
          for (var n = new Array(arguments.length - 1), r = 0, o = 2, i = true; o < arguments.length; )
            n[r++] = arguments[o++];
          return new Promise(function(o2, a) {
            n[r] = function(e3) {
              if (i)
                if (i = false, e3)
                  a(e3);
                else {
                  for (var t2 = new Array(arguments.length - 1), n2 = 0; n2 < t2.length; )
                    t2[n2++] = arguments[n2];
                  o2.apply(null, t2);
                }
            };
            try {
              e2.apply(t || null, n);
            } catch (e3) {
              i && (i = false, a(e3));
            }
          });
        };
      }, 7419: (e, t) => {
        "use strict";
        var n = t;
        n.length = function(e2) {
          var t2 = e2.length;
          if (!t2)
            return 0;
          for (var n2 = 0; --t2 % 4 > 1 && "=" === e2.charAt(t2); )
            ++n2;
          return Math.ceil(3 * e2.length) / 4 - n2;
        };
        for (var r = new Array(64), o = new Array(123), i = 0; i < 64; )
          o[r[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
        n.encode = function(e2, t2, n2) {
          for (var o2, i2 = null, a2 = [], s = 0, u = 0; t2 < n2; ) {
            var l = e2[t2++];
            switch (u) {
              case 0:
                a2[s++] = r[l >> 2], o2 = (3 & l) << 4, u = 1;
                break;
              case 1:
                a2[s++] = r[o2 | l >> 4], o2 = (15 & l) << 2, u = 2;
                break;
              case 2:
                a2[s++] = r[o2 | l >> 6], a2[s++] = r[63 & l], u = 0;
            }
            s > 8191 && ((i2 || (i2 = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
          }
          return u && (a2[s++] = r[o2], a2[s++] = 61, 1 === u && (a2[s++] = 61)), i2 ? (s && i2.push(String.fromCharCode.apply(String, a2.slice(0, s))), i2.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
        };
        var a = "invalid encoding";
        n.decode = function(e2, t2, n2) {
          for (var r2, i2 = n2, s = 0, u = 0; u < e2.length; ) {
            var l = e2.charCodeAt(u++);
            if (61 === l && s > 1)
              break;
            if (void 0 === (l = o[l]))
              throw Error(a);
            switch (s) {
              case 0:
                r2 = l, s = 1;
                break;
              case 1:
                t2[n2++] = r2 << 2 | (48 & l) >> 4, r2 = l, s = 2;
                break;
              case 2:
                t2[n2++] = (15 & r2) << 4 | (60 & l) >> 2, r2 = l, s = 3;
                break;
              case 3:
                t2[n2++] = (3 & r2) << 6 | l, s = 0;
            }
          }
          if (1 === s)
            throw Error(a);
          return n2 - i2;
        }, n.test = function(e2) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e2);
        };
      }, 9211: (e) => {
        "use strict";
        function t() {
          this._listeners = {};
        }
        e.exports = t, t.prototype.on = function(e2, t2, n) {
          return (this._listeners[e2] || (this._listeners[e2] = [])).push({ fn: t2, ctx: n || this }), this;
        }, t.prototype.off = function(e2, t2) {
          if (void 0 === e2)
            this._listeners = {};
          else if (void 0 === t2)
            this._listeners[e2] = [];
          else
            for (var n = this._listeners[e2], r = 0; r < n.length; )
              n[r].fn === t2 ? n.splice(r, 1) : ++r;
          return this;
        }, t.prototype.emit = function(e2) {
          var t2 = this._listeners[e2];
          if (t2) {
            for (var n = [], r = 1; r < arguments.length; )
              n.push(arguments[r++]);
            for (r = 0; r < t2.length; )
              t2[r].fn.apply(t2[r++].ctx, n);
          }
          return this;
        };
      }, 945: (e) => {
        "use strict";
        function t(e2) {
          return "undefined" != typeof Float32Array ? function() {
            var t2 = new Float32Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[3];
            function o2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[0], r3[o3 + 1] = n2[1], r3[o3 + 2] = n2[2], r3[o3 + 3] = n2[3];
            }
            function i2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[3], r3[o3 + 1] = n2[2], r3[o3 + 2] = n2[1], r3[o3 + 3] = n2[0];
            }
            function a(e3, r3) {
              return n2[0] = e3[r3], n2[1] = e3[r3 + 1], n2[2] = e3[r3 + 2], n2[3] = e3[r3 + 3], t2[0];
            }
            function s(e3, r3) {
              return n2[3] = e3[r3], n2[2] = e3[r3 + 1], n2[1] = e3[r3 + 2], n2[0] = e3[r3 + 3], t2[0];
            }
            e2.writeFloatLE = r2 ? o2 : i2, e2.writeFloatBE = r2 ? i2 : o2, e2.readFloatLE = r2 ? a : s, e2.readFloatBE = r2 ? s : a;
          }() : function() {
            function t2(e3, t3, n2, r2) {
              var o2 = t3 < 0 ? 1 : 0;
              if (o2 && (t3 = -t3), 0 === t3)
                e3(1 / t3 > 0 ? 0 : 2147483648, n2, r2);
              else if (isNaN(t3))
                e3(2143289344, n2, r2);
              else if (t3 > 34028234663852886e22)
                e3((o2 << 31 | 2139095040) >>> 0, n2, r2);
              else if (t3 < 11754943508222875e-54)
                e3((o2 << 31 | Math.round(t3 / 1401298464324817e-60)) >>> 0, n2, r2);
              else {
                var i2 = Math.floor(Math.log(t3) / Math.LN2);
                e3((o2 << 31 | i2 + 127 << 23 | 8388607 & Math.round(t3 * Math.pow(2, -i2) * 8388608)) >>> 0, n2, r2);
              }
            }
            function a(e3, t3, n2) {
              var r2 = e3(t3, n2), o2 = 2 * (r2 >> 31) + 1, i2 = r2 >>> 23 & 255, a2 = 8388607 & r2;
              return 255 === i2 ? a2 ? NaN : o2 * (1 / 0) : 0 === i2 ? 1401298464324817e-60 * o2 * a2 : o2 * Math.pow(2, i2 - 150) * (a2 + 8388608);
            }
            e2.writeFloatLE = t2.bind(null, n), e2.writeFloatBE = t2.bind(null, r), e2.readFloatLE = a.bind(null, o), e2.readFloatBE = a.bind(null, i);
          }(), "undefined" != typeof Float64Array ? function() {
            var t2 = new Float64Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[7];
            function o2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[0], r3[o3 + 1] = n2[1], r3[o3 + 2] = n2[2], r3[o3 + 3] = n2[3], r3[o3 + 4] = n2[4], r3[o3 + 5] = n2[5], r3[o3 + 6] = n2[6], r3[o3 + 7] = n2[7];
            }
            function i2(e3, r3, o3) {
              t2[0] = e3, r3[o3] = n2[7], r3[o3 + 1] = n2[6], r3[o3 + 2] = n2[5], r3[o3 + 3] = n2[4], r3[o3 + 4] = n2[3], r3[o3 + 5] = n2[2], r3[o3 + 6] = n2[1], r3[o3 + 7] = n2[0];
            }
            function a(e3, r3) {
              return n2[0] = e3[r3], n2[1] = e3[r3 + 1], n2[2] = e3[r3 + 2], n2[3] = e3[r3 + 3], n2[4] = e3[r3 + 4], n2[5] = e3[r3 + 5], n2[6] = e3[r3 + 6], n2[7] = e3[r3 + 7], t2[0];
            }
            function s(e3, r3) {
              return n2[7] = e3[r3], n2[6] = e3[r3 + 1], n2[5] = e3[r3 + 2], n2[4] = e3[r3 + 3], n2[3] = e3[r3 + 4], n2[2] = e3[r3 + 5], n2[1] = e3[r3 + 6], n2[0] = e3[r3 + 7], t2[0];
            }
            e2.writeDoubleLE = r2 ? o2 : i2, e2.writeDoubleBE = r2 ? i2 : o2, e2.readDoubleLE = r2 ? a : s, e2.readDoubleBE = r2 ? s : a;
          }() : function() {
            function t2(e3, t3, n2, r2, o2, i2) {
              var a2 = r2 < 0 ? 1 : 0;
              if (a2 && (r2 = -r2), 0 === r2)
                e3(0, o2, i2 + t3), e3(1 / r2 > 0 ? 0 : 2147483648, o2, i2 + n2);
              else if (isNaN(r2))
                e3(0, o2, i2 + t3), e3(2146959360, o2, i2 + n2);
              else if (r2 > 17976931348623157e292)
                e3(0, o2, i2 + t3), e3((a2 << 31 | 2146435072) >>> 0, o2, i2 + n2);
              else {
                var s;
                if (r2 < 22250738585072014e-324)
                  e3((s = r2 / 5e-324) >>> 0, o2, i2 + t3), e3((a2 << 31 | s / 4294967296) >>> 0, o2, i2 + n2);
                else {
                  var u = Math.floor(Math.log(r2) / Math.LN2);
                  1024 === u && (u = 1023), e3(4503599627370496 * (s = r2 * Math.pow(2, -u)) >>> 0, o2, i2 + t3), e3((a2 << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, o2, i2 + n2);
                }
              }
            }
            function a(e3, t3, n2, r2, o2) {
              var i2 = e3(r2, o2 + t3), a2 = e3(r2, o2 + n2), s = 2 * (a2 >> 31) + 1, u = a2 >>> 20 & 2047, l = 4294967296 * (1048575 & a2) + i2;
              return 2047 === u ? l ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * l : s * Math.pow(2, u - 1075) * (l + 4503599627370496);
            }
            e2.writeDoubleLE = t2.bind(null, n, 0, 4), e2.writeDoubleBE = t2.bind(null, r, 4, 0), e2.readDoubleLE = a.bind(null, o, 0, 4), e2.readDoubleBE = a.bind(null, i, 4, 0);
          }(), e2;
        }
        function n(e2, t2, n2) {
          t2[n2] = 255 & e2, t2[n2 + 1] = e2 >>> 8 & 255, t2[n2 + 2] = e2 >>> 16 & 255, t2[n2 + 3] = e2 >>> 24;
        }
        function r(e2, t2, n2) {
          t2[n2] = e2 >>> 24, t2[n2 + 1] = e2 >>> 16 & 255, t2[n2 + 2] = e2 >>> 8 & 255, t2[n2 + 3] = 255 & e2;
        }
        function o(e2, t2) {
          return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24) >>> 0;
        }
        function i(e2, t2) {
          return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
        }
        e.exports = t(t);
      }, 7199: (module) => {
        "use strict";
        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length))
              return mod;
          } catch (e) {
          }
          return null;
        }
        module.exports = inquire;
      }, 6662: (e) => {
        "use strict";
        e.exports = function(e2, t, n) {
          var r = n || 8192, o = r >>> 1, i = null, a = r;
          return function(n2) {
            if (n2 < 1 || n2 > o)
              return e2(n2);
            a + n2 > r && (i = e2(r), a = 0);
            var s = t.call(i, a, a += n2);
            return 7 & a && (a = 1 + (7 | a)), s;
          };
        };
      }, 4997: (e, t) => {
        "use strict";
        var n = t;
        n.length = function(e2) {
          for (var t2 = 0, n2 = 0, r = 0; r < e2.length; ++r)
            (n2 = e2.charCodeAt(r)) < 128 ? t2 += 1 : n2 < 2048 ? t2 += 2 : 55296 == (64512 & n2) && 56320 == (64512 & e2.charCodeAt(r + 1)) ? (++r, t2 += 4) : t2 += 3;
          return t2;
        }, n.read = function(e2, t2, n2) {
          if (n2 - t2 < 1)
            return "";
          for (var r, o = null, i = [], a = 0; t2 < n2; )
            (r = e2[t2++]) < 128 ? i[a++] = r : r > 191 && r < 224 ? i[a++] = (31 & r) << 6 | 63 & e2[t2++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & e2[t2++]) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++]) - 65536, i[a++] = 55296 + (r >> 10), i[a++] = 56320 + (1023 & r)) : i[a++] = (15 & r) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++], a > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), a = 0);
          return o ? (a && o.push(String.fromCharCode.apply(String, i.slice(0, a))), o.join("")) : String.fromCharCode.apply(String, i.slice(0, a));
        }, n.write = function(e2, t2, n2) {
          for (var r, o, i = n2, a = 0; a < e2.length; ++a)
            (r = e2.charCodeAt(a)) < 128 ? t2[n2++] = r : r < 2048 ? (t2[n2++] = r >> 6 | 192, t2[n2++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (o = e2.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & o), ++a, t2[n2++] = r >> 18 | 240, t2[n2++] = r >> 12 & 63 | 128, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128) : (t2[n2++] = r >> 12 | 224, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128);
          return n2 - i;
        };
      }, 3442: (e, t) => {
        "use strict";
        t.__esModule = true;
        var n = function() {
          function e2(t2) {
            if (!t2)
              throw new TypeError("Invalid argument; `value` has no value.");
            this.value = e2.EMPTY, t2 && e2.isGuid(t2) && (this.value = t2);
          }
          return e2.isGuid = function(t2) {
            var n2 = t2.toString();
            return t2 && (t2 instanceof e2 || e2.validator.test(n2));
          }, e2.create = function() {
            return new e2([e2.gen(2), e2.gen(1), e2.gen(1), e2.gen(1), e2.gen(3)].join("-"));
          }, e2.createEmpty = function() {
            return new e2("emptyguid");
          }, e2.parse = function(t2) {
            return new e2(t2);
          }, e2.raw = function() {
            return [e2.gen(2), e2.gen(1), e2.gen(1), e2.gen(1), e2.gen(3)].join("-");
          }, e2.gen = function(e3) {
            for (var t2 = "", n2 = 0; n2 < e3; n2++)
              t2 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
            return t2;
          }, e2.prototype.equals = function(t2) {
            return e2.isGuid(t2) && this.value === t2.toString();
          }, e2.prototype.isEmpty = function() {
            return this.value === e2.EMPTY;
          }, e2.prototype.toString = function() {
            return this.value;
          }, e2.prototype.toJSON = function() {
            return { value: this.value };
          }, e2.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), e2.EMPTY = "00000000-0000-0000-0000-000000000000", e2;
        }();
        t.Guid = n;
      }, 2100: (e, t, n) => {
        "use strict";
        e.exports = n(9482);
      }, 9482: (e, t, n) => {
        "use strict";
        var r = t;
        function o() {
          r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
        }
        r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = o, o();
      }, 1408: (e, t, n) => {
        "use strict";
        e.exports = u;
        var r, o = n(9693), i = o.LongBits, a = o.utf8;
        function s(e2, t2) {
          return RangeError("index out of range: " + e2.pos + " + " + (t2 || 1) + " > " + e2.len);
        }
        function u(e2) {
          this.buf = e2, this.pos = 0, this.len = e2.length;
        }
        var l, c = "undefined" != typeof Uint8Array ? function(e2) {
          if (e2 instanceof Uint8Array || Array.isArray(e2))
            return new u(e2);
          throw Error("illegal buffer");
        } : function(e2) {
          if (Array.isArray(e2))
            return new u(e2);
          throw Error("illegal buffer");
        }, p = function() {
          return o.Buffer ? function(e2) {
            return (u.create = function(e3) {
              return o.Buffer.isBuffer(e3) ? new r(e3) : c(e3);
            })(e2);
          } : c;
        };
        function d() {
          var e2 = new i(0, 0), t2 = 0;
          if (!(this.len - this.pos > 4)) {
            for (; t2 < 3; ++t2) {
              if (this.pos >= this.len)
                throw s(this);
              if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128)
                return e2;
            }
            return e2.lo = (e2.lo | (127 & this.buf[this.pos++]) << 7 * t2) >>> 0, e2;
          }
          for (; t2 < 4; ++t2)
            if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128)
              return e2;
          if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e2.hi = (e2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
            return e2;
          if (t2 = 0, this.len - this.pos > 4) {
            for (; t2 < 5; ++t2)
              if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128)
                return e2;
          } else
            for (; t2 < 5; ++t2) {
              if (this.pos >= this.len)
                throw s(this);
              if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128)
                return e2;
            }
          throw Error("invalid varint encoding");
        }
        function f(e2, t2) {
          return (e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24) >>> 0;
        }
        function h() {
          if (this.pos + 8 > this.len)
            throw s(this, 8);
          return new i(f(this.buf, this.pos += 4), f(this.buf, this.pos += 4));
        }
        u.create = p(), u.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, u.prototype.uint32 = (l = 4294967295, function() {
          if (l = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if ((this.pos += 5) > this.len)
            throw this.pos = this.len, s(this, 10);
          return l;
        }), u.prototype.int32 = function() {
          return 0 | this.uint32();
        }, u.prototype.sint32 = function() {
          var e2 = this.uint32();
          return e2 >>> 1 ^ -(1 & e2) | 0;
        }, u.prototype.bool = function() {
          return 0 !== this.uint32();
        }, u.prototype.fixed32 = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          return f(this.buf, this.pos += 4);
        }, u.prototype.sfixed32 = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          return 0 | f(this.buf, this.pos += 4);
        }, u.prototype.float = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          var e2 = o.float.readFloatLE(this.buf, this.pos);
          return this.pos += 4, e2;
        }, u.prototype.double = function() {
          if (this.pos + 8 > this.len)
            throw s(this, 4);
          var e2 = o.float.readDoubleLE(this.buf, this.pos);
          return this.pos += 8, e2;
        }, u.prototype.bytes = function() {
          var e2 = this.uint32(), t2 = this.pos, n2 = this.pos + e2;
          if (n2 > this.len)
            throw s(this, e2);
          return this.pos += e2, Array.isArray(this.buf) ? this.buf.slice(t2, n2) : t2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, t2, n2);
        }, u.prototype.string = function() {
          var e2 = this.bytes();
          return a.read(e2, 0, e2.length);
        }, u.prototype.skip = function(e2) {
          if ("number" == typeof e2) {
            if (this.pos + e2 > this.len)
              throw s(this, e2);
            this.pos += e2;
          } else
            do {
              if (this.pos >= this.len)
                throw s(this);
            } while (128 & this.buf[this.pos++]);
          return this;
        }, u.prototype.skipType = function(e2) {
          switch (e2) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              for (; 4 != (e2 = 7 & this.uint32()); )
                this.skipType(e2);
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + e2 + " at offset " + this.pos);
          }
          return this;
        }, u._configure = function(e2) {
          r = e2, u.create = p(), r._configure();
          var t2 = o.Long ? "toLong" : "toNumber";
          o.merge(u.prototype, { int64: function() {
            return d.call(this)[t2](false);
          }, uint64: function() {
            return d.call(this)[t2](true);
          }, sint64: function() {
            return d.call(this).zzDecode()[t2](false);
          }, fixed64: function() {
            return h.call(this)[t2](true);
          }, sfixed64: function() {
            return h.call(this)[t2](false);
          } });
        };
      }, 593: (e, t, n) => {
        "use strict";
        e.exports = i;
        var r = n(1408);
        (i.prototype = Object.create(r.prototype)).constructor = i;
        var o = n(9693);
        function i(e2) {
          r.call(this, e2);
        }
        i._configure = function() {
          o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice);
        }, i.prototype.string = function() {
          var e2 = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e2, this.len));
        }, i._configure();
      }, 5054: (e) => {
        "use strict";
        e.exports = {};
      }, 5994: (e, t, n) => {
        "use strict";
        t.Service = n(7948);
      }, 7948: (e, t, n) => {
        "use strict";
        e.exports = o;
        var r = n(9693);
        function o(e2, t2, n2) {
          if ("function" != typeof e2)
            throw TypeError("rpcImpl must be a function");
          r.EventEmitter.call(this), this.rpcImpl = e2, this.requestDelimited = Boolean(t2), this.responseDelimited = Boolean(n2);
        }
        (o.prototype = Object.create(r.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e2(t2, n2, o2, i, a) {
          if (!i)
            throw TypeError("request must be specified");
          var s = this;
          if (!a)
            return r.asPromise(e2, s, t2, n2, o2, i);
          if (s.rpcImpl)
            try {
              return s.rpcImpl(t2, n2[s.requestDelimited ? "encodeDelimited" : "encode"](i).finish(), function(e3, n3) {
                if (e3)
                  return s.emit("error", e3, t2), a(e3);
                if (null !== n3) {
                  if (!(n3 instanceof o2))
                    try {
                      n3 = o2[s.responseDelimited ? "decodeDelimited" : "decode"](n3);
                    } catch (e4) {
                      return s.emit("error", e4, t2), a(e4);
                    }
                  return s.emit("data", n3, t2), a(null, n3);
                }
                s.end(true);
              });
            } catch (e3) {
              return s.emit("error", e3, t2), void setTimeout(function() {
                a(e3);
              }, 0);
            }
          else
            setTimeout(function() {
              a(Error("already ended"));
            }, 0);
        }, o.prototype.end = function(e2) {
          return this.rpcImpl && (e2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
        };
      }, 1945: (e, t, n) => {
        "use strict";
        e.exports = o;
        var r = n(9693);
        function o(e2, t2) {
          this.lo = e2 >>> 0, this.hi = t2 >>> 0;
        }
        var i = o.zero = new o(0, 0);
        i.toNumber = function() {
          return 0;
        }, i.zzEncode = i.zzDecode = function() {
          return this;
        }, i.length = function() {
          return 1;
        };
        var a = o.zeroHash = "\0\0\0\0\0\0\0\0";
        o.fromNumber = function(e2) {
          if (0 === e2)
            return i;
          var t2 = e2 < 0;
          t2 && (e2 = -e2);
          var n2 = e2 >>> 0, r2 = (e2 - n2) / 4294967296 >>> 0;
          return t2 && (r2 = ~r2 >>> 0, n2 = ~n2 >>> 0, ++n2 > 4294967295 && (n2 = 0, ++r2 > 4294967295 && (r2 = 0))), new o(n2, r2);
        }, o.from = function(e2) {
          if ("number" == typeof e2)
            return o.fromNumber(e2);
          if (r.isString(e2)) {
            if (!r.Long)
              return o.fromNumber(parseInt(e2, 10));
            e2 = r.Long.fromString(e2);
          }
          return e2.low || e2.high ? new o(e2.low >>> 0, e2.high >>> 0) : i;
        }, o.prototype.toNumber = function(e2) {
          if (!e2 && this.hi >>> 31) {
            var t2 = 1 + ~this.lo >>> 0, n2 = ~this.hi >>> 0;
            return t2 || (n2 = n2 + 1 >>> 0), -(t2 + 4294967296 * n2);
          }
          return this.lo + 4294967296 * this.hi;
        }, o.prototype.toLong = function(e2) {
          return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(e2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e2) };
        };
        var s = String.prototype.charCodeAt;
        o.fromHash = function(e2) {
          return e2 === a ? i : new o((s.call(e2, 0) | s.call(e2, 1) << 8 | s.call(e2, 2) << 16 | s.call(e2, 3) << 24) >>> 0, (s.call(e2, 4) | s.call(e2, 5) << 8 | s.call(e2, 6) << 16 | s.call(e2, 7) << 24) >>> 0);
        }, o.prototype.toHash = function() {
          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        }, o.prototype.zzEncode = function() {
          var e2 = this.hi >> 31;
          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e2) >>> 0, this.lo = (this.lo << 1 ^ e2) >>> 0, this;
        }, o.prototype.zzDecode = function() {
          var e2 = -(1 & this.lo);
          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e2) >>> 0, this.hi = (this.hi >>> 1 ^ e2) >>> 0, this;
        }, o.prototype.length = function() {
          var e2 = this.lo, t2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
          return 0 === n2 ? 0 === t2 ? e2 < 16384 ? e2 < 128 ? 1 : 2 : e2 < 2097152 ? 3 : 4 : t2 < 16384 ? t2 < 128 ? 5 : 6 : t2 < 2097152 ? 7 : 8 : n2 < 128 ? 9 : 10;
        };
      }, 9693: function(e, t, n) {
        "use strict";
        var r = t;
        function o(e2, t2, n2) {
          for (var r2 = Object.keys(t2), o2 = 0; o2 < r2.length; ++o2)
            void 0 !== e2[r2[o2]] && n2 || (e2[r2[o2]] = t2[r2[o2]]);
          return e2;
        }
        function i(e2) {
          function t2(e3, n2) {
            if (!(this instanceof t2))
              return new t2(e3, n2);
            Object.defineProperty(this, "message", { get: function() {
              return e3;
            } }), Error.captureStackTrace ? Error.captureStackTrace(this, t2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n2 && o(this, n2);
          }
          return t2.prototype = Object.create(Error.prototype, { constructor: { value: t2, writable: true, enumerable: false, configurable: true }, name: { get: function() {
            return e2;
          }, set: void 0, enumerable: false, configurable: true }, toString: { value: function() {
            return this.name + ": " + this.message;
          }, writable: true, enumerable: false, configurable: true } }), t2;
        }
        r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean("undefined" != typeof global && global && global.process && global.process.versions && global.process.versions.node), r.global = r.isNode && global || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(e2) {
          return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
        }, r.isString = function(e2) {
          return "string" == typeof e2 || e2 instanceof String;
        }, r.isObject = function(e2) {
          return e2 && "object" == typeof e2;
        }, r.isset = r.isSet = function(e2, t2) {
          var n2 = e2[t2];
          return !(null == n2 || !e2.hasOwnProperty(t2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
        }, r.Buffer = function() {
          try {
            var e2 = r.inquire("buffer").Buffer;
            return e2.prototype.utf8Write ? e2 : null;
          } catch (e3) {
            return null;
          }
        }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(e2) {
          return "number" == typeof e2 ? r.Buffer ? r._Buffer_allocUnsafe(e2) : new r.Array(e2) : r.Buffer ? r._Buffer_from(e2) : "undefined" == typeof Uint8Array ? e2 : new Uint8Array(e2);
        }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(e2) {
          return e2 ? r.LongBits.from(e2).toHash() : r.LongBits.zeroHash;
        }, r.longFromHash = function(e2, t2) {
          var n2 = r.LongBits.fromHash(e2);
          return r.Long ? r.Long.fromBits(n2.lo, n2.hi, t2) : n2.toNumber(Boolean(t2));
        }, r.merge = o, r.lcFirst = function(e2) {
          return e2.charAt(0).toLowerCase() + e2.substring(1);
        }, r.newError = i, r.ProtocolError = i("ProtocolError"), r.oneOfGetter = function(e2) {
          for (var t2 = {}, n2 = 0; n2 < e2.length; ++n2)
            t2[e2[n2]] = 1;
          return function() {
            for (var e3 = Object.keys(this), n3 = e3.length - 1; n3 > -1; --n3)
              if (1 === t2[e3[n3]] && void 0 !== this[e3[n3]] && null !== this[e3[n3]])
                return e3[n3];
          };
        }, r.oneOfSetter = function(e2) {
          return function(t2) {
            for (var n2 = 0; n2 < e2.length; ++n2)
              e2[n2] !== t2 && delete this[e2[n2]];
          };
        }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
          var e2 = r.Buffer;
          e2 ? (r._Buffer_from = e2.from !== Uint8Array.from && e2.from || function(t2, n2) {
            return new e2(t2, n2);
          }, r._Buffer_allocUnsafe = e2.allocUnsafe || function(t2) {
            return new e2(t2);
          }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
        };
      }, 1173: (e, t, n) => {
        "use strict";
        e.exports = p;
        var r, o = n(9693), i = o.LongBits, a = o.base64, s = o.utf8;
        function u(e2, t2, n2) {
          this.fn = e2, this.len = t2, this.next = void 0, this.val = n2;
        }
        function l() {
        }
        function c(e2) {
          this.head = e2.head, this.tail = e2.tail, this.len = e2.len, this.next = e2.states;
        }
        function p() {
          this.len = 0, this.head = new u(l, 0, 0), this.tail = this.head, this.states = null;
        }
        var d = function() {
          return o.Buffer ? function() {
            return (p.create = function() {
              return new r();
            })();
          } : function() {
            return new p();
          };
        };
        function f(e2, t2, n2) {
          t2[n2] = 255 & e2;
        }
        function h(e2, t2) {
          this.len = e2, this.next = void 0, this.val = t2;
        }
        function g(e2, t2, n2) {
          for (; e2.hi; )
            t2[n2++] = 127 & e2.lo | 128, e2.lo = (e2.lo >>> 7 | e2.hi << 25) >>> 0, e2.hi >>>= 7;
          for (; e2.lo > 127; )
            t2[n2++] = 127 & e2.lo | 128, e2.lo = e2.lo >>> 7;
          t2[n2++] = e2.lo;
        }
        function b(e2, t2, n2) {
          t2[n2] = 255 & e2, t2[n2 + 1] = e2 >>> 8 & 255, t2[n2 + 2] = e2 >>> 16 & 255, t2[n2 + 3] = e2 >>> 24;
        }
        p.create = d(), p.alloc = function(e2) {
          return new o.Array(e2);
        }, o.Array !== Array && (p.alloc = o.pool(p.alloc, o.Array.prototype.subarray)), p.prototype._push = function(e2, t2, n2) {
          return this.tail = this.tail.next = new u(e2, t2, n2), this.len += t2, this;
        }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(e2, t2, n2) {
          for (; e2 > 127; )
            t2[n2++] = 127 & e2 | 128, e2 >>>= 7;
          t2[n2] = e2;
        }, p.prototype.uint32 = function(e2) {
          return this.len += (this.tail = this.tail.next = new h((e2 >>>= 0) < 128 ? 1 : e2 < 16384 ? 2 : e2 < 2097152 ? 3 : e2 < 268435456 ? 4 : 5, e2)).len, this;
        }, p.prototype.int32 = function(e2) {
          return e2 < 0 ? this._push(g, 10, i.fromNumber(e2)) : this.uint32(e2);
        }, p.prototype.sint32 = function(e2) {
          return this.uint32((e2 << 1 ^ e2 >> 31) >>> 0);
        }, p.prototype.uint64 = function(e2) {
          var t2 = i.from(e2);
          return this._push(g, t2.length(), t2);
        }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(e2) {
          var t2 = i.from(e2).zzEncode();
          return this._push(g, t2.length(), t2);
        }, p.prototype.bool = function(e2) {
          return this._push(f, 1, e2 ? 1 : 0);
        }, p.prototype.fixed32 = function(e2) {
          return this._push(b, 4, e2 >>> 0);
        }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(e2) {
          var t2 = i.from(e2);
          return this._push(b, 4, t2.lo)._push(b, 4, t2.hi);
        }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(e2) {
          return this._push(o.float.writeFloatLE, 4, e2);
        }, p.prototype.double = function(e2) {
          return this._push(o.float.writeDoubleLE, 8, e2);
        };
        var m = o.Array.prototype.set ? function(e2, t2, n2) {
          t2.set(e2, n2);
        } : function(e2, t2, n2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[n2 + r2] = e2[r2];
        };
        p.prototype.bytes = function(e2) {
          var t2 = e2.length >>> 0;
          if (!t2)
            return this._push(f, 1, 0);
          if (o.isString(e2)) {
            var n2 = p.alloc(t2 = a.length(e2));
            a.decode(e2, n2, 0), e2 = n2;
          }
          return this.uint32(t2)._push(m, t2, e2);
        }, p.prototype.string = function(e2) {
          var t2 = s.length(e2);
          return t2 ? this.uint32(t2)._push(s.write, t2, e2) : this._push(f, 1, 0);
        }, p.prototype.fork = function() {
          return this.states = new c(this), this.head = this.tail = new u(l, 0, 0), this.len = 0, this;
        }, p.prototype.reset = function() {
          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(l, 0, 0), this.len = 0), this;
        }, p.prototype.ldelim = function() {
          var e2 = this.head, t2 = this.tail, n2 = this.len;
          return this.reset().uint32(n2), n2 && (this.tail.next = e2.next, this.tail = t2, this.len += n2), this;
        }, p.prototype.finish = function() {
          for (var e2 = this.head.next, t2 = this.constructor.alloc(this.len), n2 = 0; e2; )
            e2.fn(e2.val, t2, n2), n2 += e2.len, e2 = e2.next;
          return t2;
        }, p._configure = function(e2) {
          r = e2, p.create = d(), r._configure();
        };
      }, 3155: (e, t, n) => {
        "use strict";
        e.exports = i;
        var r = n(1173);
        (i.prototype = Object.create(r.prototype)).constructor = i;
        var o = n(9693);
        function i() {
          r.call(this);
        }
        function a(e2, t2, n2) {
          e2.length < 40 ? o.utf8.write(e2, t2, n2) : t2.utf8Write ? t2.utf8Write(e2, n2) : t2.write(e2, n2);
        }
        i._configure = function() {
          i.alloc = o._Buffer_allocUnsafe, i.writeBytesBuffer = o.Buffer && o.Buffer.prototype instanceof Uint8Array && "set" === o.Buffer.prototype.set.name ? function(e2, t2, n2) {
            t2.set(e2, n2);
          } : function(e2, t2, n2) {
            if (e2.copy)
              e2.copy(t2, n2, 0, e2.length);
            else
              for (var r2 = 0; r2 < e2.length; )
                t2[n2++] = e2[r2++];
          };
        }, i.prototype.bytes = function(e2) {
          o.isString(e2) && (e2 = o._Buffer_from(e2, "base64"));
          var t2 = e2.length >>> 0;
          return this.uint32(t2), t2 && this._push(i.writeBytesBuffer, t2, e2), this;
        }, i.prototype.string = function(e2) {
          var t2 = o.Buffer.byteLength(e2);
          return this.uint32(t2), t2 && this._push(a, t2, e2), this;
        }, i._configure();
      }, 4154: (e) => {
        "use strict";
        e.exports = '"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\n';
      }, 7067: () => {
      }, 1296: () => {
      }, 760: () => {
      }, 1384: () => {
      }, 3993: () => {
      }, 908: () => {
      }, 6953: () => {
      }, 9925: () => {
      }, 2806: () => {
      }, 6449: () => {
      }, 2850: () => {
      }, 5381: () => {
      }, 685: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveBackend = t.registerBackend = void 0;
        const n = {}, r = [];
        t.registerBackend = (e2, t2, o) => {
          if (!t2 || "function" != typeof t2.init || "function" != typeof t2.createSessionHandler)
            throw new TypeError("not a valid backend");
          {
            const i = n[e2];
            if (void 0 === i)
              n[e2] = { backend: t2, priority: o };
            else {
              if (i.priority > o)
                return;
              if (i.priority === o && i.backend !== t2)
                throw new Error(`cannot register backend "${e2}" using priority ${o}`);
            }
            if (o >= 0) {
              const t3 = r.indexOf(e2);
              -1 !== t3 && r.splice(t3, 1);
              for (let t4 = 0; t4 < r.length; t4++)
                if (n[r[t4]].priority <= o)
                  return void r.splice(t4, 0, e2);
              r.push(e2);
            }
          }
        }, t.resolveBackend = async (e2) => {
          const t2 = 0 === e2.length ? r : e2, o = [];
          for (const e3 of t2) {
            const t3 = n[e3];
            if (t3) {
              if (t3.initialized)
                return t3.backend;
              if (t3.aborted)
                continue;
              const n2 = !!t3.initPromise;
              try {
                return n2 || (t3.initPromise = t3.backend.init()), await t3.initPromise, t3.initialized = true, t3.backend;
              } catch (r2) {
                n2 || o.push({ name: e3, err: r2 }), t3.aborted = true;
              } finally {
                delete t3.initPromise;
              }
            }
          }
          throw new Error(`no available backend found. ERR: ${o.map((e3) => `[${e3.name}] ${e3.err}`).join(", ")}`);
        };
      }, 4798: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.registerBackend = void 0;
        var r = n(685);
        Object.defineProperty(t, "registerBackend", { enumerable: true, get: function() {
          return r.registerBackend;
        } });
      }, 3121: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.env = void 0;
        const r = n(9104);
        let o = "warning";
        t.env = { wasm: {}, webgl: {}, webgpu: {}, versions: { common: r.version }, set logLevel(e2) {
          if (void 0 !== e2) {
            if ("string" != typeof e2 || -1 === ["verbose", "info", "warning", "error", "fatal"].indexOf(e2))
              throw new Error(`Unsupported logging level: ${e2}`);
            o = e2;
          }
        }, get logLevel() {
          return o;
        } }, Object.defineProperty(t.env, "logLevel", { enumerable: true });
      }, 2457: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.env = void 0;
        const r = n(3121);
        t.env = r.env;
      }, 2235: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var o2 = Object.getOwnPropertyDescriptor(t2, n2);
          o2 && !("get" in o2 ? !t2.__esModule : o2.writable || o2.configurable) || (o2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, o2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__exportStar || function(e2, t2) {
          for (var n2 in e2)
            "default" === n2 || Object.prototype.hasOwnProperty.call(t2, n2) || r(t2, e2, n2);
        };
        Object.defineProperty(t, "__esModule", { value: true }), o(n(4798), t), o(n(2457), t), o(n(3974), t), o(n(963), t), o(n(7852), t);
      }, 8036: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.InferenceSession = void 0;
        const r = n(685), o = n(963);
        class i {
          constructor(e2) {
            this.handler = e2;
          }
          async run(e2, t2, n2) {
            const r2 = {};
            let i2 = {};
            if ("object" != typeof e2 || null === e2 || e2 instanceof o.Tensor || Array.isArray(e2))
              throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
            let a = true;
            if ("object" == typeof t2) {
              if (null === t2)
                throw new TypeError("Unexpected argument[1]: cannot be null.");
              if (t2 instanceof o.Tensor)
                throw new TypeError("'fetches' cannot be a Tensor");
              if (Array.isArray(t2)) {
                if (0 === t2.length)
                  throw new TypeError("'fetches' cannot be an empty array.");
                a = false;
                for (const e3 of t2) {
                  if ("string" != typeof e3)
                    throw new TypeError("'fetches' must be a string array or an object.");
                  if (-1 === this.outputNames.indexOf(e3))
                    throw new RangeError(`'fetches' contains invalid output name: ${e3}.`);
                  r2[e3] = null;
                }
                if ("object" == typeof n2 && null !== n2)
                  i2 = n2;
                else if (void 0 !== n2)
                  throw new TypeError("'options' must be an object.");
              } else {
                let e3 = false;
                const s2 = Object.getOwnPropertyNames(t2);
                for (const n3 of this.outputNames)
                  if (-1 !== s2.indexOf(n3)) {
                    const i3 = t2[n3];
                    (null === i3 || i3 instanceof o.Tensor) && (e3 = true, a = false, r2[n3] = i3);
                  }
                if (e3) {
                  if ("object" == typeof n2 && null !== n2)
                    i2 = n2;
                  else if (void 0 !== n2)
                    throw new TypeError("'options' must be an object.");
                } else
                  i2 = t2;
              }
            } else if (void 0 !== t2)
              throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
            for (const t3 of this.inputNames)
              if (void 0 === e2[t3])
                throw new Error(`input '${t3}' is missing in 'feeds'.`);
            if (a)
              for (const e3 of this.outputNames)
                r2[e3] = null;
            const s = await this.handler.run(e2, r2, i2), u = {};
            for (const e3 in s)
              Object.hasOwnProperty.call(s, e3) && (u[e3] = new o.Tensor(s[e3].type, s[e3].data, s[e3].dims));
            return u;
          }
          async release() {
            return this.handler.dispose();
          }
          static async create(e2, t2, n2, o2) {
            let a, s = {};
            if ("string" == typeof e2) {
              if (a = e2, "object" == typeof t2 && null !== t2)
                s = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else if (e2 instanceof Uint8Array) {
              if (a = e2, "object" == typeof t2 && null !== t2)
                s = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else {
              if (!(e2 instanceof ArrayBuffer || "undefined" != typeof SharedArrayBuffer && e2 instanceof SharedArrayBuffer))
                throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
              {
                const r2 = e2;
                let i2 = 0, u2 = e2.byteLength;
                if ("object" == typeof t2 && null !== t2)
                  s = t2;
                else if ("number" == typeof t2) {
                  if (i2 = t2, !Number.isSafeInteger(i2))
                    throw new RangeError("'byteOffset' must be an integer.");
                  if (i2 < 0 || i2 >= r2.byteLength)
                    throw new RangeError(`'byteOffset' is out of range [0, ${r2.byteLength}).`);
                  if (u2 = e2.byteLength - i2, "number" == typeof n2) {
                    if (u2 = n2, !Number.isSafeInteger(u2))
                      throw new RangeError("'byteLength' must be an integer.");
                    if (u2 <= 0 || i2 + u2 > r2.byteLength)
                      throw new RangeError(`'byteLength' is out of range (0, ${r2.byteLength - i2}].`);
                    if ("object" == typeof o2 && null !== o2)
                      s = o2;
                    else if (void 0 !== o2)
                      throw new TypeError("'options' must be an object.");
                  } else if (void 0 !== n2)
                    throw new TypeError("'byteLength' must be a number.");
                } else if (void 0 !== t2)
                  throw new TypeError("'options' must be an object.");
                a = new Uint8Array(r2, i2, u2);
              }
            }
            const u = (s.executionProviders || []).map((e3) => "string" == typeof e3 ? e3 : e3.name), l = await (0, r.resolveBackend)(u), c = await l.createSessionHandler(a, s);
            return new i(c);
          }
          startProfiling() {
            this.handler.startProfiling();
          }
          endProfiling() {
            this.handler.endProfiling();
          }
          get inputNames() {
            return this.handler.inputNames;
          }
          get outputNames() {
            return this.handler.outputNames;
          }
        }
        t.InferenceSession = i;
      }, 3974: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.InferenceSession = void 0;
        const r = n(8036);
        t.InferenceSession = r.InferenceSession;
      }, 7852: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
      }, 2350: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorToImageData = t.tensorToDataURL = void 0, t.tensorToDataURL = (e2, t2) => {
          const n = document.createElement("canvas");
          n.width = e2.dims[3], n.height = e2.dims[2];
          const r = n.getContext("2d");
          if (null != r) {
            let o, i;
            void 0 !== t2?.tensorLayout && "NHWC" === t2.tensorLayout ? (o = e2.dims[2], i = e2.dims[3]) : (o = e2.dims[3], i = e2.dims[2]);
            const a = void 0 !== t2?.format ? t2.format : "RGB", s = t2?.norm;
            let u, l;
            void 0 === s || void 0 === s.mean ? u = [255, 255, 255, 255] : "number" == typeof s.mean ? u = [s.mean, s.mean, s.mean, s.mean] : (u = [s.mean[0], s.mean[1], s.mean[2], 0], void 0 !== s.mean[3] && (u[3] = s.mean[3])), void 0 === s || void 0 === s.bias ? l = [0, 0, 0, 0] : "number" == typeof s.bias ? l = [s.bias, s.bias, s.bias, s.bias] : (l = [s.bias[0], s.bias[1], s.bias[2], 0], void 0 !== s.bias[3] && (l[3] = s.bias[3]));
            const c = i * o;
            let p = 0, d = c, f = 2 * c, h = -1;
            "RGBA" === a ? (p = 0, d = c, f = 2 * c, h = 3 * c) : "RGB" === a ? (p = 0, d = c, f = 2 * c) : "RBG" === a && (p = 0, f = c, d = 2 * c);
            for (let t3 = 0; t3 < i; t3++)
              for (let n2 = 0; n2 < o; n2++) {
                const o2 = (e2.data[p++] - l[0]) * u[0], i2 = (e2.data[d++] - l[1]) * u[1], a2 = (e2.data[f++] - l[2]) * u[2], s2 = -1 === h ? 255 : (e2.data[h++] - l[3]) * u[3];
                r.fillStyle = "rgba(" + o2 + "," + i2 + "," + a2 + "," + s2 + ")", r.fillRect(n2, t3, 1, 1);
              }
            return n.toDataURL();
          }
          throw new Error("Can not access image data");
        }, t.tensorToImageData = (e2, t2) => {
          const n = document.createElement("canvas").getContext("2d");
          let r;
          if (null == n)
            throw new Error("Can not access image data");
          {
            let o, i, a;
            void 0 !== t2?.tensorLayout && "NHWC" === t2.tensorLayout ? (o = e2.dims[2], i = e2.dims[1], a = e2.dims[3]) : (o = e2.dims[3], i = e2.dims[2], a = e2.dims[1]);
            const s = void 0 !== t2 && void 0 !== t2.format ? t2.format : "RGB", u = t2?.norm;
            let l, c;
            void 0 === u || void 0 === u.mean ? l = [255, 255, 255, 255] : "number" == typeof u.mean ? l = [u.mean, u.mean, u.mean, u.mean] : (l = [u.mean[0], u.mean[1], u.mean[2], 255], void 0 !== u.mean[3] && (l[3] = u.mean[3])), void 0 === u || void 0 === u.bias ? c = [0, 0, 0, 0] : "number" == typeof u.bias ? c = [u.bias, u.bias, u.bias, u.bias] : (c = [u.bias[0], u.bias[1], u.bias[2], 0], void 0 !== u.bias[3] && (c[3] = u.bias[3]));
            const p = i * o;
            if (void 0 !== t2 && (void 0 !== t2.format && 4 === a && "RGBA" !== t2.format || 3 === a && "RGB" !== t2.format && "BGR" !== t2.format))
              throw new Error("Tensor format doesn't match input tensor dims");
            const d = 4;
            let f = 0, h = 1, g = 2, b = 3, m = 0, y = p, v = 2 * p, _ = -1;
            "RGBA" === s ? (m = 0, y = p, v = 2 * p, _ = 3 * p) : "RGB" === s ? (m = 0, y = p, v = 2 * p) : "RBG" === s && (m = 0, v = p, y = 2 * p), r = n.createImageData(o, i);
            for (let t3 = 0; t3 < i * o; f += d, h += d, g += d, b += d, t3++)
              r.data[f] = (e2.data[m++] - c[0]) * l[0], r.data[h] = (e2.data[y++] - c[1]) * l[1], r.data[g] = (e2.data[v++] - c[2]) * l[2], r.data[b] = -1 === _ ? 255 : (e2.data[_++] - c[3]) * l[3];
          }
          return r;
        };
      }, 4866: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorFromImage = t.bufferToTensor = void 0;
        const r = n(963);
        t.bufferToTensor = (e2, t2) => {
          if (void 0 === e2)
            throw new Error("Image buffer must be defined");
          if (void 0 === t2.height || void 0 === t2.width)
            throw new Error("Image height and width must be defined");
          if ("NHWC" === t2.tensorLayout)
            throw new Error("NHWC Tensor layout is not supported yet");
          const { height: n2, width: o } = t2, i = t2.norm ?? { mean: 255, bias: 0 };
          let a, s;
          a = "number" == typeof i.mean ? [i.mean, i.mean, i.mean, i.mean] : [i.mean[0], i.mean[1], i.mean[2], i.mean[3] ?? 255], s = "number" == typeof i.bias ? [i.bias, i.bias, i.bias, i.bias] : [i.bias[0], i.bias[1], i.bias[2], i.bias[3] ?? 0];
          const u = void 0 !== t2.format ? t2.format : "RGBA", l = void 0 !== t2.tensorFormat && void 0 !== t2.tensorFormat ? t2.tensorFormat : "RGB", c = n2 * o, p = "RGBA" === l ? new Float32Array(4 * c) : new Float32Array(3 * c);
          let d = 4, f = 0, h = 1, g = 2, b = 3, m = 0, y = c, v = 2 * c, _ = -1;
          "RGB" === u && (d = 3, f = 0, h = 1, g = 2, b = -1), "RGBA" === l ? _ = 3 * c : "RBG" === l ? (m = 0, v = c, y = 2 * c) : "BGR" === l && (v = 0, y = c, m = 2 * c);
          for (let t3 = 0; t3 < c; t3++, f += d, g += d, h += d, b += d)
            p[m++] = (e2[f] + s[0]) / a[0], p[y++] = (e2[h] + s[1]) / a[1], p[v++] = (e2[g] + s[2]) / a[2], -1 !== _ && -1 !== b && (p[_++] = (e2[b] + s[3]) / a[3]);
          return "RGBA" === l ? new r.Tensor("float32", p, [1, 4, n2, o]) : new r.Tensor("float32", p, [1, 3, n2, o]);
        }, t.tensorFromImage = async (e2, n2) => {
          const r2 = "undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement, o = "undefined" != typeof ImageData && e2 instanceof ImageData, i = "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap, a = "string" == typeof e2;
          let s, u = n2 ?? {};
          if (r2) {
            const t2 = document.createElement("canvas");
            t2.width = e2.width, t2.height = e2.height;
            const r3 = t2.getContext("2d");
            if (null == r3)
              throw new Error("Can not access image data");
            {
              let t3 = e2.height, o2 = e2.width;
              if (void 0 !== n2 && void 0 !== n2.resizedHeight && void 0 !== n2.resizedWidth && (t3 = n2.resizedHeight, o2 = n2.resizedWidth), void 0 !== n2) {
                if (u = n2, void 0 !== n2.tensorFormat)
                  throw new Error("Image input config format must be RGBA for HTMLImageElement");
                u.tensorFormat = "RGBA", u.height = t3, u.width = o2;
              } else
                u.tensorFormat = "RGBA", u.height = t3, u.width = o2;
              r3.drawImage(e2, 0, 0), s = r3.getImageData(0, 0, o2, t3).data;
            }
          } else {
            if (!o) {
              if (i) {
                if (void 0 === n2)
                  throw new Error("Please provide image config with format for Imagebitmap");
                const r3 = document.createElement("canvas");
                r3.width = e2.width, r3.height = e2.height;
                const o2 = r3.getContext("2d");
                if (null != o2) {
                  const n3 = e2.height, r4 = e2.width;
                  return o2.drawImage(e2, 0, 0, r4, n3), s = o2.getImageData(0, 0, r4, n3).data, u.height = n3, u.width = r4, (0, t.bufferToTensor)(s, u);
                }
                throw new Error("Can not access image data");
              }
              if (a)
                return new Promise((n3, r3) => {
                  const o2 = document.createElement("canvas"), i2 = o2.getContext("2d");
                  if (!e2 || !i2)
                    return r3();
                  const a2 = new Image();
                  a2.crossOrigin = "Anonymous", a2.src = e2, a2.onload = () => {
                    o2.width = a2.width, o2.height = a2.height, i2.drawImage(a2, 0, 0, o2.width, o2.height);
                    const e3 = i2.getImageData(0, 0, o2.width, o2.height);
                    u.height = o2.height, u.width = o2.width, n3((0, t.bufferToTensor)(e3.data, u));
                  };
                });
              throw new Error("Input data provided is not supported - aborted tensor creation");
            }
            {
              let t2, r3;
              if (void 0 !== n2 && void 0 !== n2.resizedWidth && void 0 !== n2.resizedHeight ? (t2 = n2.resizedHeight, r3 = n2.resizedWidth) : (t2 = e2.height, r3 = e2.width), void 0 !== n2 && (u = n2), u.format = "RGBA", u.height = t2, u.width = r3, void 0 !== n2) {
                const n3 = document.createElement("canvas");
                n3.width = r3, n3.height = t2;
                const o2 = n3.getContext("2d");
                if (null == o2)
                  throw new Error("Can not access image data");
                o2.putImageData(e2, 0, 0), s = o2.getImageData(0, 0, r3, t2).data;
              } else
                s = e2.data;
            }
          }
          if (void 0 !== s)
            return (0, t.bufferToTensor)(s, u);
          throw new Error("Input data provided is not supported - aborted tensor creation");
        };
      }, 5957: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const r = n(2350), o = n(4866), i = n(106), a = /* @__PURE__ */ new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["float16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]]), s = /* @__PURE__ */ new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]);
        let u = false;
        t.Tensor = class {
          constructor(e2, t2, n2) {
            let r2, o2, l;
            if ((() => {
              if (!u) {
                u = true;
                const e3 = "undefined" != typeof BigInt64Array && "function" == typeof BigInt64Array.from, t3 = "undefined" != typeof BigUint64Array && "function" == typeof BigUint64Array.from;
                e3 && (a.set("int64", BigInt64Array), s.set(BigInt64Array, "int64")), t3 && (a.set("uint64", BigUint64Array), s.set(BigUint64Array, "uint64"));
              }
            })(), "string" == typeof e2)
              if (r2 = e2, l = n2, "string" === e2) {
                if (!Array.isArray(t2))
                  throw new TypeError("A string tensor's data must be a string array.");
                o2 = t2;
              } else {
                const n3 = a.get(e2);
                if (void 0 === n3)
                  throw new TypeError(`Unsupported tensor type: ${e2}.`);
                if (Array.isArray(t2)) {
                  if ("float16" === e2)
                    throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                  o2 = "uint64" === e2 || "int64" === e2 ? n3.from(t2, BigInt) : n3.from(t2);
                } else {
                  if (!(t2 instanceof n3))
                    throw new TypeError(`A ${r2} tensor's data must be type of ${n3}`);
                  o2 = t2;
                }
              }
            else if (l = t2, Array.isArray(e2)) {
              if (0 === e2.length)
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              const t3 = typeof e2[0];
              if ("string" === t3)
                r2 = "string", o2 = e2;
              else {
                if ("boolean" !== t3)
                  throw new TypeError(`Invalid element type of data array: ${t3}.`);
                r2 = "bool", o2 = Uint8Array.from(e2);
              }
            } else {
              const t3 = s.get(e2.constructor);
              if (void 0 === t3)
                throw new TypeError(`Unsupported type for tensor data: ${e2.constructor}.`);
              r2 = t3, o2 = e2;
            }
            if (void 0 === l)
              l = [o2.length];
            else if (!Array.isArray(l))
              throw new TypeError("A tensor's dims must be a number array");
            const c = (0, i.calculateSize)(l);
            if (c !== o2.length)
              throw new Error(`Tensor's size(${c}) does not match data length(${o2.length}).`);
            this.dims = l, this.type = r2, this.data = o2, this.size = c;
          }
          static async fromImage(e2, t2) {
            return (0, o.tensorFromImage)(e2, t2);
          }
          toDataURL(e2) {
            return (0, r.tensorToDataURL)(this, e2);
          }
          toImageData(e2) {
            return (0, r.tensorToImageData)(this, e2);
          }
          reshape(e2) {
            return (0, i.tensorReshape)(this, e2);
          }
        };
      }, 106: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorReshape = t.calculateSize = void 0;
        const r = n(963);
        t.calculateSize = (e2) => {
          let t2 = 1;
          for (let n2 = 0; n2 < e2.length; n2++) {
            const r2 = e2[n2];
            if ("number" != typeof r2 || !Number.isSafeInteger(r2))
              throw new TypeError(`dims[${n2}] must be an integer, got: ${r2}`);
            if (r2 < 0)
              throw new RangeError(`dims[${n2}] must be a non-negative integer, got: ${r2}`);
            t2 *= r2;
          }
          return t2;
        }, t.tensorReshape = (e2, t2) => new r.Tensor(e2.type, e2.data, t2);
      }, 963: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const r = n(5957);
        t.Tensor = r.Tensor;
      }, 9104: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.version = void 0, t.version = "1.16.3";
      }, 1583: (e, t) => {
        var n, r = function(e2) {
          "use strict";
          Object.defineProperty(e2, "__esModule", { value: true }), e2.default = void 0;
          var t2 = null;
          try {
            t2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
          } catch (e3) {
          }
          function n2(e3, t3, n3) {
            this.low = 0 | e3, this.high = 0 | t3, this.unsigned = !!n3;
          }
          function r2(e3) {
            return true === (e3 && e3.__isLong__);
          }
          function o(e3) {
            var t3 = Math.clz32(e3 & -e3);
            return e3 ? 31 - t3 : t3;
          }
          n2.prototype.__isLong__, Object.defineProperty(n2.prototype, "__isLong__", { value: true }), n2.isLong = r2;
          var i = {}, a = {};
          function s(e3, t3) {
            var n3, r3, o2;
            return t3 ? (o2 = 0 <= (e3 >>>= 0) && e3 < 256) && (r3 = a[e3]) ? r3 : (n3 = l(e3, 0, true), o2 && (a[e3] = n3), n3) : (o2 = -128 <= (e3 |= 0) && e3 < 128) && (r3 = i[e3]) ? r3 : (n3 = l(e3, e3 < 0 ? -1 : 0, false), o2 && (i[e3] = n3), n3);
          }
          function u(e3, t3) {
            if (isNaN(e3))
              return t3 ? y : m;
            if (t3) {
              if (e3 < 0)
                return y;
              if (e3 >= h)
                return x;
            } else {
              if (e3 <= -g)
                return O;
              if (e3 + 1 >= g)
                return T;
            }
            return e3 < 0 ? u(-e3, t3).neg() : l(e3 % f | 0, e3 / f | 0, t3);
          }
          function l(e3, t3, r3) {
            return new n2(e3, t3, r3);
          }
          n2.fromInt = s, n2.fromNumber = u, n2.fromBits = l;
          var c = Math.pow;
          function p(e3, t3, n3) {
            if (0 === e3.length)
              throw Error("empty string");
            if ("number" == typeof t3 ? (n3 = t3, t3 = false) : t3 = !!t3, "NaN" === e3 || "Infinity" === e3 || "+Infinity" === e3 || "-Infinity" === e3)
              return t3 ? y : m;
            if ((n3 = n3 || 10) < 2 || 36 < n3)
              throw RangeError("radix");
            var r3;
            if ((r3 = e3.indexOf("-")) > 0)
              throw Error("interior hyphen");
            if (0 === r3)
              return p(e3.substring(1), t3, n3).neg();
            for (var o2 = u(c(n3, 8)), i2 = m, a2 = 0; a2 < e3.length; a2 += 8) {
              var s2 = Math.min(8, e3.length - a2), l2 = parseInt(e3.substring(a2, a2 + s2), n3);
              if (s2 < 8) {
                var d2 = u(c(n3, s2));
                i2 = i2.mul(d2).add(u(l2));
              } else
                i2 = (i2 = i2.mul(o2)).add(u(l2));
            }
            return i2.unsigned = t3, i2;
          }
          function d(e3, t3) {
            return "number" == typeof e3 ? u(e3, t3) : "string" == typeof e3 ? p(e3, t3) : l(e3.low, e3.high, "boolean" == typeof t3 ? t3 : e3.unsigned);
          }
          n2.fromString = p, n2.fromValue = d;
          var f = 4294967296, h = f * f, g = h / 2, b = s(1 << 24), m = s(0);
          n2.ZERO = m;
          var y = s(0, true);
          n2.UZERO = y;
          var v = s(1);
          n2.ONE = v;
          var _ = s(1, true);
          n2.UONE = _;
          var w = s(-1);
          n2.NEG_ONE = w;
          var T = l(-1, 2147483647, false);
          n2.MAX_VALUE = T;
          var x = l(-1, -1, true);
          n2.MAX_UNSIGNED_VALUE = x;
          var O = l(0, -2147483648, false);
          n2.MIN_VALUE = O;
          var S = n2.prototype;
          S.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }, S.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);
          }, S.toString = function(e3) {
            if ((e3 = e3 || 10) < 2 || 36 < e3)
              throw RangeError("radix");
            if (this.isZero())
              return "0";
            if (this.isNegative()) {
              if (this.eq(O)) {
                var t3 = u(e3), n3 = this.div(t3), r3 = n3.mul(t3).sub(this);
                return n3.toString(e3) + r3.toInt().toString(e3);
              }
              return "-" + this.neg().toString(e3);
            }
            for (var o2 = u(c(e3, 6), this.unsigned), i2 = this, a2 = ""; ; ) {
              var s2 = i2.div(o2), l2 = (i2.sub(s2.mul(o2)).toInt() >>> 0).toString(e3);
              if ((i2 = s2).isZero())
                return l2 + a2;
              for (; l2.length < 6; )
                l2 = "0" + l2;
              a2 = "" + l2 + a2;
            }
          }, S.getHighBits = function() {
            return this.high;
          }, S.getHighBitsUnsigned = function() {
            return this.high >>> 0;
          }, S.getLowBits = function() {
            return this.low;
          }, S.getLowBitsUnsigned = function() {
            return this.low >>> 0;
          }, S.getNumBitsAbs = function() {
            if (this.isNegative())
              return this.eq(O) ? 64 : this.neg().getNumBitsAbs();
            for (var e3 = 0 != this.high ? this.high : this.low, t3 = 31; t3 > 0 && 0 == (e3 & 1 << t3); t3--)
              ;
            return 0 != this.high ? t3 + 33 : t3 + 1;
          }, S.isZero = function() {
            return 0 === this.high && 0 === this.low;
          }, S.eqz = S.isZero, S.isNegative = function() {
            return !this.unsigned && this.high < 0;
          }, S.isPositive = function() {
            return this.unsigned || this.high >= 0;
          }, S.isOdd = function() {
            return 1 == (1 & this.low);
          }, S.isEven = function() {
            return 0 == (1 & this.low);
          }, S.equals = function(e3) {
            return r2(e3) || (e3 = d(e3)), (this.unsigned === e3.unsigned || this.high >>> 31 != 1 || e3.high >>> 31 != 1) && this.high === e3.high && this.low === e3.low;
          }, S.eq = S.equals, S.notEquals = function(e3) {
            return !this.eq(e3);
          }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(e3) {
            return this.comp(e3) < 0;
          }, S.lt = S.lessThan, S.lessThanOrEqual = function(e3) {
            return this.comp(e3) <= 0;
          }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(e3) {
            return this.comp(e3) > 0;
          }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(e3) {
            return this.comp(e3) >= 0;
          }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(e3) {
            if (r2(e3) || (e3 = d(e3)), this.eq(e3))
              return 0;
            var t3 = this.isNegative(), n3 = e3.isNegative();
            return t3 && !n3 ? -1 : !t3 && n3 ? 1 : this.unsigned ? e3.high >>> 0 > this.high >>> 0 || e3.high === this.high && e3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e3).isNegative() ? -1 : 1;
          }, S.comp = S.compare, S.negate = function() {
            return !this.unsigned && this.eq(O) ? O : this.not().add(v);
          }, S.neg = S.negate, S.add = function(e3) {
            r2(e3) || (e3 = d(e3));
            var t3 = this.high >>> 16, n3 = 65535 & this.high, o2 = this.low >>> 16, i2 = 65535 & this.low, a2 = e3.high >>> 16, s2 = 65535 & e3.high, u2 = e3.low >>> 16, c2 = 0, p2 = 0, f2 = 0, h2 = 0;
            return f2 += (h2 += i2 + (65535 & e3.low)) >>> 16, p2 += (f2 += o2 + u2) >>> 16, c2 += (p2 += n3 + s2) >>> 16, c2 += t3 + a2, l((f2 &= 65535) << 16 | (h2 &= 65535), (c2 &= 65535) << 16 | (p2 &= 65535), this.unsigned);
          }, S.subtract = function(e3) {
            return r2(e3) || (e3 = d(e3)), this.add(e3.neg());
          }, S.sub = S.subtract, S.multiply = function(e3) {
            if (this.isZero())
              return this;
            if (r2(e3) || (e3 = d(e3)), t2)
              return l(t2.mul(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned);
            if (e3.isZero())
              return this.unsigned ? y : m;
            if (this.eq(O))
              return e3.isOdd() ? O : m;
            if (e3.eq(O))
              return this.isOdd() ? O : m;
            if (this.isNegative())
              return e3.isNegative() ? this.neg().mul(e3.neg()) : this.neg().mul(e3).neg();
            if (e3.isNegative())
              return this.mul(e3.neg()).neg();
            if (this.lt(b) && e3.lt(b))
              return u(this.toNumber() * e3.toNumber(), this.unsigned);
            var n3 = this.high >>> 16, o2 = 65535 & this.high, i2 = this.low >>> 16, a2 = 65535 & this.low, s2 = e3.high >>> 16, c2 = 65535 & e3.high, p2 = e3.low >>> 16, f2 = 65535 & e3.low, h2 = 0, g2 = 0, v2 = 0, _2 = 0;
            return v2 += (_2 += a2 * f2) >>> 16, g2 += (v2 += i2 * f2) >>> 16, v2 &= 65535, g2 += (v2 += a2 * p2) >>> 16, h2 += (g2 += o2 * f2) >>> 16, g2 &= 65535, h2 += (g2 += i2 * p2) >>> 16, g2 &= 65535, h2 += (g2 += a2 * c2) >>> 16, h2 += n3 * f2 + o2 * p2 + i2 * c2 + a2 * s2, l((v2 &= 65535) << 16 | (_2 &= 65535), (h2 &= 65535) << 16 | (g2 &= 65535), this.unsigned);
          }, S.mul = S.multiply, S.divide = function(e3) {
            if (r2(e3) || (e3 = d(e3)), e3.isZero())
              throw Error("division by zero");
            var n3, o2, i2;
            if (t2)
              return this.unsigned || -2147483648 !== this.high || -1 !== e3.low || -1 !== e3.high ? l((this.unsigned ? t2.div_u : t2.div_s)(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned) : this;
            if (this.isZero())
              return this.unsigned ? y : m;
            if (this.unsigned) {
              if (e3.unsigned || (e3 = e3.toUnsigned()), e3.gt(this))
                return y;
              if (e3.gt(this.shru(1)))
                return _;
              i2 = y;
            } else {
              if (this.eq(O))
                return e3.eq(v) || e3.eq(w) ? O : e3.eq(O) ? v : (n3 = this.shr(1).div(e3).shl(1)).eq(m) ? e3.isNegative() ? v : w : (o2 = this.sub(e3.mul(n3)), i2 = n3.add(o2.div(e3)));
              if (e3.eq(O))
                return this.unsigned ? y : m;
              if (this.isNegative())
                return e3.isNegative() ? this.neg().div(e3.neg()) : this.neg().div(e3).neg();
              if (e3.isNegative())
                return this.div(e3.neg()).neg();
              i2 = m;
            }
            for (o2 = this; o2.gte(e3); ) {
              n3 = Math.max(1, Math.floor(o2.toNumber() / e3.toNumber()));
              for (var a2 = Math.ceil(Math.log(n3) / Math.LN2), s2 = a2 <= 48 ? 1 : c(2, a2 - 48), p2 = u(n3), f2 = p2.mul(e3); f2.isNegative() || f2.gt(o2); )
                f2 = (p2 = u(n3 -= s2, this.unsigned)).mul(e3);
              p2.isZero() && (p2 = v), i2 = i2.add(p2), o2 = o2.sub(f2);
            }
            return i2;
          }, S.div = S.divide, S.modulo = function(e3) {
            return r2(e3) || (e3 = d(e3)), t2 ? l((this.unsigned ? t2.rem_u : t2.rem_s)(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned) : this.sub(this.div(e3).mul(e3));
          }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {
            return l(~this.low, ~this.high, this.unsigned);
          }, S.countLeadingZeros = function() {
            return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
          }, S.clz = S.countLeadingZeros, S.countTrailingZeros = function() {
            return this.low ? o(this.low) : o(this.high) + 32;
          }, S.ctz = S.countTrailingZeros, S.and = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low & e3.low, this.high & e3.high, this.unsigned);
          }, S.or = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low | e3.low, this.high | e3.high, this.unsigned);
          }, S.xor = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low ^ e3.low, this.high ^ e3.high, this.unsigned);
          }, S.shiftLeft = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low << e3, this.high << e3 | this.low >>> 32 - e3, this.unsigned) : l(0, this.low << e3 - 32, this.unsigned);
          }, S.shl = S.shiftLeft, S.shiftRight = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low >>> e3 | this.high << 32 - e3, this.high >> e3, this.unsigned) : l(this.high >> e3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low >>> e3 | this.high << 32 - e3, this.high >>> e3, this.unsigned) : l(32 === e3 ? this.high : this.high >>> e3 - 32, 0, this.unsigned);
          }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.rotateLeft = function(e3) {
            var t3;
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : 32 === e3 ? l(this.high, this.low, this.unsigned) : e3 < 32 ? (t3 = 32 - e3, l(this.low << e3 | this.high >>> t3, this.high << e3 | this.low >>> t3, this.unsigned)) : (t3 = 32 - (e3 -= 32), l(this.high << e3 | this.low >>> t3, this.low << e3 | this.high >>> t3, this.unsigned));
          }, S.rotl = S.rotateLeft, S.rotateRight = function(e3) {
            var t3;
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : 32 === e3 ? l(this.high, this.low, this.unsigned) : e3 < 32 ? (t3 = 32 - e3, l(this.high << t3 | this.low >>> e3, this.low << t3 | this.high >>> e3, this.unsigned)) : (t3 = 32 - (e3 -= 32), l(this.low << t3 | this.high >>> e3, this.high << t3 | this.low >>> e3, this.unsigned));
          }, S.rotr = S.rotateRight, S.toSigned = function() {
            return this.unsigned ? l(this.low, this.high, false) : this;
          }, S.toUnsigned = function() {
            return this.unsigned ? this : l(this.low, this.high, true);
          }, S.toBytes = function(e3) {
            return e3 ? this.toBytesLE() : this.toBytesBE();
          }, S.toBytesLE = function() {
            var e3 = this.high, t3 = this.low;
            return [255 & t3, t3 >>> 8 & 255, t3 >>> 16 & 255, t3 >>> 24, 255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24];
          }, S.toBytesBE = function() {
            var e3 = this.high, t3 = this.low;
            return [e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3, t3 >>> 24, t3 >>> 16 & 255, t3 >>> 8 & 255, 255 & t3];
          }, n2.fromBytes = function(e3, t3, r3) {
            return r3 ? n2.fromBytesLE(e3, t3) : n2.fromBytesBE(e3, t3);
          }, n2.fromBytesLE = function(e3, t3) {
            return new n2(e3[0] | e3[1] << 8 | e3[2] << 16 | e3[3] << 24, e3[4] | e3[5] << 8 | e3[6] << 16 | e3[7] << 24, t3);
          }, n2.fromBytesBE = function(e3, t3) {
            return new n2(e3[4] << 24 | e3[5] << 16 | e3[6] << 8 | e3[7], e3[0] << 24 | e3[1] << 16 | e3[2] << 8 | e3[3], t3);
          };
          var A = n2;
          return e2.default = A, "default" in e2 ? e2.default : e2;
        }({});
        void 0 === (n = function() {
          return r;
        }.apply(t, [])) || (e.exports = n);
      }, 5686: (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { flatbuffers: () => r });
        var r = {};
        r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function(e2, t2) {
          this.low = 0 | e2, this.high = 0 | t2;
        }, r.Long.create = function(e2, t2) {
          return 0 == e2 && 0 == t2 ? r.Long.ZERO : new r.Long(e2, t2);
        }, r.Long.prototype.toFloat64 = function() {
          return (this.low >>> 0) + 4294967296 * this.high;
        }, r.Long.prototype.equals = function(e2) {
          return this.low == e2.low && this.high == e2.high;
        }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(e2) {
          if (e2)
            t2 = e2;
          else
            var t2 = 1024;
          this.bb = r.ByteBuffer.allocate(t2), this.space = t2, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        }, r.Builder.prototype.clear = function() {
          this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        }, r.Builder.prototype.forceDefaults = function(e2) {
          this.force_defaults = e2;
        }, r.Builder.prototype.dataBuffer = function() {
          return this.bb;
        }, r.Builder.prototype.asUint8Array = function() {
          return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
        }, r.Builder.prototype.prep = function(e2, t2) {
          e2 > this.minalign && (this.minalign = e2);
          for (var n2 = 1 + ~(this.bb.capacity() - this.space + t2) & e2 - 1; this.space < n2 + e2 + t2; ) {
            var o = this.bb.capacity();
            this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - o;
          }
          this.pad(n2);
        }, r.Builder.prototype.pad = function(e2) {
          for (var t2 = 0; t2 < e2; t2++)
            this.bb.writeInt8(--this.space, 0);
        }, r.Builder.prototype.writeInt8 = function(e2) {
          this.bb.writeInt8(this.space -= 1, e2);
        }, r.Builder.prototype.writeInt16 = function(e2) {
          this.bb.writeInt16(this.space -= 2, e2);
        }, r.Builder.prototype.writeInt32 = function(e2) {
          this.bb.writeInt32(this.space -= 4, e2);
        }, r.Builder.prototype.writeInt64 = function(e2) {
          this.bb.writeInt64(this.space -= 8, e2);
        }, r.Builder.prototype.writeFloat32 = function(e2) {
          this.bb.writeFloat32(this.space -= 4, e2);
        }, r.Builder.prototype.writeFloat64 = function(e2) {
          this.bb.writeFloat64(this.space -= 8, e2);
        }, r.Builder.prototype.addInt8 = function(e2) {
          this.prep(1, 0), this.writeInt8(e2);
        }, r.Builder.prototype.addInt16 = function(e2) {
          this.prep(2, 0), this.writeInt16(e2);
        }, r.Builder.prototype.addInt32 = function(e2) {
          this.prep(4, 0), this.writeInt32(e2);
        }, r.Builder.prototype.addInt64 = function(e2) {
          this.prep(8, 0), this.writeInt64(e2);
        }, r.Builder.prototype.addFloat32 = function(e2) {
          this.prep(4, 0), this.writeFloat32(e2);
        }, r.Builder.prototype.addFloat64 = function(e2) {
          this.prep(8, 0), this.writeFloat64(e2);
        }, r.Builder.prototype.addFieldInt8 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt8(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt16 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt16(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt32 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt32(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt64 = function(e2, t2, n2) {
          !this.force_defaults && t2.equals(n2) || (this.addInt64(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldFloat32 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addFloat32(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldFloat64 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addFloat64(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldOffset = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addOffset(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldStruct = function(e2, t2, n2) {
          t2 != n2 && (this.nested(t2), this.slot(e2));
        }, r.Builder.prototype.nested = function(e2) {
          if (e2 != this.offset())
            throw new Error("FlatBuffers: struct must be serialized inline.");
        }, r.Builder.prototype.notNested = function() {
          if (this.isNested)
            throw new Error("FlatBuffers: object serialization must not be nested.");
        }, r.Builder.prototype.slot = function(e2) {
          this.vtable[e2] = this.offset();
        }, r.Builder.prototype.offset = function() {
          return this.bb.capacity() - this.space;
        }, r.Builder.growByteBuffer = function(e2) {
          var t2 = e2.capacity();
          if (3221225472 & t2)
            throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
          var n2 = t2 << 1, o = r.ByteBuffer.allocate(n2);
          return o.setPosition(n2 - t2), o.bytes().set(e2.bytes(), n2 - t2), o;
        }, r.Builder.prototype.addOffset = function(e2) {
          this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - e2 + r.SIZEOF_INT);
        }, r.Builder.prototype.startObject = function(e2) {
          this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = e2;
          for (var t2 = 0; t2 < e2; t2++)
            this.vtable[t2] = 0;
          this.isNested = true, this.object_start = this.offset();
        }, r.Builder.prototype.endObject = function() {
          if (null == this.vtable || !this.isNested)
            throw new Error("FlatBuffers: endObject called without startObject");
          this.addInt32(0);
          for (var e2 = this.offset(), t2 = this.vtable_in_use - 1; t2 >= 0 && 0 == this.vtable[t2]; t2--)
            ;
          for (var n2 = t2 + 1; t2 >= 0; t2--)
            this.addInt16(0 != this.vtable[t2] ? e2 - this.vtable[t2] : 0);
          this.addInt16(e2 - this.object_start);
          var o = (n2 + 2) * r.SIZEOF_SHORT;
          this.addInt16(o);
          var i = 0, a = this.space;
          e:
            for (t2 = 0; t2 < this.vtables.length; t2++) {
              var s = this.bb.capacity() - this.vtables[t2];
              if (o == this.bb.readInt16(s)) {
                for (var u = r.SIZEOF_SHORT; u < o; u += r.SIZEOF_SHORT)
                  if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u))
                    continue e;
                i = this.vtables[t2];
                break;
              }
            }
          return i ? (this.space = this.bb.capacity() - e2, this.bb.writeInt32(this.space, i - e2)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e2, this.offset() - e2)), this.isNested = false, e2;
        }, r.Builder.prototype.finish = function(e2, t2, n2) {
          var o = n2 ? r.SIZE_PREFIX_LENGTH : 0;
          if (t2) {
            var i = t2;
            if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + o), i.length != r.FILE_IDENTIFIER_LENGTH)
              throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
            for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--)
              this.writeInt8(i.charCodeAt(a));
          }
          this.prep(this.minalign, r.SIZEOF_INT + o), this.addOffset(e2), o && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
        }, r.Builder.prototype.finishSizePrefixed = function(e2, t2) {
          this.finish(e2, t2, true);
        }, r.Builder.prototype.requiredField = function(e2, t2) {
          var n2 = this.bb.capacity() - e2, r2 = n2 - this.bb.readInt32(n2);
          if (0 == this.bb.readInt16(r2 + t2))
            throw new Error("FlatBuffers: field " + t2 + " must be set");
        }, r.Builder.prototype.startVector = function(e2, t2, n2) {
          this.notNested(), this.vector_num_elems = t2, this.prep(r.SIZEOF_INT, e2 * t2), this.prep(n2, e2 * t2);
        }, r.Builder.prototype.endVector = function() {
          return this.writeInt32(this.vector_num_elems), this.offset();
        }, r.Builder.prototype.createString = function(e2) {
          if (e2 instanceof Uint8Array)
            var t2 = e2;
          else {
            t2 = [];
            for (var n2 = 0; n2 < e2.length; ) {
              var r2, o = e2.charCodeAt(n2++);
              (r2 = o < 55296 || o >= 56320 ? o : (o << 10) + e2.charCodeAt(n2++) + -56613888) < 128 ? t2.push(r2) : (r2 < 2048 ? t2.push(r2 >> 6 & 31 | 192) : (r2 < 65536 ? t2.push(r2 >> 12 & 15 | 224) : t2.push(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128), t2.push(r2 >> 6 & 63 | 128)), t2.push(63 & r2 | 128));
            }
          }
          this.addInt8(0), this.startVector(1, t2.length, 1), this.bb.setPosition(this.space -= t2.length), n2 = 0;
          for (var i = this.space, a = this.bb.bytes(); n2 < t2.length; n2++)
            a[i++] = t2[n2];
          return this.endVector();
        }, r.Builder.prototype.createLong = function(e2, t2) {
          return r.Long.create(e2, t2);
        }, r.ByteBuffer = function(e2) {
          this.bytes_ = e2, this.position_ = 0;
        }, r.ByteBuffer.allocate = function(e2) {
          return new r.ByteBuffer(new Uint8Array(e2));
        }, r.ByteBuffer.prototype.clear = function() {
          this.position_ = 0;
        }, r.ByteBuffer.prototype.bytes = function() {
          return this.bytes_;
        }, r.ByteBuffer.prototype.position = function() {
          return this.position_;
        }, r.ByteBuffer.prototype.setPosition = function(e2) {
          this.position_ = e2;
        }, r.ByteBuffer.prototype.capacity = function() {
          return this.bytes_.length;
        }, r.ByteBuffer.prototype.readInt8 = function(e2) {
          return this.readUint8(e2) << 24 >> 24;
        }, r.ByteBuffer.prototype.readUint8 = function(e2) {
          return this.bytes_[e2];
        }, r.ByteBuffer.prototype.readInt16 = function(e2) {
          return this.readUint16(e2) << 16 >> 16;
        }, r.ByteBuffer.prototype.readUint16 = function(e2) {
          return this.bytes_[e2] | this.bytes_[e2 + 1] << 8;
        }, r.ByteBuffer.prototype.readInt32 = function(e2) {
          return this.bytes_[e2] | this.bytes_[e2 + 1] << 8 | this.bytes_[e2 + 2] << 16 | this.bytes_[e2 + 3] << 24;
        }, r.ByteBuffer.prototype.readUint32 = function(e2) {
          return this.readInt32(e2) >>> 0;
        }, r.ByteBuffer.prototype.readInt64 = function(e2) {
          return new r.Long(this.readInt32(e2), this.readInt32(e2 + 4));
        }, r.ByteBuffer.prototype.readUint64 = function(e2) {
          return new r.Long(this.readUint32(e2), this.readUint32(e2 + 4));
        }, r.ByteBuffer.prototype.readFloat32 = function(e2) {
          return r.int32[0] = this.readInt32(e2), r.float32[0];
        }, r.ByteBuffer.prototype.readFloat64 = function(e2) {
          return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(e2), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(e2 + 4), r.float64[0];
        }, r.ByteBuffer.prototype.writeInt8 = function(e2, t2) {
          this.bytes_[e2] = t2;
        }, r.ByteBuffer.prototype.writeUint8 = function(e2, t2) {
          this.bytes_[e2] = t2;
        }, r.ByteBuffer.prototype.writeInt16 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8;
        }, r.ByteBuffer.prototype.writeUint16 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8;
        }, r.ByteBuffer.prototype.writeInt32 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8, this.bytes_[e2 + 2] = t2 >> 16, this.bytes_[e2 + 3] = t2 >> 24;
        }, r.ByteBuffer.prototype.writeUint32 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8, this.bytes_[e2 + 2] = t2 >> 16, this.bytes_[e2 + 3] = t2 >> 24;
        }, r.ByteBuffer.prototype.writeInt64 = function(e2, t2) {
          this.writeInt32(e2, t2.low), this.writeInt32(e2 + 4, t2.high);
        }, r.ByteBuffer.prototype.writeUint64 = function(e2, t2) {
          this.writeUint32(e2, t2.low), this.writeUint32(e2 + 4, t2.high);
        }, r.ByteBuffer.prototype.writeFloat32 = function(e2, t2) {
          r.float32[0] = t2, this.writeInt32(e2, r.int32[0]);
        }, r.ByteBuffer.prototype.writeFloat64 = function(e2, t2) {
          r.float64[0] = t2, this.writeInt32(e2, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(e2 + 4, r.int32[r.isLittleEndian ? 1 : 0]);
        }, r.ByteBuffer.prototype.getBufferIdentifier = function() {
          if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
          for (var e2 = "", t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++)
            e2 += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + t2));
          return e2;
        }, r.ByteBuffer.prototype.__offset = function(e2, t2) {
          var n2 = e2 - this.readInt32(e2);
          return t2 < this.readInt16(n2) ? this.readInt16(n2 + t2) : 0;
        }, r.ByteBuffer.prototype.__union = function(e2, t2) {
          return e2.bb_pos = t2 + this.readInt32(t2), e2.bb = this, e2;
        }, r.ByteBuffer.prototype.__string = function(e2, t2) {
          e2 += this.readInt32(e2);
          var n2 = this.readInt32(e2), o = "", i = 0;
          if (e2 += r.SIZEOF_INT, t2 === r.Encoding.UTF8_BYTES)
            return this.bytes_.subarray(e2, e2 + n2);
          for (; i < n2; ) {
            var a, s = this.readUint8(e2 + i++);
            if (s < 192)
              a = s;
            else {
              var u = this.readUint8(e2 + i++);
              if (s < 224)
                a = (31 & s) << 6 | 63 & u;
              else {
                var l = this.readUint8(e2 + i++);
                a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & l : (7 & s) << 18 | (63 & u) << 12 | (63 & l) << 6 | 63 & this.readUint8(e2 + i++);
              }
            }
            a < 65536 ? o += String.fromCharCode(a) : (a -= 65536, o += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));
          }
          return o;
        }, r.ByteBuffer.prototype.__indirect = function(e2) {
          return e2 + this.readInt32(e2);
        }, r.ByteBuffer.prototype.__vector = function(e2) {
          return e2 + this.readInt32(e2) + r.SIZEOF_INT;
        }, r.ByteBuffer.prototype.__vector_len = function(e2) {
          return this.readInt32(e2 + this.readInt32(e2));
        }, r.ByteBuffer.prototype.__has_identifier = function(e2) {
          if (e2.length != r.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
          for (var t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++)
            if (e2.charCodeAt(t2) != this.readInt8(this.position_ + r.SIZEOF_INT + t2))
              return false;
          return true;
        }, r.ByteBuffer.prototype.createLong = function(e2, t2) {
          return r.Long.create(e2, t2);
        };
      } }, __webpack_module_cache__ = {};
      function __webpack_require__(e) {
        var t = __webpack_module_cache__[e];
        if (void 0 !== t)
          return t.exports;
        var n = __webpack_module_cache__[e] = { exports: {} };
        return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.exports;
      }
      __webpack_require__.n = (e) => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return __webpack_require__.d(t, { a: t }), t;
      }, __webpack_require__.d = (e, t) => {
        for (var n in t)
          __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, { enumerable: true, get: t[n] });
      }, __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = (e) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: true });
      };
      var __webpack_exports__ = __webpack_require__(1057);
      return __webpack_exports__;
    })());
  }
});

// node_modules/onnxruntime-web/dist/ort.webgpu.min.js
var require_ort_webgpu_min = __commonJS({
  "node_modules/onnxruntime-web/dist/ort.webgpu.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.ort = t() : e.ort = t();
    }(self, () => (() => {
      var __webpack_modules__ = { 5716: (e, t, n) => {
        "use strict";
        t.R = void 0;
        const r = n(6027), i = n(1723);
        t.R = new class {
          async init() {
          }
          async createSessionHandler(e2, t2) {
            const n2 = new r.Session(t2);
            return await n2.loadModel(e2), new i.OnnxjsSessionHandler(n2);
          }
        }();
      }, 2818: (e, t, n) => {
        "use strict";
        t.c8 = t.rX = void 0;
        const r = n(2235), i = n(5381), o = n(9544), a = n(6640);
        t.rX = () => {
          if (("number" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), "boolean" != typeof r.env.wasm.simd && (r.env.wasm.simd = true), "boolean" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = false), "number" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {
            const e2 = "undefined" == typeof navigator ? (0, i.cpus)().length : navigator.hardwareConcurrency;
            r.env.wasm.numThreads = Math.min(4, Math.ceil((e2 || 1) / 2));
          }
        }, t.c8 = new class {
          async init() {
            (0, t.rX)(), await (0, o.initializeWebAssemblyInstance)();
          }
          async createSessionHandler(e2, t2) {
            const n2 = new a.OnnxruntimeWebAssemblySessionHandler();
            return await n2.loadModel(e2, t2), Promise.resolve(n2);
          }
        }();
      }, 1057: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var i2 = Object.getOwnPropertyDescriptor(t2, n2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, i2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__exportStar || function(e2, t2) {
          for (var n2 in e2)
            "default" === n2 || Object.prototype.hasOwnProperty.call(t2, n2) || r(t2, e2, n2);
        };
        Object.defineProperty(t, "__esModule", { value: true }), i(n(2235), t);
        const o = n(2235), a = n(8408);
        {
          const e2 = n(5716).R;
          (0, o.registerBackend)("webgl", e2, -10);
        }
        {
          const e2 = n(2818).c8;
          "undefined" != typeof navigator && navigator.gpu && (0, o.registerBackend)("webgpu", e2, 5), (0, o.registerBackend)("cpu", e2, 10), (0, o.registerBackend)("wasm", e2, 10), (0, o.registerBackend)("xnnpack", e2, 9), (0, o.registerBackend)("webnn", e2, 9);
        }
        o.env.versions.web = a.version;
      }, 4910: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createAttributeWithCacheKey = void 0;
        class n {
          constructor(e2) {
            Object.assign(this, e2);
          }
          get cacheKey() {
            return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((e2) => `${this[e2]}`).join(";")), this._cacheKey;
          }
        }
        t.createAttributeWithCacheKey = (e2) => new n(e2);
      }, 6874: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Attribute = void 0;
        const r = n(5127), i = n(2446), o = n(9240), a = n(7273);
        var s = r.onnxruntime.experimental.fbs;
        class u {
          constructor(e2) {
            if (this._attributes = /* @__PURE__ */ new Map(), null != e2) {
              for (const t2 of e2)
                t2 instanceof i.onnx.AttributeProto ? this._attributes.set(t2.name, [u.getValue(t2), u.getType(t2)]) : t2 instanceof s.Attribute && this._attributes.set(t2.name(), [u.getValue(t2), u.getType(t2)]);
              if (this._attributes.size < e2.length)
                throw new Error("duplicated attribute names");
            }
          }
          set(e2, t2, n2) {
            this._attributes.set(e2, [n2, t2]);
          }
          delete(e2) {
            this._attributes.delete(e2);
          }
          getFloat(e2, t2) {
            return this.get(e2, "float", t2);
          }
          getInt(e2, t2) {
            return this.get(e2, "int", t2);
          }
          getString(e2, t2) {
            return this.get(e2, "string", t2);
          }
          getTensor(e2, t2) {
            return this.get(e2, "tensor", t2);
          }
          getFloats(e2, t2) {
            return this.get(e2, "floats", t2);
          }
          getInts(e2, t2) {
            return this.get(e2, "ints", t2);
          }
          getStrings(e2, t2) {
            return this.get(e2, "strings", t2);
          }
          getTensors(e2, t2) {
            return this.get(e2, "tensors", t2);
          }
          get(e2, t2, n2) {
            const r2 = this._attributes.get(e2);
            if (void 0 === r2) {
              if (void 0 !== n2)
                return n2;
              throw new Error(`required attribute not found: ${e2}`);
            }
            if (r2[1] !== t2)
              throw new Error(`type mismatch: expected ${t2} but got ${r2[1]}`);
            return r2[0];
          }
          static getType(e2) {
            const t2 = e2 instanceof i.onnx.AttributeProto ? e2.type : e2.type();
            switch (t2) {
              case i.onnx.AttributeProto.AttributeType.FLOAT:
                return "float";
              case i.onnx.AttributeProto.AttributeType.INT:
                return "int";
              case i.onnx.AttributeProto.AttributeType.STRING:
                return "string";
              case i.onnx.AttributeProto.AttributeType.TENSOR:
                return "tensor";
              case i.onnx.AttributeProto.AttributeType.FLOATS:
                return "floats";
              case i.onnx.AttributeProto.AttributeType.INTS:
                return "ints";
              case i.onnx.AttributeProto.AttributeType.STRINGS:
                return "strings";
              case i.onnx.AttributeProto.AttributeType.TENSORS:
                return "tensors";
              default:
                throw new Error(`attribute type is not supported yet: ${i.onnx.AttributeProto.AttributeType[t2]}`);
            }
          }
          static getValue(e2) {
            const t2 = e2 instanceof i.onnx.AttributeProto ? e2.type : e2.type();
            if (t2 === i.onnx.AttributeProto.AttributeType.GRAPH || t2 === i.onnx.AttributeProto.AttributeType.GRAPHS)
              throw new Error("graph attribute is not supported yet");
            const n2 = this.getValueNoCheck(e2);
            if (t2 === i.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n2))
              return a.LongUtil.longToNumber(n2);
            if (t2 === i.onnx.AttributeProto.AttributeType.INTS) {
              const e3 = n2, t3 = new Array(e3.length);
              for (let n3 = 0; n3 < e3.length; n3++) {
                const r2 = e3[n3];
                t3[n3] = a.LongUtil.longToNumber(r2);
              }
              return t3;
            }
            if (t2 === i.onnx.AttributeProto.AttributeType.TENSOR)
              return e2 instanceof i.onnx.AttributeProto ? o.Tensor.fromProto(n2) : o.Tensor.fromOrtTensor(n2);
            if (t2 === i.onnx.AttributeProto.AttributeType.TENSORS) {
              if (e2 instanceof i.onnx.AttributeProto)
                return n2.map((e3) => o.Tensor.fromProto(e3));
              if (e2 instanceof s.Attribute)
                return n2.map((e3) => o.Tensor.fromOrtTensor(e3));
            }
            if (t2 === i.onnx.AttributeProto.AttributeType.STRING && e2 instanceof i.onnx.AttributeProto) {
              const e3 = n2;
              return (0, a.decodeUtf8String)(e3);
            }
            return t2 === i.onnx.AttributeProto.AttributeType.STRINGS && e2 instanceof i.onnx.AttributeProto ? n2.map(a.decodeUtf8String) : n2;
          }
          static getValueNoCheck(e2) {
            return e2 instanceof i.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e2) : this.getValueNoCheckFromOrtFormat(e2);
          }
          static getValueNoCheckFromOnnxFormat(e2) {
            switch (e2.type) {
              case i.onnx.AttributeProto.AttributeType.FLOAT:
                return e2.f;
              case i.onnx.AttributeProto.AttributeType.INT:
                return e2.i;
              case i.onnx.AttributeProto.AttributeType.STRING:
                return e2.s;
              case i.onnx.AttributeProto.AttributeType.TENSOR:
                return e2.t;
              case i.onnx.AttributeProto.AttributeType.GRAPH:
                return e2.g;
              case i.onnx.AttributeProto.AttributeType.FLOATS:
                return e2.floats;
              case i.onnx.AttributeProto.AttributeType.INTS:
                return e2.ints;
              case i.onnx.AttributeProto.AttributeType.STRINGS:
                return e2.strings;
              case i.onnx.AttributeProto.AttributeType.TENSORS:
                return e2.tensors;
              case i.onnx.AttributeProto.AttributeType.GRAPHS:
                return e2.graphs;
              default:
                throw new Error(`unsupported attribute type: ${i.onnx.AttributeProto.AttributeType[e2.type]}`);
            }
          }
          static getValueNoCheckFromOrtFormat(e2) {
            switch (e2.type()) {
              case s.AttributeType.FLOAT:
                return e2.f();
              case s.AttributeType.INT:
                return e2.i();
              case s.AttributeType.STRING:
                return e2.s();
              case s.AttributeType.TENSOR:
                return e2.t();
              case s.AttributeType.GRAPH:
                return e2.g();
              case s.AttributeType.FLOATS:
                return e2.floatsArray();
              case s.AttributeType.INTS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.intsLength(); n2++)
                  t2.push(e2.ints(n2));
                return t2;
              }
              case s.AttributeType.STRINGS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.stringsLength(); n2++)
                  t2.push(e2.strings(n2));
                return t2;
              }
              case s.AttributeType.TENSORS: {
                const t2 = [];
                for (let n2 = 0; n2 < e2.tensorsLength(); n2++)
                  t2.push(e2.tensors(n2));
                return t2;
              }
              default:
                throw new Error(`unsupported attribute type: ${s.AttributeType[e2.type()]}`);
            }
          }
        }
        t.Attribute = u;
      }, 1975: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveBackend = t.backend = void 0;
        const r = n(4418), i = /* @__PURE__ */ new Map();
        async function o(e2) {
          const n2 = t.backend;
          if (void 0 !== n2[e2] && function(e3) {
            const t2 = e3;
            return "initialize" in t2 && "function" == typeof t2.initialize && "createSessionHandler" in t2 && "function" == typeof t2.createSessionHandler && "dispose" in t2 && "function" == typeof t2.dispose;
          }(n2[e2])) {
            const t2 = n2[e2];
            let r2 = t2.initialize();
            if ("object" == typeof r2 && "then" in r2 && (r2 = await r2), r2)
              return i.set(e2, t2), t2;
          }
        }
        t.backend = { webgl: new r.WebGLBackend() }, t.resolveBackend = async function e2(t2) {
          if (!t2)
            return e2(["webgl"]);
          {
            const e3 = "string" == typeof t2 ? [t2] : t2;
            for (const t3 of e3) {
              const e4 = i.get(t3);
              if (e4)
                return e4;
              const n2 = await o(t3);
              if (n2)
                return n2;
            }
          }
          throw new Error("no available backend to use");
        };
      }, 4418: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLBackend = void 0;
        const r = n(2235), i = n(1315), o = n(2171), a = n(3389);
        t.WebGLBackend = class {
          get contextId() {
            return r.env.webgl.contextId;
          }
          set contextId(e2) {
            r.env.webgl.contextId = e2;
          }
          get matmulMaxBatchSize() {
            return r.env.webgl.matmulMaxBatchSize;
          }
          set matmulMaxBatchSize(e2) {
            r.env.webgl.matmulMaxBatchSize = e2;
          }
          get textureCacheMode() {
            return r.env.webgl.textureCacheMode;
          }
          set textureCacheMode(e2) {
            r.env.webgl.textureCacheMode = e2;
          }
          get pack() {
            return r.env.webgl.pack;
          }
          set pack(e2) {
            r.env.webgl.pack = e2;
          }
          get async() {
            return r.env.webgl.async;
          }
          set async(e2) {
            r.env.webgl.async = e2;
          }
          initialize() {
            try {
              return this.glContext = (0, a.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), i.Logger.setWithEnv(r.env), i.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
            } catch (e2) {
              return i.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e2}`), false;
            }
          }
          createSessionHandler(e2) {
            return new o.WebGLSessionHandler(this, e2);
          }
          dispose() {
            this.glContext.dispose();
          }
        };
      }, 6859: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.CoordsGlslLib = void 0;
        const r = n(7273), i = n(1997), o = n(6757), a = n(7618), s = n(432);
        class u extends i.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
          }
          getCustomTypes() {
            return {};
          }
          offsetToCoords() {
            return { offsetToCoords: new i.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
          }
          coordsToOffset() {
            return { coordsToOffset: new i.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
          }
          getOutputSamplingSnippet() {
            const e2 = this.context.outputTextureLayout;
            return e2.isPacked ? this.getPackedOutputSamplingSnippet(e2) : this.getUnpackedOutputSamplingSnippet(e2);
          }
          getPackedOutputSamplingSnippet(e2) {
            const t2 = e2.unpackedShape, n2 = [e2.width, e2.height], r2 = {}, a2 = "getOutputCoords";
            switch (t2.length) {
              case 0:
                r2[a2] = this.getOutputScalarCoords();
                break;
              case 1:
                r2[a2] = this.getOutputPacked1DCoords(t2, n2);
                break;
              case 2:
                r2[a2] = this.getOutputPacked2DCoords(t2, n2);
                break;
              case 3:
                r2[a2] = this.getOutputPacked3DCoords(t2, n2);
                break;
              default:
                r2[a2] = this.getOutputPackedNDCoords(t2, n2);
            }
            const s2 = `
      void setOutput(vec4 val) {
        ${(0, o.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
            return r2.floatTextureSetRGBA = new i.GlslLibRoutine(s2), r2;
          }
          getUnpackedOutputSamplingSnippet(e2) {
            const t2 = e2.unpackedShape, n2 = [e2.width, e2.height], r2 = {}, a2 = "getOutputCoords";
            switch (t2.length) {
              case 0:
                r2[a2] = this.getOutputScalarCoords();
                break;
              case 1:
                r2[a2] = this.getOutputUnpacked1DCoords(t2, n2);
                break;
              case 2:
                r2[a2] = this.getOutputUnpacked2DCoords(t2, n2);
                break;
              case 3:
                r2[a2] = this.getOutputUnpacked3DCoords(t2, n2);
                break;
              case 4:
                r2[a2] = this.getOutputUnpacked4DCoords(t2, n2);
                break;
              case 5:
                r2[a2] = this.getOutputUnpacked5DCoords(t2, n2);
                break;
              case 6:
                r2[a2] = this.getOutputUnpacked6DCoords(t2, n2);
                break;
              default:
                throw new Error(`Unsupported output dimensionality: ${t2.length}`);
            }
            const s2 = `
        void setOutput(float val) {
          ${(0, o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
            return r2.floatTextureSetR = new i.GlslLibRoutine(s2), r2;
          }
          getOutputScalarCoords() {
            return new i.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
          }
          getOutputPacked1DCoords(e2, t2) {
            const n2 = t2;
            let r2 = "";
            return 1 === n2[0] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n2[1]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : 1 === n2[1] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n2[0]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : (r2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n2[0]}, ${n2[1]}));
          return 2 * (resTexRC.y * ${n2[0]} + resTexRC.x);
        }
      `, new i.GlslLibRoutine(r2));
          }
          getOutputPacked2DCoords(e2, t2) {
            let n2 = "";
            if (r.ArrayUtil.arraysEqual(e2, t2))
              return n2 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t2[0]}, ${t2[1]}));
        }
      `, new i.GlslLibRoutine(n2);
            const o2 = t2, a2 = Math.ceil(e2[1] / 2);
            return n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o2[0]}, ${o2[1]}));

          int index = resTexRC.y * ${o2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a2}) * 2;
          int c = 2 * (index / ${a2});

          return ivec2(r, c);
        }
      `, new i.GlslLibRoutine(n2);
          }
          getOutputPacked3DCoords(e2, t2) {
            const n2 = [t2[0], t2[1]], r2 = Math.ceil(e2[2] / 2), o2 = r2 * Math.ceil(e2[1] / 2), a2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n2[0]}, ${n2[1]}));
          int index = resTexRC.y * ${n2[0]} + resTexRC.x;

          int b = index / ${o2};
          index -= b * ${o2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r2}) * 2;
          int c = 2 * (index / ${r2});

          return ivec3(b, r, c);
        }
      `;
            return new i.GlslLibRoutine(a2);
          }
          getOutputPackedNDCoords(e2, t2) {
            const n2 = [t2[0], t2[1]], r2 = Math.ceil(e2[e2.length - 1] / 2), o2 = r2 * Math.ceil(e2[e2.length - 2] / 2);
            let a2 = o2, s2 = "", u2 = "b, r, c";
            for (let t3 = 2; t3 < e2.length - 1; t3++)
              a2 *= e2[e2.length - t3 - 1], s2 = `
      int b${t3} = index / ${a2};
      index -= b${t3} * ${a2};
    ` + s2, u2 = `b${t3}, ` + u2;
            const l = `
      ivec${e2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n2[0]}, ${n2[1]}));
        int index = resTexRC.y * ${n2[0]} + resTexRC.x;

        ${s2}

        int b = index / ${o2};
        index -= b * ${o2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r2}) * 2;
        int c = 2 * (index / ${r2});

        return ivec${e2.length}(${u2});
      }
    `;
            return new i.GlslLibRoutine(l);
          }
          getOutputUnpacked1DCoords(e2, t2) {
            const n2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          return resTexRC.y * ${t2[0]} + resTexRC.x;
        }
      `;
            return new i.GlslLibRoutine(n2);
          }
          getOutputUnpacked2DCoords(e2, t2) {
            const n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          int r = index / ${e2[1]};
          int c = index - r * ${e2[1]};
          return ivec2(r, c);
        }
      `;
            return new i.GlslLibRoutine(n2);
          }
          getOutputUnpacked3DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let o2 = null;
            r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              o2[t3] = o2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d"], s2 = o2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === o2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec3(r, c, d);
        }
      `, new i.GlslLibRoutine(n2);
          }
          getOutputUnpacked4DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let o2 = null;
            r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              o2[t3] = o2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2"], s2 = o2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === o2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec4(r, c, d, d2);
        }
      `, new i.GlslLibRoutine(n2);
          }
          getOutputUnpacked5DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let o2 = null;
            r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              o2[t3] = o2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2", "d3"], s2 = o2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === o2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t2[0]}, ${t2[1]}));
          int index = resTexRC.y * ${t2[0]} + resTexRC.x;
          ${s2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new i.GlslLibRoutine(n2);
          }
          getOutputUnpacked6DCoords(e2, t2) {
            let n2 = "";
            const r2 = e2.length;
            let o2 = null;
            r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = e2[r2 - 1];
            for (let t3 = r2 - 3; t3 >= 0; --t3)
              o2[t3] = o2[t3 + 1] * e2[t3 + 1];
            const a2 = ["r", "c", "d", "d2", "d3", "d4"], s2 = o2.map((e3, t3) => `int ${a2[t3]} = index / ${e3}; ${t3 === o2.length - 1 ? `int ${a2[t3 + 1]} = index - ${a2[t3]} * ${e3}` : `index -= ${a2[t3]} * ${e3}`};`).join("");
            return n2 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t2[0]}, ${t2[1]}));
         int index = resTexRC.y * ${t2[0]} + resTexRC.x;
         ${s2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new i.GlslLibRoutine(n2);
          }
          getCommonUtilFuncs() {
            const e2 = {};
            let t2 = "uvFromFlat";
            e2[t2] = new i.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), t2 = "packedUVfrom1D", e2[t2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom2D", e2[t2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "packedUVfrom3D", e2[t2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), t2 = "sampleTexture";
            const n2 = (0, o.getGlsl)(this.context.glContext.version);
            return e2[t2] = new i.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n2.texture2D}(textureSampler, uv).r;
        }`), e2;
          }
          getInputsSamplingSnippets() {
            const e2 = {}, t2 = this.context.outputTextureLayout;
            return this.context.programInfo.inputNames.forEach((n2, r2) => {
              const i2 = this.context.inputTextureLayouts[r2], o2 = (0, s.generateShaderFuncNameFromInputSamplerName)(n2);
              i2.isPacked ? e2[o2] = this.getPackedSamplerFromInput(o2, n2, i2) : e2[o2] = this.getUnpackedSamplerFromInput(o2, n2, i2);
              const a2 = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n2);
              i2.unpackedShape.length <= t2.unpackedShape.length && (i2.isPacked ? e2[a2] = this.getPackedSamplerAtOutputCoords(a2, i2, t2, n2) : e2[a2] = this.getUnpackedSamplerAtOutputCoords(a2, i2, t2, n2));
            }), e2;
          }
          getPackedSamplerAtOutputCoords(e2, t2, n2, o2) {
            const a2 = t2.unpackedShape, u2 = n2.unpackedShape, l = o2, c = (0, s.generateShaderFuncNameFromInputSamplerName)(l), p = a2.length, d = u2.length, f = r.BroadcastUtil.getBroadcastDims(a2, u2), h = (0, s.getCoordsDataType)(d), g = d - p;
            let m;
            const b = (0, s.getGlChannels)();
            m = 0 === p ? "" : d < 2 && f.length >= 1 ? "coords = 0;" : f.map((e3) => `coords.${b[e3 + g]} = 0;`).join("\n");
            let y = "";
            y = d < 2 && p > 0 ? "coords" : a2.map((e3, t3) => `coords.${b[t3 + g]}`).join(", ");
            let v = "return outputValue;";
            const w = 1 === r.ShapeUtil.size(a2), x = 1 === r.ShapeUtil.size(u2);
            if (1 !== p || w || x) {
              if (w && !x)
                v = 1 === d ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
              else if (f.length) {
                const e3 = p - 2, t3 = p - 1;
                f.indexOf(e3) > -1 && f.indexOf(t3) > -1 ? v = "return vec4(outputValue.x);" : f.indexOf(e3) > -1 ? v = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : f.indexOf(t3) > -1 && (v = "return vec4(outputValue.xx, outputValue.zz);");
              }
            } else
              v = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
            const _ = `
      vec4 ${e2}() {
        ${h} coords = getOutputCoords();
        
        int lastDim = coords.${b[d - 1]};
        coords.${b[d - 1]} = coords.${b[d - 2]};
        coords.${b[d - 2]} = lastDim;
      
        ${m}
        vec4 outputValue = ${c}(${y});
        ${v}
      }
    `;
            return new i.GlslLibRoutine(_, ["coordinates.getOutputCoords"]);
          }
          getUnpackedSamplerAtOutputCoords(e2, t2, n2, o2) {
            const a2 = [n2.width, n2.height], u2 = [t2.width, t2.height], l = t2.unpackedShape.length, c = n2.unpackedShape.length, p = t2.unpackedShape, d = n2.unpackedShape, f = (0, s.generateShaderFuncNameFromInputSamplerName)(o2);
            if (l === c && r.ArrayUtil.arraysEqual(u2, a2)) {
              const t3 = `
          float ${e2}() {
            return sampleTexture(${o2}, TexCoords);
          }
        `;
              return new i.GlslLibRoutine(t3, ["coordinates.sampleTexture"]);
            }
            const h = (0, s.getCoordsDataType)(c), g = r.BroadcastUtil.getBroadcastDims(p, d), m = c - l;
            let b;
            const y = (0, s.getGlChannels)();
            b = 0 === l ? "" : c < 2 && g.length >= 1 ? "coords = 0;" : g.map((e3) => `coords.${y[e3 + m]} = 0;`).join("\n");
            let v = "";
            v = c < 2 && l > 0 ? "coords" : t2.unpackedShape.map((e3, t3) => `coords.${y[t3 + m]}`).join(", ");
            const w = `
        float ${e2}() {
          ${h} coords = getOutputCoords();
          ${b}
          return ${f}(${v});
        }
      `;
            return new i.GlslLibRoutine(w, ["coordinates.getOutputCoords"]);
          }
          getPackedSamplerFromInput(e2, t2, n2) {
            switch (n2.unpackedShape.length) {
              case 0:
                return this.getPackedSamplerScalar(e2, t2);
              case 1:
                return this.getPackedSampler1D(e2, t2, n2);
              case 2:
                return this.getPackedSampler2D(e2, t2, n2);
              case 3:
                return this.getPackedSampler3D(e2, t2, n2);
              default:
                return this.getPackedSamplerND(e2, t2, n2);
            }
          }
          getUnpackedSamplerFromInput(e2, t2, n2) {
            const r2 = n2.unpackedShape;
            switch (r2.length) {
              case 0:
                return this.getUnpackedSamplerScalar(e2, t2, n2);
              case 1:
                return this.getUnpackedSampler1D(e2, t2, n2);
              case 2:
                return this.getUnpackedSampler2D(e2, t2, n2);
              case 3:
                return this.getUnpackedSampler3D(e2, t2, n2);
              case 4:
                return this.getUnpackedSampler4D(e2, t2, n2);
              case 5:
                return this.getUnpackedSampler5D(e2, t2, n2);
              case 6:
                return this.getUnpackedSampler6D(e2, t2, n2);
              default:
                throw new Error(`Unsupported dimension ${r2.length}-D`);
            }
          }
          getPackedSamplerScalar(e2, t2) {
            const n2 = `
          vec4 ${e2}() {
            return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t2}, halfCR);
          }
        `;
            return new i.GlslLibRoutine(n2);
          }
          getPackedSampler1D(e2, t2, n2) {
            const r2 = [n2.width, n2.height], a2 = [r2[1], r2[0]], s2 = (0, o.getGlsl)(this.context.glContext.version), u2 = `vec4 ${e2}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a2[0]}, ${a2[1]}, index);
      return ${s2.texture2D}(${t2}, uv);
    }`;
            return new i.GlslLibRoutine(u2, ["coordinates.packedUVfrom1D"]);
          }
          getPackedSampler2D(e2, t2, n2) {
            const a2 = n2.unpackedShape, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), l = s2[0], c = s2[1];
            if (null != s2 && r.ArrayUtil.arraysEqual(a2, s2)) {
              const n3 = `vec4 ${e2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${l}.0);
        return ${u2.texture2D}(${t2}, uv);
      }`;
              return new i.GlslLibRoutine(n3);
            }
            const p = s2, d = Math.ceil(a2[1] / 2), f = `vec4 ${e2}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${d}, row, col);
      return ${u2.texture2D}(${t2}, uv);
    }`;
            return new i.GlslLibRoutine(f, ["coordinates.packedUVfrom2D"]);
          }
          getPackedSampler3D(e2, t2, n2) {
            const r2 = n2.unpackedShape, a2 = [n2.width, n2.height], u2 = [a2[0], a2[1]], l = (0, o.getGlsl)(this.context.glContext.version);
            if (1 === r2[0]) {
              const o2 = r2.slice(1), a3 = [1, 2], u3 = (0, s.squeezeInputShape)(r2, o2), l2 = ["b", "row", "col"], c2 = JSON.parse(JSON.stringify(n2));
              c2.unpackedShape = u3;
              const p2 = this.getPackedSamplerFromInput(e2, t2, c2), d2 = `${p2.routineBody}
      vec4 ${e2}(int b, int row, int col) {
        return ${e2}(${(0, s.getSqueezedParams)(l2, a3)});
      } `;
              return new i.GlslLibRoutine(d2, p2.dependencies);
            }
            const c = u2[0], p = u2[1], d = Math.ceil(r2[2] / 2), f = `vec4 ${e2}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${c}, ${d * Math.ceil(r2[1] / 2)}, ${d}, b, row, col);
      return ${l.texture2D}(${t2}, uv);}`;
            return new i.GlslLibRoutine(f, ["coordinates.packedUVfrom3D"]);
          }
          getPackedSamplerND(e2, t2, n2) {
            const r2 = n2.unpackedShape, a2 = r2.length, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), l = [s2[0], s2[1]], c = l[1], p = l[0], d = Math.ceil(r2[a2 - 1] / 2);
            let f = d * Math.ceil(r2[a2 - 2] / 2), h = "int b, int row, int col", g = `b * ${f} + (row / 2) * ${d} + (col / 2)`;
            for (let e3 = 2; e3 < a2 - 1; e3++)
              h = `int b${e3}, ` + h, f *= r2[a2 - e3 - 1], g = `b${e3} * ${f} + ` + g;
            const m = `vec4 ${e2}(${h}) {
      int index = ${g};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${c});
      return ${u2.texture2D}(${t2}, uv);
    }`;
            return new i.GlslLibRoutine(m);
          }
          getUnpackedSamplerScalar(e2, t2, n2) {
            const [r2, o2] = [n2.width, n2.height];
            if (1 === r2 && 1 === o2) {
              const n3 = `
          float ${e2}() {
            return sampleTexture(${t2}, halfCR);
          }
        `;
              return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const a2 = `
        float ${e2}() {
          int offset_${t2} = coordsToOffset(TexCoords, ${r2}, ${o2});
          vec2 uv = uvFromFlat(${r2}, ${o2}, offset_${t2});
          return sampleTexture(${t2}, uv);
        }
      `;
            return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler1D(e2, t2, n2) {
            const r2 = n2.width, o2 = n2.height;
            if (1 === o2 && 1 === r2) {
              const n3 = `
        float ${e2}(int index) {
          return sampleTexture(${t2}, halfCR);
        }
      `;
              return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            if (1 === o2) {
              const n3 = `
          float ${e2}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r2}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            if (1 === r2) {
              const n3 = `
          float ${e2}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o2}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const a2 = `
        float ${e2}(int index) {
          vec2 uv = uvFromFlat(${r2}, ${o2}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler2D(e2, t2, n2) {
            const o2 = n2.unpackedShape, u2 = [n2.height, n2.width];
            if (null != u2 && r.ArrayUtil.arraysEqual(o2, u2)) {
              const n3 = `
          float ${e2}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u2[1]}.0, ${u2[0]}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
            }
            const { newShape: l, keptDims: c } = (0, a.squeezeShape)(o2), p = l;
            if (p.length < o2.length) {
              const r2 = (0, s.squeezeInputShape)(o2, p), a2 = JSON.parse(JSON.stringify(n2));
              a2.unpackedShape = r2;
              const u3 = ["col", "row"], l2 = `
          ${this.getUnpackedSamplerFromInput(e2, t2, a2).routineBody}
          float ${e2}(int row, int col) {
            return ${e2}(${(0, s.getSqueezedParams)(u3, c)});
          }
        `;
              return new i.GlslLibRoutine(l2, ["coordinates.sampleTexture"]);
            }
            const d = u2[1], f = u2[0];
            if (1 === f) {
              const n3 = `
          float ${e2}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            if (1 === d) {
              const n3 = `
          float ${e2}(int row, int col) {
            int offset_${t2} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);
            return sampleTexture(${t2}, uv);
          }
        `;
              return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            const h = `
        float ${e2}(int row, int col) {
          int index = col * ${o2[1]} + row;
          vec2 uv = uvFromFlat(${d}, ${f}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler3D(e2, t2, n2) {
            const r2 = n2.unpackedShape, o2 = r2[1] * r2[2], u2 = r2[2], { newShape: l, keptDims: c } = (0, a.squeezeShape)(r2), p = l;
            if (p.length < r2.length) {
              const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["batch", "col", "row"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = o3;
              const l2 = this.getUnpackedSamplerFromInput(e2, t2, u3), d2 = c.reverse(), f = `
          ${l2.routineBody}
          float ${e2}(int batch, int row, int col) {
            return ${e2}(${(0, s.getSqueezedParams)(a2, d2)});
          }
        `;
              return new i.GlslLibRoutine(f, l2.dependencies);
            }
            const d = `
          float ${e2}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${o2} + col * ${u2} + row;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
      `;
            return new i.GlslLibRoutine(d, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          getUnpackedSampler4D(e2, t2, n2) {
            const r2 = n2.unpackedShape, o2 = r2[3], a2 = r2[2] * o2, s2 = `
        float ${e2}(int row, int col, int depth, int depth2) {
          int index = row * ${r2[1] * a2} + col * ${a2} +
              depth2 * ${o2} + depth;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new i.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
          }
          getUnpackedSampler5D(e2, t2, n2) {
            const r2 = n2.unpackedShape, o2 = r2[4], u2 = r2[3] * o2, l = r2[2] * u2, c = r2[1] * l, { newShape: p, keptDims: d } = (0, a.squeezeShape)(r2);
            if (p.length < r2.length) {
              const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["row", "col", "depth", "depth2", "depth3"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = o3;
              const l2 = `
          ${this.getUnpackedSamplerFromInput(e2, t2, u3).routineBody}
          float ${e2}(int row, int col, int depth, int depth2, int depth3) {
            return ${e2}(${(0, s.getSqueezedParams)(a2, d)});
          }
        `;
              return new i.GlslLibRoutine(l2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            const f = `
        float ${e2}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${c} + col * ${l} + depth * ${u2} +
          depth3 * ${o2} + depth2;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${t2}, uv);
        }
      `;
            return new i.GlslLibRoutine(f, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
          }
          getUnpackedSampler6D(e2, t2, n2) {
            const r2 = n2.unpackedShape, o2 = r2[5], u2 = r2[4] * o2, l = r2[3] * u2, c = r2[2] * l, p = r2[1] * c, { newShape: d, keptDims: f } = (0, a.squeezeShape)(r2);
            if (d.length < r2.length) {
              const o3 = (0, s.squeezeInputShape)(r2, d), a2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u3 = JSON.parse(JSON.stringify(n2));
              u3.unpackedShape = o3;
              const l2 = `
            ${this.getUnpackedSamplerFromInput(e2, t2, u3).routineBody}
            float ${e2}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e2}(${(0, s.getSqueezedParams)(a2, f)});
            }
          `;
              return new i.GlslLibRoutine(l2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            const h = `
          float ${e2}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${c} + depth * ${l} +
            depth2 * ${u2} + depth3 * ${o2} + depth4;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${t2}, uv);
          }
        `;
            return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
          }
          toVec() {
            const e2 = this.context.outputTextureLayout, t2 = e2.shape.length, n2 = e2.strides, r2 = e2.width, o2 = e2.height, a2 = [];
            for (let e3 = 0; e3 < t2 - 1; ++e3)
              a2.push(`
        c[${e3}] = offset / ${n2[e3]};`), a2.push(`
        offset -= c[${e3}] * ${n2[e3]};`);
            a2.push(`
        c[${t2 - 1}] = offset;`);
            const s2 = `
      void toVec(vec2 texCoords, out int c[${t2}]) {
        int offset = coordsToOffset(texCoords, ${r2}, ${o2});
        ${a2.join("")}
      }
      void toVec(int offset, out int c[${t2}]) {
        ${a2.join("")}
      }
    `;
            return { toVec: new i.GlslLibRoutine(s2, ["coordinates.coordsToOffset"]) };
          }
          valueFrom() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const r2 = this.context.inputTextureLayouts[n2], o2 = (r2.unpackedShape.length > 0 ? r2.unpackedShape : r2.shape).length;
              let a2 = `_${t2}`;
              e2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(t2, o2, r2.width, r2.height, false), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a2 += "_T", e2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(t2, o2, r2.width, r2.height, true), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
            }), e2;
          }
          getValueFromSingle(e2, t2, n2, r2, i2) {
            let a2 = `_${e2}`;
            return i2 && (a2 += "_T"), `
        float ${a2}(int m[${t2}]) {
          int offset = indicesToOffset${a2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          float value = getColorAsFloat(${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e2}, coords));
          return value;
        }
        `;
          }
          getPackedValueFrom(e2, t2, n2, r2, i2) {
            let a2 = `_${e2}_Pack`;
            return i2 && (a2 += "_T"), `
        vec4 ${a2}(int m[${t2}]) {
          int offset = indicesToOffset_${e2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e2}, coords);
        }
        `;
          }
        }
        t.CoordsGlslLib = u;
      }, 1997: (e, t) => {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: true }), t.TopologicalSortGlslRoutines = t.GlslLibRoutineNode = t.GlslLibRoutine = t.GlslLib = t.GlslContext = t.FunctionType = void 0, (n = t.FunctionType || (t.FunctionType = {}))[n.ValueBased = 0] = "ValueBased", n[n.Positional = 1] = "Positional", t.GlslContext = class {
          constructor(e2, t2, n2, r) {
            this.glContext = e2, this.programInfo = t2, this.inputTextureLayouts = n2, this.outputTextureLayout = r;
          }
        }, t.GlslLib = class {
          constructor(e2) {
            this.context = e2;
          }
        }, t.GlslLibRoutine = class {
          constructor(e2, t2) {
            this.routineBody = e2, this.dependencies = t2;
          }
        }, t.GlslLibRoutineNode = class {
          constructor(e2, t2, n2) {
            this.name = e2, this.dependencies = n2 || [], t2 && (this.routineBody = t2);
          }
          addDependency(e2) {
            e2 && this.dependencies.push(e2);
          }
        }, t.TopologicalSortGlslRoutines = class {
          static returnOrderedNodes(e2) {
            if (!e2 || 0 === e2.length)
              return [];
            if (1 === e2.length)
              return e2;
            const t2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), r = new Array();
            return this.createOrderedNodes(e2, t2, n2, r), r;
          }
          static createOrderedNodes(e2, t2, n2, r) {
            for (let i = 0; i < e2.length; ++i)
              this.dfsTraverse(e2[i], t2, n2, r);
          }
          static dfsTraverse(e2, t2, n2, r) {
            if (!e2 || n2.has(e2.name))
              return;
            if (t2.has(e2.name))
              throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
            t2.add(e2.name);
            const i = e2.dependencies;
            if (i && i.length > 0)
              for (let e3 = 0; e3 < i.length; ++e3)
                this.dfsTraverse(i[e3], t2, n2, r);
            r.push(e2), n2.add(e2.name), t2.delete(e2.name);
          }
        };
      }, 1371: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.EncodingGlslLib = void 0;
        const r = n(1997);
        class i extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
          }
          getCustomTypes() {
            return {};
          }
          encodeFloat32() {
            return { encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
          }
          decodeFloat32() {
            return { decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
          }
          encodeUint8() {
            const e2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { encode: new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e2}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
          }
          decodeUint8() {
            const e2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
            return { decode: new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e2}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
          }
          static isLittleEndian() {
            const e2 = new ArrayBuffer(4), t2 = new Uint32Array(e2), n2 = new Uint8Array(e2);
            if (t2[0] = 3735928559, 239 === n2[0])
              return true;
            if (222 === n2[0])
              return false;
            throw new Error("unknown endianness");
          }
        }
        t.EncodingGlslLib = i;
      }, 2691: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FragColorGlslLib = void 0;
        const r = n(1997), i = n(6757);
        class o extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
          }
          getCustomTypes() {
            return {};
          }
          setFragColor() {
            const e2 = (0, i.getGlsl)(this.context.glContext.version);
            return { setFragColor: new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${e2.output} = encode(value);
        }
        `, ["encoding.encode"]) };
          }
          getColorAsFloat() {
            return { getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
          }
        }
        t.FragColorGlslLib = o;
      }, 3878: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.replaceInlines = void 0;
        const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
        t.replaceInlines = function(e2) {
          const t2 = {};
          let r;
          for (; null !== (r = n.exec(e2)); ) {
            const e3 = r[3].split(",").map((e4) => {
              const t3 = e4.trim().split(" ");
              return t3 && 2 === t3.length ? { type: t3[0], name: t3[1] } : null;
            }).filter((e4) => null !== e4);
            t2[r[2]] = { params: e3, body: r[4] };
          }
          for (const n2 in t2) {
            const i = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n2), o = new RegExp(i, "gm");
            for (; null !== (r = o.exec(e2)); ) {
              const i2 = r[1], o2 = r[2], a = r[3].split(","), s = i2 ? `${i2} ${o2};` : "";
              let u = t2[n2].body, l = "";
              t2[n2].params.forEach((e3, t3) => {
                e3 && (l += `${e3.type} ${e3.name} = ${a[t3]};
`);
              }), u = `${l}
 ${u}`, u = u.replace("return", `${o2} = `);
              const c = `
      ${s}
      {
        ${u}
      }
      `;
              e2 = e2.replace(r[0], c);
            }
          }
          return e2.replace(n, "");
        };
      }, 8897: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.GlslPreprocessor = void 0;
        const r = n(1997), i = n(3878), o = n(1248), a = n(6757);
        t.GlslPreprocessor = class {
          constructor(e2, t2, n2, i2) {
            this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(e2, t2, n2, i2), Object.keys(o.glslRegistry).forEach((e3) => {
              const t3 = new o.glslRegistry[e3](this.context);
              this.libs[e3] = t3;
            });
            const a2 = this.glslLibRoutineDependencyGraph;
            for (const e3 in this.libs) {
              const t3 = this.libs[e3].getFunctions();
              for (const n3 in t3) {
                const i3 = e3 + "." + n3;
                let o2;
                a2[i3] ? (o2 = a2[i3], o2.routineBody = t3[n3].routineBody) : (o2 = new r.GlslLibRoutineNode(i3, t3[n3].routineBody), a2[i3] = o2);
                const s = t3[n3].dependencies;
                if (s)
                  for (let e4 = 0; e4 < s.length; ++e4)
                    if (a2[s[e4]])
                      o2.addDependency(a2[s[e4]]);
                    else {
                      const t4 = new r.GlslLibRoutineNode(s[e4]);
                      a2[s[e4]] = t4, o2.addDependency(t4);
                    }
              }
            }
          }
          preprocess() {
            const e2 = this.context.programInfo;
            let t2 = e2.shaderSource;
            return this.context.programInfo.hasMain || (t2 = `${t2}
      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), t2 = (0, i.replaceInlines)(t2), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(e2.inputNames, e2.variables)}
    ${this.getImports(t2)}
    ${t2}`;
          }
          getImports(e2) {
            const t2 = this.selectGlslLibRoutinesToBeIncluded(e2);
            if (0 === t2.length)
              return "";
            let n2 = "";
            for (let e3 = 0; e3 < t2.length; ++e3) {
              if (!t2[e3].routineBody)
                throw new Error(`Missing body for the Glsl Library routine: ${t2[e3].name}`);
              n2 += t2[e3].routineBody + "\n";
            }
            return n2;
          }
          selectGlslLibRoutinesToBeIncluded(e2) {
            const t2 = [];
            return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n2) => {
              const r2 = n2.split(".")[1];
              -1 !== e2.indexOf(r2) && t2.push(this.glslLibRoutineDependencyGraph[n2]);
            }), r.TopologicalSortGlslRoutines.returnOrderedNodes(t2);
          }
          getUniforms(e2, t2) {
            const n2 = [];
            if (e2)
              for (const t3 of e2)
                n2.push(`uniform sampler2D ${t3};`);
            if (t2)
              for (const e3 of t2)
                n2.push(`uniform ${e3.type} ${e3.name}${e3.arrayLength ? `[${e3.arrayLength}]` : ""};`);
            return n2.join("\n");
          }
        };
      }, 1248: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.glslRegistry = void 0;
        const r = n(6859), i = n(1371), o = n(2691), a = n(9183), s = n(9314);
        t.glslRegistry = { encoding: i.EncodingGlslLib, fragcolor: o.FragColorGlslLib, vec: s.VecGlslLib, shapeUtils: a.ShapeUtilsGlslLib, coordinates: r.CoordsGlslLib };
      }, 9183: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ShapeUtilsGlslLib = void 0;
        const r = n(1997);
        class i extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
          }
          getCustomTypes() {
            return {};
          }
          bcastIndex() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = {};
            return this.context.programInfo.inputNames.forEach((n2, i2) => {
              const o = this.context.inputTextureLayouts[i2].unpackedShape;
              if (o.length <= e2) {
                const i3 = o.length, a = e2 - i3, s = `bcastIndices_${n2}`;
                let u = "";
                for (let e3 = 0; e3 < i3; ++e3)
                  u += `
          realIndices[${e3}] = int( mod(float(bcastedIndices[${a + e3}]), ${o[e3]}.0) );
          `;
                const l = `
        void ${s} (int bcastedIndices[${e2}], out int realIndices[${i3}]) {
          ${u}
        }
        `;
                t2[s] = new r.GlslLibRoutine(l);
              }
            }), t2;
          }
          bcastMatmulIndex() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = {};
            return this.context.programInfo.inputNames.forEach((n2, i2) => {
              const o = this.context.inputTextureLayouts[i2].shape;
              if (!(o.length < 2 || o.length > e2)) {
                const i3 = o.length, a = e2 - i3, s = `bcastMatmulIndices_${n2}`;
                let u = "";
                for (let e3 = 0; e3 < i3 - 2; ++e3)
                  u += `
          realIndices[${e3}] = int( mod(float(bcastedIndices[${a + e3}]), ${o[e3]}.0) );
          `;
                const l = `
        void ${s}(int bcastedIndices[${e2}], out int realIndices[${i3}]) {
          ${u}
          realIndices[${i3 - 1}] = bcastedIndices[${e2 - 1}];
          realIndices[${i3 - 2}] = bcastedIndices[${e2 - 2}];
        }
        `;
                t2[s] = new r.GlslLibRoutine(l);
              }
            }), t2;
          }
          indicesToOffset() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
              let u = `indicesToOffset_${t2}`;
              e2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${t2}_T`, e2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a.slice().reverse()));
            }), e2;
          }
          static indexToOffsetSingle(e2, t2, n2) {
            let r2 = "";
            for (let e3 = t2 - 1; e3 >= 0; --e3)
              r2 += `
        offset += indices[${e3}] * ${n2[e3]};
        `;
            return `
      int ${e2}(int indices[${t2}]) {
        int offset = 0;
        ${r2}
        return offset;
      }
      `;
          }
          offsetToIndices() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
              let u = `offsetToIndices_${t2}`;
              e2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${t2}_T`, e2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a.slice().reverse()));
            }), e2;
          }
          static offsetToIndicesSingle(e2, t2, n2) {
            const r2 = [];
            for (let e3 = 0; e3 < t2 - 1; ++e3)
              r2.push(`
      indices[${e3}] = offset / ${n2[e3]};`), r2.push(`
        offset -= indices[${e3}] * ${n2[e3]};`);
            return r2.push(`
      indices[${t2 - 1}] = offset;`), `
      void ${e2}(int offset, out int indices[${t2}]) {
        ${r2.join("")}
      }
      `;
          }
          incrementIndices() {
            const e2 = {};
            return this.context.programInfo.inputNames.forEach((t2, n2) => {
              const i2 = this.context.inputTextureLayouts[n2].shape, o = i2.length, a = `incrementIndices_${t2}`;
              let s = "";
              for (let e3 = 0; e3 < o; ++e3)
                s += `
        shape[${e3}] = ${i2[e3]};`;
              const u = `
        void ${a}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${s};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
              e2[a] = new r.GlslLibRoutine(u);
            }), e2;
          }
        }
        t.ShapeUtilsGlslLib = i;
      }, 6757: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getDefaultFragShaderMain = t.getFragShaderPreamble = t.getVertexShaderSource = t.getGlsl = void 0;
        const n = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
        function i(e2) {
          return 1 === e2 ? n : r;
        }
        t.getGlsl = i, t.getVertexShaderSource = function(e2) {
          const t2 = i(e2);
          return `${t2.version}
      precision highp float;
      ${t2.attribute} vec3 position;
      ${t2.attribute} vec2 textureCoord;

      ${t2.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
        }, t.getFragShaderPreamble = function(e2) {
          const t2 = i(e2);
          return `${t2.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t2.varyingFrag} vec2 TexCoords;
    ${t2.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
        }, t.getDefaultFragShaderMain = function(e2, t2) {
          return `
  void main() {
    int indices[${t2}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i(e2).output} = result;
  }
  `;
        };
      }, 9314: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.VecGlslLib = void 0;
        const r = n(1997);
        class i extends r.GlslLib {
          constructor(e2) {
            super(e2);
          }
          getCustomTypes() {
            return {};
          }
          getFunctions() {
            return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
          }
          binaryVecFunctions() {
            const e2 = this.context.outputTextureLayout.shape.length, t2 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n2 = {};
            for (const i2 in t2) {
              const o = `${i2}Vec`;
              let a = "";
              for (let n3 = 0; n3 < e2; ++n3)
                a += `
          dest[${n3}] ${t2[i2]} src[${n3}];
          `;
              const s = `
        void ${o}(int src[${e2}], out int dest[${e2}]) {
          ${a}
        }
        `;
              n2[o] = new r.GlslLibRoutine(s);
            }
            return n2;
          }
          copyVec() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = "";
            for (let n3 = 0; n3 < e2; ++n3)
              t2 += `
        dest[${n3}] = src[${n3}];
        `;
            const n2 = `
      void copyVec(int src[${e2}], out int dest[${e2}]) {
        ${t2}
      }
      `;
            return { copyVec: new r.GlslLibRoutine(n2) };
          }
          setVecItem() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = `
        if(index < 0)
            index =${e2} + index;
        if (index == 0)
            m[0] = value;
        `;
            for (let n3 = 1; n3 < e2 - 1; ++n3)
              t2 += `
        else if (index == ${n3})
            m[${n3}] = value;
            `;
            t2 += `
        else
            m[${e2 - 1}] = value;
        `;
            const n2 = `
      void setVecItem(out int m[${e2}], int index, int value) {
        ${t2}
      }
        `;
            return { setVecItem: new r.GlslLibRoutine(n2) };
          }
          getVecItem() {
            const e2 = this.context.outputTextureLayout.shape.length;
            let t2 = `
        if(index < 0)
            index = ${e2} + index;
        if (index == 0)
            return m[0];
      `;
            for (let n3 = 1; n3 < e2 - 1; ++n3)
              t2 += `
        else if (index == ${n3})
            return m[${n3}];
      `;
            t2 += `
        else
            return m[${e2 - 1}];
        `;
            const n2 = `
      int getVecItem(int m[${e2}], int index) {
        ${t2}
      }
    `;
            return { getVecItem: new r.GlslLibRoutine(n2) };
          }
        }
        t.VecGlslLib = i;
      }, 7860: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLInferenceHandler = void 0;
        const r = n(1315), i = n(9240), o = n(7273), a = n(9), s = n(7379), u = n(2488), l = n(540), c = n(3314), p = n(5639);
        t.WebGLInferenceHandler = class {
          constructor(e2) {
            this.session = e2, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          calculateTextureWidthAndHeight(e2, t2) {
            return (0, c.calculateTextureWidthAndHeight)(this.session.layoutStrategy, e2, t2);
          }
          executeProgram(e2, t2) {
            if (t2.length < e2.inputNames.length)
              throw new Error(`Input size mustn't be less than ${e2.inputNames.length}.`);
            if (e2.inputNames.length !== e2.inputTypes.length)
              throw new Error("input names size does not match input types");
            const n2 = [];
            for (let r3 = 0; r3 < e2.inputNames.length; ++r3)
              n2[r3] = this.getOrCreateTextureData(t2[r3], e2.inputTypes[r3]);
            const r2 = ((e3, t3) => {
              const n3 = t3.map((e4) => `${e4.unpackedShape.join(",")};${e4.width}x${e4.height}`).join("_");
              let r3 = e3.name;
              return e3.cacheHint && (r3 += "[" + e3.cacheHint + "]"), r3 += ":" + n3, r3;
            })(e2, n2);
            let i2 = this.session.programManager.getArtifact(r2);
            const o2 = i2 ? i2.programInfo : "function" == typeof e2.get ? e2.get() : e2, a2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2.output.dims, o2.output.textureType), s2 = this.createTextureData(a2, o2.output.type);
            return i2 || (i2 = this.session.programManager.build(o2, n2, s2), this.session.programManager.setArtifact(r2, i2)), this.runProgram(i2, n2, s2), s2;
          }
          run(e2, t2) {
            return this.executeProgram(e2, t2).tensor;
          }
          runProgram(e2, t2, n2) {
            for (let n3 = 0; n3 < t2.length; ++n3)
              if (!!t2[n3].isPacked != (e2.programInfo.inputTypes[n3] === p.TextureType.packed))
                throw new Error(`input[${n3}] property packed inconsistent`);
            if (!!n2.isPacked != (e2.programInfo.output.textureType === p.TextureType.packed))
              throw new Error("output property packed inconsistent");
            this.session.programManager.run(e2, t2, n2);
          }
          getOrCreateTextureData(e2, t2) {
            let n2 = this.getTextureData(e2.dataId, t2 === p.TextureType.packed);
            if (!n2 && (n2 = this.getTextureData(e2.dataId, t2 !== p.TextureType.packed), n2))
              return t2 === p.TextureType.packed ? this.pack(n2) : this.unpack(n2);
            if (!n2) {
              const r2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, e2.dims, t2);
              if (t2 === p.TextureType.packedLastDimension) {
                const n3 = 1, r3 = 4, i2 = e2.dims;
                if (4 === i2.length) {
                  const o2 = [i2[0], Math.ceil(i2[1] * i2[2] * i2[3] / r3)], a2 = (0, c.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2, t2);
                  let s2 = e2.numberData;
                  if (i2[1] * i2[2] * i2[3] % r3 != 0) {
                    const t3 = i2[0], o3 = i2[1] * i2[2] * i2[3], a3 = Math.ceil(o3 * n3 / r3) * r3;
                    s2 = new Float32Array(t3 * a3);
                    for (let r4 = 0; r4 < t3; ++r4) {
                      const t4 = r4 * o3, i3 = r4 * a3 + r4 % n3 * o3;
                      s2.set(e2.numberData.subarray(t4, t4 + o3), i3);
                    }
                  }
                  return this.createTextureData(a2, e2.type, s2, e2, 1);
                }
              }
              if (t2 === p.TextureType.packed) {
                const t3 = (0, c.createTextureLayoutFromShape)(this.session.layoutStrategy, e2.dims, 1, [], { reverseWH: true }), r3 = this.createTextureData(t3, e2.type, e2.numberData, e2, 1);
                n2 = this.pack(r3);
              } else
                n2 = this.createTextureData(r2, e2.type, e2.numberData, e2, 1);
            }
            return n2;
          }
          createTextureDataFromLayoutBindTensor(e2, t2, n2, r2) {
            return this.createTextureData(e2, t2, n2, r2, 1);
          }
          createTextureData(e2, t2, n2, i2, o2) {
            r.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(e2)}]`);
            const a2 = this.session.textureManager.createTextureFromLayout(t2, e2, n2, o2);
            return this.createTextureDataFromTexture(e2, t2, a2, i2);
          }
          reshapeUnpacked(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.unpacked), r2 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: o.ShapeUtil.computeStrides(t2), unpackedShape: t2 };
            return this.createTextureDataFromTexture(r2, e2.type, n2.texture).tensor;
          }
          reshapePacked(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.packed);
            if ((0, s.isReshapeCheap)(e2.dims, t2)) {
              const r3 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== t2.length ? t2 : [1], strides: o.ShapeUtil.computeStrides(t2), unpackedShape: t2, isPacked: true };
              return this.createTextureDataFromTexture(r3, e2.type, n2.texture).tensor;
            }
            const r2 = (0, s.processDims3D)(e2.dims), i2 = (0, s.processDims3D)(t2), a2 = this.reshapePacked(e2, r2), u2 = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a2, i2), [a2]);
            return this.reshapePacked(u2, t2);
          }
          cast(e2, t2) {
            const n2 = this.getOrCreateTextureData(e2, p.TextureType.unpacked);
            return this.createTextureDataFromTexture(n2, t2, n2.texture).tensor;
          }
          createTextureDataFromTexture(e2, t2, n2, r2, o2) {
            const a2 = Object.assign(Object.assign({}, e2), { tensor: r2 || new i.Tensor(e2.unpackedShape, t2, (e3) => this.readTexture(a2), async (e3) => this.readTextureAsync(a2), void 0, o2), texture: n2 });
            return this.setTextureData(a2.tensor.dataId, a2, e2.isPacked), a2;
          }
          getTextureData(e2, t2 = false) {
            return this.session.isInitializer(e2) ? this.session.getTextureData(e2, t2) : t2 ? this.packedTextureDataCache.get(e2) : this.unpackedTextureDataCache.get(e2);
          }
          setTextureData(e2, t2, n2 = false) {
            this.session.isInitializer(e2) ? this.session.setTextureData(e2, t2, n2) : (n2 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e2, t2);
          }
          isTextureLayoutCached(e2, t2 = false) {
            return !!this.getTextureData(e2.dataId, t2);
          }
          dispose() {
            this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e2) => this.session.textureManager.releaseTexture(e2)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((e2) => this.session.textureManager.releaseTexture(e2)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          readTexture(e2) {
            return e2.isPacked ? this.readTexture(this.unpack(e2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e2, e2.tensor.type, e2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e2));
          }
          async readTextureAsync(e2) {
            return e2.isPacked ? this.readTextureAsync(this.unpack(e2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e2, e2.tensor.type, e2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, e2));
          }
          pack(e2) {
            return this.executeProgram((0, a.createPackProgramInfoLoader)(this, e2.tensor), [e2.tensor]);
          }
          unpack(e2) {
            return this.executeProgram((0, l.createUnpackProgramInfoLoader)(this, e2.tensor), [e2.tensor]);
          }
        };
      }, 4110: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var i2 = Object.getOwnPropertyDescriptor(t2, n2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, i2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), o = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return i(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WEBGL_OP_RESOLVE_RULES = void 0;
        const a = n(8817), s = o(n(5194)), u = n(4752), l = n(6668), c = n(9754), p = n(5042), d = n(6742), f = n(4125), h = n(6149), g = n(5378), m = n(6981), b = n(7413), y = n(7006), v = n(8276), w = n(5565), x = n(2834), _ = n(1010), T = n(8126), S = n(2801), $ = n(565), O = n(2444), A = n(815), P = n(564), I = n(5416), E = n(1240), C2 = n(5944), D = n(5707), k = o(n(9087)), R = n(7862), M = n(3980);
        t.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", k.abs], ["Acos", "", "7+", k.acos], ["Add", "", "7+", s.add], ["And", "", "7+", s.and], ["Asin", "", "7+", k.asin], ["Atan", "", "7+", k.atan], ["AveragePool", "", "7+", x.averagePool, x.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a.batchNormalization, a.parseBatchNormalizationAttributes], ["Cast", "", "6+", u.cast, u.parseCastAttributes], ["Ceil", "", "6+", k.ceil], ["Clip", "", "6-10", k.clip, k.parseClipAttributes], ["Clip", "", "11+", k.clipV11], ["Concat", "", "4+", l.concat, l.parseConcatAttributes], ["Conv", "", "1+", c.conv, c.parseConvAttributes], ["ConvTranspose", "", "1+", p.convTranspose, p.parseConvTransposeAttributes], ["Cos", "", "7+", k.cos], ["Div", "", "7+", s.div], ["Dropout", "", "7+", k.identity], ["DepthToSpace", "", "1+", d.depthToSpace, d.parseDepthToSpaceAttributes], ["Equal", "", "7+", s.equal], ["Elu", "", "6+", k.elu, k.parseEluAttributes], ["Exp", "", "6+", k.exp], ["Flatten", "", "1+", f.flatten, f.parseFlattenAttributes], ["Floor", "", "6+", k.floor], ["FusedConv", "com.microsoft", "1+", c.conv, c.parseConvAttributes], ["Gather", "", "1+", h.gather, h.parseGatherAttributes], ["Gemm", "", "7-10", g.gemm, g.parseGemmAttributesV7], ["Gemm", "", "11+", g.gemm, g.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", x.globalAveragePool, x.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", x.globalMaxPool], ["Greater", "", "7+", s.greater], ["Identity", "", "1+", k.identity], ["ImageScaler", "", "1+", m.imageScaler, m.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", b.instanceNormalization, b.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", k.leakyRelu, k.parseLeakyReluAttributes], ["Less", "", "7+", s.less], ["LRN", "", "1+", y.lrn, y.parseLrnAttributes], ["Log", "", "6+", k.log], ["MatMul", "", "1+", v.matMul, v.parseMatMulAttributes], ["MaxPool", "", "1+", x.maxPool, x.parseMaxPoolAttributes], ["Mul", "", "7+", s.mul], ["Neg", "", "6+", k.neg], ["Not", "", "1+", k.not], ["Or", "", "7+", s.or], ["Pad", "", "2-10", w.padV2, w.parsePadAttributesV2], ["Pad", "", "11+", w.padV11, w.parsePadAttributesV11], ["Pow", "", "7+", s.pow], ["PRelu", "", "7+", s.pRelu], ["ReduceLogSum", "", "1+", _.reduceLogSum, _.parseReduceAttributes], ["ReduceMax", "", "1+", _.reduceMax, _.parseReduceAttributes], ["ReduceMean", "", "1+", _.reduceMean, _.parseReduceAttributes], ["ReduceMin", "", "1+", _.reduceMin, _.parseReduceAttributes], ["ReduceProd", "", "1+", _.reduceProd, _.parseReduceAttributes], ["ReduceSum", "", "1-12", _.reduceSum, _.parseReduceAttributes], ["ReduceSumSquare", "", "1+", _.reduceLogSumSquare, _.parseReduceAttributes], ["Relu", "", "6+", k.relu], ["Reshape", "", "5+", T.reshape], ["Resize", "", "10", S.resize, S.parseResizeAttributesV10], ["Resize", "", "11+", S.resize, S.parseResizeAttributesV11], ["Shape", "", "1+", $.shape], ["Sigmoid", "", "6+", k.sigmoid], ["Sin", "", "7+", k.sin], ["Slice", "", "10+", O.sliceV10], ["Slice", "", "1-9", O.slice, O.parseSliceAttributes], ["Softmax", "", "1-12", A.softmax, A.parseSoftmaxAttributes], ["Softmax", "", "13+", A.softmaxV13, A.parseSoftmaxAttributesV13], ["Split", "", "2-12", P.split, P.parseSplitAttributes], ["Sqrt", "", "6+", k.sqrt], ["Squeeze", "", "1-12", I.squeeze, I.parseSqueezeAttributes], ["Squeeze", "", "13+", I.squeezeV13], ["Sub", "", "7+", s.sub], ["Sum", "", "6+", E.sum], ["Tan", "", "7+", k.tan], ["Tanh", "", "6+", k.tanh], ["Tile", "", "6+", C2.tile], ["Transpose", "", "1+", D.transpose, D.parseTransposeAttributes], ["Upsample", "", "7-8", M.upsample, M.parseUpsampleAttributesV7], ["Upsample", "", "9", M.upsample, M.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", R.unsqueeze, R.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", R.unsqueezeV13], ["Xor", "", "7+", s.xor]];
      }, 8817: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseBatchNormalizationAttributes = t.batchNormalization = void 0;
        const r = n(4910), i = n(6757), o = n(5639), a = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] };
        t.batchNormalization = (e2, t2, n2) => (u(t2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(e2, t2, n2) }), t2)]), t.parseBatchNormalizationAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("epsilon", 1e-5), n2 = e2.attributes.getFloat("momentum", 0.9), i2 = e2.attributes.getInt("spatial", 1);
          return (0, r.createAttributeWithCacheKey)({ epsilon: t2, momentum: n2, spatial: i2 });
        };
        const s = (e2, t2, n2) => {
          const r2 = (0, i.getGlsl)(e2.session.backend.glContext.version), s2 = t2[0].dims.length, [u2, l] = e2.calculateTextureWidthAndHeight(t2[1].dims, o.TextureType.unpacked), c = `
  float process(int[${s2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u2}, ${l});
    float scale = getColorAsFloat(${r2.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r2.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r2.texture2D}(Variance, position));
    float b = getColorAsFloat(${r2.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n2.epsilon})) ) + b;
  }`;
          return Object.assign(Object.assign({}, a), { output: { dims: t2[0].dims, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: c });
        }, u = (e2) => {
          if (!e2 || 5 !== e2.length)
            throw new Error("BatchNormalization requires 5 inputs.");
          const t2 = e2[0], n2 = e2[1], r2 = e2[2], i2 = e2[3], o2 = e2[4];
          if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length || 1 !== i2.dims.length || 1 !== o2.dims.length)
            throw new Error("invalid input shape.");
          if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1] || i2.dims[0] !== t2.dims[1] || o2.dims[0] !== t2.dims[1])
            throw new Error("invalid input shape.");
          if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type || "float32" !== i2.type && "float64" !== i2.type || "float32" !== o2.type && "float64" !== o2.type)
            throw new Error("invalid input tensor types.");
        };
      }, 5194: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.xor = t.sub = t.pRelu = t.pow = t.or = t.mul = t.less = t.greater = t.equal = t.div = t.and = t.add = t.glslPRelu = t.glslPow = t.glslXor = t.glslOr = t.glslAnd = t.glslLess = t.glslGreater = t.glslEqual = t.glslSub = t.glslMul = t.glslDiv = t.glslAdd = void 0;
        const r = n(7273), i = n(1997), o = n(6757), a = n(5639);
        function s() {
          const e2 = "add_";
          return { body: `
  float ${e2}(float a, float b) {
    return a + b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function u() {
          const e2 = "div_";
          return { body: `
  float ${e2}(float a, float b) {
    return a / b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function l() {
          const e2 = "mul_";
          return { body: `
  float ${e2}(float a, float b) {
    return a * b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function c() {
          const e2 = "sub_";
          return { body: `
  float ${e2}(float a, float b) {
    return a - b;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function p() {
          const e2 = "equal_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function d() {
          const e2 = "greater_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function f() {
          const e2 = "less_";
          return { body: `
  float ${e2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function h() {
          const e2 = "and_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function g() {
          const e2 = "or_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function m() {
          const e2 = "xor_";
          return { body: `
  float ${e2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        function b() {
          return function(e2) {
            const t2 = `${e2}_`;
            return { body: `
  float ${t2}(float a, float b) {
    return ${e2}(a, b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return ${e2}(v1, v2);
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }("pow");
        }
        function y() {
          const e2 = "prelu_";
          return { body: `
  float ${e2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: e2, type: i.FunctionType.ValueBased };
        }
        t.glslAdd = s, t.glslDiv = u, t.glslMul = l, t.glslSub = c, t.glslEqual = p, t.glslGreater = d, t.glslLess = f, t.glslAnd = h, t.glslOr = g, t.glslXor = m, t.glslPow = b, t.glslPRelu = y;
        const v = (e2, t2, n2, r2 = t2[0].type, i2) => {
          const o2 = e2.session.pack ? a.TextureType.packed : a.TextureType.unpacked;
          return { name: n2.name, inputNames: ["A", "B"], inputTypes: [o2, o2], cacheHint: i2, get: () => w(e2, t2, n2, r2) };
        }, w = (e2, t2, n2, i2 = t2[0].type) => {
          const s2 = e2.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u2 = !r.ShapeUtil.areEqual(t2[0].dims, t2[1].dims);
          let l2 = t2[0].dims;
          const c2 = e2.session.pack;
          if (u2) {
            const a2 = r.BroadcastUtil.calcShape(t2[0].dims, t2[1].dims, false);
            if (!a2)
              throw new Error("Can't perform binary op on the given tensors");
            l2 = a2;
            const u3 = l2.length, p3 = 0 !== t2[0].dims.length ? t2[0].dims.length : 1, d3 = 0 !== t2[1].dims.length ? t2[1].dims.length : 1, f2 = 0 !== t2[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h2 = 0 !== t2[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g2 = (0, o.getGlsl)(e2.session.backend.glContext.version), m2 = c2 ? `
      ${n2.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n2.name}(a, b);
        ${g2.output} = result;
      }` : `
      ${n2.body}
      float process(int indices[${u3}]) {
        int aindices[${p3}];
        int bindices[${d3}];
        ${f2}
        ${h2}
        return ${n2.name}(_A(aindices), _B(bindices));
      }`;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: l2, type: i2, textureType: s2 }, shaderSource: m2, hasMain: c2 };
          }
          const p2 = (0, o.getGlsl)(e2.session.backend.glContext.version), d2 = `
    ${n2.body}
    void main() {
      vec4 v1 = ${p2.texture2D}(A, TexCoords);
      vec4 v2 = ${p2.texture2D}(B, TexCoords);
      vec4 result = ${n2.name}(v1, v2);
      ${p2.output} = result;
    }
    `;
          return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: t2[0].dims, type: i2, textureType: s2 }, shaderSource: d2, hasMain: true };
        };
        t.add = (e2, t2) => [e2.run(v(e2, t2, s()), t2)], t.and = (e2, t2) => [e2.run(v(e2, t2, h(), "bool"), t2)], t.div = (e2, t2) => [e2.run(v(e2, t2, u()), t2)], t.equal = (e2, t2) => [e2.run(v(e2, t2, p(), "bool"), t2)], t.greater = (e2, t2) => [e2.run(v(e2, t2, d(), "bool"), t2)], t.less = (e2, t2) => [e2.run(v(e2, t2, f(), "bool"), t2)], t.mul = (e2, t2) => [e2.run(v(e2, t2, l()), t2)], t.or = (e2, t2) => [e2.run(v(e2, t2, g(), "bool"), t2)], t.pow = (e2, t2) => [e2.run(v(e2, t2, b()), t2)], t.pRelu = (e2, t2) => [e2.run(v(e2, t2, y()), t2)], t.sub = (e2, t2) => [e2.run(v(e2, t2, c()), t2)], t.xor = (e2, t2) => [e2.run(v(e2, t2, m(), "bool"), t2)];
      }, 4752: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseCastAttributes = t.cast = void 0;
        const r = n(7273);
        t.cast = (e2, t2, n2) => (i(t2), [e2.cast(t2[0], n2)]), t.parseCastAttributes = (e2) => r.ProtoUtil.tensorDataTypeFromProto(e2.attributes.getInt("to"));
        const i = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Cast requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 4595: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedConcatProgramInfoLoader = void 0;
        const r = n(6757), i = n(5639), o = n(432), a = n(5614);
        t.createPackedConcatProgramInfoLoader = (e2, t2, n2) => {
          const u = (l = t2.length, c = n2.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: l }, (e3, t3) => `X${t3}`), inputTypes: Array(l).fill(i.TextureType.packed), cacheHint: c });
          var l, c;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, u2) => {
            const l2 = n3[0].dims.slice();
            if (u2 >= l2.length || u2 < -1 * l2.length)
              throw new Error("axis specified for concat doesn't match input dimensionality");
            u2 < 0 && (u2 = l2.length + u2);
            const c2 = l2.slice(0);
            for (let e4 = 1; e4 < n3.length; e4++) {
              const t4 = n3[e4].dims.slice();
              for (let e5 = 0; e5 < l2.length; e5++)
                if (e5 === u2)
                  c2[u2] += t4[e5];
                else if (l2[e5] !== t4[e5])
                  throw new Error("non concat dimensions must match");
            }
            const p = c2.length, d = (0, a.getChannels)("coords", p), f = (0, o.getCoordsDataType)(p), h = (0, a.unpackFromChannel)(), g = n3.map((e4) => e4.dims), m = (0, o.getGlChannels)(p), b = new Array(g.length - 1);
            b[0] = g[0][u2];
            for (let e4 = 1; e4 < b.length; e4++)
              b[e4] = b[e4 - 1] + g[e4][u2];
            const y = m[u2], v = m.slice(-2), w = m.join();
            let x = `if (${y} < ${b[0]}) {
        return getChannel(
            getX0(${w}), vec2(${v.join()}));
        }`;
            for (let e4 = 1; e4 < b.length; e4++) {
              const t4 = b[e4 - 1];
              x += `
            if (${y} < ${b[e4]}  && ${y} >= ${b[e4 - 1]}) {
              return getChannel(
                getX${e4}(${s(m, y, t4)}),
                vec2(${s(v, y, t4)}));
            }`;
            }
            const _ = b.length, T = b[b.length - 1];
            x += `
            return getChannel(
              getX${_}(${s(m, y, T)}),
              vec2(${s(v, y, T)}));`;
            const S = (0, r.getGlsl)(e3.session.backend.glContext.version), $ = `
          ${h}
          float getValue(${m.map((e4) => "int " + e4)}) {
            ${x}
          }

          void main() {
            ${f} coords = getOutputCoords();
            int lastDim = coords.${m[p - 1]};
            coords.${m[p - 1]} = coords.${m[p - 2]};
            coords.${m[p - 2]} = lastDim;

            vec4 result = vec4(getValue(${d}), 0., 0., 0.);

            ${d[p - 1]} = ${d[p - 1]} + 1;
            if (${d[p - 1]} < ${c2[p - 1]}) {
              result.g = getValue(${d});
            }

            ${d[p - 2]} = ${d[p - 2]} + 1;
            if (${d[p - 2]} < ${c2[p - 2]}) {
              result.a = getValue(${d});
            }

            ${d[p - 1]} = ${d[p - 1]} - 1;
            if (${d[p - 2]} < ${c2[p - 2]} &&
                ${d[p - 1]} < ${c2[p - 1]}) {
              result.b = getValue(${d});
            }
            ${S.output} = result;
          }
        `;
            return Object.assign(Object.assign({}, t3), { output: { dims: c2, type: n3[0].type, textureType: i.TextureType.packed }, shaderSource: $, hasMain: true });
          })(e2, u, t2, n2.axis) });
        };
        const s = (e2, t2, n2) => {
          const r2 = e2.indexOf(t2);
          return e2.map((e3, t3) => t3 === r2 ? `${e3} - ${n2}` : e3).join();
        };
      }, 6668: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConcatAttributes = t.concat = void 0;
        const r = n(4910), i = n(5639), o = n(4595);
        t.concat = (e2, t2, n2) => (p(t2), e2.session.pack && t2[0].dims.length > 1 ? [e2.run((0, o.createPackedConcatProgramInfoLoader)(e2, t2, n2), t2)] : [e2.run(a(e2, t2, n2), t2)]);
        const a = (e2, t2, n2) => {
          const r2 = (o2 = t2.length, a2 = n2.cacheKey, { name: "Concat", inputNames: Array.from({ length: o2 }, (e3, t3) => `X${t3}`), inputTypes: Array(o2).fill(i.TextureType.unpacked), cacheHint: a2 });
          var o2, a2;
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const o3 = n3[0].dims.slice();
            if (r3 >= o3.length || r3 < -1 * o3.length)
              throw new Error("axis specified for concat doesn't match input dimensionality");
            r3 < 0 && (r3 = o3.length + r3);
            const a3 = o3.slice(0);
            for (let e4 = 1; e4 < n3.length; e4++) {
              const t4 = n3[e4].dims.slice();
              for (let e5 = 0; e5 < o3.length; e5++)
                if (e5 === r3)
                  a3[r3] += t4[e5];
                else if (o3[e5] !== t4[e5])
                  throw new Error("non concat dimensions must match");
            }
            const p2 = a3.length, d = new Array(n3.length);
            let f = 0;
            for (let e4 = 0; e4 < d.length; ++e4)
              f += n3[e4].dims[r3], d[e4] = f;
            let h = "";
            h = n3.length < 5 ? s(d) : u(d);
            const g = `
        ${l(n3.length, p2)}
        ${c(d)}
        ${h}
        float process(int indices[${p2}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r3}]);

          if(textureIndex != 0) {
            indices[${r3}] = indices[${r3}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: a3, type: n3[0].type, textureType: i.TextureType.unpacked }, shaderSource: g });
          })(0, r2, t2, n2.axis) });
        }, s = (e2) => `int getTextureWhereDataResides(int index) {
      ${e2.map((e3, t2) => `if(index<${e3}) {return ${t2};}
`).join("")}
    }`, u = (e2) => s(e2), l = (e2, t2) => {
          const n2 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t2}]) {`];
          for (let t3 = 0; t3 < e2; ++t3)
            0 === t3 ? n2.push(`	if (textureIndex == ${t3}) { return _X${t3}(indices); }`) : t3 === e2 - 1 ? n2.push(`	else { return _X${t3}(indices); }`) : n2.push(`	else if (textureIndex == ${t3}) { return _X${t3}(indices); }`);
          return n2.push("	}"), n2.join("\n");
        }, c = (e2) => {
          const t2 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
          for (let n2 = 0; n2 < e2.length; ++n2)
            0 === n2 ? t2.push(`	if (index == ${n2}) { return ${e2[n2]}; }`) : n2 === e2.length - 1 ? t2.push(`	else { return ${e2[n2]}; }`) : t2.push(`	else if (index == ${n2}) { return ${e2[n2]}; }`);
          return t2.push("	}"), t2.join("\n");
        };
        t.parseConcatAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis") });
        const p = (e2) => {
          if (!e2 || e2.length < 1)
            throw new Error("too few inputs");
          const t2 = e2[0].type, n2 = e2[0].dims.length;
          if ("string" === t2)
            throw new Error("string tensor is not supported yet");
          for (const r2 of e2) {
            if (r2.type !== t2)
              throw new Error("input tensors should be one type");
            if (r2.dims.length !== n2)
              throw new Error("input tensors should have the same shape");
          }
        };
      }, 7825: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackedGroupedConvProgramInfoLoader = void 0;
        const r = n(1315), i = n(6757), o = n(5639), a = n(9754), s = n(2150);
        t.createUnpackedGroupedConvProgramInfoLoader = (e2, t2, n2) => {
          const u = (l = t2.length > 2, c = n2.cacheKey, { name: "GroupedConv", inputNames: l ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: l ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: c });
          var l, c;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, u2) => {
            const l2 = t3.length > 2 ? "value += getBias(output_channel);" : "", c2 = t3[0].dims.slice(), p = t3[1].dims.slice(), d = p[0] / u2.group;
            r.Logger.verbose("GroupedConv", `autpPad:${u2.autoPad}, dilations:${u2.dilations}, group:${u2.group}, kernelShape:${u2.kernelShape}, pads:${u2.pads}, strides:${u2.strides}`);
            const f = (0, a.calculateOutputShape)(c2, p, u2.dilations, u2.pads, u2.strides), h = (0, i.getGlsl)(e3.session.backend.glContext.version), { activationFunction: g, applyActivation: m } = (0, s.getActivationSnippet)(u2), b = `
  const ivec2 strides = ivec2(${u2.strides[0]}, ${u2.strides[1]});
  const ivec2 pads = ivec2(${u2.pads[0]}, ${u2.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${d};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u2.dilations[0]};

        if (xHeight < 0 || xHeight >= ${c2[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u2.dilations[1]};
          if (xWidth < 0 || xWidth >= ${c2[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${l2}
    ${m}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
            return Object.assign(Object.assign({}, n3), { output: { dims: f, type: t3[0].type, textureType: o.TextureType.unpacked }, shaderSource: b, hasMain: true });
          })(e2, t2, u, n2) });
        };
      }, 7708: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.conv2DPacked = t.conv2DPackedPointwise = void 0;
        const r = n(9754), i = n(5950), o = n(5632);
        t.conv2DPackedPointwise = (e2, t2, n2) => {
          const i2 = t2[0].dims, a = t2[1].dims, s = (0, r.calculateOutputShape)(i2, a, n2.dilations, n2.pads, n2.strides), u = e2.reshapePacked(t2[0], [i2[1], i2[2] * i2[3]]), l = e2.reshapePacked(t2[1], [a[0], a[1]]), c = t2.length > 2 ? [l, u, t2[2]] : [l, u], p = e2.run((0, o.createPackedMatmulProgramInfoLoader)(e2, c, n2), c);
          return e2.reshapePacked(p, s);
        }, t.conv2DPacked = (e2, t2, n2) => {
          const a = t2[0].dims, s = t2[1].dims, u = (0, r.calculateOutputShape)(a, s, n2.dilations, n2.pads, n2.strides), l = e2.run((0, i.createPackedIm2ColProgramInfoLoader)(e2, t2[0], t2[1], u, n2), [t2[0]]), c = e2.reshapePacked(t2[1], [s[0], s[1] * s[2] * s[3]]), p = 3 === t2.length ? [c, l, t2[2]] : [c, l], d = e2.run((0, o.createPackedMatmulProgramInfoLoader)(e2, p, n2), p);
          return e2.reshapePacked(d, u);
        };
      }, 5042: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConvTransposeAttributes = t.convTranspose = void 0;
        const r = n(4910), i = n(6757), o = n(5639), a = n(2150), s = (e2, t2, n2, r2, i2, o2) => (e2 - 1) * t2 + n2 + (r2 - 1) * i2 + 1 - o2, u = (e2, t2, n2, r2, i2) => {
          const o2 = Math.floor(e2 / 2);
          "SAME_UPPER" === t2 ? (n2[r2] = o2, n2[i2] = e2 - o2) : "SAME_LOWER" === t2 && (n2[r2] = e2 - o2, n2[i2] = o2);
        };
        t.convTranspose = (e2, t2, n2) => (d(t2, n2), l(e2, t2, n2));
        const l = (e2, t2, n2) => {
          const r2 = p(n2, t2);
          return [c(e2, t2, r2)];
        }, c = (e2, t2, n2) => e2.run(((e3, t3, n3) => {
          const r2 = (s2 = t3.length > 2, u2 = n3.cacheKey, { name: "ConvTranspose", inputNames: s2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: u2 });
          var s2, u2;
          return Object.assign(Object.assign({}, r2), { get: () => ((e4, t4, n4, r3) => {
            const s3 = t4.length > 2 ? "getB(output_channel)" : "0.0", u3 = t4[0].dims, l2 = t4[1].dims, c2 = l2[1], p2 = l2[0] / r3.group, d2 = [t4[0].dims[0], t4[1].dims[1] * r3.group, ...r3.outputShape], f = (0, i.getGlsl)(e4.session.backend.glContext.version), { activationFunction: h, applyActivation: g } = (0, a.getActivationSnippet)(r3), m = `
  const ivec2 strides = ivec2(${r3.strides[0]}, ${r3.strides[1]});
  const ivec2 pads = ivec2(${r3.pads[0]}, ${r3.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${c2};
    int wOutChannel = output_channel - group_id * ${c2};

    float value = ${s3};
    for (int inChannelOffset = 0; inChannelOffset < ${p2}; inChannelOffset++) {
      int input_channel = group_id * ${p2} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${l2[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${l2[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r3.dilations[0]}, wHOff * ${r3.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u3[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u3[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${f.output} = vec4(value, .0, .0, .0);
  }
`;
            return Object.assign(Object.assign({}, n4), { output: { dims: d2, type: t4[0].type, textureType: o.TextureType.unpacked }, shaderSource: m, hasMain: true });
          })(e3, t3, r2, n3) });
        })(e2, t2, n2), t2), p = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          if (0 === e2.kernelShape.length)
            for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
              n2.push(t2[1].dims[e3]);
          const r2 = e2.pads.slice(), i2 = e2.outputShape.slice();
          ((e3, t3, n3, r3, i3, o3, a2, l2) => {
            const c2 = e3.length - 2, p2 = 0 === l2.length;
            for (let d2 = 0; d2 < c2; ++d2) {
              const f = p2 ? e3[d2 + 2] * o3[d2] : l2[d2], h = s(e3[d2 + 2], o3[d2], i3[d2], t3[d2], n3[d2], f);
              u(h, r3, i3, d2, d2 + c2), p2 && l2.push(o3[d2] * (e3[d2 + 2] - 1) + a2[d2] + (t3[d2] - 1) * n3[d2] + 1 - i3[d2] - i3[d2 + c2]);
            }
          })(t2[0].dims, n2, e2.dilations, e2.autoPad, r2, e2.strides, e2.outputPadding, i2);
          const o2 = Object.assign({}, e2);
          return Object.assign(o2, { kernelShape: n2, pads: r2, outputShape: i2, cacheKey: e2.cacheKey }), o2;
        };
        t.parseConvTransposeAttributes = (e2) => {
          const t2 = e2.attributes, n2 = (0, a.parseInternalActivationAttributes)(t2), i2 = t2.getString("auto_pad", "NOTSET"), o2 = t2.getInts("dilations", [1, 1]), s2 = t2.getInt("group", 1), u2 = t2.getInts("kernel_shape", []), l2 = t2.getInts("output_padding", [0, 0]), c2 = t2.getInts("output_shape", []), p2 = t2.getInts("pads", [0, 0, 0, 0]), d2 = t2.getInts("strides", [1, 1]);
          return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: s2, kernelShape: u2, outputPadding: l2, outputShape: c2, pads: p2, strides: d2 }, n2));
        };
        const d = (e2, t2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Conv requires 2 or 3 inputs");
          if (4 !== e2[0].dims.length || 4 !== e2[1].dims.length)
            throw new Error("currently only support 2-dimensional conv");
          if (e2[0].dims[1] !== e2[1].dims[0])
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          const n2 = e2[1].dims[1] * t2.group;
          if (3 === e2.length && (1 !== e2[2].dims.length || e2[2].dims[0] !== n2))
            throw new Error("invalid bias");
          const r2 = e2[0].dims.length - 2;
          if (t2.dilations.length !== r2)
            throw new Error(`dilations should be ${r2}D`);
          if (t2.strides.length !== r2)
            throw new Error(`strides should be ${r2}D`);
          if (t2.pads.length !== 2 * r2)
            throw new Error(`pads should be ${2 * r2}D`);
          if (t2.outputPadding.length !== r2)
            throw new Error(`output_padding should be ${r2}D`);
          if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e2[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if (0 !== t2.outputShape.length && t2.outputShape.length !== e2[0].dims.length - 2)
            throw new Error("invalid output shape");
          if ("float32" !== e2[0].type || "float32" !== e2[1].type)
            throw new Error("ConvTranspose input(X,W) should be float tensor");
          if (3 === e2.length && "float32" !== e2[2].type)
            throw new Error("ConvTranspose input(bias) should be float tensor");
        };
      }, 9754: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConvAttributes = t.conv = t.calculateOutputShape = void 0;
        const r = n(4910), i = n(7273), o = n(7825), a = n(7708), s = n(3281), u = n(2150), l = n(1625), c = n(8276);
        t.calculateOutputShape = (e2, t2, n2, r2, i2) => {
          const o2 = e2[0], a2 = e2.slice(2), s2 = a2.length, u2 = t2[0], l2 = t2.slice(2).map((e3, t3) => e3 + (e3 - 1) * (n2[t3] - 1)), c2 = a2.map((e3, t3) => e3 + r2[t3] + r2[t3 + s2]).map((e3, t3) => Math.floor((e3 - l2[t3] + i2[t3]) / i2[t3]));
          return [o2, u2].concat(...c2);
        }, t.conv = (e2, t2, n2) => (g(t2, n2), p(e2, t2, n2));
        const p = (e2, t2, n2) => {
          const r2 = h(n2, t2), i2 = e2.session.pack, s2 = 1 === r2.kernelShape[0] && 1 === r2.kernelShape[1];
          return r2.group > 1 ? [e2.run((0, o.createUnpackedGroupedConvProgramInfoLoader)(e2, t2, r2), t2)] : s2 && i2 ? [d(e2, t2, r2)] : i2 && 4 === t2[0].dims.length && 1 === t2[0].dims[0] && !s2 ? [(0, a.conv2DPacked)(e2, t2, r2)] : [f(e2, t2, r2)];
        }, d = (e2, n2, r2) => {
          const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, t.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), s2 = e2.reshapeUnpacked(n2[0], [i2[1], i2[2] * i2[3]]), u2 = e2.reshapeUnpacked(n2[1], [o2[0], o2[1]]), l2 = n2.length > 2 ? [u2, s2, n2[2]] : [u2, s2], p2 = e2.run((0, c.createMatmulProgramInfoLoader)(l2, r2), l2);
          return e2.reshapeUnpacked(p2, a2);
        }, f = (e2, n2, r2) => {
          const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, t.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), u2 = e2.run((0, l.createIm2ColProgramInfoLoader)(e2, n2[0], n2[1], a2, r2), [n2[0]]), c2 = 3 === n2.length ? [u2, n2[1], n2[2]] : [u2, n2[1]];
          return e2.run((0, s.createDotProductProgramInfoLoader)(e2, n2, a2, r2), c2);
        }, h = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          if (0 === e2.kernelShape.length)
            for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
              n2.push(t2[1].dims[e3]);
          const r2 = e2.pads.slice();
          i.PoolConvUtil.adjustPadsBasedOnAutoPad(t2[0].dims, e2.strides, e2.dilations, n2, r2, e2.autoPad);
          const o2 = Object.assign({}, e2);
          return Object.assign(o2, { kernelShape: n2, pads: r2, cacheKey: e2.cacheKey }), o2;
        };
        t.parseConvAttributes = (e2) => {
          const t2 = e2.attributes, n2 = (0, u.parseInternalActivationAttributes)(t2), i2 = t2.getString("auto_pad", "NOTSET"), o2 = t2.getInts("dilations", [1, 1]), a2 = t2.getInt("group", 1), s2 = t2.getInts("kernel_shape", []), l2 = t2.getInts("pads", [0, 0, 0, 0]), c2 = t2.getInts("strides", [1, 1]);
          return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: a2, kernelShape: s2, pads: l2, strides: c2 }, n2));
        };
        const g = (e2, t2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Conv requires 2 or 3 inputs");
          if (4 !== e2[0].dims.length || 4 !== e2[1].dims.length)
            throw new Error("currently only support 2-dimensional conv");
          if (e2[0].dims[1] !== e2[1].dims[1] * t2.group)
            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
          if (3 === e2.length && (1 !== e2[2].dims.length || e2[1].dims[0] !== e2[2].dims[0]))
            throw new Error("invalid bias");
          const n2 = e2[0].dims.length - 2;
          if (t2.dilations.length !== n2)
            throw new Error(`dilations should be ${n2}D`);
          if (t2.strides.length !== n2)
            throw new Error(`strides should be ${n2}D`);
          if (t2.pads.length !== 2 * n2)
            throw new Error(`pads should be ${2 * n2}D`);
          if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e2[1].dims.length - 2)
            throw new Error("invalid kernel shape");
          if ("float32" !== e2[0].type || "float32" !== e2[1].type)
            throw new Error("Conv input(X,W) should be float tensor");
          if (3 === e2.length && "float32" !== e2[2].type)
            throw new Error("Conv input(bias) should be float tensor");
        };
      }, 6742: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseDepthToSpaceAttributes = t.depthToSpace = void 0;
        const r = n(5707);
        t.depthToSpace = (e2, t2, n2) => {
          i(t2);
          const o = n2.blocksize, a = o * o, s = "DCR" === n2.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u = "DCR" === n2.mode ? [t2[0].dims[0], o, o, t2[0].dims[1] / a, t2[0].dims[2], t2[0].dims[3]] : [t2[0].dims[0], t2[0].dims[1] / a, o, o, t2[0].dims[2], t2[0].dims[3]], l = e2.reshapeUnpacked(t2[0], u), c = { perm: s, cacheKey: `${s}` }, [p] = (0, r.transpose)(e2, [l], c), d = [t2[0].dims[0], t2[0].dims[1] / a, t2[0].dims[2] * o, t2[0].dims[3] * o];
          return [e2.reshapeUnpacked(p, d)];
        }, t.parseDepthToSpaceAttributes = (e2) => {
          const t2 = e2.attributes.getInt("blocksize");
          if (t2 < 1)
            throw new Error(`blocksize must be >= 1, but got : ${t2} for DepthToSpace`);
          const n2 = e2.attributes.getString("mode", "DCR");
          if ("DCR" !== n2 && "CRD" !== n2)
            throw new Error(`unrecognized mode: ${n2} for DepthToSpace`);
          return { mode: n2, blocksize: t2 };
        };
        const i = (e2) => {
          if (1 !== e2.length)
            throw new Error(`DepthToSpace expect 1 inputs, but got ${e2.length}`);
          if ("string" === e2[0].type || 4 !== e2[0].dims.length)
            throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
        };
      }, 3281: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createDotProductProgramInfoLoader = void 0;
        const r = n(7273), i = n(6757), o = n(5639), a = n(2150), s = n(1625);
        t.createDotProductProgramInfoLoader = (e2, t2, n2, u) => {
          const l = ((e3, t3) => ({ name: "ConvDotProduct", inputNames: e3 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: e3 ? [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.packedLastDimension], cacheKey: t3.activationCacheKey }))(t2.length > 2, u);
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, u2, l2) => {
            const c = n3[0].dims, p = n3[1].dims, d = [p[0], Math.ceil(c[1] * p[2] * p[3] / 4)], f = (0, s.calculateIm2ColDims)(c, p, u2), [h, g] = e3.calculateTextureWidthAndHeight(d, o.TextureType.packedLastDimension), m = r.ShapeUtil.computeStrides(f), [b, y] = e3.calculateTextureWidthAndHeight(f, o.TextureType.packedLastDimension), v = u2.length, w = n3.length < 3 ? "0.0" : "_B(b)", x = Math.ceil(c[1] * p[2] * p[3] / 4), { activationFunction: _, applyActivation: T } = (0, a.getActivationSnippet)(l2), S = (0, i.getGlsl)(e3.session.backend.glContext.version), $ = `
${_}
float process(int indices[${v}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${m[0]} + im2col[1] * ${m[1]} + im2col[2] * ${m[2]};
  int kernelOffset = indices[1] * ${d[1]};
  float value = ${w};
  for (int i = 0; i < ${x}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${b}, ${y});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${T}
  return value;
}`;
            return Object.assign(Object.assign({}, t3), { output: { dims: u2, type: n3[0].type, textureType: o.TextureType.unpacked }, shaderSource: $ });
          })(e2, l, t2, n2, u) });
        };
      }, 4125: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseFlattenAttributes = t.flatten = void 0;
        const r = n(7273);
        t.flatten = (e2, t2, n2) => {
          i(t2, n2);
          const o = r.ShapeUtil.flattenShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], o)];
        }, t.parseFlattenAttributes = (e2) => e2.attributes.getInt("axis", 1);
        const i = (e2, t2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Flatten requires 1 input.");
          const n2 = e2[0].dims.length;
          if (0 === n2)
            throw new Error("scalar tensor is not supported.");
          if (t2 < -n2 || t2 > n2)
            throw new Error("Invalid axis");
          if ("string" === e2[0].type)
            throw new Error("string tensor is not supported.");
        };
      }, 2150: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseInternalActivationAttributes = t.getActivationSnippet = void 0;
        const r = n(7273), i = n(9087);
        t.getActivationSnippet = function(e2) {
          let t2;
          switch (e2.activation) {
            case "Relu":
              t2 = (0, i.glslRelu)();
              break;
            case "Sigmoid":
              t2 = (0, i.glslSigmoid)();
              break;
            case "Clip":
              t2 = (0, i.glslClip)(e2.clipMin, e2.clipMax);
              break;
            default:
              return { activationFunction: "", applyActivation: "" };
          }
          const n2 = t2.name;
          return { activationFunction: t2.body, applyActivation: `value = ${n2}_(value);` };
        }, t.parseInternalActivationAttributes = (e2) => {
          const t2 = e2.getString("activation", "");
          if ("Clip" === t2) {
            const [n2, i2] = e2.getFloats("activation_params", [r.MIN_CLIP, r.MAX_CLIP]);
            return { activation: t2, clipMax: i2, clipMin: n2, activationCacheKey: `${t2}:${n2},${i2}` };
          }
          return { activation: t2, activationCacheKey: t2 };
        };
      }, 6149: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseGatherAttributes = t.gather = void 0;
        const r = n(4910), i = n(6145), o = n(7273), a = n(5639);
        t.gather = (e2, t2, n2) => (l(t2, n2.axis), [e2.run(u(e2, t2, n2), t2)]), t.parseGatherAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", 0) });
        const s = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, u = (e2, t2, n2) => {
          const r2 = Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey });
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const i2 = n3[0].dims.slice(), s2 = n3[1].dims.slice(), u2 = new Array(i2.length + s2.length - 1);
            r3 = o.ShapeUtil.normalizeAxis(r3, i2.length);
            const l2 = [];
            for (let e4 = 0; e4 < u2.length; e4++)
              e4 < r3 ? (u2[e4] = i2[e4], l2.push(`inputIdx[${e4}] = outputIdx[${e4}];`)) : e4 < r3 + s2.length ? (u2[e4] = s2[e4 - r3], l2.push(`indexDataIdx[${e4 - r3}] = outputIdx[${e4}];`)) : (u2[e4] = i2[e4 - s2.length + 1], l2.push(`inputIdx[${e4 - s2.length + 1}] = outputIdx[${e4}];`));
            const c = `
      float process(int outputIdx[${u2.length || 1}]) {
        int inputIdx[${i2.length}];
        int indexDataIdx[${s2.length || 1}];
        indexDataIdx[0] = 0;
        ${l2.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r3}] = idx < 0 ? idx + ${i2[r3]} : idx;
        return _A(inputIdx);
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: u2, type: n3[0].type, textureType: a.TextureType.unpacked }, shaderSource: c });
          })(0, r2, t2, n2.axis) });
        }, l = (e2, t2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Gather requires 2 inputs.");
          const n2 = e2[0].dims.length;
          if (n2 < 1)
            throw new Error("Invalid input shape.");
          if (t2 < -n2 || t2 > n2 - 1)
            throw new Error("Invalid axis.");
          if (-1 === i.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invaid input type.");
          if ("int32" !== e2[1].type && "int16" !== e2[1].type)
            throw new Error("Invaid input type.");
        };
      }, 5378: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseGemmAttributesV11 = t.parseGemmAttributesV7 = t.gemm = void 0;
        const r = n(4910), i = n(7273), o = n(5639);
        t.gemm = (e2, t2, n2) => (l(t2, n2), [e2.run(s(t2, n2), t2)]);
        const a = (e2, t2) => {
          const n2 = 0 !== e2.attributes.getInt("transA", 0), i2 = 0 !== e2.attributes.getInt("transB", 0), o2 = e2.attributes.getFloat("alpha", 1), a2 = e2.attributes.getFloat("beta", 1);
          return (0, r.createAttributeWithCacheKey)({ transA: n2, transB: i2, alpha: o2, beta: a2, isOptionalC: t2 });
        };
        t.parseGemmAttributesV7 = (e2) => a(e2, false), t.parseGemmAttributesV11 = (e2) => a(e2, true);
        const s = (e2, t2) => {
          const n2 = { name: "Gemm", inputNames: 3 === e2.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === e2.length ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], key: t2.cacheKey };
          return Object.assign(Object.assign({}, n2), { get: () => u(n2, e2, t2) });
        }, u = (e2, t2, n2) => {
          const r2 = t2[0].dims.slice(), a2 = t2[1].dims.slice(), [s2, u2] = i.GemmUtil.getShapeOfGemmResult(r2, n2.transA, a2, n2.transB, 3 === t2.length ? t2[2].dims : void 0), l2 = [s2, u2];
          if (!l2)
            throw new Error("Can't use gemm on the given tensors");
          let c = r2[r2.length - 1], p = "";
          n2.transA && (c = r2[0]), n2.transA && n2.transB ? p = "value += _A_T(a) * _B_T(b);" : n2.transA && !n2.transB ? p = "value += _A_T(a) * _B(b);" : !n2.transA && n2.transB ? p = "value += _A(a) * _B_T(b);" : n2.transA || n2.transB || (p = "value += _A(a) * _B(b);");
          const d = l2.length, f = `
      float process(int indices[${d}]) {
          int a[${d}];
          int b[${d}];
          ${3 === t2.length ? `int c[${t2[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === t2.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${c}; ++k) {
              a[${d - 1}] = k;
              b[${d - 2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3 === t2.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
          return Object.assign(Object.assign({}, e2), { output: { dims: l2, type: t2[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n2.alpha }, { name: "beta", type: "float", data: n2.beta }], shaderSource: f });
        }, l = (e2, t2) => {
          if (!e2)
            throw new Error("Input is missing");
          if (t2.isOptionalC && (e2.length < 2 || e2.length > 3))
            throw new Error("Invaid input shape.");
          if (!t2.isOptionalC && 3 !== e2.length)
            throw new Error("Gemm requires 3 inputs");
          if (3 === e2.length && 1 !== e2[2].dims.length && 2 !== e2[2].dims.length)
            throw new Error("Invalid input shape of C");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type || "float32" !== e2[1].type && "float64" !== e2[1].type || 3 === e2.length && "float32" !== e2[2].type && "float64" !== e2[2].type)
            throw new Error("Invalid input type.");
          if (e2[0].type !== e2[1].type || 3 === e2.length && e2[0].type !== e2[2].type)
            throw new Error("Input types are mismatched");
        };
      }, 5950: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedIm2ColProgramInfoLoader = void 0;
        const r = n(6757), i = n(5639), o = n(5614);
        t.createPackedIm2ColProgramInfoLoader = (e2, t2, n2, a, s) => {
          const u = (l = s.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [i.TextureType.packed], cacheHint: l });
          var l;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, a2, s2, u2) => {
            const l2 = n3.dims, c = a2.dims, p = s2.length, d = [c[1] * c[2] * c[3], s2[2] * s2[3]], f = c[2] * c[3], h = (0, o.unpackFromChannel)(), g = (0, r.getGlsl)(e3.session.backend.glContext.version);
            let m = "";
            for (let e4 = 0; e4 <= 1; e4++)
              for (let t4 = 0; t4 <= 1; t4++)
                m += `
            blockIndex = rc.x + ${t4};
            pos = rc.y + ${e4};

            if(blockIndex < ${d[1]} && pos < ${d[0]}) {
              offsetY = int(blockIndex / (${s2[p - 1]})) * ${u2.strides[0]} -
                ${u2.pads[0]};
              d0 = offsetY + ${u2.dilations[0]} * (imod(pos, ${f}) / ${c[2]});

              if(d0 < ${l2[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s2[p - 1]}) * ${u2.strides[1]} -
                  ${u2.pads[1]};
                d1 = offsetX + ${u2.dilations[1]} * imod(imod(pos, ${f}), ${c[2]});

                if(d1 < ${l2[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${f}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * e4 + t4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
            const b = `
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${m}
          ${g.output} = result;
      }
            `;
            return Object.assign(Object.assign({}, t3), { output: { dims: d, type: n3.type, textureType: i.TextureType.packed }, shaderSource: b, hasMain: true });
          })(e2, u, t2, n2, a, s) });
        };
      }, 1625: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.calculateIm2ColDims = t.createIm2ColProgramInfoLoader = void 0;
        const r = n(5639);
        t.createIm2ColProgramInfoLoader = (e2, n2, i, o, a) => {
          const s = (u = a.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r.TextureType.unpacked], cacheHint: u });
          var u;
          return Object.assign(Object.assign({}, s), { get: () => ((e3, n3, i2, o2, a2, s2) => {
            const u2 = i2.dims, l = o2.dims, c = a2.length, p = (0, t.calculateIm2ColDims)(u2, l, a2, 4), d = `
        const int XC = ${u2[1]};
        const int XH = ${u2[2]};
        const int XW = ${u2[3]};
        const int KH = ${s2.kernelShape[0]};
        const int KW = ${s2.kernelShape[1]};
        const int dilationH = ${s2.dilations[0]};
        const int dilationW = ${s2.dilations[1]};
        const int strideH = ${s2.strides[0]};
        const int strideW = ${s2.strides[1]};
        const int padH = ${s2.pads[0]};
        const int padW = ${s2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${c}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u2.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
            return Object.assign(Object.assign({}, n3), { output: { dims: p, type: i2.type, textureType: r.TextureType.packedLastDimension }, shaderSource: d });
          })(0, s, n2, i, o, a) });
        }, t.calculateIm2ColDims = (e2, t2, n2, r2 = 4) => [n2[0], n2[2], n2[3], Math.ceil(e2[1] * t2[2] * t2[3] / r2)];
      }, 6981: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseImageScalerAttributes = t.imageScaler = void 0;
        const r = n(4910), i = n(5639);
        t.imageScaler = (e2, t2, n2) => (u(t2), [e2.run(a(e2, t2, n2), t2)]), t.parseImageScalerAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("scale"), n2 = e2.attributes.getFloats("bias");
          return (0, r.createAttributeWithCacheKey)({ scale: t2, bias: n2 });
        };
        const o = { name: "ImageScaler", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (e2, t2, n2) => {
          const r2 = Object.assign(Object.assign({}, o), { cacheHint: n2.cacheKey });
          return Object.assign(Object.assign({}, r2), { get: () => ((e3, t3, n3, r3) => {
            const o2 = n3[0].dims.slice(), a2 = o2.length, u2 = `
      ${s(r3.bias.length)}
      float process(int indices[${a2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: o2, type: n3[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r3.bias.length, data: r3.bias }, { name: "scale", type: "float", data: r3.scale }], shaderSource: u2 });
          })(0, r2, t2, n2) });
        }, s = (e2) => {
          const t2 = [`float getBias(float bias[${e2}], int channel) {`];
          for (let n2 = 0; n2 < e2; ++n2)
            0 === n2 ? t2.push(`	if (channel == ${n2}) { return bias[${n2}]; }`) : n2 === e2 - 1 ? t2.push(`	else { return bias[${n2}]; }`) : t2.push(`	else if (channel == ${n2}) { return bias[${n2}]; }`);
          return t2.push("	}"), t2.join("\n");
        }, u = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("ImageScaler requires 1 input.");
          if (4 !== e2[0].dims.length)
            throw new Error("Invalid input shape.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 7413: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseInstanceNormalizationAttributes = t.instanceNormalization = void 0;
        const r = n(6757), i = n(5639);
        t.instanceNormalization = (e2, t2, n2) => {
          l(t2);
          const r2 = e2.run(a(t2[0]), t2);
          return [e2.run(u(e2, t2[0], n2, r2.dims), [t2[0], r2, t2[1], t2[2]])];
        }, t.parseInstanceNormalizationAttributes = (e2) => e2.attributes.getFloat("epsilon", 1e-5);
        const o = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (e2) => Object.assign(Object.assign({}, o), { get: () => ((e3, t2) => {
          const n2 = t2.dims.slice(), r2 = n2[1], o2 = n2[2] * n2[3], a2 = [n2[0], r2], s2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o2});
        temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o2});

        return v;
      }`;
          return Object.assign(Object.assign({}, e3), { output: { dims: a2, type: t2.type, textureType: i.TextureType.packedLastDimension }, shaderSource: s2 });
        })(o, e2) }), s = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked, i.TextureType.unpacked] }, u = (e2, t2, n2, o2) => {
          const a2 = Object.assign(Object.assign({}, s), { cacheHint: `${n2}` });
          return Object.assign(Object.assign({}, a2), { get: () => ((e3, t3, n3, o3, a3) => {
            const s2 = (0, r.getGlsl)(e3.session.backend.glContext.version), [u2, l2] = e3.calculateTextureWidthAndHeight(a3, i.TextureType.packedLastDimension), [c, p] = [u2 / 4, l2], d = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${c}, ${p});
        return ${s2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: i.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: o3 }], shaderSource: d });
          })(e2, a2, t2, n2, o2) });
        }, l = (e2) => {
          if (!e2 || 3 !== e2.length)
            throw new Error("InstanceNormalization requires 3 inputs.");
          const t2 = e2[0], n2 = e2[1], r2 = e2[2];
          if (t2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length)
            throw new Error("Invalid input shape.");
          if (n2.dims[0] !== t2.dims[1] || r2.dims[0] !== t2.dims[1])
            throw new Error("Input shapes are mismatched.");
          if ("float32" !== t2.type && "float64" !== t2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type)
            throw new Error("Invalid input type.");
          if (4 !== e2[0].dims.length)
            throw new Error("Only support 4-D input shape.");
        };
      }, 7006: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createLrnProgramInfoLoader = t.parseLrnAttributes = t.lrn = void 0;
        const r = n(4910), i = n(5639);
        t.lrn = (e2, t2, n2) => (s(t2), [e2.run(a(t2, n2), t2)]), t.parseLrnAttributes = (e2) => {
          const t2 = e2.attributes.getFloat("alpha", 1e-4), n2 = e2.attributes.getFloat("beta", 0.75), i2 = e2.attributes.getFloat("bias", 1), o2 = e2.attributes.getInt("size");
          return (0, r.createAttributeWithCacheKey)({ alpha: t2, beta: n2, bias: i2, size: o2 });
        };
        const o = { name: "LRN", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] };
        function a(e2, t2) {
          return Object.assign(Object.assign({}, o), { cacheHint: t2.cacheKey, get: () => function(e3, t3) {
            const n2 = e3[0].dims[1], r2 = e3[0].dims.length, a2 = -Math.floor((t3.size - 1) / 2), s2 = Math.ceil((t3.size - 1) / 2), u = `float(${t3.alpha}) / float(${t3.size})`, l = `
    float process(int indices[${r2}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${a2}; i <= ${s2}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${n2}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${t3.bias}) + ${u} * square_sum, float(${t3.beta}));
    }`;
            return Object.assign(Object.assign({}, o), { cacheHint: t3.cacheKey, output: { dims: e3[0].dims, type: e3[0].type, textureType: i.TextureType.unpacked }, shaderSource: l });
          }(e2, t2) });
        }
        t.createLrnProgramInfoLoader = a;
        const s = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("LRN requires 1 input.");
          if (4 !== e2[0].dims.length)
            throw new Error('currently only support LRN for input with "NCHW" format');
          if ("float32" !== e2[0].type)
            throw new Error("input should be float type");
        };
      }, 5632: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackedMatmulProgramInfoLoader = void 0;
        const r = n(7273), i = n(6757), o = n(5639), a = n(432), s = n(2150), u = n(8276);
        t.createPackedMatmulProgramInfoLoader = (e2, t2, n2) => {
          const l = (c = t2.length > 2, p = n2.activationCacheKey, { name: "MatMul (packed)", inputNames: c ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: c ? [o.TextureType.packed, o.TextureType.packed, o.TextureType.packed] : [o.TextureType.packed, o.TextureType.packed], cacheHint: p });
          var c, p;
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, l2) => {
            const c2 = n3.length > 2, p2 = c2 ? "value += getBiasForMatmul();" : "", d = n3[0].dims, f = n3[1].dims, h = r.BroadcastUtil.calcShape(d, f, true), g = !r.ShapeUtil.areEqual(n3[0].dims, n3[1].dims);
            if (!h)
              throw new Error("Can't use matmul on the given tensors");
            const m = d[d.length - 1], b = Math.ceil(m / 2), y = d.length, v = f.length, w = (0, i.getGlsl)(e3.session.backend.glContext.version), x = (0, a.getCoordsDataType)(h.length), _ = h.length, T = (0, a.getGlChannels)(), { activationFunction: S, applyActivation: $ } = (0, s.getActivationSnippet)(l2), O = c2 ? `${(0, u.getBiasForMatmul)(x, T, n3[2].dims, h, true)}` : "", A = g ? `${function(e4, t4, n4, i2) {
              let o2 = [], a2 = [];
              const s2 = n4[0].dims, u2 = n4[1].dims, l3 = s2.length, c3 = u2.length, p3 = i2.length, d2 = p3 - l3, f2 = p3 - c3;
              o2 = s2.map((e5, n5) => `coords.${t4[n5 + d2]}`), o2[l3 - 1] = "i*2", o2.join(", "), a2 = u2.map((e5, n5) => `coords.${t4[n5 + f2]}`), a2[c3 - 2] = "i*2", a2.join(", ");
              const h2 = r.BroadcastUtil.getBroadcastDims(s2, i2), g2 = r.BroadcastUtil.getBroadcastDims(u2, i2), m2 = h2.map((e5) => `coords.${t4[e5 + d2]} = 0;`).join("\n"), b2 = g2.map((e5) => `coords.${t4[e5 + f2]} = 0;`).join("\n"), y2 = `int lastDim = coords.${t4[p3 - 1]};
  coords.${t4[p3 - 1]} = coords.${t4[p3 - 2]};
  coords.${t4[p3 - 2]} = lastDim;`;
              return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${e4} coords = getOutputCoords();
  ${y2}
  ${m2}
  vec4 outputValue = getA(${o2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e4} coords = getOutputCoords();
  ${y2}
  ${b2}
  vec4 outputValue = getB(${a2});
  return outputValue;
}`;
            }(x, T, n3, h)}` : "", P = g ? "getAAtOutCoordsMatmul(i)" : `getA(${function(e4, t4) {
              let n4 = "";
              for (let r2 = 0; r2 < t4 - 2; r2++)
                n4 += `rc.${e4[r2]}, `;
              return n4 += `rc.${e4[t4 - 2]}, i*2`, n4;
            }(T, y)})`, I = g ? "getBAtOutCoordsMatmul(i)" : `getB(${function(e4, t4) {
              let n4 = "";
              for (let r2 = 0; r2 < t4 - 2; r2++)
                n4 += `rc.${e4[r2]}, `;
              return n4 += `i*2, rc.${e4[t4 - 1]}`, n4;
            }(T, v)})`, E = `
            ${A}
            ${O}
            ${S}
            void main() {
              ${g ? "" : `${x} rc =
          getOutputCoords(); int lastDim = rc.${T[_ - 1]}; rc.${T[_ - 1]} =
          rc.${T[_ - 2]}; rc.${T[_ - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${b}; i++) {
                vec4 a = ${P};
                vec4 b = ${I};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p2}
              ${$}
              ${w.output} = value;
            }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: h, type: n3[0].type, textureType: o.TextureType.packed }, shaderSource: E, hasMain: true });
          })(e2, l, t2, n2) });
        };
      }, 8276: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getBiasForMatmul = t.createMatmulProgramInfoLoader = t.parseMatMulAttributes = t.matMul = void 0;
        const r = n(7273), i = n(5639), o = n(432), a = n(2150), s = n(5632);
        t.matMul = (e2, t2, n2) => (c(t2), e2.session.pack ? [e2.run((0, s.createPackedMatmulProgramInfoLoader)(e2, t2, n2), t2)] : [e2.run(l(t2, n2), t2)]), t.parseMatMulAttributes = (e2) => (0, a.parseInternalActivationAttributes)(e2.attributes);
        const u = (e2, t2) => ({ name: "MatMul", inputNames: e2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: e2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: t2 });
        function l(e2, t2) {
          const n2 = u(e2.length > 2, t2.activationCacheKey);
          return Object.assign(Object.assign({}, n2), { get: () => function(e3, t3, n3) {
            const s2 = t3[0].dims, u2 = t3[1].dims, l2 = r.BroadcastUtil.calcShape(s2, u2, true);
            if (!l2)
              throw new Error("Can't use matmul on the given tensors");
            const c2 = (0, o.getCoordsDataType)(l2.length), d = (0, o.getGlChannels)(), { activationFunction: f, applyActivation: h } = (0, a.getActivationSnippet)(n3), g = t3.length > 2, m = g ? "value += getBiasForMatmul();" : "", b = g ? `${p(c2, d, t3[2].dims, l2, false)}` : "", y = l2.length, v = s2.length, w = u2.length, x = `
    ${f}
    ${b}
    float process(int indices[${y}]) {
        int a[${v}];
        int b[${w}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s2[s2.length - 1]}; ++k) {
            a[${v - 1}] = k;
            b[${w - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${m}
        ${h}
        return value;
    }`;
            return Object.assign(Object.assign({}, e3), { output: { dims: l2, type: t3[0].type, textureType: i.TextureType.unpacked }, shaderSource: x });
          }(n2, e2, t2) });
        }
        t.createMatmulProgramInfoLoader = l;
        const c = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("MatMul requires 2 inputs.");
          if (e2[0].dims[e2[0].dims.length - 1] !== e2[1].dims[e2[1].dims.length - 2])
            throw new Error("shared dimension does not match.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type || "float32" !== e2[1].type && "float64" !== e2[1].type)
            throw new Error("inputs should be float type");
          if (e2[0].type !== e2[1].type)
            throw new Error("inputs types should match");
        };
        function p(e2, t2, n2, i2, o2) {
          let a2 = "";
          const s2 = n2.length, u2 = i2.length, l2 = u2 - s2;
          a2 = u2 < 2 && s2 > 0 ? "coords" : n2.map((e3, n3) => `coords.${t2[n3 + l2]}`).join(", ");
          const c2 = r.BroadcastUtil.getBroadcastDims(n2, i2).map((e3) => `coords.${t2[e3 + l2]} = 0;`).join("\n");
          let p2 = "vec4(outputValue.xx, outputValue.yy)";
          return 1 === r.ShapeUtil.size(n2) && (p2 = "vec4(outputValue.x)"), o2 ? `
vec4 getBiasForMatmul() {
  ${e2} coords = getOutputCoords();
  ${c2}
  vec4 outputValue = getBias(${a2});
  return ${p2};
}` : `
float getBiasForMatmul() {
  ${e2} coords = getOutputCoords();
  ${c2}
  return getBias(coords.x);
}`;
        }
        t.getBiasForMatmul = p;
      }, 9: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createPackProgramInfoLoader = void 0;
        const r = n(6757), i = n(5639), o = n(432), a = n(5614), s = { name: "pack", inputNames: ["A"], inputTypes: [i.TextureType.unpackedReversed] };
        t.createPackProgramInfoLoader = (e2, t2) => Object.assign(Object.assign({}, s), { get: () => ((e3, t3) => {
          const n2 = (0, r.getGlsl)(e3.session.backend.glContext.version), u = t3.dims, l = u.length, c = t3.dims.length, p = (0, o.getCoordsDataType)(c), d = (0, a.getChannels)("rc", c), f = (h = c, g = d, m = u[u.length - 2], b = u[u.length - 1], 0 === h || 1 === h ? "" : `
    int r = ${g[h - 2]};
    int c = ${g[h - 1]};
    int rp1 = ${g[h - 2]} + 1;
    int cp1 = ${g[h - 1]} + 1;
    bool rEdge = rp1 >= ${b};
    bool cEdge = cp1 >= ${m};
    `);
          var h, g, m, b;
          let y;
          y = 0 === l ? [1, 1] : 1 === l ? [u[0], 1] : [u[c - 1], u[c - 2]];
          const v = function(e4, t4, n3) {
            if (0 === e4)
              return "false";
            if (1 === e4)
              return `rc > ${t4[0]}`;
            let r2 = "";
            for (let i2 = e4 - 2; i2 < e4; i2++)
              r2 += `${n3[i2]} >= ${t4[i2 - e4 + 2]}`, i2 < e4 - 1 && (r2 += "||");
            return r2;
          }(c, y, d), w = function(e4, t4) {
            const n3 = e4.length;
            if (0 === n3)
              return "getA(), 0, 0, 0";
            if (1 === n3)
              return `getA(rc),
            rc + 1 >= ${e4[0]} ? 0. : getA(rc + 1),
            0, 0`;
            let r2 = "";
            if (n3 > 2)
              for (let e5 = 0; e5 < n3 - 2; ++e5)
                r2 += `${t4[e5]},`;
            return `getA(${r2}r, c),
          rEdge ? 0. : getA(${r2}rp1, c),
          cEdge ? 0. : getA(${r2}r, cp1),
          rEdge || cEdge ? 0. : getA(${r2}rp1, cp1)`;
          }(u, d), x = `
        void main() {
          ${p} rc = getOutputCoords();

          if(${v}) {
            ${n2.output} = vec4(0);
          } else {
            ${f}

            ${n2.output} = vec4(${w});
          }
        }
      `;
          return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: t3.dims, type: t3.type, textureType: i.TextureType.packed }, shaderSource: x });
        })(e2, t2) });
      }, 5614: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.unpackFromChannel = t.getChannels = t.getVecChannels = void 0;
        const r = n(432);
        function i(e2, t2) {
          return (0, r.getGlChannels)(t2).map((t3) => `${e2}.${t3}`);
        }
        t.getVecChannels = i, t.getChannels = function(e2, t2) {
          return 1 === t2 ? [e2] : i(e2, t2);
        }, t.unpackFromChannel = function() {
          return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
        };
      }, 5565: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parsePadAttributesV11 = t.padV11 = t.parsePadAttributesV2 = t.padV2 = void 0;
        const r = n(4910), i = n(7273), o = n(6757), a = n(5639), s = { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
        t.padV2 = (e2, t2, n2) => (c(t2), [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => l(e2, t2[0], n2) }), t2)]), t.parsePadAttributesV2 = (e2) => {
          const t2 = e2.attributes.getString("mode", "constant"), n2 = e2.attributes.getFloat("value", 0), i2 = e2.attributes.getInts("pads");
          return (0, r.createAttributeWithCacheKey)({ mode: t2, value: n2, pads: i2 });
        }, t.padV11 = (e2, n2, r2) => {
          p(n2);
          const i2 = u(e2, n2, r2);
          return (0, t.padV2)(e2, [n2[0]], i2);
        }, t.parsePadAttributesV11 = (e2) => e2.attributes.getString("mode", "constant");
        const u = (e2, t2, n2) => {
          if (!e2.session.isInitializer(t2[1].dataId) || t2.length >= 3 && !e2.session.isInitializer(t2[2].dataId))
            throw new Error("dynamic pad attributes are not allowed");
          const i2 = Array.from(t2[1].integerData), o2 = t2.length >= 3 ? t2[2].floatData[0] : 0;
          return (0, r.createAttributeWithCacheKey)({ mode: n2, pads: i2, value: o2 });
        }, l = (e2, t2, n2) => {
          const r2 = i.ShapeUtil.padShape(t2.dims.slice(), n2.pads), o2 = r2.length, s2 = `
      ${d(e2, t2, n2)}
      float process(int[${o2}] indices) {
          return padA(indices);
      }`;
          return { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked], output: { dims: r2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: s2 };
        }, c = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Pad requires 1 input");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        }, p = (e2) => {
          if (!e2 || 2 !== e2.length && 3 !== e2.length)
            throw new Error("Pad requires 2 or 3 inputs");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
          if (e2.length >= 3 && "string" === e2[2].type)
            throw new Error("Invalid input type.");
        }, d = (e2, t2, n2) => {
          const r2 = (0, o.getGlsl)(e2.session.backend.glContext.version), [s2, u2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), l2 = i.ShapeUtil.computeStrides(t2.dims);
          switch (n2.mode) {
            case "constant":
              return f(r2, t2.dims, l2, s2, u2, n2.pads, n2.value);
            case "reflect":
              return h(r2, t2.dims, l2, s2, u2, n2.pads);
            case "edge":
              return g(r2, t2.dims, l2, s2, u2, n2.pads);
            default:
              throw new Error("Invalid mode");
          }
        }, f = (e2, t2, n2, r2, i2, o2, a2) => {
          const s2 = t2.length;
          let u2 = "";
          for (let e3 = s2 - 1; e3 >= 0; --e3)
            u2 += `
        k = m[${e3}] - ${o2[e3]};
        if (k < 0)  return constant;
        if (k >= ${t2[e3]}) return constant;
        offset += k * ${n2[e3]};
        `;
          return `
      float padA(int m[${s2}]) {
        const float constant = float(${a2});
        int offset = 0;
        int k = 0;
        ${u2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        }, h = (e2, t2, n2, r2, i2, o2) => {
          const a2 = t2.length;
          let s2 = "";
          for (let e3 = a2 - 1; e3 >= 0; --e3)
            s2 += `
        k = m[${e3}] - ${o2[e3]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (t2[e3] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${t2[e3]}) { k = _2n_1 - k; }
        }
        offset += k * ${n2[e3]};
        `;
          return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        }, g = (e2, t2, n2, r2, i2, o2) => {
          const a2 = t2.length;
          let s2 = "";
          for (let e3 = a2 - 1; e3 >= 0; --e3)
            s2 += `
        k = m[${e3}] - ${o2[e3]};
        if (k < 0)  k = 0;
        if (k >= ${t2[e3]}) k = ${t2[e3] - 1};
        offset += k * ${n2[e3]};
      `;
          return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${e2.texture2D}(A, coords));
        return value;
      }
      `;
        };
      }, 2834: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.globalMaxPool = t.parseMaxPoolAttributes = t.maxPool = t.parseGlobalAveragePoolAttributes = t.globalAveragePool = t.parseAveragePoolAttributes = t.averagePool = void 0;
        const r = n(4910), i = n(7273), o = n(5639);
        t.averagePool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "AveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => a(t2, r2, false, n2) }), t2)];
        }, t.parseAveragePoolAttributes = (e2) => {
          const t2 = e2.attributes.getString("auto_pad", "NOTSET"), n2 = e2.attributes.getInt("ceil_mode", 0), i2 = 0 !== e2.attributes.getInt("count_include_pad", 0), o2 = e2.attributes.getInts("kernel_shape"), a2 = e2.attributes.getInts("strides", []), s2 = e2.attributes.getInts("pads", []);
          if (0 !== n2)
            throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
          return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: i2, kernelShape: o2, strides: a2, pads: s2 });
        };
        const a = (e2, t2, n2, r2) => {
          const [a2, s2] = u(e2, r2, n2), l2 = i.ShapeUtil.size(a2.kernelShape);
          let c2 = "";
          a2.countIncludePad ? c2 += `value /= float(${l2});` : c2 += `value /= float(${l2} - pad);`;
          const p2 = `
        ${d(e2[0].dims, a2, "value += _X(x);", c2, "0.0")}
      `;
          return Object.assign(Object.assign({}, t2), { output: { dims: s2, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
        };
        t.globalAveragePool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: `${n2.countIncludePad}` };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => a(t2, r2, true, n2) }), t2)];
        }, t.parseGlobalAveragePoolAttributes = (e2) => {
          const t2 = 0 !== e2.attributes.getInt("count_include_pad", 0);
          return (0, r.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: t2, kernelShape: [], strides: [], pads: [] });
        }, t.maxPool = (e2, t2, n2) => {
          p(t2);
          const r2 = { name: "MaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
          return [e2.run(Object.assign(Object.assign({}, r2), { get: () => s(t2, r2, false, n2) }), t2)];
        }, t.parseMaxPoolAttributes = (e2) => {
          const t2 = e2.attributes.getString("auto_pad", "NOTSET"), n2 = e2.attributes.getInt("ceil_mode", 0), i2 = e2.attributes.getInts("kernel_shape"), o2 = e2.attributes.getInts("strides", []), a2 = e2.attributes.getInts("pads", []), s2 = e2.attributes.getInt("storage_order", 0), u2 = e2.attributes.getInts("dilations", []);
          if (0 !== s2)
            throw new Error("column major storage order is not yet supported for MaxPool");
          if (0 !== n2)
            throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
          return (0, r.createAttributeWithCacheKey)({ autoPad: t2, ceilMode: n2, countIncludePad: false, kernelShape: i2, strides: o2, pads: a2, storageOrder: s2, dilations: u2 });
        };
        const s = (e2, t2, n2, r2) => {
          const [i2, a2] = u(e2, r2, n2), s2 = `
      ${d(e2[0].dims, i2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
          return Object.assign(Object.assign({}, t2), { output: { dims: a2, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: s2 });
        }, u = (e2, t2, n2) => {
          const r2 = e2[0].dims.slice(), o2 = Object.hasOwnProperty.call(t2, "dilations"), a2 = t2.kernelShape.slice(), s2 = t2.strides.slice(), u2 = o2 ? t2.dilations.slice() : [], l2 = t2.pads.slice();
          i.PoolConvUtil.adjustPoolAttributes(n2, r2, a2, s2, u2, l2);
          const c2 = i.PoolConvUtil.computePoolOutputShape(n2, r2, s2, u2, a2, l2, t2.autoPad), p2 = Object.assign({}, t2);
          return o2 ? Object.assign(p2, { kernelShape: a2, strides: s2, pads: l2, dilations: u2, cacheKey: t2.cacheKey }) : Object.assign(p2, { kernelShape: a2, strides: s2, pads: l2, cacheKey: t2.cacheKey }), [p2, c2];
        }, l = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, c = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
        t.globalMaxPool = (e2, t2) => (p(t2), [e2.run(Object.assign(Object.assign({}, c), { get: () => s(t2, c, true, l) }), t2)]);
        const p = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Pool ops requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
        }, d = (e2, t2, n2, r2, o2) => {
          const a2 = e2.length;
          if (t2.kernelShape.length <= 2) {
            const i2 = t2.kernelShape[t2.kernelShape.length - 1], s2 = t2.strides[t2.strides.length - 1], u2 = t2.pads[t2.pads.length / 2 - 1], l2 = t2.pads[t2.pads.length - 1], c2 = e2[a2 - 1];
            let p2 = "", d2 = "", f2 = "";
            if (p2 = u2 + l2 !== 0 ? `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            if (x[${a2} - 1] < 0 || x[${a2} - 1] >= ${c2}) {
              pad++;
              continue;
            }
            ${n2}
          }` : `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            ${n2}
          }`, 2 === t2.kernelShape.length) {
              const n3 = t2.kernelShape[t2.kernelShape.length - 2], r3 = t2.strides[t2.strides.length - 2], o3 = t2.pads[t2.pads.length / 2 - 2], s3 = t2.pads[t2.pads.length - 2], u3 = e2[a2 - 2];
              d2 = o3 + s3 !== 0 ? `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
              if (x[${a2} - 2] < 0 || x[${a2} - 2] >= ${u3}) {
                pad+= ${i2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
            `, f2 = "\n          }\n        ";
            }
            return `
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);

          float value = ${o2};
          int pad = 0;
          ${d2}
          ${p2}
          ${f2}
          ${r2}
          return value;
        }
      `;
          }
          {
            const s2 = i.ShapeUtil.size(t2.kernelShape), u2 = i.ShapeUtil.computeStrides(t2.kernelShape), l2 = u2.length, c2 = t2.pads.length, p2 = h(l2), d2 = f(e2, "inputDims"), g = f(t2.pads, "pads"), m = f(u2, "kernelStrides"), b = f(t2.strides, "strides");
            let y = "";
            return y = t2.pads.reduce((e3, t3) => e3 + t3) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n2}
          }` : `
          }
          ${n2}
        `, `
        ${p2}
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);
          int offset[${l2}];
          int pads[${c2}];
          int inputDims[${a2}];
          int kernelStrides[${l2}];
          int strides[${l2}];
          ${g}
          ${d2}
          ${b}
          ${m}

          float value = ${o2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a2} - ${l2}; j < ${a2}; j++) {
              x[j] = indices[j] * strides[j - ${a2} + ${l2}]
                + offset[j - ${a2} + ${l2}] - pads[j - 2];
              ${y}
          }
          ${r2}

          return value;
        }
      `;
          }
        }, f = (e2, t2) => {
          let n2 = "";
          for (let r2 = 0; r2 < e2.length; r2++)
            n2 += `
      ${t2}[${r2}] = ${e2[r2]};
    `;
          return n2;
        }, h = (e2) => `
  void offsetToIndices(int offset, int[${e2}] strides, out int[${e2}] indices) {
    if (${e2} == 0) {
      return;
    }
    for (int i = 0; i < ${e2} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e2} - 1] = offset;
  }`;
      }, 1010: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.reduceLogSumSquare = t.reduceLogSum = t.reduceProd = t.reduceMin = t.reduceMax = t.reduceMean = t.reduceSum = t.parseReduceAttributes = void 0;
        const r = n(4910), i = n(6145), o = n(7273), a = n(5639), s = (e2, t2, n2, r2, i2) => {
          l(t2);
          const o2 = { name: r2, inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
          return [e2.run(Object.assign(Object.assign({}, o2), { cacheHint: n2.cacheKey, get: () => u(e2, t2, n2, r2, i2, o2) }), t2)];
        };
        t.parseReduceAttributes = (e2) => {
          const t2 = e2.attributes.getInts("axes", []), n2 = 1 === e2.attributes.getInt("keepdims", 1);
          return (0, r.createAttributeWithCacheKey)({ axes: t2, keepDims: n2 });
        };
        const u = (e2, t2, n2, r2, i2, s2) => {
          const u2 = [], l2 = t2[0].dims.length || 1, c = [], p = o.ShapeUtil.normalizeAxes(n2.axes, t2[0].dims.length), d = i2(t2, p);
          let f = d[1];
          for (let e3 = 0; e3 < t2[0].dims.length; e3++)
            p.indexOf(e3) >= 0 || 0 === p.length ? (n2.keepDims && u2.push(1), f = `
          for(int j${e3} = 0; j${e3} < ${t2[0].dims[e3]}; j${e3}++) {
            inputIdx[${e3}] = j${e3};
            ${f}
          }`) : (c.push(`inputIdx[${e3}] = outputIdx[${u2.length}];`), u2.push(t2[0].dims[e3]));
          const h = `
      float process(int outputIdx[${u2.length || 1}]) {
        float value;                 // final result
        int inputIdx[${l2}];      // addressing input data
        ${c.join("\n")}
        ${d[0]}       // init ops for reduce max/min
        ${f}
        ${d[2]}       // final computation for reduce mean
        return value;
      }`;
          return Object.assign(Object.assign({}, s2), { output: { dims: u2, type: t2[0].type, textureType: a.TextureType.unpacked }, shaderSource: h });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Reduce op requires 1 input.");
          if (-1 === i.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
        };
        t.reduceSum = (e2, t2, n2) => s(e2, t2, n2, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), t.reduceMean = (e2, t2, n2) => s(e2, t2, n2, "ReduceMean", (e3, t3) => {
          let n3 = 1;
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && (n3 *= e3[0].dims[r2]);
          return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n3}.;`];
        }), t.reduceMax = (e2, t2, n2) => s(e2, t2, n2, "ReduceMax", (e3, t3) => {
          const n3 = [];
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
          return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
        }), t.reduceMin = (e2, t2, n2) => s(e2, t2, n2, "ReduceMin", (e3, t3) => {
          const n3 = [];
          for (let r2 = 0; r2 < e3[0].dims.length; r2++)
            (t3.indexOf(r2) >= 0 || 0 === t3.length) && n3.push(`inputIdx[${r2}] = 0;`);
          return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
        }), t.reduceProd = (e2, t2, n2) => s(e2, t2, n2, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), t.reduceLogSum = (e2, t2, n2) => s(e2, t2, n2, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), t.reduceLogSumSquare = (e2, t2, n2) => s(e2, t2, n2, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
      }, 7379: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.isReshapeCheap = t.processDims3D = t.createPackedReshape3DProgramInfoLoader = void 0;
        const r = n(7273), i = n(6757), o = n(5639), a = n(5614);
        t.createPackedReshape3DProgramInfoLoader = (e2, t2, n2) => {
          const s = ((e3) => ({ name: "Reshape (packed)", inputTypes: [o.TextureType.packed], inputNames: ["A"], cacheHint: `${e3}` }))(n2);
          return Object.assign(Object.assign({}, s), { get: () => ((e3, t3, n3, s2) => {
            const u = t3.dims, l = s2;
            let c = "";
            for (let e4 = 0; e4 < 4; e4++) {
              let t4 = "";
              switch (e4) {
                case 0:
                  t4 = "outputCoords = rc;";
                  break;
                case 1:
                  t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                  break;
                case 2:
                  t4 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                  break;
                case 3:
                  t4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                  break;
                default:
                  throw new Error();
              }
              c += `
        ${t4}
        ${e4 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e4}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${e4 > 0 ? "}" : ""}
      `;
            }
            const p = (0, i.getGlsl)(e3.session.backend.glContext.version), d = `
      ${function(e4) {
              const t4 = r.ShapeUtil.computeStrides(e4), n4 = ["b", "r", "c"], i2 = "index";
              return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t4.map((e5, r2) => `int ${n4[r2]} = ${i2} / ${e5}; ${r2 === t4.length - 1 ? `int ${n4[r2 + 1]} = ${i2} - ${n4[r2]} * ${e5}` : `index -= ${n4[r2]} * ${e5}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
            }(u)}
      ${function(e4) {
              const t4 = r.ShapeUtil.computeStrides(e4);
              return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${t4[0]} + coords.z * ${t4[1]} + coords.y;
  }
`;
            }(l)}
      ${(0, a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${l[2]};
        int cols = ${l[1]};

        ${c}
        ${p.output} = result;
      }
    `;
            return Object.assign(Object.assign({}, n3), { output: { dims: l, type: t3.type, textureType: o.TextureType.packed }, shaderSource: d, hasMain: true });
          })(e2, t2, s, n2) });
        }, t.processDims3D = function(e2) {
          if (0 === e2.length)
            return [1, 1, 1];
          let t2 = 1;
          for (let n2 = 0; n2 < e2.length - 2; ++n2)
            t2 *= e2[n2];
          return [t2, e2.length > 1 ? e2[e2.length - 2] : 1, e2[e2.length - 1]];
        }, t.isReshapeCheap = function(e2, t2) {
          let n2 = false;
          return n2 = 0 === e2.length || 0 === t2.length || (e2.length < 2 || t2.length < 2 ? e2[e2.length - 1] === t2[t2.length - 1] : e2[e2.length - 1] === t2[t2.length - 1] && e2[e2.length - 2] === t2[t2.length - 2]), n2;
        };
      }, 8126: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.reshape = void 0;
        const r = n(7273);
        t.reshape = (e2, t2) => {
          const n2 = r.ShapeUtil.calculateReshapedDims(t2[0].dims, t2[1].integerData);
          return e2.session.pack ? [e2.reshapePacked(t2[0], n2)] : [e2.reshapeUnpacked(t2[0], n2)];
        };
      }, 2801: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseResizeAttributesV11 = t.parseResizeAttributesV10 = t.resize = void 0;
        const r = n(6757), i = n(5639), o = n(432), a = n(5614), s = n(3980), u = { name: "Resize", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
        t.resize = (e2, t2, n2) => ((0, s.validateInputs)(t2, n2), [e2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => l(e2, t2, n2) }), t2)]), t.parseResizeAttributesV10 = (e2) => (0, s.parseUpsampleAttributes)(e2, 10), t.parseResizeAttributesV11 = (e2) => (0, s.parseUpsampleAttributes)(e2, 11);
        const l = (e2, t2, n2) => {
          const s2 = (0, r.getGlsl)(e2.session.backend.glContext.version), [l2, p2] = c(t2, n2);
          if (l2.every((e3) => 1 === e3) && "tf_crop_and_resize" !== n2.coordinateTransformMode)
            return Object.assign(Object.assign({}, u), { output: { dims: p2, type: t2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s2.texture2D}(X, TexCoords);
                    ${s2.output} = v;
                }` });
          const d2 = p2.length;
          if (d2 < 2)
            throw new Error(`output dimension should be at least 2, but got ${d2}`);
          const f = p2[d2 - 2], h = p2[d2 - 1], g = t2[0].dims;
          if (d2 !== g.length)
            throw new Error(`output dimension should match input ${g.length}, but got ${d2}`);
          const m = g[d2 - 2], b = g[d2 - 1], y = l2[d2 - 2], v = l2[d2 - 1];
          let w = "";
          if ("linear" !== n2.mode)
            throw new Error(`resize (packed) does not support mode: '${n2.mode}'`);
          switch (n2.coordinateTransformMode) {
            case "asymmetric":
              w = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
              break;
            case "half_pixel":
              w = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
              break;
            case "pytorch_half_pixel":
              w = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${f}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${f}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
              break;
            case "align_corners":
              w = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h}.0 - 1.0, ${f}.0 - 1.0, ${h}.0 - 1.0,
                            ${f}.0 - 1.0);
                        vec4 original = vec4(${b}.0 - 1.0, ${m}.0 - 1.0, ${b}.0 - 1.0,
                            ${m}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
              break;
            default:
              throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n2.coordinateTransformMode}'`);
          }
          const x = (0, o.getCoordsDataType)(d2), _ = `
            const vec2 inputWH = vec2(${m}.0, ${b}.0);
            const vec4 scaleWHWH = vec4(float(${y}), float(${v}), float(${y}), float(${v}));
            ${(0, a.unpackFromChannel)()}
            ${w}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${x} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${f - 1};
                bool hasNextCol = rc.z < ${h - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s2.output} = vec4(newValue);
            }
        `;
          return Object.assign(Object.assign({}, u), { output: { dims: p2, type: t2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: _ });
        }, c = (e2, t2) => {
          const n2 = e2[0].dims;
          let r2, i2 = t2.scales;
          if (0 === i2.length) {
            const o3 = e2[t2.scalesInputIdx];
            if (o3 && 0 !== o3.size) {
              if (e2[t2.sizesInputIdx])
                throw new Error("Only one of scales or sizes must be provided as input.");
              i2 = p(o3, t2.mode, t2.isResize);
            } else {
              const o4 = e2[t2.sizesInputIdx];
              if (!o4 || 0 === o4.size)
                throw new Error("Either scales or sizes MUST be provided as input.");
              r2 = Array.from(o4.integerData), i2 = d(r2, n2, t2.mode, t2.isResize);
            }
          } else if (e2[t2.sizesInputIdx])
            throw new Error("Only one of scales or sizes must be provided as input.");
          const o2 = r2 || n2.map((e3, t3) => Math.floor(e3 * i2[t3]));
          return [i2, o2];
        }, p = (e2, t2, n2) => {
          const r2 = Array.from(e2.floatData);
          return (0, s.scalesValidation)(r2, t2, n2), r2;
        }, d = (e2, t2, n2, r2) => {
          const i2 = t2.length, o2 = new Array(i2);
          for (let n3 = 0, r3 = i2; n3 < r3; n3++)
            if (0 === t2[n3]) {
              if (0 !== e2[n3])
                throw new Error("Input dim is zero but required output dim is non-zero.");
              o2[n3] = 1;
            } else
              o2[n3] = e2[n3] / t2[n3];
          return (0, s.scalesValidation)(o2, n2, r2), o2;
        };
      }, 565: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.shape = void 0;
        const r = n(9240);
        t.shape = (e2, t2) => (i(t2), [new r.Tensor([t2[0].dims.length], "int32", void 0, void 0, new Int32Array(t2[0].dims))]);
        const i = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Shape requires 1 input.");
        };
      }, 2444: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.sliceV10 = t.parseSliceAttributes = t.slice = void 0;
        const r = n(4910), i = n(6145), o = n(7273), a = n(5639), s = { name: "Slice", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
        t.slice = (e2, t2, n2) => (l(t2), [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(e2, t2[0], n2) }), t2)]), t.parseSliceAttributes = (e2) => {
          const t2 = e2.attributes.getInts("starts"), n2 = e2.attributes.getInts("ends"), i2 = e2.attributes.getInts("axes", []);
          return (0, r.createAttributeWithCacheKey)({ starts: t2, ends: n2, axes: i2 });
        };
        const u = (e2, t2, n2) => {
          const r2 = 0 === n2.axes.length ? t2.dims.slice(0).map((e3, t3) => t3) : n2.axes, i2 = o.ShapeUtil.normalizeAxes(r2, t2.dims.length), u2 = n2.starts.map((e3, n3) => e3 > t2.dims[i2[n3]] - 1 ? t2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(e3, t2.dims[i2[n3]])), l2 = n2.ends.map((e3, n3) => e3 > t2.dims[i2[n3]] - 1 ? t2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(e3, t2.dims[i2[n3]])), c2 = t2.dims.slice(), p2 = [];
          for (let e3 = 0; e3 < i2.length; e3++)
            c2[i2[e3]] = l2[e3] - u2[e3], u2[e3] > 0 && p2.push(`outputIdx[${i2[e3]}] += ${u2[e3]};`);
          const d = `
      float process(int outputIdx[${c2.length}]) {
        ${p2.join("\n      ")}
        return _A(outputIdx);
      }`;
          return Object.assign(Object.assign({}, s), { output: { dims: c2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Slice requires 1 input.");
          if (-1 === i.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
        };
        t.sliceV10 = (e2, t2) => {
          p(t2);
          const n2 = c(e2, t2);
          return [e2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(e2, t2[0], n2) }), [t2[0]])];
        };
        const c = (e2, t2) => {
          if (!e2.session.isInitializer(t2[1].dataId) || !e2.session.isInitializer(t2[2].dataId) || t2.length >= 4 && !e2.session.isInitializer(t2[3].dataId) || t2.length >= 5 && !e2.session.isInitializer(t2[4].dataId))
            throw new Error("dynamic slice attributes are not allowed");
          if (t2.length >= 5 && t2[4].integerData.some((e3) => 1 !== e3))
            throw new Error("currently non-1 steps is not supported for Slice");
          const n2 = Array.from(t2[1].integerData), r2 = Array.from(t2[2].integerData), i2 = t2.length >= 4 ? Array.from(t2[3].integerData) : [];
          return { starts: n2, ends: r2, axes: i2, cacheKey: `${i2};${n2};${r2}` };
        }, p = (e2) => {
          if (!e2 || e2.length < 3 || e2.length > 5)
            throw new Error("Invalid input number.");
          if ("int32" !== e2[1].type || 1 !== e2[1].dims.length)
            throw new Error("Invalid input type.");
          if ("int32" !== e2[2].type || 1 !== e2[2].dims.length)
            throw new Error("Invalid input type.");
          if (e2.length >= 4 && ("int32" !== e2[3].type || 1 !== e2[3].dims.length))
            throw new Error("Invalid input type.");
          if (e2.length >= 5 && ("int32" !== e2[4].type || 1 !== e2[4].dims.length))
            throw new Error("Invalid input type.");
        };
      }, 815: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.softmaxV13 = t.parseSoftmaxAttributesV13 = t.parseSoftmaxAttributes = t.softmax = void 0;
        const r = n(4910), i = n(7273), o = n(6757), a = n(5639), s = n(5707), u = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] }, l = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, c = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked] };
        t.softmax = (e2, t2, n2) => {
          g(t2);
          const r2 = t2[0].dims.slice(), o2 = i.ShapeUtil.normalizeAxis(n2.axis, r2.length), a2 = i.ShapeUtil.sizeToDimension(r2, o2), s2 = i.ShapeUtil.sizeFromDimension(r2, o2);
          return p(e2, t2, n2, a2, s2);
        }, t.parseSoftmaxAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", 1) }), t.parseSoftmaxAttributesV13 = (e2) => (0, r.createAttributeWithCacheKey)({ axis: e2.attributes.getInt("axis", -1) }), t.softmaxV13 = (e2, t2, n2) => {
          g(t2);
          const o2 = t2[0].dims.slice(), a2 = i.ShapeUtil.normalizeAxis(n2.axis, o2.length), u2 = o2.length, l2 = a2 !== u2 - 1, c2 = [];
          let d2, f2 = [], h2 = [];
          l2 && (f2 = Array.from({ length: u2 }).map((e3, t3) => t3), f2[a2] = u2 - 1, f2[u2 - 1] = a2, f2.map((e3) => c2.push(o2[e3])), d2 = (0, r.createAttributeWithCacheKey)({ perm: f2 }), h2 = (0, s.transpose)(e2, t2, d2));
          const m = l2 ? i.ShapeUtil.sizeToDimension(c2, u2 - 1) : i.ShapeUtil.sizeToDimension(o2, u2 - 1), b = l2 ? i.ShapeUtil.sizeFromDimension(c2, u2 - 1) : i.ShapeUtil.sizeFromDimension(o2, u2 - 1), y = p(e2, l2 ? h2 : t2, n2, m, b);
          return l2 ? (0, s.transpose)(e2, y, d2) : y;
        };
        const p = (e2, t2, n2, r2, i2) => {
          const o2 = d(e2, t2[0], r2, i2, [r2]), a2 = e2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => o2 }), t2), s2 = f(e2, t2[0], r2, i2, o2.output.dims, [r2]), p2 = e2.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => s2 }), [t2[0], a2]), g2 = h(e2, t2[0], r2, i2, o2.output.dims, s2.output.dims);
          return [e2.run(Object.assign(Object.assign({}, c), { cacheHint: n2.cacheKey, get: () => g2 }), [t2[0], a2, p2])];
        }, d = (e2, t2, n2, r2, i2) => {
          const [s2, l2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), c2 = i2.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== i2.length)
            throw new Error("Dimensionality of the output should be 1");
          if (i2[0] !== n2)
            throw new Error("Shape of the output should be equal to logical row count");
          const p2 = (0, o.getGlsl)(e2.session.backend.glContext.version), d2 = `
      float process(int[${c2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float max = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s2},
        ${l2} )));
        for(int i=1; i<${r2}; ++i)
        {
          float current = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s2}, ${l2})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
          return Object.assign(Object.assign({}, u), { output: { dims: i2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d2 });
        }, f = (e2, t2, n2, r2, i2, s2) => {
          const [u2, c2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), p2 = s2.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== s2.length)
            throw new Error("Dimensionality of the output should be 1");
          if (s2[0] !== n2)
            throw new Error("Shape of the output should be equal to logical row count");
          if (1 !== i2.length)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (i2[0] !== n2)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          const d2 = `
      float process(int[${p2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r2}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, o.getGlsl)(e2.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u2}, ${c2}))) - max);
        }

        return norm_factor;
      }`;
          return Object.assign(Object.assign({}, l), { output: { dims: s2, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: d2 });
        }, h = (e2, t2, n2, r2, i2, o2) => {
          const [s2, u2] = e2.calculateTextureWidthAndHeight(t2.dims, a.TextureType.unpacked), l2 = t2.dims.length;
          if (n2 < 1 || r2 < 1)
            throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
          if (1 !== i2.length || 1 !== o2.length)
            throw new Error("Dimensionality of the intermediate results should be 1");
          if (i2[0] !== n2 || o2[0] !== n2)
            throw new Error("Shape of the intermediate results should be equal to logical row count");
          const p2 = `
      float process(int[${l2}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s2}, ${u2});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r2};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
          return Object.assign(Object.assign({}, c), { output: { dims: t2.dims, type: t2.type, textureType: a.TextureType.unpacked }, shaderSource: p2 });
        }, g = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Softmax requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type");
        };
      }, 564: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSplitAttributes = t.split = void 0;
        const r = n(4910), i = n(7273), o = n(5639), a = { name: "Split", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
        t.split = (e2, t2, n2) => {
          l(t2);
          const r2 = i.ShapeUtil.normalizeAxis(n2.axis, t2[0].dims.length), o2 = s(e2, t2, r2, n2), c = [];
          for (let i2 = 0; i2 < o2; ++i2)
            c.push(e2.run(Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey};${i2}`, get: () => u(e2, t2[0], n2, r2, i2) }), t2));
          return c;
        }, t.parseSplitAttributes = (e2) => {
          const t2 = e2.attributes.getInt("axis", 0), n2 = e2.attributes.getInts("split", []), i2 = e2.outputs.length;
          return (0, r.createAttributeWithCacheKey)({ axis: t2, split: n2, numOutputs: i2 });
        };
        const s = (e2, t2, n2, r2) => {
          const [, o2] = i.SplitUtil.splitShape(t2[0].dims, n2, r2.split, r2.numOutputs);
          return o2.length;
        }, u = (e2, t2, n2, r2, s2) => {
          const [u2, l2] = i.SplitUtil.splitShape(t2.dims, r2, n2.split, n2.numOutputs), c = l2[s2], p = u2[s2], d = `
      float process(int indices[${p.length}]) {
        indices[${r2}] += ${c};
        return _A(indices);
      }
    `;
          return Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey}:${s2}`, output: { dims: p, type: t2.type, textureType: o.TextureType.unpacked }, shaderSource: d });
        }, l = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Split requires one input.");
          if ("int8" !== e2[0].type && "uint8" !== e2[0].type && "int16" !== e2[0].type && "uint16" !== e2[0].type && "int32" !== e2[0].type && "uint32" !== e2[0].type && "float32" !== e2[0].type && "float64" !== e2[0].type && "bool" !== e2[0].type)
            throw new Error("Invalid input type.");
        };
      }, 5416: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSqueezeAttributes = t.squeezeV13 = t.squeeze = void 0;
        const r = n(7273);
        t.squeeze = (e2, t2, n2) => {
          i(t2);
          const o2 = r.ShapeUtil.squeezeShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], o2)];
        }, t.squeezeV13 = (e2, n2) => (o(n2), (0, t.squeeze)(e2, [n2[0]], Array.from(n2[1].integerData))), t.parseSqueezeAttributes = (e2) => e2.attributes.getInts("axes");
        const i = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Squeeze requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("invalid input tensor types.");
        }, o = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Squeeze requires 2 inputs.");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
        };
      }, 1240: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.sum = void 0;
        const r = n(6757), i = n(5639);
        t.sum = (e2, t2) => {
          a(t2);
          const n2 = { name: "Sum", inputNames: t2.map((e3, t3) => `X${t3}`), inputTypes: new Array(t2.length).fill(i.TextureType.unpacked) };
          return [e2.run(Object.assign(Object.assign({}, n2), { get: () => o(e2, t2, n2) }), t2)];
        };
        const o = (e2, t2, n2) => {
          const o2 = (0, r.getGlsl)(e2.session.backend.glContext.version), a2 = t2[0].dims.slice(), s = `
      void main() {
        vec4 result = ${t2.map((e3, t3) => `${o2.texture2D}(X${t3},TexCoords)`).join(" + ")};
        ${o2.output} = result;
      }
    `;
          return Object.assign(Object.assign({}, n2), { output: { dims: a2, type: t2[0].type, textureType: i.TextureType.unpacked }, hasMain: true, shaderSource: s });
        }, a = (e2) => {
          if (!e2 || 0 === e2.length)
            throw new Error("Sum requires inputs.");
          const t2 = e2[0].dims.length;
          for (let n2 = 1; n2 < e2.length; n2++) {
            if (t2 !== e2[n2].dims.length)
              throw new Error("Input shapes are mismatched.");
            for (let r2 = 0; r2 < t2; r2++)
              if (e2[0].dims[r2] !== e2[n2].dims[r2])
                throw new Error("Input shapes are not matched.");
          }
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("Invalid input type.");
          for (let t3 = 1; t3 < e2.length; t3++)
            if (e2[0].type !== e2[t3].type)
              throw new Error("Input types are not matched.");
        };
      }, 5944: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tile = void 0;
        const r = n(6145), i = n(5639);
        t.tile = (e2, t2) => {
          a(t2);
          const n2 = { name: "Tile", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
          return [e2.run(Object.assign(Object.assign({}, n2), { get: () => o(e2, t2, n2) }), t2)];
        };
        const o = (e2, t2, n2) => {
          const r2 = t2[0].dims.slice(), o2 = new Array(r2.length), a2 = [];
          for (let e3 = 0; e3 < r2.length; e3++)
            o2[e3] = r2[e3] * t2[1].numberData[e3], a2.push(`inputIdx[${e3}] = int(mod(float(outputIdx[${e3}]), ${r2[e3]}.));`);
          const s = o2.length, u = `
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${a2.join("\n")}
        return _A(inputIdx);
      }
    `;
          return Object.assign(Object.assign({}, n2), { output: { dims: o2, type: t2[0].type, textureType: i.TextureType.unpacked }, shaderSource: u });
        }, a = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Tile requires 2 input.");
          if (1 !== e2[1].dims.length)
            throw new Error("The second input shape must 1 dimension.");
          if (e2[1].dims[0] !== e2[0].dims.length)
            throw new Error("Invalid input shape.");
          if (-1 === r.NUMBER_TYPES.indexOf(e2[0].type))
            throw new Error("Invalid input type.");
          if ("int32" !== e2[1].type && "int16" !== e2[1].type)
            throw new Error("Invalid repeat type.");
        };
      }, 5707: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseTransposeAttributes = t.transpose = void 0;
        const r = n(4910), i = n(7273), o = n(5639), a = { name: "Transpose", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
        t.transpose = (e2, t2, n2) => (p(t2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(e2, t2[0], n2.perm) }), t2)]), t.parseTransposeAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ perm: e2.attributes.getInts("perm", []) });
        const s = (e2, t2, n2) => {
          const r2 = t2.dims;
          n2 = u(r2, n2);
          const i2 = l(r2, n2), s2 = r2.length, p2 = `
      ${c("perm", n2, s2)}
      float process(int indices[${s2}]) {
        int a[${s2}];
        perm(a, indices);
        return _A(a);
      }`;
          return Object.assign(Object.assign({}, a), { output: { dims: i2, type: t2.type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
        }, u = (e2, t2) => (t2 && t2.length !== e2.length && (t2 = [...e2.keys()].reverse()), t2), l = (e2, t2) => (t2 = u(e2, t2), i.ShapeUtil.sortBasedOnPerm(e2, t2)), c = (e2, t2, n2) => {
          const r2 = [];
          r2.push(`void ${e2}(out int a[${n2}], int src[${n2}]) {`);
          for (let e3 = 0; e3 < n2; ++e3)
            r2.push(`	a[${t2[e3]}]=src[${e3}];`);
          return r2.push("	}"), r2.join("\n");
        }, p = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Transpose requires 1 input.");
          if ("float32" !== e2[0].type && "float64" !== e2[0].type)
            throw new Error("input should be float tensor");
        };
      }, 2488: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.encodeAsUint8 = void 0;
        const r = n(6757), i = n(5639);
        t.encodeAsUint8 = (e2, t2) => {
          const n2 = t2.shape, o = (0, r.getGlsl)(e2.session.backend.glContext.version), a = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`, s = { name: "Uint8Encode", inputTypes: [i.TextureType.unpacked], inputNames: ["X"], output: { dims: n2, type: t2.tensor.type, textureType: i.TextureType.downloadUint8AsFloat }, shaderSource: a, hasMain: true };
          return e2.executeProgram(s, [t2.tensor]);
        };
      }, 9087: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tanh = t.tan = t.sqrt = t.sin = t.sigmoid = t.relu = t.not = t.neg = t.log = t.parseLeakyReluAttributes = t.leakyRelu = t.identity = t.floor = t.exp = t.parseEluAttributes = t.elu = t.cos = t.ceil = t.clipV11 = t.parseClipAttributes = t.clip = t.atan = t.asin = t.acos = t.abs = t.glslTanh = t.glslTan = t.glslSqrt = t.glslSigmoid = t.glslRelu = t.glslSin = t.glslNot = t.glslNeg = t.glslLog = t.glslLeakyRelu = t.glslIdentity = t.glslClip = t.glslFloor = t.glslExp = t.glslElu = t.glslCos = t.glslCeil = t.glslAtan = t.glslAsin = t.glslAcos = t.glslAbs = void 0;
        const r = n(4910), i = n(7273), o = n(1997), a = n(6757), s = n(5639);
        function u() {
          return I("abs");
        }
        function l() {
          return I("acos");
        }
        function c() {
          return I("asin");
        }
        function p() {
          return I("atan");
        }
        function d() {
          return I("ceil");
        }
        function f() {
          return I("cos");
        }
        function h(e2) {
          const t2 = "elu";
          return { body: `
  const float alpha = float(${e2});

  float ${t2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: o.FunctionType.ValueBased };
        }
        function g() {
          return I("exp");
        }
        function m() {
          return I("floor");
        }
        function b(e2, t2) {
          const n2 = "clip";
          return { body: `
  const float min = float(${e2});
  const float max = float(${t2});

  float ${n2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n2, type: o.FunctionType.ValueBased };
        }
        function y() {
          const e2 = "indentity";
          return { body: `
  float ${e2}_(float a) {
    return a;
  }
  vec4 ${e2}_(vec4 v) {
    return v;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function v(e2) {
          const t2 = "leakyRelu";
          return { body: `
  const float alpha = float(${e2});

  float ${t2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(${t2}_(v.x), ${t2}_(v.y), ${t2}_(v.z), ${t2}_(v.w));
  }
  `, name: t2, type: o.FunctionType.ValueBased };
        }
        function w() {
          return I("log");
        }
        function x() {
          const e2 = "neg";
          return { body: `
  float ${e2}_(float a) {
    return -a;
  }
  vec4 ${e2}_(vec4 v) {
    return -v;
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function _() {
          const e2 = "not";
          return { body: `
  float ${e2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e2}_(bool a) {
    return !a;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function T() {
          return I("sin");
        }
        function S() {
          const e2 = "relu";
          return { body: `
  float ${e2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function $() {
          const e2 = "sigmoid";
          return { body: `
  float ${e2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function O() {
          return I("sqrt");
        }
        function A() {
          return I("tan");
        }
        function P() {
          const e2 = "tanh";
          return { body: `
  float ${e2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        function I(e2) {
          return { body: `
  float ${e2}_(float a) {
    return ${e2}(a);
  }
  vec4 ${e2}_(vec4 v) {
    return ${e2}(v);
  }
  `, name: e2, type: o.FunctionType.ValueBased };
        }
        t.glslAbs = u, t.glslAcos = l, t.glslAsin = c, t.glslAtan = p, t.glslCeil = d, t.glslCos = f, t.glslElu = h, t.glslExp = g, t.glslFloor = m, t.glslClip = b, t.glslIdentity = y, t.glslLeakyRelu = v, t.glslLog = w, t.glslNeg = x, t.glslNot = _, t.glslSin = T, t.glslRelu = S, t.glslSigmoid = $, t.glslSqrt = O, t.glslTan = A, t.glslTanh = P;
        const E = (e2, t2, n2, r2) => {
          const i2 = e2.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o2 = { name: n2.name, inputTypes: [i2], inputNames: ["A"], cacheHint: r2 };
          return Object.assign(Object.assign({}, o2), { get: () => ((e3, t3, n3, r3) => {
            const i3 = e3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o3 = (0, a.getGlsl)(e3.session.backend.glContext.version);
            return Object.assign(Object.assign({}, t3), { output: { dims: n3.dims, type: n3.type, textureType: i3 }, shaderSource: `
     ${r3.body}
     void main() {
       vec4 v = ${o3.texture2D}(A, TexCoords);
       v = ${r3.name}_(v);
       ${o3.output} = v;
     }
     `, hasMain: true });
          })(e2, o2, t2, n2) });
        };
        t.abs = (e2, t2) => [e2.run(E(e2, t2[0], u()), t2)], t.acos = (e2, t2) => [e2.run(E(e2, t2[0], l()), t2)], t.asin = (e2, t2) => [e2.run(E(e2, t2[0], c()), t2)], t.atan = (e2, t2) => [e2.run(E(e2, t2[0], p()), t2)], t.clip = (e2, t2, n2) => [e2.run(E(e2, t2[0], b(n2.min, n2.max), n2.cacheKey), t2)], t.parseClipAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ min: e2.attributes.getFloat("min", i.MIN_CLIP), max: e2.attributes.getFloat("max", i.MAX_CLIP) }), t.clipV11 = (e2, n2) => {
          const r2 = C2(e2, n2);
          return (0, t.clip)(e2, [n2[0]], r2);
        };
        const C2 = (e2, t2) => {
          if (t2.length >= 3 && (!e2.session.isInitializer(t2[1].dataId) || !e2.session.isInitializer(t2[2].dataId)))
            throw new Error("dynamic clip attributes are not allowed");
          const n2 = t2.length >= 3 ? t2[1].numberData[0] : i.MIN_CLIP, o2 = t2.length >= 3 ? t2[2].numberData[0] : i.MAX_CLIP;
          return (0, r.createAttributeWithCacheKey)({ min: n2, max: o2 });
        };
        t.ceil = (e2, t2) => [e2.run(E(e2, t2[0], d()), t2)], t.cos = (e2, t2) => [e2.run(E(e2, t2[0], f()), t2)], t.elu = (e2, t2, n2) => [e2.run(E(e2, t2[0], h(n2.alpha), n2.cacheKey), t2)], t.parseEluAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ alpha: e2.attributes.getFloat("alpha", 1) }), t.exp = (e2, t2) => [e2.run(E(e2, t2[0], g()), t2)], t.floor = (e2, t2) => [e2.run(E(e2, t2[0], m()), t2)], t.identity = (e2, t2) => [e2.run(E(e2, t2[0], y()), t2)], t.leakyRelu = (e2, t2, n2) => [e2.run(E(e2, t2[0], v(n2.alpha), n2.cacheKey), t2)], t.parseLeakyReluAttributes = (e2) => (0, r.createAttributeWithCacheKey)({ alpha: e2.attributes.getFloat("alpha", 0.01) }), t.log = (e2, t2) => [e2.run(E(e2, t2[0], w()), t2)], t.neg = (e2, t2) => [e2.run(E(e2, t2[0], x()), t2)], t.not = (e2, t2) => [e2.run(E(e2, t2[0], _()), t2)], t.relu = (e2, t2) => [e2.run(E(e2, t2[0], S()), t2)], t.sigmoid = (e2, t2) => [e2.run(E(e2, t2[0], $()), t2)], t.sin = (e2, t2) => [e2.run(E(e2, t2[0], T()), t2)], t.sqrt = (e2, t2) => [e2.run(E(e2, t2[0], O()), t2)], t.tan = (e2, t2) => [e2.run(E(e2, t2[0], A()), t2)], t.tanh = (e2, t2) => [e2.run(E(e2, t2[0], P()), t2)];
      }, 540: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createUnpackProgramInfoLoader = t.createUnpackProgramInfo = void 0;
        const r = n(6757), i = n(5639), o = n(432), a = n(5614), s = { name: "unpack", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
        t.createUnpackProgramInfo = (e2, t2) => {
          const n2 = t2.dims.length, u = (0, a.getChannels)("rc", n2), l = u.slice(-2), c = (0, o.getCoordsDataType)(n2), p = (0, a.unpackFromChannel)(), d = 0 === t2.dims.length ? "" : function(e3, t3) {
            if (1 === e3)
              return "rc";
            let n3 = "";
            for (let r2 = 0; r2 < e3; r2++)
              n3 += t3[r2], r2 < e3 - 1 && (n3 += ",");
            return n3;
          }(n2, u), f = n2 <= 1 ? "rc" : `vec2(${l.join(",")})`, h = `
    ${p}
    void main() {
      ${c} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${d});

       ${(0, r.getGlsl)(e2.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f}), 0, 0, 0);
     }
   `;
          return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: t2.dims, type: t2.type, textureType: i.TextureType.unpacked }, shaderSource: h });
        }, t.createUnpackProgramInfoLoader = (e2, n2) => Object.assign(Object.assign({}, s), { get: () => (0, t.createUnpackProgramInfo)(e2, n2) });
      }, 7862: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseUnsqueezeAttributes = t.unsqueezeV13 = t.unsqueeze = void 0;
        const r = n(7273);
        t.unsqueeze = (e2, t2, n2) => {
          i(t2);
          const o2 = r.ShapeUtil.unsqueezeShape(t2[0].dims, n2);
          return [e2.reshapeUnpacked(t2[0], o2)];
        }, t.unsqueezeV13 = (e2, n2) => (o(n2), (0, t.unsqueeze)(e2, [n2[0]], Array.from(n2[1].integerData))), t.parseUnsqueezeAttributes = (e2) => e2.attributes.getInts("axes");
        const i = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Unsqueeze requires 1 input.");
          if ("string" === e2[0].type)
            throw new Error("invalid input tensor types.");
        }, o = (e2) => {
          if (!e2 || 2 !== e2.length)
            throw new Error("Unsqueeze requires 2 inputs.");
          if ("int32" !== e2[1].type)
            throw new Error("Invalid input type.");
        };
      }, 3980: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.scalesValidation = t.validateInputs = t.parseUpsampleAttributes = t.parseUpsampleAttributesV9 = t.parseUpsampleAttributesV7 = t.upsample = void 0;
        const r = n(4910), i = n(6757), o = n(5639), a = { name: "Upsample", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
        t.upsample = (e2, n2, r2) => ((0, t.validateInputs)(n2, r2), [e2.run(Object.assign(Object.assign({}, a), { cacheHint: r2.cacheKey, get: () => s(e2, n2, r2) }), n2)]), t.parseUpsampleAttributesV7 = (e2) => (0, t.parseUpsampleAttributes)(e2, 7), t.parseUpsampleAttributesV9 = (e2) => (0, t.parseUpsampleAttributes)(e2, 9), t.parseUpsampleAttributes = (e2, n2) => {
          const i2 = n2 >= 10, o2 = e2.attributes.getString("mode", "nearest");
          if ("nearest" !== o2 && "linear" !== o2 && (n2 < 11 || "cubic" !== o2))
            throw new Error(`unrecognized mode: ${o2}`);
          let a2 = [];
          n2 < 9 && (a2 = e2.attributes.getFloats("scales"), (0, t.scalesValidation)(a2, o2, i2));
          const s2 = e2.attributes.getFloat("extrapolation_value", 0), u = n2 > 10 ? e2.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
          if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u))
            throw new Error(`coordinate_transform_mode '${u}' is not supported`);
          const l = "tf_crop_and_resize" === u, c = l, p = "nearest" === o2 && n2 >= 11 ? e2.attributes.getString("nearest_mode", "round_prefer_floor") : "";
          if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p))
            throw new Error(`nearest_mode '${p}' is not supported`);
          const d = e2.attributes.getFloat("cubic_coeff_a", -0.75), f = 0 !== e2.attributes.getInt("exclude_outside", 0);
          if (f && "cubic" !== o2)
            throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
          const h = n2 < 11 || "nearest" === o2 && "asymmetric" === u && "floor" === p;
          let g = 0, m = 0, b = 0;
          return n2 > 10 ? e2.inputs.length > 2 ? (g = 1, m = 2, b = 3) : (m = 1, b = 2) : 9 === n2 && (m = 1), (0, r.createAttributeWithCacheKey)({ opset: n2, isResize: i2, mode: o2, scales: a2, extrapolationValue: s2, coordinateTransformMode: u, useExtrapolation: c, needRoiInput: l, nearestMode: p, cubicCoefficientA: d, excludeOutside: f, useNearest2xOptimization: h, roiInputIdx: g, scalesInputIdx: m, sizesInputIdx: b });
        };
        const s = (e2, t2, n2) => {
          const r2 = (0, i.getGlsl)(e2.session.backend.glContext.version), [s2, u] = e2.calculateTextureWidthAndHeight(t2[0].dims, o.TextureType.unpacked), l = t2[0].dims.map((e3, t3) => Math.floor(e3 * n2.scales[t3])), [c, p] = e2.calculateTextureWidthAndHeight(l, o.TextureType.unpacked), d = l.length, f = new Array(d), h = new Array(d);
          let g = `
      int output_pitches[${d}];
      int input_pitches[${d}];
      `;
          for (let e3 = d - 1; e3 >= 0; e3--)
            f[e3] = e3 === d - 1 ? 1 : f[e3 + 1] * l[e3 + 1], h[e3] = e3 === d - 1 ? 1 : h[e3 + 1] * t2[0].dims[e3 + 1], g += `
        output_pitches[${e3}] = ${f[e3]};
        input_pitches[${e3}] = ${h[e3]};
        `;
          const m = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s2}, ${u});
        float value = getColorAsFloat(${r2.texture2D}(X, coords));
        return value;
      }
      `, b = "nearest" === n2.mode ? `
    ${m}
    float process(int indices[${d}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int d, m;
      for (int dim = 0; dim < ${d}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === d ? `
    ${m}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${t2[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${m}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${c}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${t2[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
          return Object.assign(Object.assign({}, a), { output: { dims: l, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: b, variables: [{ name: "scales", type: "int", arrayLength: n2.scales.length, data: n2.scales.map((e3) => Math.ceil(e3)) }] });
        };
        t.validateInputs = (e2, t2) => {
          if (!e2 || t2.opset < 9 && 1 !== e2.length || t2.opset >= 9 && t2.opset < 11 && 2 !== e2.length || t2.opset >= 11 && e2.length < 2)
            throw new Error("invalid inputs.");
          if (t2.scales.length > 0 && e2[0].dims.length !== t2.scales.length)
            throw new Error("Invalid input shape.");
          if ("string" === e2[0].type)
            throw new Error("Invalid input tensor types.");
        }, t.scalesValidation = (e2, t2, n2) => {
          if (n2) {
            for (const t3 of e2)
              if (t3 <= 0)
                throw new Error("Scale value should be greater than 0.");
          } else
            for (const t3 of e2)
              if (t3 < 1)
                throw new Error("Scale value should be greater than or equal to 1.");
          if (!("linear" !== t2 && "cubic" !== t2 || 2 === e2.length || 4 === e2.length && 1 === e2[0] && 1 === e2[1]))
            throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n2 ? "Resize" : "Upsample"} opeartor.`);
        };
      }, 2757: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ProgramManager = void 0;
        const r = n(2235), i = n(1315), o = n(8897), a = n(6757);
        t.ProgramManager = class {
          constructor(e2, t2, n2) {
            this.profiler = e2, this.glContext = t2, this.textureLayoutStrategy = n2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
          }
          getArtifact(e2) {
            return this.repo.get(e2);
          }
          setArtifact(e2, t2) {
            this.repo.set(e2, t2);
          }
          run(e2, t2, n2) {
            var r2;
            this.profiler.event("op", `ProgramManager.run ${null !== (r2 = e2.programInfo.name) && void 0 !== r2 ? r2 : "unknown kernel"}`, () => {
              var r3;
              const o2 = this.glContext.gl, a2 = e2.program;
              o2.useProgram(a2);
              try {
                this.bindOutput(n2), this.attributesBound || this.bindAttributes(e2.attribLocations), this.bindUniforms(e2.uniformLocations, null !== (r3 = e2.programInfo.variables) && void 0 !== r3 ? r3 : [], t2);
              } catch (t3) {
                throw i.Logger.error("ProgramManager", e2.programInfo.shaderSource), t3;
              }
              this.profiler.event("backend", "GlContext.draw()", () => {
                this.glContext.draw();
              });
            }, this.glContext);
          }
          dispose() {
            this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((e2) => this.glContext.deleteProgram(e2.program));
          }
          build(e2, t2, n2) {
            return this.profiler.event("backend", "ProgramManager.build", () => {
              const r2 = new o.GlslPreprocessor(this.glContext, e2, t2, n2), i2 = r2.preprocess(), a2 = this.compile(i2);
              return { programInfo: e2, program: a2, uniformLocations: this.getUniformLocations(a2, r2.context.programInfo.inputNames, r2.context.programInfo.variables), attribLocations: this.getAttribLocations(a2) };
            });
          }
          compile(e2) {
            if (!this.vertexShader) {
              i.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
              const e3 = (0, a.getVertexShaderSource)(this.glContext.version);
              this.vertexShader = this.glContext.compileShader(e3, this.glContext.gl.VERTEX_SHADER);
            }
            r.env.debug && i.Logger.verbose("ProrgramManager", `FragShader:
${e2}
`);
            const t2 = this.glContext.compileShader(e2, this.glContext.gl.FRAGMENT_SHADER), n2 = this.glContext.createProgram(this.vertexShader, t2);
            return this.glContext.deleteShader(t2), n2;
          }
          bindOutput(e2) {
            const t2 = e2.width, n2 = e2.height;
            i.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${t2}/${n2}, shape=${e2.shape}, type=${e2.tensor.type}`), this.glContext.attachFramebuffer(e2.texture, t2, n2);
          }
          bindAttributes(e2) {
            const t2 = e2.position, n2 = e2.textureCoord;
            this.glContext.setVertexAttributes(t2, n2), this.attributesBound = true;
          }
          bindUniforms(e2, t2, n2) {
            var r2;
            const i2 = this.glContext.gl;
            let o2 = 0;
            for (const { name: a2, type: s, location: u, arrayLength: l } of e2) {
              const e3 = null === (r2 = t2.find((e4) => e4.name === a2)) || void 0 === r2 ? void 0 : r2.data;
              if ("sampler2D" !== s && !e3)
                throw new Error(`variable '${a2}' does not have data defined in program info`);
              switch (s) {
                case "sampler2D":
                  this.bindTexture(n2[o2], u, o2), o2++;
                  break;
                case "float":
                  l ? i2.uniform1fv(u, e3) : i2.uniform1f(u, e3);
                  break;
                case "int":
                  l ? i2.uniform1iv(u, e3) : i2.uniform1i(u, e3);
                  break;
                default:
                  throw new Error(`Uniform not implemented: ${s}`);
              }
            }
          }
          bindTexture(e2, t2, n2) {
            this.glContext.bindTextureToUniform(e2.texture, n2, t2);
          }
          getAttribLocations(e2) {
            return { position: this.getAttribLocation(e2, "position"), textureCoord: this.getAttribLocation(e2, "textureCoord") };
          }
          getUniformLocations(e2, t2, n2) {
            const r2 = [];
            if (t2)
              for (const n3 of t2)
                r2.push({ name: n3, type: "sampler2D", location: this.getUniformLocation(e2, n3) });
            if (n2)
              for (const t3 of n2)
                r2.push(Object.assign(Object.assign({}, t3), { location: this.getUniformLocation(e2, t3.name) }));
            return r2;
          }
          getUniformLocation(e2, t2) {
            const n2 = this.glContext.gl.getUniformLocation(e2, t2);
            if (null === n2)
              throw new Error(`Uniform ${t2} not found.`);
            return n2;
          }
          getAttribLocation(e2, t2) {
            return this.glContext.gl.getAttribLocation(e2, t2);
          }
        };
      }, 2171: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLSessionHandler = void 0;
        const r = n(1315), i = n(5881), o = n(7860), a = n(4110), s = n(2757), u = n(7618), l = n(5243);
        t.WebGLSessionHandler = class {
          constructor(e2, t2) {
            this.backend = e2, this.context = t2, this.layoutStrategy = new u.PreferLogicalStrategy(e2.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, e2.glContext, this.layoutStrategy), this.textureManager = new l.TextureManager(e2.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === e2.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = e2.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
          }
          createInferenceHandler() {
            return new o.WebGLInferenceHandler(this);
          }
          onGraphInitialized(e2) {
            const t2 = e2.getValues().filter((e3) => -1 === e3.from && e3.tensor).map((e3) => e3.tensor.dataId);
            this.initializers = new Set(t2);
          }
          isInitializer(e2) {
            return !!this.initializers && this.initializers.has(e2);
          }
          addInitializer(e2) {
            this.initializers.add(e2);
          }
          getTextureData(e2, t2) {
            return t2 ? this.packedTextureDataCache.get(e2) : this.unpackedTextureDataCache.get(e2);
          }
          setTextureData(e2, t2, n2 = false) {
            r.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n2 ? this.packedTextureDataCache.set(e2, t2) : this.unpackedTextureDataCache.set(e2, t2);
          }
          dispose() {
            this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e2) => this.textureManager.releaseTexture(e2, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((e2) => this.textureManager.releaseTexture(e2, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
          }
          resolve(e2, t2, n2) {
            const r2 = (0, i.resolveOperator)(e2, t2, a.WEBGL_OP_RESOLVE_RULES);
            return { impl: r2.opImpl, context: r2.opInit ? r2.opInit(e2, n2) : e2 };
          }
        };
      }, 9622: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Uint8DataEncoder = t.RGBAFloatDataEncoder = t.RedFloat32DataEncoder = void 0;
        const r = n(1315);
        t.RedFloat32DataEncoder = class {
          constructor(e2, t2 = 1) {
            if (1 === t2)
              this.internalFormat = e2.R32F, this.format = e2.RED, this.textureType = e2.FLOAT, this.channelSize = t2;
            else {
              if (4 !== t2)
                throw new Error(`Invalid number of channels: ${t2}`);
              this.internalFormat = e2.RGBA32F, this.format = e2.RGBA, this.textureType = e2.FLOAT, this.channelSize = t2;
            }
          }
          encode(e2, t2) {
            let n2, i;
            return e2.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), i = new Float32Array(e2)), t2 * this.channelSize > e2.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), i = e2, n2 = this.allocate(t2 * this.channelSize), i.forEach((e3, t3) => n2[t3] = e3)) : (i = e2, n2 = i), n2;
          }
          allocate(e2) {
            return new Float32Array(4 * e2);
          }
          decode(e2, t2) {
            return 1 === this.channelSize ? e2.filter((e3, t3) => t3 % 4 == 0).subarray(0, t2) : e2.subarray(0, t2);
          }
        }, t.RGBAFloatDataEncoder = class {
          constructor(e2, t2 = 1, n2) {
            if (1 !== t2 && 4 !== t2)
              throw new Error(`Invalid number of channels: ${t2}`);
            this.internalFormat = e2.RGBA, this.format = e2.RGBA, this.channelSize = t2, this.textureType = n2 || e2.FLOAT;
          }
          encode(e2, t2) {
            let n2 = e2;
            return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n2 = this.allocate(t2), e2.forEach((e3, t3) => n2[4 * t3] = e3)), n2;
          }
          allocate(e2) {
            return new Float32Array(4 * e2);
          }
          decode(e2, t2) {
            return 1 === this.channelSize ? e2.filter((e3, t3) => t3 % 4 == 0).subarray(0, t2) : e2.subarray(0, t2);
          }
        }, t.Uint8DataEncoder = class {
          constructor(e2, t2 = 1) {
            if (this.channelSize = 4, 1 === t2)
              this.internalFormat = e2.ALPHA, this.format = e2.ALPHA, this.textureType = e2.UNSIGNED_BYTE, this.channelSize = t2;
            else {
              if (4 !== t2)
                throw new Error(`Invalid number of channels: ${t2}`);
              this.internalFormat = e2.RGBA, this.format = e2.RGBA, this.textureType = e2.UNSIGNED_BYTE, this.channelSize = t2;
            }
          }
          encode(e2, t2) {
            return new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength);
          }
          allocate(e2) {
            return new Uint8Array(e2 * this.channelSize);
          }
          decode(e2, t2) {
            if (e2 instanceof Uint8Array)
              return e2.subarray(0, t2);
            throw new Error(`Invalid array type: ${e2.constructor}`);
          }
        };
      }, 7618: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getBatchDim = t.sizeToSquarishShape = t.getRowsCols = t.sizeFromShape = t.isInt = t.parseAxisParam = t.squeezeShape = t.PreferLogicalStrategy = t.AlwaysKeepOriginalSizeStrategy = void 0;
        const r = n(1315), i = n(7273);
        function o(e2, t2) {
          const n2 = [], r2 = [], i2 = null != t2 && Array.isArray(t2) && 0 === t2.length, o2 = null == t2 || i2 ? null : a(t2, e2).sort();
          let s2 = 0;
          for (let t3 = 0; t3 < e2.length; ++t3) {
            if (null != o2) {
              if (o2[s2] === t3 && 1 !== e2[t3])
                throw new Error(`Can't squeeze axis ${t3} since its dim '${e2[t3]}' is not 1`);
              (null == o2[s2] || o2[s2] > t3) && 1 === e2[t3] && (n2.push(e2[t3]), r2.push(t3)), o2[s2] <= t3 && s2++;
            }
            1 !== e2[t3] && (n2.push(e2[t3]), r2.push(t3));
          }
          return { newShape: n2, keptDims: r2 };
        }
        function a(e2, t2) {
          const n2 = t2.length;
          return e2 = null == e2 ? t2.map((e3, t3) => t3) : [].concat(e2), (0, i.assert)(e2.every((e3) => e3 >= -n2 && e3 < n2), () => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${e2}`), (0, i.assert)(e2.every(s), () => `All values in axis param must be integers but got axis ${e2}`), e2.map((e3) => e3 < 0 ? n2 + e3 : e3);
        }
        function s(e2) {
          return e2 % 1 == 0;
        }
        function u(e2) {
          if (0 === e2.length)
            return 1;
          let t2 = e2[0];
          for (let n2 = 1; n2 < e2.length; n2++)
            t2 *= e2[n2];
          return t2;
        }
        function l(e2) {
          const t2 = Math.ceil(Math.sqrt(e2));
          return [t2, Math.ceil(e2 / t2)];
        }
        t.AlwaysKeepOriginalSizeStrategy = class {
          constructor(e2) {
            this.maxTextureSize = e2;
          }
          computeTextureWH(e2, t2) {
            if (0 === e2.length)
              return [1, 1];
            const n2 = this.maxTextureSize;
            if (t2 && void 0 !== t2.breakAxis) {
              const i3 = t2.breakAxis >= e2.length ? 1 : e2.slice(t2.breakAxis).reduce((e3, t3) => e3 * t3), o3 = t2.breakAxis <= 0 ? 1 : e2.slice(0, t2.breakAxis).reduce((e3, t3) => e3 * t3);
              if (!(i3 > n2 || o3 > n2))
                return [i3, o3];
              r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e2}, breakAxis:${t2.breakAxis}`);
            }
            const i2 = e2.reduce((e3, t3) => e3 * t3);
            let o2 = Math.floor(Math.sqrt(i2));
            for (; o2 < n2 && o2 < i2 && i2 % o2 != 0; o2++)
              ;
            if (o2 >= n2 || i2 % o2 != 0)
              throw new Error(`The given dimensions are outside this GPU's boundaries: ${e2}`);
            return [o2, i2 / o2];
          }
        }, t.PreferLogicalStrategy = class {
          constructor(e2) {
            this.maxTextureSize = e2;
          }
          computeTextureWH(e2, t2) {
            const n2 = this.computeTexture(e2, t2);
            return t2 && t2.isPacked && (n2[0] /= 2, n2[1] /= 2), t2 && t2.reverseWH ? [n2[1], n2[0]] : n2;
          }
          computeTexture(e2, t2) {
            const n2 = t2 && t2.isPacked;
            if (0 === e2.length)
              return n2 ? [2, 2] : [1, 1];
            let i2 = this.maxTextureSize;
            if (t2 && void 0 !== t2.breakAxis) {
              const n3 = t2.breakAxis >= e2.length ? 1 : e2.slice(t2.breakAxis).reduce((e3, t3) => e3 * t3), o2 = t2.breakAxis <= 0 ? 1 : e2.slice(0, t2.breakAxis).reduce((e3, t3) => e3 * t3);
              if (!(n3 > i2 || o2 > i2))
                return [n3, o2];
              r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${e2}, breakAxis:${t2.breakAxis}`);
            }
            let a2 = e2.slice(0);
            if (n2 && (i2 *= 2, a2 = a2.map((e3, t3) => t3 >= a2.length - 2 ? a2[t3] % 2 == 0 ? a2[t3] : a2[t3] + 1 : a2[t3]), 1 === a2.length && (a2 = [2, a2[0]])), 2 !== a2.length) {
              const e3 = o(a2);
              a2 = e3.newShape;
            }
            const s2 = u(a2);
            return a2.length <= 1 && s2 <= i2 ? [1, s2] : 2 === a2.length && a2[0] <= i2 && a2[1] <= i2 ? a2 : 3 === a2.length && a2[0] * a2[1] <= i2 && a2[2] <= i2 ? [a2[0] * a2[1], a2[2]] : 3 === a2.length && a2[0] <= i2 && a2[1] * a2[2] <= i2 ? [a2[0], a2[1] * a2[2]] : 4 === a2.length && a2[0] * a2[1] * a2[2] <= i2 && a2[3] <= i2 ? [a2[0] * a2[1] * a2[2], a2[3]] : 4 === a2.length && a2[0] <= i2 && a2[1] * a2[2] * a2[3] <= i2 ? [a2[0], a2[1] * a2[2] * a2[3]] : n2 ? l(s2 / 4).map((e3) => 2 * e3) : l(s2);
          }
        }, t.squeezeShape = o, t.parseAxisParam = a, t.isInt = s, t.sizeFromShape = u, t.getRowsCols = function(e2) {
          if (0 === e2.length)
            throw Error("Cannot get rows and columns of an empty shape array.");
          return [e2.length > 1 ? e2[e2.length - 2] : 1, e2[e2.length - 1]];
        }, t.sizeToSquarishShape = l, t.getBatchDim = function(e2, t2 = 2) {
          return u(e2.slice(0, e2.length - t2));
        };
      }, 3314: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createTextureLayoutFromShape = t.calculateTextureWidthAndHeight = t.createTextureLayoutFromTextureType = void 0;
        const r = n(7273), i = n(5639);
        t.createTextureLayoutFromTextureType = (e2, n2, r2) => {
          const o = r2 === i.TextureType.unpacked || r2 === i.TextureType.unpackedReversed ? 1 : 4, a = r2 === i.TextureType.packed, s = r2 === i.TextureType.unpackedReversed || r2 === i.TextureType.packed, u = r2 === i.TextureType.packedLastDimension ? n2.length - 1 : void 0, l = r2 === i.TextureType.packedLastDimension ? n2.map((e3, t2) => t2 === n2.length - 1 ? 4 * e3 : e3) : void 0;
          return (0, t.createTextureLayoutFromShape)(e2, n2, o, l, { isPacked: a, reverseWH: s, breakAxis: u });
        }, t.calculateTextureWidthAndHeight = (e2, n2, r2) => {
          const i2 = (0, t.createTextureLayoutFromTextureType)(e2, n2, r2);
          return [i2.width, i2.height];
        }, t.createTextureLayoutFromShape = (e2, t2, n2 = 1, i2, o) => {
          const a = !(!o || !o.isPacked), [s, u] = e2.computeTextureWH(a && i2 || t2, o), l = t2.length;
          let c = t2.slice(0);
          if (0 === l && (c = [1]), 1 === n2)
            i2 = t2;
          else if (a) {
            if (4 !== n2)
              throw new Error("a packed texture must be 4-channel");
            i2 = t2, l > 0 && (c[l - 1] = Math.ceil(c[l - 1] / 2)), l > 1 && (c[l - 2] = Math.ceil(c[l - 2] / 2));
          } else if (!i2)
            throw new Error("Unpacked shape is needed when using channels > 1");
          return { width: s, height: u, channels: n2, isPacked: a, shape: c, strides: r.ShapeUtil.computeStrides(c), unpackedShape: i2, reversedWH: o && o.reverseWH };
        };
      }, 5243: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.TextureManager = void 0;
        const r = n(1315);
        t.TextureManager = class {
          constructor(e2, t2, n2, r2) {
            this.glContext = e2, this.layoutStrategy = t2, this.profiler = n2, this.config = r2, this.pendingRead = /* @__PURE__ */ new Map(), r2.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
          }
          createTextureFromLayout(e2, t2, n2, i) {
            const o = this.toEncoderType(e2), a = this.glContext.getEncoder(o, t2.channels || 1, i);
            if (t2.isPacked && 1 === i)
              throw new Error("not implemented");
            const s = t2.width, u = t2.height;
            let l, c;
            if (this.config.reuseTextures) {
              l = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, c = this.inUseTextures.get(l), c || (c = [], this.inUseTextures.set(l, c));
              const t3 = this.idleTextures.get(l);
              if (t3 && t3.length > 0) {
                const r2 = t3.pop();
                return c.push(r2), 1 === i && this.glContext.updateTexture(r2, s, u, a, this.toTextureData(e2, n2)), r2;
              }
            }
            r.Logger.verbose("TextureManager", `Creating new texture of size ${t2.width}x${t2.height}`);
            const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(e2, n2));
            return this.config.reuseTextures && (c.push(p), this.textureLookup.set(p, l)), p;
          }
          readTexture(e2, t2, n2) {
            return n2 || (n2 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
              const r2 = e2.shape.reduce((e3, t3) => e3 * t3) * n2, i = this.glContext.readTexture(e2.texture, e2.width, e2.height, r2, this.toEncoderType(t2), n2);
              return this.toTensorData(t2, i);
            });
          }
          async readTextureAsync(e2, t2, n2) {
            const r2 = e2.tensor.dataId;
            if (n2 || (n2 = 1), this.pendingRead.has(r2)) {
              const e3 = this.pendingRead.get(r2);
              return new Promise((t3) => null == e3 ? void 0 : e3.push(t3));
            }
            return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
              this.pendingRead.set(r2, []);
              const i = e2.shape.reduce((e3, t3) => e3 * t3) * n2;
              await this.glContext.createAndWaitForFence();
              const o = this.glContext.readTexture(e2.texture, e2.width, e2.height, i, this.toEncoderType(t2), n2), a = this.toTensorData(t2, o), s = this.pendingRead.get(r2);
              return this.pendingRead.delete(r2), null == s || s.forEach((e3) => e3(a)), a;
            });
          }
          readUint8TextureAsFloat(e2) {
            return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
              const t2 = e2.shape.reduce((e3, t3) => e3 * t3), n2 = this.glContext.readTexture(e2.texture, e2.width, e2.height, 4 * t2, "byte", 4);
              return new Float32Array(n2.buffer, n2.byteOffset, t2);
            });
          }
          releaseTexture(e2, t2) {
            let n2;
            if (this.config.reuseTextures && (n2 = this.textureLookup.get(e2.texture), n2)) {
              t2 && this.textureLookup.delete(n2);
              const r2 = this.inUseTextures.get(n2);
              if (r2) {
                const t3 = r2.indexOf(e2.texture);
                if (-1 !== t3) {
                  r2.splice(t3, 1);
                  let i = this.idleTextures.get(n2);
                  i || (i = [], this.idleTextures.set(n2, i)), i.push(e2.texture);
                }
              }
            }
            n2 && !t2 || (r.Logger.verbose("TextureManager", `Deleting texture of size ${e2.width}x${e2.height}`), this.glContext.deleteTexture(e2.texture));
          }
          toTensorData(e2, t2) {
            switch (e2) {
              case "int16":
                return t2 instanceof Int16Array ? t2 : Int16Array.from(t2);
              case "int32":
                return t2 instanceof Int32Array ? t2 : Int32Array.from(t2);
              case "int8":
                return t2 instanceof Int8Array ? t2 : Int8Array.from(t2);
              case "uint16":
                return t2 instanceof Uint16Array ? t2 : Uint16Array.from(t2);
              case "uint32":
                return t2 instanceof Uint32Array ? t2 : Uint32Array.from(t2);
              case "uint8":
              case "bool":
                return t2 instanceof Uint8Array ? t2 : Uint8Array.from(t2);
              case "float32":
                return t2 instanceof Float32Array ? t2 : Float32Array.from(t2);
              case "float64":
                return t2 instanceof Float64Array ? t2 : Float64Array.from(t2);
              default:
                throw new Error(`TensorData type ${e2} is not supported`);
            }
          }
          toTextureData(e2, t2) {
            if (t2)
              return t2 instanceof Float32Array ? t2 : new Float32Array(t2);
          }
          toEncoderType(e2) {
            return "float";
          }
          clearActiveTextures() {
            this.glContext.clearActiveTextures();
          }
        };
      }, 5639: (e, t) => {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: true }), t.TextureType = void 0, (n = t.TextureType || (t.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
      }, 432: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getGlChannels = t.getCoordsDataType = t.getSqueezedParams = t.squeezeInputShape = t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = t.generateShaderFuncNameFromInputSamplerName = t.repeatedTry = t.getPackedShape = void 0;
        const r = n(7273);
        t.getPackedShape = function(e2) {
          const t2 = e2.length;
          return e2.slice(0, t2 - 1).concat(e2[t2 - 1] / 4);
        }, t.repeatedTry = async function(e2, t2 = (e3) => 0, n2) {
          return new Promise((r2, i) => {
            let o = 0;
            const a = () => {
              if (e2())
                return void r2();
              o++;
              const s = t2(o);
              null != n2 && o >= n2 ? i() : setTimeout(a, s);
            };
            a();
          });
        }, t.generateShaderFuncNameFromInputSamplerName = function(e2) {
          return (0, r.assert)(void 0 !== e2 && 0 !== e2.length, () => "empty string found for sampler name"), "get" + e2.charAt(0).toUpperCase() + e2.slice(1);
        }, t.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(e2) {
          return (0, r.assert)(void 0 !== e2 && 0 !== e2.length, () => "empty string found for sampler name"), "get" + e2.charAt(0).toUpperCase() + e2.slice(1) + "AtOutCoords";
        }, t.squeezeInputShape = function(e2, t2) {
          let n2 = JSON.parse(JSON.stringify(e2));
          return n2 = t2, n2;
        }, t.getSqueezedParams = function(e2, t2) {
          return t2.map((t3) => e2[t3]).join(", ");
        }, t.getCoordsDataType = function(e2) {
          if (e2 <= 1)
            return "int";
          if (2 === e2)
            return "ivec2";
          if (3 === e2)
            return "ivec3";
          if (4 === e2)
            return "ivec4";
          if (5 === e2)
            return "ivec5";
          if (6 === e2)
            return "ivec6";
          throw Error(`GPU for rank ${e2} is not yet supported`);
        }, t.getGlChannels = function(e2 = 6) {
          return ["x", "y", "z", "w", "u", "v"].slice(0, e2);
        };
      }, 3389: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createNewWebGLContext = t.createWebGLContext = void 0;
        const r = n(1315), i = n(3524), o = {};
        function a(e2, t2) {
          let n2;
          const o2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
          if ((!t2 || "webgl2" === t2) && (n2 = e2.getContext("webgl2", o2), n2))
            try {
              return new i.WebGLContext(n2, 2);
            } catch (e3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${e3}`);
            }
          if ((!t2 || "webgl" === t2) && (n2 = e2.getContext("webgl", o2) || e2.getContext("experimental-webgl", o2), n2))
            try {
              return new i.WebGLContext(n2, 1);
            } catch (e3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e3}`);
            }
          throw new Error("WebGL is not supported");
        }
        t.createWebGLContext = function e2(t2) {
          let n2;
          if (t2 && "webgl2" !== t2 || !("webgl2" in o) ? t2 && "webgl" !== t2 || !("webgl" in o) || (n2 = o.webgl) : n2 = o.webgl2, !n2)
            try {
              n2 = a(function() {
                if ("undefined" == typeof OffscreenCanvas)
                  throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
                return new OffscreenCanvas(1, 1);
              }(), t2);
            } catch (e3) {
              n2 = a(function() {
                if ("undefined" == typeof document)
                  throw new TypeError("failed to create canvas: document is not supported");
                const e4 = document.createElement("canvas");
                return e4.width = 1, e4.height = 1, e4;
              }(), t2);
            }
          t2 = t2 || 1 === n2.version ? "webgl" : "webgl2";
          const r2 = n2.gl;
          return o[t2] = n2, r2.isContextLost() ? (delete o[t2], e2(t2)) : (r2.disable(r2.DEPTH_TEST), r2.disable(r2.STENCIL_TEST), r2.disable(r2.BLEND), r2.disable(r2.DITHER), r2.disable(r2.POLYGON_OFFSET_FILL), r2.disable(r2.SAMPLE_COVERAGE), r2.enable(r2.SCISSOR_TEST), r2.enable(r2.CULL_FACE), r2.cullFace(r2.BACK), n2);
        }, t.createNewWebGLContext = a;
      }, 3524: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var i2 = Object.getOwnPropertyDescriptor(t2, n2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, i2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), o = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return i(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGLContext = t.linearSearchLastTrue = void 0;
        const a = n(2235), s = o(n(9622)), u = n(432);
        function l(e2) {
          let t2 = 0;
          for (; t2 < e2.length && e2[t2](); ++t2)
            ;
          return t2 - 1;
        }
        t.linearSearchLastTrue = l, t.WebGLContext = class {
          constructor(e2, t2) {
            this.frameBufferBound = false, this.itemsToPoll = [], this.gl = e2, this.version = t2, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
          }
          allocateTexture(e2, t2, n2, r2) {
            const i2 = this.gl, o2 = i2.createTexture();
            i2.bindTexture(i2.TEXTURE_2D, o2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, i2.CLAMP_TO_EDGE), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, i2.CLAMP_TO_EDGE);
            const a2 = r2 ? n2.encode(r2, e2 * t2) : null;
            return i2.texImage2D(i2.TEXTURE_2D, 0, n2.internalFormat, e2, t2, 0, n2.format, n2.textureType, a2), this.checkError(), o2;
          }
          updateTexture(e2, t2, n2, r2, i2) {
            const o2 = this.gl;
            o2.bindTexture(o2.TEXTURE_2D, e2);
            const a2 = r2.encode(i2, t2 * n2);
            o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, t2, n2, r2.format, r2.textureType, a2), this.checkError();
          }
          attachFramebuffer(e2, t2, n2) {
            const r2 = this.gl;
            r2.bindTexture(r2.TEXTURE_2D, e2), r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer), r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.COLOR_ATTACHMENT0, r2.TEXTURE_2D, e2, 0), this.checkError(), r2.viewport(0, 0, t2, n2), r2.scissor(0, 0, t2, n2);
          }
          readTexture(e2, t2, n2, r2, i2, o2) {
            const a2 = this.gl;
            o2 || (o2 = 1), this.frameBufferBound || this.attachFramebuffer(e2, t2, n2);
            const s2 = this.getEncoder(i2, o2), u2 = s2.allocate(t2 * n2);
            return a2.bindTexture(a2.TEXTURE_2D, e2), a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_2D, e2, 0), a2.readPixels(0, 0, t2, n2, a2.RGBA, s2.textureType, u2), this.checkError(), s2.decode(u2, r2);
          }
          isFramebufferReady() {
            return true;
          }
          getActiveTexture() {
            const e2 = this.gl;
            return "TEXTURE" + (e2.getParameter(this.gl.ACTIVE_TEXTURE) - e2.TEXTURE0);
          }
          getTextureBinding() {
            return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
          }
          getFramebufferBinding() {
            return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
          }
          setVertexAttributes(e2, t2) {
            const n2 = this.gl;
            n2.vertexAttribPointer(e2, 3, n2.FLOAT, false, 20, 0), n2.enableVertexAttribArray(e2), -1 !== t2 && (n2.vertexAttribPointer(t2, 2, n2.FLOAT, false, 20, 12), n2.enableVertexAttribArray(t2)), this.checkError();
          }
          createProgram(e2, t2) {
            const n2 = this.gl, r2 = n2.createProgram();
            return n2.attachShader(r2, e2), n2.attachShader(r2, t2), n2.linkProgram(r2), r2;
          }
          compileShader(e2, t2) {
            const n2 = this.gl, r2 = n2.createShader(t2);
            if (!r2)
              throw new Error(`createShader() returned null with type ${t2}`);
            if (n2.shaderSource(r2, e2), n2.compileShader(r2), false === n2.getShaderParameter(r2, n2.COMPILE_STATUS))
              throw new Error(`Failed to compile shader: ${n2.getShaderInfoLog(r2)}
Shader source:
${e2}`);
            return r2;
          }
          deleteShader(e2) {
            this.gl.deleteShader(e2);
          }
          bindTextureToUniform(e2, t2, n2) {
            const r2 = this.gl;
            r2.activeTexture(r2.TEXTURE0 + t2), this.checkError(), r2.bindTexture(r2.TEXTURE_2D, e2), this.checkError(), r2.uniform1i(n2, t2), this.checkError();
          }
          draw() {
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
          }
          checkError() {
            if (a.env.debug) {
              const e2 = this.gl, t2 = e2.getError();
              let n2 = "";
              switch (t2) {
                case e2.NO_ERROR:
                  return;
                case e2.INVALID_ENUM:
                  n2 = "INVALID_ENUM";
                  break;
                case e2.INVALID_VALUE:
                  n2 = "INVALID_VALUE";
                  break;
                case e2.INVALID_OPERATION:
                  n2 = "INVALID_OPERATION";
                  break;
                case e2.INVALID_FRAMEBUFFER_OPERATION:
                  n2 = "INVALID_FRAMEBUFFER_OPERATION";
                  break;
                case e2.OUT_OF_MEMORY:
                  n2 = "OUT_OF_MEMORY";
                  break;
                case e2.CONTEXT_LOST_WEBGL:
                  n2 = "CONTEXT_LOST_WEBGL";
                  break;
                default:
                  n2 = `Unknown WebGL Error: ${t2.toString(16)}`;
              }
              throw new Error(n2);
            }
          }
          deleteTexture(e2) {
            this.gl.deleteTexture(e2);
          }
          deleteProgram(e2) {
            this.gl.deleteProgram(e2);
          }
          getEncoder(e2, t2, n2 = 0) {
            if (2 === this.version)
              return new s.RedFloat32DataEncoder(this.gl, t2);
            switch (e2) {
              case "float":
                return 1 === n2 || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, t2) : new s.RGBAFloatDataEncoder(this.gl, t2, this.textureHalfFloatExtension.HALF_FLOAT_OES);
              case "int":
                throw new Error("not implemented");
              case "byte":
                return new s.Uint8DataEncoder(this.gl, t2);
              default:
                throw new Error(`Invalid dataType: ${e2}`);
            }
          }
          clearActiveTextures() {
            const e2 = this.gl;
            for (let t2 = 0; t2 < this.maxTextureImageUnits; ++t2)
              e2.activeTexture(e2.TEXTURE0 + t2), e2.bindTexture(e2.TEXTURE_2D, null);
          }
          dispose() {
            if (this.disposed)
              return;
            const e2 = this.gl;
            e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteFramebuffer(this.framebuffer), e2.bindBuffer(e2.ARRAY_BUFFER, null), e2.deleteBuffer(this.vertexbuffer), e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, null), e2.finish(), this.disposed = true;
          }
          createDefaultGeometry() {
            return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
          }
          createVertexbuffer() {
            const e2 = this.gl, t2 = e2.createBuffer();
            if (!t2)
              throw new Error("createBuffer() returned null");
            const n2 = this.createDefaultGeometry();
            return e2.bindBuffer(e2.ARRAY_BUFFER, t2), e2.bufferData(e2.ARRAY_BUFFER, n2, e2.STATIC_DRAW), this.checkError(), t2;
          }
          createFramebuffer() {
            const e2 = this.gl.createFramebuffer();
            if (!e2)
              throw new Error("createFramebuffer returned null");
            return e2;
          }
          queryVitalParameters() {
            const e2 = this.gl;
            if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported)
              throw new Error("both float32 and float16 TextureType are not supported");
            this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e2.getParameter(e2.MAX_TEXTURE_IMAGE_UNITS), this.version;
          }
          getExtensions() {
            2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
          }
          checkFloatTextureAttachableToFrameBuffer() {
            const e2 = this.gl, t2 = e2.createTexture();
            e2.bindTexture(e2.TEXTURE_2D, t2);
            const n2 = 2 === this.version ? e2.RGBA32F : e2.RGBA;
            e2.texImage2D(e2.TEXTURE_2D, 0, n2, 1, 1, 0, e2.RGBA, e2.FLOAT, null);
            const r2 = e2.createFramebuffer();
            e2.bindFramebuffer(e2.FRAMEBUFFER, r2), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0);
            const i2 = e2.checkFramebufferStatus(e2.FRAMEBUFFER) === e2.FRAMEBUFFER_COMPLETE;
            return e2.bindTexture(e2.TEXTURE_2D, null), e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteTexture(t2), e2.deleteFramebuffer(r2), i2;
          }
          checkRenderFloat32() {
            if (2 === this.version) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else if (!this.textureFloatExtension)
              return false;
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Download() {
            if (2 === this.version) {
              if (!this.colorBufferFloatExtension)
                return false;
            } else {
              if (!this.textureFloatExtension)
                return false;
              if (!this.gl.getExtension("WEBGL_color_buffer_float"))
                return false;
            }
            return this.isFloatTextureAttachableToFrameBuffer;
          }
          checkFloat32Blend() {
            const e2 = this.gl;
            let t2, n2, r2, i2, o2;
            try {
              t2 = e2.createTexture(), n2 = e2.createFramebuffer(), e2.bindTexture(e2.TEXTURE_2D, t2);
              const a2 = 2 === this.version ? e2.RGBA32F : e2.RGBA;
              return e2.texImage2D(e2.TEXTURE_2D, 0, a2, 1, 1, 0, e2.RGBA, e2.FLOAT, null), e2.bindFramebuffer(e2.FRAMEBUFFER, n2), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), e2.enable(e2.BLEND), r2 = e2.createShader(e2.VERTEX_SHADER), !!r2 && (e2.shaderSource(r2, "void main(){}"), e2.compileShader(r2), i2 = e2.createShader(e2.FRAGMENT_SHADER), !!i2 && (e2.shaderSource(i2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), e2.compileShader(i2), o2 = e2.createProgram(), !!o2 && (e2.attachShader(o2, r2), e2.attachShader(o2, i2), e2.linkProgram(o2), e2.useProgram(o2), e2.drawArrays(e2.POINTS, 0, 1), e2.getError() === e2.NO_ERROR)));
            } finally {
              e2.disable(e2.BLEND), o2 && e2.deleteProgram(o2), r2 && e2.deleteShader(r2), i2 && e2.deleteShader(i2), n2 && (e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.deleteFramebuffer(n2)), t2 && (e2.bindTexture(e2.TEXTURE_2D, null), e2.deleteTexture(t2));
            }
          }
          beginTimer() {
            if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
              const e2 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension, n2 = e2.createQuery();
              return e2.beginQuery(t2.TIME_ELAPSED_EXT, n2), n2;
            }
            throw new Error("WebGL1 profiling currently not supported.");
          }
          endTimer() {
            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const e2 = this.gl, t2 = this.disjointTimerQueryWebgl2Extension;
              e2.endQuery(t2.TIME_ELAPSED_EXT);
            }
          }
          isTimerResultAvailable(e2) {
            let t2 = false, n2 = false;
            if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const r2 = this.gl, i2 = this.disjointTimerQueryWebgl2Extension;
              t2 = r2.getQueryParameter(e2, r2.QUERY_RESULT_AVAILABLE), n2 = r2.getParameter(i2.GPU_DISJOINT_EXT);
            }
            return t2 && !n2;
          }
          getTimerResult(e2) {
            let t2 = 0;
            if (2 !== this.version)
              throw new Error("WebGL1 profiling currently not supported");
            {
              const n2 = this.gl;
              t2 = n2.getQueryParameter(e2, n2.QUERY_RESULT), n2.deleteQuery(e2);
            }
            return t2 / 1e6;
          }
          async waitForQueryAndGetTime(e2) {
            return await (0, u.repeatedTry)(() => this.isTimerResultAvailable(e2)), this.getTimerResult(e2);
          }
          async createAndWaitForFence() {
            const e2 = this.createFence(this.gl);
            return this.pollFence(e2);
          }
          createFence(e2) {
            let t2;
            const n2 = e2, r2 = n2.fenceSync(n2.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return e2.flush(), t2 = null === r2 ? () => true : () => {
              const e3 = n2.clientWaitSync(r2, 0, 0);
              return e3 === n2.ALREADY_SIGNALED || e3 === n2.CONDITION_SATISFIED;
            }, { query: r2, isFencePassed: t2 };
          }
          async pollFence(e2) {
            return new Promise((t2) => {
              this.addItemToPoll(() => e2.isFencePassed(), () => t2());
            });
          }
          pollItems() {
            const e2 = l(this.itemsToPoll.map((e3) => e3.isDoneFn));
            for (let t2 = 0; t2 <= e2; ++t2) {
              const { resolveFn: e3 } = this.itemsToPoll[t2];
              e3();
            }
            this.itemsToPoll = this.itemsToPoll.slice(e2 + 1);
          }
          async addItemToPoll(e2, t2) {
            this.itemsToPoll.push({ isDoneFn: e2, resolveFn: t2 }), this.itemsToPoll.length > 1 || await (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length));
          }
        };
      }, 6496: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ExecutionPlan = void 0;
        const r = n(1315);
        class i {
          constructor(e2, t2) {
            this.op = e2, this.node = t2;
          }
        }
        t.ExecutionPlan = class {
          constructor(e2, t2, n2) {
            this.graph = e2, this.profiler = n2, this.initialize(t2);
          }
          initialize(e2) {
            this.profiler.event("session", "ExecutionPlan.initialize", () => {
              const t2 = this.graph.getNodes();
              if (t2.length !== e2.length)
                throw new Error("The size of nodes and OPs do not match.");
              this._ops = e2.map((e3, n2) => new i(e3, t2[n2])), this.reset(), this._starter = [], this._ops.forEach((e3, t3) => {
                let n2 = true;
                for (const t4 of e3.node.inputs)
                  if (!this._values[t4] && -1 === this.graph.getInputIndices().indexOf(t4)) {
                    n2 = false;
                    break;
                  }
                n2 && this._starter.push(t3);
              });
            });
          }
          reset() {
            this._values = this.graph.getValues().map((e2) => e2.tensor);
          }
          async execute(e2, t2) {
            return this.profiler.event("session", "ExecutionPlan.execute", async () => {
              this.reset();
              const n2 = e2.createInferenceHandler(), i2 = this.graph.getInputIndices();
              if (t2.length !== i2.length)
                throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t2.length} expected: ${i2.length}`);
              t2.forEach((e3, t3) => {
                const n3 = i2[t3];
                this._values[n3] = e3;
              });
              const o = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();
              let u = 0;
              for (; u < o.length; ) {
                const e3 = o[u++], t3 = this._ops[e3], i3 = t3.node.inputs.map((e4) => this._values[e4]);
                if (-1 !== i3.indexOf(void 0))
                  throw new Error(`unresolved input detected: op: ${t3.node}`);
                const l2 = i3;
                r.Logger.verbose("ExecPlan", `Runing op:${t3.node.name} (${l2.map((e4, n3) => `'${t3.node.inputs[n3]}': ${e4.type}[${e4.dims.join(",")}]`).join(", ")})`);
                const c = await this.profiler.event("node", t3.node.name, async () => t3.op.impl(n2, l2, t3.op.context));
                if (c.length !== t3.node.outputs.length)
                  throw new Error("the size of output does not match model definition.");
                c.forEach((e4, n3) => {
                  const r2 = t3.node.outputs[n3];
                  if (this._values[r2])
                    throw new Error(`output [${r2}] already has value: op:${t3.node.name}`);
                  this._values[r2] = e4;
                });
                const p = /* @__PURE__ */ new Set();
                c.forEach((e4, n3) => {
                  const r2 = t3.node.outputs[n3];
                  for (const e5 of a[r2].to) {
                    const t4 = s[e5];
                    let n4 = true;
                    for (const e6 of t4.inputs)
                      if (!this._values[e6]) {
                        n4 = false;
                        break;
                      }
                    n4 && p.add(e5);
                  }
                }), o.push(...p);
              }
              const l = [];
              for (let e3 = 0; e3 < this.graph.getOutputIndices().length; e3++) {
                const t3 = this.graph.getOutputIndices()[e3], n3 = this._values[t3];
                if (void 0 === n3)
                  throw new Error(`required output [${t3}] does not have value`);
                0 === t3 ? await n3.getData() : n3.data, l.push(n3);
              }
              return r.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n2.dispose(), l;
            });
          }
        };
      }, 4662: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Graph = void 0;
        const r = n(6874), i = n(5127), o = n(2446), a = n(9240), s = n(7273);
        var u = i.onnxruntime.experimental.fbs;
        t.Graph = { from: (e2, t2) => new p(e2, t2) };
        class l {
          constructor(e2) {
            this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e2 && (this.type = s.ProtoUtil.tensorValueTypeFromProto(e2.type.tensorType));
          }
          get from() {
            return this._from;
          }
          get to() {
            return this._to;
          }
        }
        class c {
          constructor(e2, t2) {
            e2 instanceof o.onnx.NodeProto ? (this.name = e2.name, this.opType = e2.opType, this.attributes = new r.Attribute(e2.attribute)) : e2 instanceof u.Node && (this.name = null != t2 ? t2 : e2.name(), this.opType = e2.opType(), this.attributes = new r.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(e2))), this.inputs = [], this.outputs = [], this.executeNode = true;
          }
        }
        class p {
          constructor(e2, t2) {
            if (!e2)
              throw new TypeError("graph is empty");
            this.buildGraph(e2), this.transformGraph(t2), this.checkIsAcyclic();
          }
          getInputIndices() {
            return this._allInputIndices;
          }
          getInputNames() {
            return this._allInputNames;
          }
          getOutputIndices() {
            return this._allOutputIndices;
          }
          getOutputNames() {
            return this._allOutputNames;
          }
          getValues() {
            return this._allData;
          }
          getNodes() {
            return this._nodes;
          }
          buildGraph(e2) {
            if (e2 instanceof o.onnx.GraphProto)
              this.buildGraphFromOnnxFormat(e2);
            else {
              if (!(e2 instanceof u.Graph))
                throw new TypeError("Graph type is not supported.");
              this.buildGraphFromOrtFormat(e2);
            }
          }
          buildGraphFromOnnxFormat(e2) {
            const t2 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            const n2 = /* @__PURE__ */ new Map();
            if (!e2.input)
              throw new Error("missing information in graph: input");
            const r2 = [];
            for (const n3 of e2.input) {
              if (t2.has(n3.name))
                throw new Error(`duplicated input name: ${n3.name}`);
              const e3 = this._allData.push(new l(n3)) - 1;
              t2.set(n3.name, e3), r2.push(n3.name);
            }
            if (!e2.initializer)
              throw new Error("missing information in graph: initializer");
            for (const n3 of e2.initializer) {
              let e3 = t2.get(n3.name);
              if (void 0 === e3) {
                const r3 = new l();
                r3.type = { shape: { dims: s.ProtoUtil.tensorDimsFromProto(n3.dims) }, tensorType: s.ProtoUtil.tensorDataTypeFromProto(n3.dataType) }, e3 = this._allData.push(r3) - 1, t2.set(n3.name, e3);
              }
              this._allData[e3]._from = -1, this._allData[e3].tensor = a.Tensor.fromProto(n3);
            }
            for (let e3 = 0; e3 < this._allData.length; e3++)
              this._allData[e3].tensor || (this._allInputIndices.push(e3), this._allInputNames.push(r2[e3]));
            if (!e2.output)
              throw new Error("missing information in graph: output");
            for (const n3 of e2.output) {
              if (t2.has(n3.name))
                throw new Error(`duplicated output name: ${n3.name}`);
              const e3 = this._allData.push(new l(n3)) - 1;
              t2.set(n3.name, e3), this._allOutputIndices.push(e3), this._allOutputNames.push(n3.name);
            }
            if (!e2.node)
              throw new Error("missing information in graph: node");
            for (const t3 of e2.node) {
              if (!t3.name)
                for (let e4 = 0; ; e4++) {
                  const r3 = `unnamed_${t3.opType}_${e4}`;
                  if (!n2.has(r3)) {
                    t3.name = r3;
                    break;
                  }
                }
              if (n2.has(t3.name))
                throw new Error(`duplicated node name: ${t3.name}`);
              const e3 = this._nodes.push(new c(t3)) - 1;
              n2.set(t3.name, e3);
            }
            for (let n3 = 0; n3 < this._nodes.length; n3++) {
              const r3 = this._nodes[n3], i2 = e2.node[n3];
              if (!i2.output)
                throw new Error(`missing output for node: ${i2.name}`);
              for (const e3 of i2.output) {
                let o2 = t2.get(e3);
                if (void 0 === o2 && (o2 = this._allData.push(new l()) - 1, t2.set(e3, o2)), r3.outputs.push(o2), void 0 !== this._allData[o2]._from)
                  throw new Error(`multiple nodes output to one data value: ${o2}`);
                if (this._allData[o2]._from = n3, "Constant" === i2.opType) {
                  if (!i2.attribute || 1 !== i2.attribute.length || !i2.attribute[0].t)
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (!i2.output || 1 !== i2.output.length)
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  r3.outputs.pop(), r3.executeNode = false, this._allData[o2]._from = -1, this._allData[o2].tensor = a.Tensor.fromProto(i2.attribute[0].t);
                }
              }
            }
            for (let n3 = 0; n3 < this._nodes.length; n3++) {
              const r3 = this._nodes[n3], i2 = e2.node[n3];
              if (!i2.input)
                throw new Error(`missing input for node: ${i2.name}`);
              for (const e3 of i2.input) {
                const o2 = t2.get(e3);
                if (void 0 === o2) {
                  if ("" === e3 && (3 === i2.input.length || 4 === i2.input.length) && "Resize" === i2.opType)
                    continue;
                  throw new Error(`unrecognized input '${e3}' for node: ${i2.name}`);
                }
                r3.inputs.push(o2), this._allData[o2]._to.push(n3);
              }
            }
            return true;
          }
          buildGraphFromOrtFormat(e2) {
            var t2, n2, r2;
            const i2 = /* @__PURE__ */ new Map();
            this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
            const o2 = /* @__PURE__ */ new Map(), p2 = [];
            for (let o3 = 0; o3 < e2.inputsLength(); o3++) {
              const a2 = e2.inputs(o3);
              if (i2.has(a2))
                throw new Error(`duplicated input name: ${a2}`);
              for (let o4 = 0; o4 < e2.nodeArgsLength(); o4++)
                if ((null === (t2 = e2.nodeArgs(o4)) || void 0 === t2 ? void 0 : t2.name()) === a2) {
                  const t3 = new l();
                  if ((null === (r2 = null === (n2 = e2.nodeArgs(o4)) || void 0 === n2 ? void 0 : n2.type()) || void 0 === r2 ? void 0 : r2.valueType()) !== u.TypeInfoValue.tensor_type)
                    throw new Error("Unexpected value type for the nodeArg.");
                  const c2 = e2.nodeArgs(o4).type().value(new u.TensorTypeAndShape()), d = s.ProtoUtil.tensorDataTypeFromProto(c2.elemType()), f = c2.shape(), h = [];
                  for (let e3 = 0; e3 < f.dimLength(); e3++)
                    h.push(s.LongUtil.longToNumber(f.dim(e3).value().dimValue()));
                  t3.type = { shape: { dims: h }, tensorType: d };
                  const g = this._allData.push(t3) - 1;
                  i2.set(a2, g), p2.push(a2);
                }
            }
            for (let t3 = 0; t3 < e2.initializersLength(); t3++) {
              const n3 = e2.initializers(t3);
              let r3 = i2.get(n3.name());
              if (void 0 === r3) {
                const e3 = new l(), t4 = s.ProtoUtil.tensorDimsFromORTFormat(n3), o3 = s.ProtoUtil.tensorDataTypeFromProto(n3.dataType());
                e3.type = { shape: { dims: t4 }, tensorType: o3 }, r3 = this._allData.push(e3) - 1, i2.set(n3.name(), r3);
              }
              this._allData[r3]._from = -1, this._allData[r3].tensor = a.Tensor.fromOrtTensor(n3);
            }
            for (let e3 = 0; e3 < this._allData.length; e3++)
              this._allData[e3].tensor || (this._allInputIndices.push(e3), this._allInputNames.push(p2[e3]));
            for (let t3 = 0; t3 < e2.outputsLength(); t3++) {
              const n3 = e2.outputs(t3);
              if (i2.has(n3))
                throw new Error(`duplicated output name: ${n3}`);
              const r3 = this._allData.push(new l()) - 1;
              i2.set(n3, r3), this._allOutputIndices.push(r3), this._allOutputNames.push(n3);
            }
            if (!e2.nodes)
              throw new Error("missing information in graph: node");
            for (let t3 = 0; t3 < e2.nodesLength(); t3++) {
              const n3 = e2.nodes(t3);
              let r3 = n3.name();
              if (!r3)
                for (let e3 = 0; r3 = `unnamed_${n3.opType()}_${e3}`, o2.has(r3); e3++)
                  ;
              if (o2.has(r3))
                throw new Error(`duplicated node name: ${r3}`);
              const i3 = this._nodes.push(new c(n3, r3)) - 1;
              o2.set(r3, i3);
            }
            for (let t3 = 0; t3 < this._nodes.length; t3++) {
              const n3 = this._nodes[t3], r3 = e2.nodes(t3);
              if (null == r3)
                throw new Error(`No node exists at index ${t3}`);
              if (0 === (null == r3 ? void 0 : r3.outputsLength()))
                throw new Error(`missing output for node: ${r3.name}`);
              for (let e3 = 0; e3 < (null == r3 ? void 0 : r3.outputsLength()); e3++) {
                const o3 = null == r3 ? void 0 : r3.outputs(e3);
                let s2 = i2.get(o3);
                if (void 0 === s2 && (s2 = this._allData.push(new l()) - 1, i2.set(o3, s2)), n3.outputs.push(s2), void 0 !== this._allData[s2]._from)
                  throw new Error(`multiple nodes output to one data value: ${s2}`);
                if (this._allData[s2]._from = t3, "Constant" === r3.opType()) {
                  if (1 !== r3.attributesLength() || !r3.attributes(0).t())
                    throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                  if (1 !== r3.outputsLength())
                    throw new Error("missing output or incorrect number of outputs for this Constant operator");
                  n3.outputs.pop(), n3.executeNode = false, this._allData[s2]._from = -1, this._allData[s2].tensor = a.Tensor.fromOrtTensor(r3.attributes(0).t());
                }
              }
            }
            for (let t3 = 0; t3 < this._nodes.length; t3++) {
              const n3 = this._nodes[t3], r3 = e2.nodes(t3);
              if (0 === r3.inputsLength())
                throw new Error(`missing input for node: ${r3.name}`);
              for (let e3 = 0; e3 < r3.inputsLength(); e3++) {
                const o3 = r3.inputs(e3), a2 = i2.get(o3);
                if (void 0 === a2)
                  throw new Error(`unrecognized input '${o3}' for node: ${r3.name()}`);
                n3.inputs.push(a2), this._allData[a2]._to.push(t3);
              }
            }
          }
          checkIsAcyclic() {
            const e2 = /* @__PURE__ */ new Set();
            this._allInputIndices.forEach((t3) => {
              this._allData[t3]._to.forEach((t4) => {
                e2.add(t4);
              });
            });
            const t2 = Array.from(e2), n2 = new Array(this._nodes.length).fill("white");
            for (; t2.length > 0; ) {
              const e3 = t2.pop();
              "gray" === n2[e3] ? n2[e3] = "black" : (t2.push(e3), n2[e3] = "gray", this._nodes[e3].outputs.forEach((r2) => {
                const i2 = this._allData[r2];
                if (void 0 !== i2.tensor)
                  throw new Error("node outputs should not be initialized");
                if (i2._from !== e3)
                  throw new Error("from property of the Value object doesn't match index of Node being processed");
                i2._to.forEach((e4) => {
                  if ("gray" === n2[e4])
                    throw new Error("model graph is cyclic");
                  "white" === n2[e4] && t2.push(e4);
                });
              }));
            }
          }
          transformGraph(e2) {
            this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e2 && e2.transformGraph(this), this.finalizeGraph();
          }
          finalizeGraph() {
            let e2 = 0;
            const t2 = new Array(this._nodes.length, 0);
            let n2 = 0;
            for (let e3 = 0; e3 < this._nodes.length; e3++)
              t2[e3] = n2, this._nodes[e3].executeNode ? (n2 !== e3 && (this._nodes[n2] = this._nodes[e3]), n2++) : this._nodes[e3].outputs.forEach((e4) => {
                this._allData[e4]._from = -2;
              });
            this._nodes.splice(n2, this._nodes.length - n2);
            for (let e3 = 0; e3 < this._allData.length; e3++) {
              const n3 = this._allData[e3];
              void 0 !== n3._from && -1 !== n3._from && -2 !== n3._from && (n3._from = t2[n3._from]);
              for (let e4 = 0; e4 < n3._to.length; e4++) {
                if (!(n3._to[e4] >= 0))
                  throw new Error("Trying to update a removed node");
                n3._to[e4] = t2[n3._to[e4]];
              }
            }
            e2 = 0;
            for (let t3 = 0; t3 < this._allData.length; t3++)
              if (-2 !== this._allData[t3].from || -1 !== this._allOutputIndices.indexOf(t3 + e2)) {
                if (e2 > 0) {
                  let n3 = -1;
                  void 0 !== this._allData[t3].from && -1 !== this._allData[t3].from ? (n3 = this._nodes[this._allData[t3].from].outputs.indexOf(t3 + e2), -1 !== n3 && (this._nodes[this._allData[t3].from].outputs[n3] = t3)) : (n3 = this._allInputIndices.indexOf(t3 + e2), -1 !== n3 && (this._allInputIndices[n3] = t3)), this._allData[t3].to.forEach((r2) => {
                    n3 = this._nodes[r2].inputs.indexOf(t3 + e2), -1 !== n3 && (this._nodes[r2].inputs[n3] = t3);
                  }), 0 === this._allData[t3].to.length && (n3 = this._allOutputIndices.indexOf(t3 + e2), -1 !== n3 && (this._allOutputIndices[n3] = t3));
                }
              } else
                e2++, this._allData.splice(t3, 1), t3--;
          }
          deleteNode(e2) {
            const t2 = this._nodes[e2];
            if (t2.outputs.length > 1) {
              for (let e3 = 1; e3 < t2.outputs.length; e3++)
                if (this._allData[t2.outputs[e3]].to.length > 0)
                  throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
            }
            t2.executeNode = false;
            const n2 = t2.inputs[0], r2 = t2.outputs[0], i2 = this._allData[r2].to;
            for (let n3 = 0; n3 < t2.inputs.length; n3++) {
              const r3 = this._allData[t2.inputs[n3]].to.indexOf(e2);
              if (-1 === r3)
                throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
              this._allData[t2.inputs[n3]].to.splice(r3, 1);
            }
            this._allData[r2]._to = [];
            const o2 = this._allOutputIndices.indexOf(r2);
            if (-1 !== o2 && (this._allOutputIndices[o2] = n2), i2 && i2.length > 0)
              for (const e3 of i2) {
                const t3 = this._nodes[e3].inputs.indexOf(r2);
                if (-1 === t3)
                  throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                this._nodes[e3].inputs[t3] = n2, this._allData[n2].to.push(e3);
              }
          }
          removeAllDropoutNodes() {
            let e2 = 0;
            for (const t2 of this._nodes) {
              if ("Dropout" === t2.opType) {
                if (1 !== t2.inputs.length)
                  throw new Error("Dropout nodes should only contain one input. ");
                if (1 !== t2.outputs.length && 2 !== t2.outputs.length)
                  throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                if (2 === t2.outputs.length && 0 !== this._allData[t2.outputs[1]]._to.length)
                  throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                this.deleteNode(e2);
              }
              e2++;
            }
          }
          removeAllIdentityNodes() {
            let e2 = 0;
            for (const t2 of this._nodes)
              "Identity" === t2.opType && this.deleteNode(e2), e2++;
          }
          isActivation(e2) {
            switch (e2.opType) {
              case "Relu":
              case "Sigmoid":
              case "Clip":
                return true;
              default:
                return false;
            }
          }
          fuseConvActivationNodes() {
            for (const e2 of this._nodes)
              if ("Conv" === e2.opType) {
                const t2 = this._allData[e2.outputs[0]]._to;
                if (1 === t2.length && this.isActivation(this._nodes[t2[0]])) {
                  const n2 = this._nodes[t2[0]];
                  if ("Clip" === n2.opType)
                    if (1 === n2.inputs.length)
                      try {
                        e2.attributes.set("activation_params", "floats", [n2.attributes.getFloat("min"), n2.attributes.getFloat("max")]);
                      } catch (t3) {
                        e2.attributes.set("activation_params", "floats", [s.MIN_CLIP, s.MAX_CLIP]);
                      }
                    else {
                      if (!(n2.inputs.length >= 3 && void 0 !== this._allData[n2.inputs[1]].tensor && void 0 !== this._allData[n2.inputs[2]].tensor))
                        continue;
                      e2.attributes.set("activation_params", "floats", [this._allData[n2.inputs[1]].tensor.floatData[0], this._allData[n2.inputs[2]].tensor.floatData[0]]);
                    }
                  e2.attributes.set("activation", "string", n2.opType), this.deleteNode(t2[0]);
                }
              }
          }
        }
      }, 1315: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.now = t.Profiler = t.Logger = void 0;
        const n = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r = { none: new class {
          log(e2, t2, n2) {
          }
        }(), console: new class {
          log(e2, t2, n2) {
            console.log(`${this.color(e2)} ${n2 ? "\x1B[35m" + n2 + "\x1B[0m " : ""}${t2}`);
          }
          color(e2) {
            switch (e2) {
              case "verbose":
                return "\x1B[34;40mv\x1B[0m";
              case "info":
                return "\x1B[32mi\x1B[0m";
              case "warning":
                return "\x1B[30;43mw\x1B[0m";
              case "error":
                return "\x1B[31;40me\x1B[0m";
              case "fatal":
                return "\x1B[101mf\x1B[0m";
              default:
                throw new Error(`unsupported severity: ${e2}`);
            }
          }
        }() }, i = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
        let o = { "": i };
        function a(e2, t2, n2, r2) {
          if (void 0 === t2)
            return i2 = e2, { verbose: a.verbose.bind(null, i2), info: a.info.bind(null, i2), warning: a.warning.bind(null, i2), error: a.error.bind(null, i2), fatal: a.fatal.bind(null, i2) };
          if (void 0 === n2)
            s(e2, t2);
          else if ("number" == typeof n2 && void 0 === r2)
            s(e2, t2);
          else if ("string" == typeof n2 && void 0 === r2)
            s(e2, n2, 0, t2);
          else {
            if ("string" != typeof n2 || "number" != typeof r2)
              throw new TypeError("input is valid");
            s(e2, n2, 0, t2);
          }
          var i2;
        }
        function s(e2, t2, i2, a2) {
          const s2 = o[a2 || ""] || o[""];
          n[e2] < n[s2.minimalSeverity] || (s2.logDateTime && (t2 = `${(/* @__PURE__ */ new Date()).toISOString()}|${t2}`), s2.logSourceLocation, r[s2.provider].log(e2, t2, a2));
        }
        !function(e2) {
          function t2(e3) {
            o = {}, n2("", e3 || {});
          }
          function n2(e3, n3) {
            if ("*" === e3)
              t2(n3);
            else {
              const t3 = o[e3] || i;
              o[e3] = { provider: n3.provider || t3.provider, minimalSeverity: n3.minimalSeverity || t3.minimalSeverity, logDateTime: void 0 === n3.logDateTime ? t3.logDateTime : n3.logDateTime, logSourceLocation: void 0 === n3.logSourceLocation ? t3.logSourceLocation : n3.logSourceLocation };
            }
          }
          e2.verbose = function(t3, n3) {
            e2("verbose", t3, n3);
          }, e2.info = function(t3, n3) {
            e2("info", t3, n3);
          }, e2.warning = function(t3, n3) {
            e2("warning", t3, n3);
          }, e2.error = function(t3, n3) {
            e2("error", t3, n3);
          }, e2.fatal = function(t3, n3) {
            e2("fatal", t3, n3);
          }, e2.reset = t2, e2.set = n2, e2.setWithEnv = function(e3) {
            const t3 = {};
            e3.logLevel && (t3.minimalSeverity = e3.logLevel), n2("", t3);
          };
        }(a || (a = {})), t.Logger = a;
        class u {
          constructor(e2, t2, n2, r2, i2, o2) {
            this.category = e2, this.name = t2, this.startTime = n2, this.endCallback = r2, this.timer = i2, this.ctx = o2;
          }
          async end() {
            return this.endCallback(this);
          }
          async checkTimer() {
            if (void 0 === this.ctx || void 0 === this.timer)
              throw new Error("No webgl timer found");
            return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
          }
        }
        class l {
          constructor(e2, t2, n2, r2) {
            this.category = e2, this.name = t2, this.startTime = n2, this.endTime = r2;
          }
        }
        t.Profiler = class {
          static create(e2) {
            return void 0 === e2 ? new this() : new this(e2.maxNumberEvents, e2.flushBatchSize, e2.flushIntervalInMilliseconds);
          }
          constructor(e2, t2, n2) {
            this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === e2 ? 1e4 : e2, this._flushBatchSize = void 0 === t2 ? 10 : t2, this._flushIntervalInMilliseconds = void 0 === n2 ? 5e3 : n2;
          }
          start() {
            this._started = true, this._timingEvents = [], this._flushTime = (0, t.now)(), this._flushPointer = 0;
          }
          stop() {
            for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++)
              this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
          event(e2, t2, n2, r2) {
            const i2 = this._started ? this.begin(e2, t2, r2) : void 0;
            let o2 = false;
            const a2 = n2();
            if (a2 && "function" == typeof a2.then)
              return o2 = true, new Promise((e3, t3) => {
                a2.then(async (t4) => {
                  i2 && await i2.end(), e3(t4);
                }, async (e4) => {
                  i2 && await i2.end(), t3(e4);
                });
              });
            if (!o2 && i2) {
              const e3 = i2.end();
              if (e3 && "function" == typeof e3.then)
                return new Promise((t3, n3) => {
                  e3.then(() => {
                    t3(a2);
                  }, (e4) => {
                    n3(e4);
                  });
                });
            }
            return a2;
          }
          begin(e2, n2, r2) {
            if (!this._started)
              throw new Error("profiler is not started yet");
            if (void 0 === r2) {
              const r3 = (0, t.now)();
              return this.flush(r3), new u(e2, n2, r3, (e3) => this.endSync(e3));
            }
            {
              const t2 = r2.beginTimer();
              return new u(e2, n2, 0, async (e3) => this.end(e3), t2, r2);
            }
          }
          async end(e2) {
            const t2 = await e2.checkTimer();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e2.category, e2.name, e2.startTime, t2)), this.flush(t2));
          }
          endSync(e2) {
            const n2 = (0, t.now)();
            this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l(e2.category, e2.name, e2.startTime, n2)), this.flush(n2));
          }
          logOneEvent(e2) {
            t.Logger.verbose(`Profiler.${e2.category}`, `${(e2.endTime - e2.startTime).toFixed(2)}ms on event '${e2.name}' at ${e2.endTime.toFixed(2)}`);
          }
          flush(e2) {
            if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e2 - this._flushTime >= this._flushIntervalInMilliseconds) {
              for (const e3 = this._flushPointer; this._flushPointer < e3 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)
                this.logOneEvent(this._timingEvents[this._flushPointer]);
              this._flushTime = (0, t.now)();
            }
          }
          get started() {
            return this._started;
          }
        }, t.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
      }, 1745: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Model = void 0;
        const r = n(5686), i = n(4662), o = n(5127), a = n(2446), s = n(7273);
        var u = o.onnxruntime.experimental.fbs;
        t.Model = class {
          constructor() {
          }
          load(e2, t2, n2) {
            if (!n2)
              try {
                return void this.loadFromOnnxFormat(e2, t2);
              } catch (e3) {
                if (void 0 !== n2)
                  throw e3;
              }
            this.loadFromOrtFormat(e2, t2);
          }
          loadFromOnnxFormat(e2, t2) {
            const n2 = a.onnx.ModelProto.decode(e2);
            if (s.LongUtil.longToNumber(n2.irVersion) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = n2.opsetImport.map((e3) => ({ domain: e3.domain, version: s.LongUtil.longToNumber(e3.version) })), this._graph = i.Graph.from(n2.graph, t2);
          }
          loadFromOrtFormat(e2, t2) {
            const n2 = new r.flatbuffers.ByteBuffer(e2), o2 = u.InferenceSession.getRootAsInferenceSession(n2).model();
            if (s.LongUtil.longToNumber(o2.irVersion()) < 3)
              throw new Error("only support ONNX model with IR_VERSION>=3");
            this._opsets = [];
            for (let e3 = 0; e3 < o2.opsetImportLength(); e3++) {
              const t3 = o2.opsetImport(e3);
              this._opsets.push({ domain: null == t3 ? void 0 : t3.domain(), version: s.LongUtil.longToNumber(t3.version()) });
            }
            this._graph = i.Graph.from(o2.graph(), t2);
          }
          get graph() {
            return this._graph;
          }
          get opsets() {
            return this._opsets;
          }
        };
      }, 6145: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FLOAT_TYPES = t.INT_TYPES = t.NUMBER_TYPES = void 0, t.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], t.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], t.FLOAT_TYPES = ["float32", "float64"];
      }, 5881: (e, t) => {
        "use strict";
        function n(e2, t2) {
          if (t2.endsWith("+")) {
            const n2 = Number.parseInt(t2.substring(0, t2.length - 1), 10);
            return !isNaN(n2) && n2 <= e2;
          }
          if (2 === t2.split("-").length) {
            const n2 = t2.split("-"), r = Number.parseInt(n2[0], 10), i = Number.parseInt(n2[1], 10);
            return !isNaN(r) && !isNaN(i) && r <= e2 && e2 <= i;
          }
          return Number.parseInt(t2, 10) === e2;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveOperator = void 0, t.resolveOperator = function(e2, t2, r) {
          for (const i of r) {
            const r2 = i[0], o = i[1], a = i[2], s = i[3], u = i[4];
            if (e2.opType === r2) {
              for (const e3 of t2)
                if ((e3.domain === o || "ai.onnx" === e3.domain && "" === o) && n(e3.version, a))
                  return { opImpl: s, opInit: u };
            }
          }
          throw new TypeError(`cannot resolve operator '${e2.opType}' with opsets: ${t2.map((e3) => `${e3.domain || "ai.onnx"} v${e3.version}`).join(", ")}`);
        };
      }, 5127: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.onnxruntime = void 0;
        const r = n(5686);
        var i, o;
        i = t.onnxruntime || (t.onnxruntime = {}), function(e2) {
          let t2;
          !function(e3) {
            e3[e3.UNDEFINED = 0] = "UNDEFINED", e3[e3.FLOAT = 1] = "FLOAT", e3[e3.INT = 2] = "INT", e3[e3.STRING = 3] = "STRING", e3[e3.TENSOR = 4] = "TENSOR", e3[e3.GRAPH = 5] = "GRAPH", e3[e3.FLOATS = 6] = "FLOATS", e3[e3.INTS = 7] = "INTS", e3[e3.STRINGS = 8] = "STRINGS", e3[e3.TENSORS = 9] = "TENSORS", e3[e3.GRAPHS = 10] = "GRAPHS", e3[e3.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", e3[e3.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
          }(t2 = e2.AttributeType || (e2.AttributeType = {}));
        }((o = i.experimental || (i.experimental = {})).fbs || (o.fbs = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.UNKNOWN = 0] = "UNKNOWN", e5[e5.VALUE = 1] = "VALUE", e5[e5.PARAM = 2] = "PARAM";
              }(t2 = e4.DimensionValueType || (e4.DimensionValueType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.UNDEFINED = 0] = "UNDEFINED", e5[e5.FLOAT = 1] = "FLOAT", e5[e5.UINT8 = 2] = "UINT8", e5[e5.INT8 = 3] = "INT8", e5[e5.UINT16 = 4] = "UINT16", e5[e5.INT16 = 5] = "INT16", e5[e5.INT32 = 6] = "INT32", e5[e5.INT64 = 7] = "INT64", e5[e5.STRING = 8] = "STRING", e5[e5.BOOL = 9] = "BOOL", e5[e5.FLOAT16 = 10] = "FLOAT16", e5[e5.DOUBLE = 11] = "DOUBLE", e5[e5.UINT32 = 12] = "UINT32", e5[e5.UINT64 = 13] = "UINT64", e5[e5.COMPLEX64 = 14] = "COMPLEX64", e5[e5.COMPLEX128 = 15] = "COMPLEX128", e5[e5.BFLOAT16 = 16] = "BFLOAT16", e5[e5.FLOAT8E4M3FN = 17] = "FLOAT8E4M3FN", e5[e5.FLOAT8E4M3FNUZ = 18] = "FLOAT8E4M3FNUZ", e5[e5.FLOAT8E5M2 = 19] = "FLOAT8E5M2", e5[e5.FLOAT8E5M2FNUZ = 20] = "FLOAT8E5M2FNUZ";
              }(t2 = e4.TensorDataType || (e4.TensorDataType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.Primitive = 0] = "Primitive", e5[e5.Fused = 1] = "Fused";
              }(t2 = e4.NodeType || (e4.NodeType = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              let t2;
              !function(e5) {
                e5[e5.NONE = 0] = "NONE", e5[e5.tensor_type = 1] = "tensor_type", e5[e5.sequence_type = 2] = "sequence_type", e5[e5.map_type = 3] = "map_type";
              }(t2 = e4.TypeInfoValue || (e4.TypeInfoValue = {}));
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsShape(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsShape(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                dim(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 4);
                  return r2 ? (n3 || new e2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                dimLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startShape(e3) {
                  e3.startObject(1);
                }
                static addDim(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static createDimVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startDimVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endShape(e3) {
                  return e3.endObject();
                }
                static createShape(e3, t4) {
                  return n2.startShape(e3), n2.addDim(e3, t4), n2.endShape(e3);
                }
              }
              t3.Shape = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsDimension(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsDimension(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                value(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                denotation(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startDimension(e3) {
                  e3.startObject(2);
                }
                static addValue(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDenotation(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endDimension(e3) {
                  return e3.endObject();
                }
                static createDimension(e3, t4, r2) {
                  return n2.startDimension(e3), n2.addValue(e3, t4), n2.addDenotation(e3, r2), n2.endDimension(e3);
                }
              }
              t3.Dimension = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsDimensionValue(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsDimensionValue(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                dimType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt8(this.bb_pos + t4) : e2.experimental.fbs.DimensionValueType.UNKNOWN;
                }
                dimValue() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                dimParam(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startDimensionValue(e3) {
                  e3.startObject(3);
                }
                static addDimType(t4, n3) {
                  t4.addFieldInt8(0, n3, e2.experimental.fbs.DimensionValueType.UNKNOWN);
                }
                static addDimValue(e3, t4) {
                  e3.addFieldInt64(1, t4, e3.createLong(0, 0));
                }
                static addDimParam(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endDimensionValue(e3) {
                  return e3.endObject();
                }
                static createDimensionValue(e3, t4, r2, i2) {
                  return n2.startDimensionValue(e3), n2.addDimType(e3, t4), n2.addDimValue(e3, r2), n2.addDimParam(e3, i2), n2.endDimensionValue(e3);
                }
              }
              t3.DimensionValue = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTensorTypeAndShape(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTensorTypeAndShape(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                elemType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                shape(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startTensorTypeAndShape(e3) {
                  e3.startObject(2);
                }
                static addElemType(t4, n3) {
                  t4.addFieldInt32(0, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addShape(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endTensorTypeAndShape(e3) {
                  return e3.endObject();
                }
                static createTensorTypeAndShape(e3, t4, r2) {
                  return n2.startTensorTypeAndShape(e3), n2.addElemType(e3, t4), n2.addShape(e3, r2), n2.endTensorTypeAndShape(e3);
                }
              }
              t3.TensorTypeAndShape = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsMapType(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsMapType(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                keyType() {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                valueType(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startMapType(e3) {
                  e3.startObject(2);
                }
                static addKeyType(t4, n3) {
                  t4.addFieldInt32(0, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addValueType(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endMapType(e3) {
                  return e3.endObject();
                }
                static createMapType(e3, t4, r2) {
                  return n2.startMapType(e3), n2.addKeyType(e3, t4), n2.addValueType(e3, r2), n2.endMapType(e3);
                }
              }
              t3.MapType = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSequenceType(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSequenceType(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                elemType(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startSequenceType(e3) {
                  e3.startObject(1);
                }
                static addElemType(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static endSequenceType(e3) {
                  return e3.endObject();
                }
                static createSequenceType(e3, t4) {
                  return n2.startSequenceType(e3), n2.addElemType(e3, t4), n2.endSequenceType(e3);
                }
              }
              t3.SequenceType = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            (e3.fbs || (e3.fbs = {})).EdgeEnd = class {
              constructor() {
                this.bb = null, this.bb_pos = 0;
              }
              __init(e4, t2) {
                return this.bb_pos = e4, this.bb = t2, this;
              }
              nodeIndex() {
                return this.bb.readUint32(this.bb_pos);
              }
              srcArgIndex() {
                return this.bb.readInt32(this.bb_pos + 4);
              }
              dstArgIndex() {
                return this.bb.readInt32(this.bb_pos + 8);
              }
              static createEdgeEnd(e4, t2, n2, r2) {
                return e4.prep(4, 12), e4.writeInt32(r2), e4.writeInt32(n2), e4.writeInt32(t2), e4.offset();
              }
            };
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsNodeEdge(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsNodeEdge(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                nodeIndex() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                inputEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                }
                inputEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 8);
                  return r2 ? (n3 || new e2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * t4, this.bb) : null;
                }
                outputEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startNodeEdge(e3) {
                  e3.startObject(3);
                }
                static addNodeIndex(e3, t4) {
                  e3.addFieldInt32(0, t4, 0);
                }
                static addInputEdges(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static startInputEdgesVector(e3, t4) {
                  e3.startVector(12, t4, 4);
                }
                static addOutputEdges(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static startOutputEdgesVector(e3, t4) {
                  e3.startVector(12, t4, 4);
                }
                static endNodeEdge(e3) {
                  return e3.endObject();
                }
                static createNodeEdge(e3, t4, r2, i2) {
                  return n2.startNodeEdge(e3), n2.addNodeIndex(e3, t4), n2.addInputEdges(e3, r2), n2.addOutputEdges(e3, i2), n2.endNodeEdge(e3);
                }
              }
              t3.NodeEdge = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsNode(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsNode(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                domain(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                sinceVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readInt32(this.bb_pos + e3) : 0;
                }
                index() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                opType(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 14);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type() {
                  let t4 = this.bb.__offset(this.bb_pos, 16);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.NodeType.Primitive;
                }
                executionProviderType(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 18);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                inputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 20);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                inputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 22);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                outputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 22);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                attributes(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 24);
                  return r2 ? (n3 || new e2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                attributesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 24);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputArgCounts(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 26);
                  return t4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + t4) + 4 * e3) : 0;
                }
                inputArgCountsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputArgCountsArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                implicitInputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 28);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                implicitInputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 28);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startNode(e3) {
                  e3.startObject(13);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDomain(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static addSinceVersion(e3, t4) {
                  e3.addFieldInt32(3, t4, 0);
                }
                static addIndex(e3, t4) {
                  e3.addFieldInt32(4, t4, 0);
                }
                static addOpType(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static addType(t4, n3) {
                  t4.addFieldInt32(6, n3, e2.experimental.fbs.NodeType.Primitive);
                }
                static addExecutionProviderType(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addInputs(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static createInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addOutputs(e3, t4) {
                  e3.addFieldOffset(9, t4, 0);
                }
                static createOutputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOutputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addAttributes(e3, t4) {
                  e3.addFieldOffset(10, t4, 0);
                }
                static createAttributesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startAttributesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInputArgCounts(e3, t4) {
                  e3.addFieldOffset(11, t4, 0);
                }
                static createInputArgCountsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt32(t4[n3]);
                  return e3.endVector();
                }
                static startInputArgCountsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addImplicitInputs(e3, t4) {
                  e3.addFieldOffset(12, t4, 0);
                }
                static createImplicitInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startImplicitInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endNode(e3) {
                  return e3.endObject();
                }
                static createNode(e3, t4, r2, i2, o2, a, s, u, l, c, p, d, f, h) {
                  return n2.startNode(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addDomain(e3, i2), n2.addSinceVersion(e3, o2), n2.addIndex(e3, a), n2.addOpType(e3, s), n2.addType(e3, u), n2.addExecutionProviderType(e3, l), n2.addInputs(e3, c), n2.addOutputs(e3, p), n2.addAttributes(e3, d), n2.addInputArgCounts(e3, f), n2.addImplicitInputs(e3, h), n2.endNode(e3);
                }
              }
              t3.Node = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsValueInfo(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsValueInfo(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 8);
                  return n3 ? (t4 || new e2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startValueInfo(e3) {
                  e3.startObject(3);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addType(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endValueInfo(e3) {
                  return e3.endObject();
                }
                static createValueInfo(e3, t4, r2, i2) {
                  return n2.startValueInfo(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addType(e3, i2), n2.endValueInfo(e3);
                }
              }
              t3.ValueInfo = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTypeInfo(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTypeInfo(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                denotation(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                valueType() {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.readUint8(this.bb_pos + t4) : e2.experimental.fbs.TypeInfoValue.NONE;
                }
                value(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__union(e3, this.bb_pos + t4) : null;
                }
                static startTypeInfo(e3) {
                  e3.startObject(3);
                }
                static addDenotation(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addValueType(t4, n3) {
                  t4.addFieldInt8(1, n3, e2.experimental.fbs.TypeInfoValue.NONE);
                }
                static addValue(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endTypeInfo(e3) {
                  return e3.endObject();
                }
                static createTypeInfo(e3, t4, r2, i2) {
                  return n2.startTypeInfo(e3), n2.addDenotation(e3, t4), n2.addValueType(e3, r2), n2.addValue(e3, i2), n2.endTypeInfo(e3);
                }
              }
              t3.TypeInfo = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              class t2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e5, t3) {
                  return this.bb_pos = e5, this.bb = t3, this;
                }
                static getRootAsOperatorSetId(e5, n2) {
                  return (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                static getSizePrefixedRootAsOperatorSetId(e5, n2) {
                  return e5.setPosition(e5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                domain(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 4);
                  return t3 ? this.bb.__string(this.bb_pos + t3, e5) : null;
                }
                version() {
                  let e5 = this.bb.__offset(this.bb_pos, 6);
                  return e5 ? this.bb.readInt64(this.bb_pos + e5) : this.bb.createLong(0, 0);
                }
                static startOperatorSetId(e5) {
                  e5.startObject(2);
                }
                static addDomain(e5, t3) {
                  e5.addFieldOffset(0, t3, 0);
                }
                static addVersion(e5, t3) {
                  e5.addFieldInt64(1, t3, e5.createLong(0, 0));
                }
                static endOperatorSetId(e5) {
                  return e5.endObject();
                }
                static createOperatorSetId(e5, n2, r2) {
                  return t2.startOperatorSetId(e5), t2.addDomain(e5, n2), t2.addVersion(e5, r2), t2.endOperatorSetId(e5);
                }
              }
              e4.OperatorSetId = t2;
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsTensor(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsTensor(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                dims(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                dataType() {
                  let t4 = this.bb.__offset(this.bb_pos, 10);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.TensorDataType.UNDEFINED;
                }
                rawData(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 12);
                  return t4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t4) + e3) : 0;
                }
                rawDataLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                rawDataArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                stringData(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 14);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                stringDataLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startTensor(e3) {
                  e3.startObject(6);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDims(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createDimsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startDimsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static addDataType(t4, n3) {
                  t4.addFieldInt32(3, n3, e2.experimental.fbs.TensorDataType.UNDEFINED);
                }
                static addRawData(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static createRawDataVector(e3, t4) {
                  e3.startVector(1, t4.length, 1);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt8(t4[n3]);
                  return e3.endVector();
                }
                static startRawDataVector(e3, t4) {
                  e3.startVector(1, t4, 1);
                }
                static addStringData(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static createStringDataVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startStringDataVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endTensor(e3) {
                  return e3.endObject();
                }
                static createTensor(e3, t4, r2, i2, o2, a, s) {
                  return n2.startTensor(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addDims(e3, i2), n2.addDataType(e3, o2), n2.addRawData(e3, a), n2.addStringData(e3, s), n2.endTensor(e3);
                }
              }
              t3.Tensor = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSparseTensor(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSparseTensor(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                values(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                indices(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                dims(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                dimsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startSparseTensor(e3) {
                  e3.startObject(3);
                }
                static addValues(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addIndices(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addDims(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createDimsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startDimsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static endSparseTensor(e3) {
                  return e3.endObject();
                }
                static createSparseTensor(e3, t4, r2, i2) {
                  return n2.startSparseTensor(e3), n2.addValues(e3, t4), n2.addIndices(e3, r2), n2.addDims(e3, i2), n2.endSparseTensor(e3);
                }
              }
              t3.SparseTensor = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsAttribute(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsAttribute(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                name(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 6);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                type() {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.readInt32(this.bb_pos + t4) : e2.experimental.fbs.AttributeType.UNDEFINED;
                }
                f() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readFloat32(this.bb_pos + e3) : 0;
                }
                i() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                s(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 14);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                t(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 16);
                  return n3 ? (t4 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                g(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 18);
                  return n3 ? (t4 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                floats(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 20);
                  return t4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + t4) + 4 * e3) : 0;
                }
                floatsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                floatsArray() {
                  let e3 = this.bb.__offset(this.bb_pos, 20);
                  return e3 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e3), this.bb.__vector_len(this.bb_pos + e3)) : null;
                }
                ints(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 22);
                  return t4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t4) + 8 * e3) : this.bb.createLong(0, 0);
                }
                intsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 22);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                strings(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 24);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                stringsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 24);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                tensors(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 26);
                  return r2 ? (n3 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                tensorsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 26);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                graphs(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 28);
                  return r2 ? (n3 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                graphsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 28);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startAttribute(e3) {
                  e3.startObject(13);
                }
                static addName(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addType(t4, n3) {
                  t4.addFieldInt32(2, n3, e2.experimental.fbs.AttributeType.UNDEFINED);
                }
                static addF(e3, t4) {
                  e3.addFieldFloat32(3, t4, 0);
                }
                static addI(e3, t4) {
                  e3.addFieldInt64(4, t4, e3.createLong(0, 0));
                }
                static addS(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static addT(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static addG(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addFloats(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static createFloatsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addFloat32(t4[n3]);
                  return e3.endVector();
                }
                static startFloatsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInts(e3, t4) {
                  e3.addFieldOffset(9, t4, 0);
                }
                static createIntsVector(e3, t4) {
                  e3.startVector(8, t4.length, 8);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addInt64(t4[n3]);
                  return e3.endVector();
                }
                static startIntsVector(e3, t4) {
                  e3.startVector(8, t4, 8);
                }
                static addStrings(e3, t4) {
                  e3.addFieldOffset(10, t4, 0);
                }
                static createStringsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startStringsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addTensors(e3, t4) {
                  e3.addFieldOffset(11, t4, 0);
                }
                static createTensorsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startTensorsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addGraphs(e3, t4) {
                  e3.addFieldOffset(12, t4, 0);
                }
                static createGraphsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startGraphsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endAttribute(e3) {
                  return e3.endObject();
                }
                static createAttribute(e3, t4, r2, i2, o2, a, s, u, l, c, p, d, f, h) {
                  return n2.startAttribute(e3), n2.addName(e3, t4), n2.addDocString(e3, r2), n2.addType(e3, i2), n2.addF(e3, o2), n2.addI(e3, a), n2.addS(e3, s), n2.addT(e3, u), n2.addG(e3, l), n2.addFloats(e3, c), n2.addInts(e3, p), n2.addStrings(e3, d), n2.addTensors(e3, f), n2.addGraphs(e3, h), n2.endAttribute(e3);
                }
              }
              t3.Attribute = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsGraph(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsGraph(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                initializers(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 4);
                  return r2 ? (n3 || new e2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                initializersLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                nodeArgs(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodeArgsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                nodes(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 8);
                  return r2 ? (n3 || new e2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 8);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                maxNodeIndex() {
                  let e3 = this.bb.__offset(this.bb_pos, 10);
                  return e3 ? this.bb.readUint32(this.bb_pos + e3) : 0;
                }
                nodeEdges(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 12);
                  return r2 ? (n3 || new e2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                nodeEdgesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 12);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                inputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 14);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                inputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                outputs(e3, t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 16);
                  return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * e3, t4) : null;
                }
                outputsLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 16);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                sparseInitializers(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 18);
                  return r2 ? (n3 || new e2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                sparseInitializersLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 18);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startGraph(e3) {
                  e3.startObject(8);
                }
                static addInitializers(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static createInitializersVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInitializersVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addNodeArgs(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createNodeArgsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodeArgsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addNodes(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static createNodesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addMaxNodeIndex(e3, t4) {
                  e3.addFieldInt32(3, t4, 0);
                }
                static addNodeEdges(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static createNodeEdgesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startNodeEdgesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addInputs(e3, t4) {
                  e3.addFieldOffset(5, t4, 0);
                }
                static createInputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startInputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addOutputs(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static createOutputsVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOutputsVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addSparseInitializers(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static createSparseInitializersVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startSparseInitializersVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endGraph(e3) {
                  return e3.endObject();
                }
                static createGraph(e3, t4, r2, i2, o2, a, s, u, l) {
                  return n2.startGraph(e3), n2.addInitializers(e3, t4), n2.addNodeArgs(e3, r2), n2.addNodes(e3, i2), n2.addMaxNodeIndex(e3, o2), n2.addNodeEdges(e3, a), n2.addInputs(e3, s), n2.addOutputs(e3, u), n2.addSparseInitializers(e3, l), n2.endGraph(e3);
                }
              }
              t3.Graph = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsModel(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsModel(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                irVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 4);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                opsetImport(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                opsetImportLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                producerName(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 8);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                producerVersion(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 10);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                domain(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 12);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                modelVersion() {
                  let e3 = this.bb.__offset(this.bb_pos, 14);
                  return e3 ? this.bb.readInt64(this.bb_pos + e3) : this.bb.createLong(0, 0);
                }
                docString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 16);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                graph(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 18);
                  return n3 ? (t4 || new e2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                graphDocString(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 20);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                static startModel(e3) {
                  e3.startObject(9);
                }
                static addIrVersion(e3, t4) {
                  e3.addFieldInt64(0, t4, e3.createLong(0, 0));
                }
                static addOpsetImport(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createOpsetImportVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startOpsetImportVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static addProducerName(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static addProducerVersion(e3, t4) {
                  e3.addFieldOffset(3, t4, 0);
                }
                static addDomain(e3, t4) {
                  e3.addFieldOffset(4, t4, 0);
                }
                static addModelVersion(e3, t4) {
                  e3.addFieldInt64(5, t4, e3.createLong(0, 0));
                }
                static addDocString(e3, t4) {
                  e3.addFieldOffset(6, t4, 0);
                }
                static addGraph(e3, t4) {
                  e3.addFieldOffset(7, t4, 0);
                }
                static addGraphDocString(e3, t4) {
                  e3.addFieldOffset(8, t4, 0);
                }
                static endModel(e3) {
                  return e3.endObject();
                }
                static createModel(e3, t4, r2, i2, o2, a, s, u, l, c) {
                  return n2.startModel(e3), n2.addIrVersion(e3, t4), n2.addOpsetImport(e3, r2), n2.addProducerName(e3, i2), n2.addProducerVersion(e3, o2), n2.addDomain(e3, a), n2.addModelVersion(e3, s), n2.addDocString(e3, u), n2.addGraph(e3, l), n2.addGraphDocString(e3, c), n2.endModel(e3);
                }
              }
              t3.Model = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(e3) {
            !function(e4) {
              class t2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e5, t3) {
                  return this.bb_pos = e5, this.bb = t3, this;
                }
                static getRootAsKernelCreateInfos(e5, n2) {
                  return (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                static getSizePrefixedRootAsKernelCreateInfos(e5, n2) {
                  return e5.setPosition(e5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new t2()).__init(e5.readInt32(e5.position()) + e5.position(), e5);
                }
                nodeIndices(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 4);
                  return t3 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t3) + 4 * e5) : 0;
                }
                nodeIndicesLength() {
                  let e5 = this.bb.__offset(this.bb_pos, 4);
                  return e5 ? this.bb.__vector_len(this.bb_pos + e5) : 0;
                }
                nodeIndicesArray() {
                  let e5 = this.bb.__offset(this.bb_pos, 4);
                  return e5 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e5), this.bb.__vector_len(this.bb_pos + e5)) : null;
                }
                kernelDefHashes(e5) {
                  let t3 = this.bb.__offset(this.bb_pos, 6);
                  return t3 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t3) + 8 * e5) : this.bb.createLong(0, 0);
                }
                kernelDefHashesLength() {
                  let e5 = this.bb.__offset(this.bb_pos, 6);
                  return e5 ? this.bb.__vector_len(this.bb_pos + e5) : 0;
                }
                static startKernelCreateInfos(e5) {
                  e5.startObject(2);
                }
                static addNodeIndices(e5, t3) {
                  e5.addFieldOffset(0, t3, 0);
                }
                static createNodeIndicesVector(e5, t3) {
                  e5.startVector(4, t3.length, 4);
                  for (let n2 = t3.length - 1; n2 >= 0; n2--)
                    e5.addInt32(t3[n2]);
                  return e5.endVector();
                }
                static startNodeIndicesVector(e5, t3) {
                  e5.startVector(4, t3, 4);
                }
                static addKernelDefHashes(e5, t3) {
                  e5.addFieldOffset(1, t3, 0);
                }
                static createKernelDefHashesVector(e5, t3) {
                  e5.startVector(8, t3.length, 8);
                  for (let n2 = t3.length - 1; n2 >= 0; n2--)
                    e5.addInt64(t3[n2]);
                  return e5.endVector();
                }
                static startKernelDefHashesVector(e5, t3) {
                  e5.startVector(8, t3, 8);
                }
                static endKernelCreateInfos(e5) {
                  return e5.endObject();
                }
                static createKernelCreateInfos(e5, n2, r2) {
                  return t2.startKernelCreateInfos(e5), t2.addNodeIndices(e5, n2), t2.addKernelDefHashes(e5, r2), t2.endKernelCreateInfos(e5);
                }
              }
              e4.KernelCreateInfos = t2;
            }(e3.fbs || (e3.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSubGraphSessionState(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSubGraphSessionState(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                graphId(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                sessionState(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startSubGraphSessionState(e3) {
                  e3.startObject(2);
                }
                static addGraphId(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addSessionState(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static endSubGraphSessionState(e3) {
                  let t4 = e3.endObject();
                  return e3.requiredField(t4, 4), t4;
                }
                static createSubGraphSessionState(e3, t4, r2) {
                  return n2.startSubGraphSessionState(e3), n2.addGraphId(e3, t4), n2.addSessionState(e3, r2), n2.endSubGraphSessionState(e3);
                }
              }
              t3.SubGraphSessionState = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsSessionState(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsSessionState(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                kernels(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 4);
                  return n3 ? (t4 || new e2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                subGraphSessionStates(t4, n3) {
                  let r2 = this.bb.__offset(this.bb_pos, 6);
                  return r2 ? (n3 || new e2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * t4), this.bb) : null;
                }
                subGraphSessionStatesLength() {
                  let e3 = this.bb.__offset(this.bb_pos, 6);
                  return e3 ? this.bb.__vector_len(this.bb_pos + e3) : 0;
                }
                static startSessionState(e3) {
                  e3.startObject(2);
                }
                static addKernels(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addSubGraphSessionStates(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static createSubGraphSessionStatesVector(e3, t4) {
                  e3.startVector(4, t4.length, 4);
                  for (let n3 = t4.length - 1; n3 >= 0; n3--)
                    e3.addOffset(t4[n3]);
                  return e3.endVector();
                }
                static startSubGraphSessionStatesVector(e3, t4) {
                  e3.startVector(4, t4, 4);
                }
                static endSessionState(e3) {
                  return e3.endObject();
                }
                static createSessionState(e3, t4, r2) {
                  return n2.startSessionState(e3), n2.addKernels(e3, t4), n2.addSubGraphSessionStates(e3, r2), n2.endSessionState(e3);
                }
              }
              t3.SessionState = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {})), function(e2) {
          !function(t2) {
            !function(t3) {
              class n2 {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(e3, t4) {
                  return this.bb_pos = e3, this.bb = t4, this;
                }
                static getRootAsInferenceSession(e3, t4) {
                  return (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static getSizePrefixedRootAsInferenceSession(e3, t4) {
                  return e3.setPosition(e3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (t4 || new n2()).__init(e3.readInt32(e3.position()) + e3.position(), e3);
                }
                static bufferHasIdentifier(e3) {
                  return e3.__has_identifier("ORTM");
                }
                ortVersion(e3) {
                  let t4 = this.bb.__offset(this.bb_pos, 4);
                  return t4 ? this.bb.__string(this.bb_pos + t4, e3) : null;
                }
                model(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 6);
                  return n3 ? (t4 || new e2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                sessionState(t4) {
                  let n3 = this.bb.__offset(this.bb_pos, 8);
                  return n3 ? (t4 || new e2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                }
                static startInferenceSession(e3) {
                  e3.startObject(3);
                }
                static addOrtVersion(e3, t4) {
                  e3.addFieldOffset(0, t4, 0);
                }
                static addModel(e3, t4) {
                  e3.addFieldOffset(1, t4, 0);
                }
                static addSessionState(e3, t4) {
                  e3.addFieldOffset(2, t4, 0);
                }
                static endInferenceSession(e3) {
                  return e3.endObject();
                }
                static finishInferenceSessionBuffer(e3, t4) {
                  e3.finish(t4, "ORTM");
                }
                static finishSizePrefixedInferenceSessionBuffer(e3, t4) {
                  e3.finish(t4, "ORTM", true);
                }
                static createInferenceSession(e3, t4, r2, i2) {
                  return n2.startInferenceSession(e3), n2.addOrtVersion(e3, t4), n2.addModel(e3, r2), n2.addSessionState(e3, i2), n2.endInferenceSession(e3);
                }
              }
              t3.InferenceSession = n2;
            }(t2.fbs || (t2.fbs = {}));
          }(e2.experimental || (e2.experimental = {}));
        }(t.onnxruntime || (t.onnxruntime = {}));
      }, 1723: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.OnnxjsSessionHandler = void 0;
        const r = n(2235), i = n(9240);
        t.OnnxjsSessionHandler = class {
          constructor(e2) {
            this.session = e2, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
          }
          async dispose() {
          }
          async run(e2, t2, n2) {
            const o = /* @__PURE__ */ new Map();
            for (const t3 in e2)
              if (Object.hasOwnProperty.call(e2, t3)) {
                const n3 = e2[t3];
                o.set(t3, new i.Tensor(n3.dims, n3.type, void 0, void 0, n3.data));
              }
            const a = await this.session.run(o), s = {};
            return a.forEach((e3, t3) => {
              s[t3] = new r.Tensor(e3.type, e3.data, e3.dims);
            }), s;
          }
          startProfiling() {
            this.session.startProfiling();
          }
          endProfiling() {
            this.session.endProfiling();
          }
        };
      }, 6027: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Session = void 0;
        const r = n(7067), i = n(1296), o = n(1975), a = n(6496), s = n(1315), u = n(1745);
        t.Session = class {
          constructor(e2 = {}) {
            this._initialized = false, this.backendHint = e2.backendHint, this.profiler = s.Profiler.create(e2.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
          }
          get inputNames() {
            return this._model.graph.getInputNames();
          }
          get outputNames() {
            return this._model.graph.getOutputNames();
          }
          startProfiling() {
            this.profiler.start();
          }
          endProfiling() {
            this.profiler.stop();
          }
          async loadModel(e2, t2, n2) {
            await this.profiler.event("session", "Session.loadModel", async () => {
              const a2 = await (0, o.resolveBackend)(this.backendHint);
              if (this.sessionHandler = a2.createSessionHandler(this.context), this._model = new u.Model(), "string" == typeof e2) {
                const t3 = e2.endsWith(".ort");
                if ("undefined" != typeof process && process.versions && process.versions.node) {
                  const n3 = await (0, i.promisify)(r.readFile)(e2);
                  this.initialize(n3, t3);
                } else {
                  const n3 = await fetch(e2), r2 = await n3.arrayBuffer();
                  this.initialize(new Uint8Array(r2), t3);
                }
              } else if (ArrayBuffer.isView(e2))
                this.initialize(e2);
              else {
                const r2 = new Uint8Array(e2, t2 || 0, n2 || e2.byteLength);
                this.initialize(r2);
              }
            });
          }
          initialize(e2, t2) {
            if (this._initialized)
              throw new Error("already initialized");
            this.profiler.event("session", "Session.initialize", () => {
              const n2 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
              this._model.load(e2, n2, t2), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);
            }), this._initialized = true;
          }
          async run(e2) {
            if (!this._initialized)
              throw new Error("session not initialized yet");
            return this.profiler.event("session", "Session.run", async () => {
              const t2 = this.normalizeAndValidateInputs(e2), n2 = await this._executionPlan.execute(this.sessionHandler, t2);
              return this.createOutput(n2);
            });
          }
          normalizeAndValidateInputs(e2) {
            const t2 = this._model.graph.getInputNames();
            if (Array.isArray(e2)) {
              if (e2.length !== t2.length)
                throw new Error(`incorrect input array length: expected ${t2.length} but got ${e2.length}`);
            } else {
              if (e2.size !== t2.length)
                throw new Error(`incorrect input map size: expected ${t2.length} but got ${e2.size}`);
              const n2 = new Array(e2.size);
              let r2 = 0;
              for (let i2 = 0; i2 < t2.length; ++i2) {
                const o2 = e2.get(t2[i2]);
                if (!o2)
                  throw new Error(`missing input tensor for: '${name}'`);
                n2[r2++] = o2;
              }
              e2 = n2;
            }
            if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length)
              this.validateInputTensorDims(this.context.graphInputDims, e2, false);
            else {
              const t3 = this._model.graph.getInputIndices(), n2 = this._model.graph.getValues(), r2 = new Array(t3.length);
              for (let i2 = 0; i2 < t3.length; ++i2) {
                const o2 = n2[t3[i2]];
                r2[i2] = o2.type.shape.dims, this.context.graphInputTypes.push(o2.type.tensorType), this.context.graphInputDims.push(e2[i2].dims);
              }
              this.validateInputTensorDims(r2, e2, true);
            }
            return this.validateInputTensorTypes(this.context.graphInputTypes, e2), e2;
          }
          validateInputTensorTypes(e2, t2) {
            for (let n2 = 0; n2 < t2.length; n2++) {
              const r2 = e2[n2], i2 = t2[n2].type;
              if (r2 !== i2)
                throw new Error(`input tensor[${n2}] check failed: expected type '${r2}' but got ${i2}`);
            }
          }
          validateInputTensorDims(e2, t2, n2) {
            for (let r2 = 0; r2 < t2.length; r2++) {
              const i2 = e2[r2], o2 = t2[r2].dims;
              if (!this.compareTensorDims(i2, o2, n2))
                throw new Error(`input tensor[${r2}] check failed: expected shape '[${i2.join(",")}]' but got [${o2.join(",")}]`);
            }
          }
          compareTensorDims(e2, t2, n2) {
            if (e2.length !== t2.length)
              return false;
            for (let r2 = 0; r2 < e2.length; ++r2)
              if (e2[r2] !== t2[r2] && (!n2 || 0 !== e2[r2]))
                return false;
            return true;
          }
          createOutput(e2) {
            const t2 = this._model.graph.getOutputNames();
            if (e2.length !== t2.length)
              throw new Error("expected number of outputs do not match number of generated outputs");
            const n2 = /* @__PURE__ */ new Map();
            for (let r2 = 0; r2 < t2.length; ++r2)
              n2.set(t2[r2], e2[r2]);
            return n2;
          }
          initializeOps(e2) {
            const t2 = e2.getNodes();
            this._ops = new Array(t2.length);
            for (let n2 = 0; n2 < t2.length; n2++)
              this._ops[n2] = this.sessionHandler.resolve(t2[n2], this._model.opsets, e2);
          }
        };
      }, 9240: function(e, t, n) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const i = n(3442), o = r(n(1583)), a = n(5127), s = n(2446), u = n(7273);
        var l = a.onnxruntime.experimental.fbs;
        class c {
          get data() {
            if (void 0 === this.cache) {
              const e2 = this.dataProvider(this.dataId);
              if (e2.length !== this.size)
                throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
              this.cache = e2;
            }
            return this.cache;
          }
          get stringData() {
            if ("string" !== this.type)
              throw new TypeError("data type is not string");
            return this.data;
          }
          get integerData() {
            switch (this.type) {
              case "uint8":
              case "int8":
              case "uint16":
              case "int16":
              case "int32":
              case "uint32":
              case "bool":
                return this.data;
              default:
                throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
            }
          }
          get floatData() {
            switch (this.type) {
              case "float32":
              case "float64":
                return this.data;
              default:
                throw new TypeError("data type is not float (float32, float64)");
            }
          }
          get numberData() {
            if ("string" !== this.type)
              return this.data;
            throw new TypeError("type cannot be non-number (string)");
          }
          get(e2) {
            return this.data[u.ShapeUtil.indicesToOffset(e2, this.strides)];
          }
          set(e2, t2) {
            this.data[u.ShapeUtil.indicesToOffset(e2, this.strides)] = t2;
          }
          async getData() {
            return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;
          }
          get strides() {
            return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;
          }
          constructor(e2, t2, n2, r2, o2, a2 = i.Guid.create()) {
            this.dims = e2, this.type = t2, this.dataProvider = n2, this.asyncDataProvider = r2, this.cache = o2, this.dataId = a2, this.size = u.ShapeUtil.validateDimsAndCalcSize(e2);
            const s2 = this.size, l2 = void 0 === n2 && void 0 === r2 && void 0 === o2;
            if (void 0 !== o2 && o2.length !== s2)
              throw new RangeError("Input dims doesn't match data length.");
            if ("string" === t2) {
              if (!(void 0 === o2 || Array.isArray(o2) && o2.every((e3) => "string" == typeof e3)))
                throw new TypeError("cache should be a string array");
              l2 && (this.cache = new Array(s2));
            } else {
              if (void 0 !== o2) {
                const e3 = d(t2);
                if (!(o2 instanceof e3))
                  throw new TypeError(`cache should be type ${e3.name}`);
              }
              if (l2) {
                const e3 = new ArrayBuffer(s2 * function(e4) {
                  switch (e4) {
                    case "bool":
                    case "int8":
                    case "uint8":
                      return 1;
                    case "int16":
                    case "uint16":
                      return 2;
                    case "int32":
                    case "uint32":
                    case "float32":
                      return 4;
                    case "float64":
                      return 8;
                    default:
                      throw new Error(`cannot calculate sizeof() on type ${e4}`);
                  }
                }(t2));
                this.cache = function(e4, t3) {
                  return new (d(t3))(e4);
                }(e3, t2);
              }
            }
          }
          static fromProto(e2) {
            if (!e2)
              throw new Error("cannot construct Value from an empty tensor");
            const t2 = u.ProtoUtil.tensorDataTypeFromProto(e2.dataType), n2 = u.ProtoUtil.tensorDimsFromProto(e2.dims), r2 = new c(n2, t2);
            if ("string" === t2)
              e2.stringData.forEach((e3, t3) => {
                r2.data[t3] = (0, u.decodeUtf8String)(e3);
              });
            else if (e2.rawData && "number" == typeof e2.rawData.byteLength && e2.rawData.byteLength > 0) {
              const t3 = r2.data, n3 = new DataView(e2.rawData.buffer, e2.rawData.byteOffset, e2.rawData.byteLength), i2 = p(e2.dataType), o2 = e2.rawData.byteLength / i2;
              if (e2.rawData.byteLength % i2 != 0)
                throw new Error("invalid buffer length");
              if (t3.length !== o2)
                throw new Error("buffer length mismatch");
              for (let r3 = 0; r3 < o2; r3++) {
                const o3 = h(n3, e2.dataType, r3 * i2);
                t3[r3] = o3;
              }
            } else {
              let t3;
              switch (e2.dataType) {
                case s.onnx.TensorProto.DataType.FLOAT:
                  t3 = e2.floatData;
                  break;
                case s.onnx.TensorProto.DataType.INT32:
                case s.onnx.TensorProto.DataType.INT16:
                case s.onnx.TensorProto.DataType.UINT16:
                case s.onnx.TensorProto.DataType.INT8:
                case s.onnx.TensorProto.DataType.UINT8:
                case s.onnx.TensorProto.DataType.BOOL:
                  t3 = e2.int32Data;
                  break;
                case s.onnx.TensorProto.DataType.INT64:
                  t3 = e2.int64Data;
                  break;
                case s.onnx.TensorProto.DataType.DOUBLE:
                  t3 = e2.doubleData;
                  break;
                case s.onnx.TensorProto.DataType.UINT32:
                case s.onnx.TensorProto.DataType.UINT64:
                  t3 = e2.uint64Data;
                  break;
                default:
                  throw new Error("unspecific error");
              }
              if (null == t3)
                throw new Error("failed to populate data from a tensorproto value");
              const n3 = r2.data;
              if (n3.length !== t3.length)
                throw new Error("array length mismatch");
              for (let r3 = 0; r3 < t3.length; r3++) {
                const i2 = t3[r3];
                o.default.isLong(i2) ? n3[r3] = f(i2, e2.dataType) : n3[r3] = i2;
              }
            }
            return r2;
          }
          static fromData(e2, t2, n2) {
            return new c(t2, n2, void 0, void 0, e2);
          }
          static fromOrtTensor(e2) {
            if (!e2)
              throw new Error("cannot construct Value from an empty tensor");
            const t2 = u.ProtoUtil.tensorDimsFromORTFormat(e2), n2 = u.ProtoUtil.tensorDataTypeFromProto(e2.dataType()), r2 = new c(t2, n2);
            if ("string" === n2)
              for (let t3 = 0; t3 < e2.stringDataLength(); t3++)
                r2.data[t3] = e2.stringData(t3);
            else if (e2.rawDataArray() && "number" == typeof e2.rawDataLength() && e2.rawDataLength() > 0) {
              const t3 = r2.data, n3 = new DataView(e2.rawDataArray().buffer, e2.rawDataArray().byteOffset, e2.rawDataLength()), i2 = p(e2.dataType()), o2 = e2.rawDataLength() / i2;
              if (e2.rawDataLength() % i2 != 0)
                throw new Error("invalid buffer length");
              if (t3.length !== o2)
                throw new Error("buffer length mismatch");
              for (let r3 = 0; r3 < o2; r3++) {
                const o3 = h(n3, e2.dataType(), r3 * i2);
                t3[r3] = o3;
              }
            }
            return r2;
          }
        }
        function p(e2) {
          switch (e2) {
            case s.onnx.TensorProto.DataType.UINT8:
            case s.onnx.TensorProto.DataType.INT8:
            case s.onnx.TensorProto.DataType.BOOL:
              return 1;
            case s.onnx.TensorProto.DataType.UINT16:
            case s.onnx.TensorProto.DataType.INT16:
              return 2;
            case s.onnx.TensorProto.DataType.FLOAT:
            case s.onnx.TensorProto.DataType.INT32:
            case s.onnx.TensorProto.DataType.UINT32:
              return 4;
            case s.onnx.TensorProto.DataType.INT64:
            case s.onnx.TensorProto.DataType.DOUBLE:
            case s.onnx.TensorProto.DataType.UINT64:
              return 8;
            default:
              throw new Error(`cannot calculate sizeof() on type ${s.onnx.TensorProto.DataType[e2]}`);
          }
        }
        function d(e2) {
          switch (e2) {
            case "bool":
            case "uint8":
              return Uint8Array;
            case "int8":
              return Int8Array;
            case "int16":
              return Int16Array;
            case "uint16":
              return Uint16Array;
            case "int32":
              return Int32Array;
            case "uint32":
              return Uint32Array;
            case "int64":
              return BigInt64Array;
            case "float32":
              return Float32Array;
            case "float64":
              return Float64Array;
            default:
              throw new Error("unspecified error");
          }
        }
        function f(e2, t2) {
          if (t2 === s.onnx.TensorProto.DataType.INT64 || t2 === l.TensorDataType.INT64) {
            if (e2.greaterThanOrEqual(2147483648) || e2.lessThan(-2147483648))
              throw new TypeError("int64 is not supported");
          } else {
            if (t2 !== s.onnx.TensorProto.DataType.UINT32 && t2 !== l.TensorDataType.UINT32 && t2 !== s.onnx.TensorProto.DataType.UINT64 && t2 !== l.TensorDataType.UINT64)
              throw new TypeError(`not a LONG type: ${s.onnx.TensorProto.DataType[t2]}`);
            if (e2.greaterThanOrEqual(4294967296) || e2.lessThan(0))
              throw new TypeError("uint64 is not supported");
          }
          return e2.toNumber();
        }
        function h(e2, t2, n2) {
          switch (t2) {
            case s.onnx.TensorProto.DataType.BOOL:
            case s.onnx.TensorProto.DataType.UINT8:
              return e2.getUint8(n2);
            case s.onnx.TensorProto.DataType.INT8:
              return e2.getInt8(n2);
            case s.onnx.TensorProto.DataType.UINT16:
              return e2.getUint16(n2, true);
            case s.onnx.TensorProto.DataType.INT16:
              return e2.getInt16(n2, true);
            case s.onnx.TensorProto.DataType.FLOAT:
              return e2.getFloat32(n2, true);
            case s.onnx.TensorProto.DataType.INT32:
              return e2.getInt32(n2, true);
            case s.onnx.TensorProto.DataType.UINT32:
              return e2.getUint32(n2, true);
            case s.onnx.TensorProto.DataType.INT64:
              return f(o.default.fromBits(e2.getUint32(n2, true), e2.getUint32(n2 + 4, true), false), t2);
            case s.onnx.TensorProto.DataType.DOUBLE:
              return e2.getFloat64(n2, true);
            case s.onnx.TensorProto.DataType.UINT64:
              return f(o.default.fromBits(e2.getUint32(n2, true), e2.getUint32(n2 + 4, true), true), t2);
            default:
              throw new Error(`cannot read from DataView for type ${s.onnx.TensorProto.DataType[t2]}`);
          }
        }
        t.Tensor = c;
      }, 7273: function(e, t, n) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.decodeUtf8String = t.MAX_CLIP = t.MIN_CLIP = t.PoolConvUtil = t.ReduceUtil = t.SplitUtil = t.MathUtil = t.ShapeUtil = t.LongUtil = t.ProtoUtil = t.GemmUtil = t.arrayCopyHelper = t.BroadcastUtil = t.MatMulUtil = t.ArrayUtil = t.assert = t.checkInputsShape = void 0;
        const i = n(5686), o = r(n(1583)), a = n(2446), s = n(9240);
        t.checkInputsShape = function(e2, ...t2) {
          if (!e2 || e2.length !== t2.length)
            return false;
          for (let n2 = 0; n2 < e2.length; n2++)
            if (!e2[n2].dims || e2[n2].dims.length !== t2[n2])
              return false;
          return true;
        }, t.assert = function(e2, t2) {
          if (!e2)
            throw new Error("string" == typeof t2 ? t2 : t2());
        }, t.ArrayUtil = class {
          static arraysEqual(e2, t2) {
            if (e2.length !== t2.length)
              return false;
            for (let n2 = 0; n2 < e2.length; n2++)
              if (e2[n2] !== t2[n2])
                return false;
            return true;
          }
        };
        class u {
          static preprocessInputShapes(e2, t2) {
            return [1 === e2.length ? [1, e2[0]] : e2, 1 === t2.length ? [t2[0], 1] : t2];
          }
          static postprocessOutputShape(e2, t2, n2) {
            1 === t2 && e2.splice(e2.length - 2, 1), 1 === n2 && e2.pop();
          }
          static calcMatMulShape(e2, t2) {
            return e2[1] !== t2[0] ? void 0 : [e2[0], t2[1]];
          }
        }
        t.MatMulUtil = u;
        class l {
          static calcShape(e2, t2, n2 = false) {
            const r2 = e2.length, i2 = t2.length;
            if (0 === r2)
              return t2;
            if (0 === i2)
              return e2;
            const o2 = Math.max(e2.length, t2.length), a2 = new Array(o2);
            if (n2) {
              if (r2 < 2 || i2 < 2)
                return;
              const n3 = u.calcMatMulShape([e2[r2 - 2], e2[r2 - 1]], [t2[i2 - 2], t2[i2 - 1]]);
              if (void 0 === n3)
                return;
              [a2[o2 - 2], a2[o2 - 1]] = n3;
            }
            for (let s2 = n2 ? 3 : 1; s2 <= o2; s2++) {
              const n3 = r2 - s2 < 0 ? 1 : e2[r2 - s2], u2 = i2 - s2 < 0 ? 1 : t2[i2 - s2];
              if (n3 !== u2 && n3 > 1 && u2 > 1)
                return;
              a2[o2 - s2] = Math.max(n3, u2);
            }
            return a2;
          }
          static index(e2, t2) {
            const n2 = new Array(t2.length);
            return l.fillIndex(e2, t2, n2), n2;
          }
          static fillIndex(e2, t2, n2) {
            const r2 = e2.length - t2.length;
            for (let i2 = 0; i2 < t2.length; i2++)
              n2[i2] = e2[r2 + i2] % t2[i2];
          }
          static calc(e2, t2, n2, r2, i2) {
            const o2 = l.calcShape(e2.dims, t2.dims);
            if (o2) {
              if (r2 && !d.areEqual(o2, e2.dims))
                return;
              const a2 = d.size(o2), u2 = r2 ? e2 : new s.Tensor(o2, i2 || e2.type);
              if (0 === o2.length)
                u2.set([], n2(e2.get([]), t2.get([])));
              else {
                const r3 = new Array(o2.length), i3 = new Array(e2.dims.length), s2 = new Array(t2.dims.length);
                let c2, p2 = 0, d2 = 0, f2 = false, h2 = false;
                0 === e2.dims.length && (p2 = e2.get([]), f2 = true), 0 === t2.dims.length && (d2 = t2.get([]), h2 = true);
                for (let g2 = 0; g2 < a2; g2++) {
                  c2 = g2;
                  for (let e3 = o2.length - 1; e3 >= 0; e3--)
                    r3[e3] = c2 % o2[e3], c2 = Math.floor(c2 / o2[e3]);
                  f2 || (l.fillIndex(r3, e2.dims, i3), p2 = e2.get(i3)), h2 || (l.fillIndex(r3, t2.dims, s2), d2 = t2.get(s2)), u2.set(r3, n2(p2, d2));
                }
              }
              return u2;
            }
          }
          static isValidBroadcast(e2, t2) {
            const n2 = e2.length, r2 = t2.length;
            if (n2 > r2)
              return false;
            for (let i2 = 1; i2 <= n2; i2++)
              if (1 !== e2[n2 - i2] && e2[n2 - i2] !== t2[r2 - i2])
                return false;
            return true;
          }
          static getBroadcastDims(e2, t2) {
            const n2 = e2.length, r2 = [];
            for (let i2 = 0; i2 < n2; i2++) {
              const o2 = n2 - 1 - i2, a2 = e2[o2] || 1;
              (t2[t2.length - 1 - i2] || 1) > 1 && 1 === a2 && r2.unshift(o2);
            }
            return r2;
          }
        }
        t.BroadcastUtil = l, t.arrayCopyHelper = function(e2, t2, n2, r2, i2) {
          if (r2 < 0 || r2 >= t2.length)
            throw new Error("sourceIndex out of bounds");
          if (n2 < 0 || n2 >= e2.length)
            throw new Error("targetIndex out of bounds");
          if (r2 + i2 > t2.length)
            throw new Error("source indices to be copied are outside bounds");
          if (n2 + i2 > e2.length)
            throw new Error("target array is too small to hold result");
          for (let o2 = 0; o2 < i2; o2++)
            e2[n2 + o2] = t2[r2 + o2];
        }, t.GemmUtil = class {
          static getShapeOfGemmResult(e2, t2, n2, r2, i2) {
            if (2 !== e2.length || 2 !== n2.length)
              throw new Error("shape need to be of size 2");
            let o2, a2, s2;
            t2 ? (o2 = e2[1], a2 = e2[0]) : (o2 = e2[0], a2 = e2[1]);
            let u2 = -1;
            if (r2 ? (s2 = n2[0], u2 = 1) : (s2 = n2[1], u2 = 0), n2[u2] !== a2)
              throw new Error("dimension mismatch");
            if (o2 <= 0 || s2 <= 0 || a2 <= 0)
              throw new Error("invalid shape specified");
            if (i2 && !l.isValidBroadcast(i2, [o2, s2]))
              throw new Error("gemm: invalid bias shape for broadcast");
            return [o2, s2, a2];
          }
        };
        class c {
          static tensorDataTypeFromProto(e2) {
            switch (e2) {
              case a.onnx.TensorProto.DataType.INT8:
                return "int8";
              case a.onnx.TensorProto.DataType.UINT8:
                return "uint8";
              case a.onnx.TensorProto.DataType.BOOL:
                return "bool";
              case a.onnx.TensorProto.DataType.INT16:
                return "int16";
              case a.onnx.TensorProto.DataType.UINT16:
                return "uint16";
              case a.onnx.TensorProto.DataType.INT32:
                return "int32";
              case a.onnx.TensorProto.DataType.UINT32:
                return "uint32";
              case a.onnx.TensorProto.DataType.FLOAT:
                return "float32";
              case a.onnx.TensorProto.DataType.DOUBLE:
                return "float64";
              case a.onnx.TensorProto.DataType.STRING:
                return "string";
              case a.onnx.TensorProto.DataType.INT64:
                return "int32";
              case a.onnx.TensorProto.DataType.UINT64:
                return "uint32";
              default:
                throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[e2]}`);
            }
          }
          static tensorDataTypeStringToEnum(e2) {
            switch (e2) {
              case "int8":
                return a.onnx.TensorProto.DataType.INT8;
              case "uint8":
                return a.onnx.TensorProto.DataType.UINT8;
              case "bool":
                return a.onnx.TensorProto.DataType.BOOL;
              case "int16":
                return a.onnx.TensorProto.DataType.INT16;
              case "uint16":
                return a.onnx.TensorProto.DataType.UINT16;
              case "int32":
                return a.onnx.TensorProto.DataType.INT32;
              case "uint32":
                return a.onnx.TensorProto.DataType.UINT32;
              case "float32":
                return a.onnx.TensorProto.DataType.FLOAT;
              case "float64":
                return a.onnx.TensorProto.DataType.DOUBLE;
              case "string":
                return a.onnx.TensorProto.DataType.STRING;
              case "int64":
                return a.onnx.TensorProto.DataType.INT64;
              case "uint64":
                return a.onnx.TensorProto.DataType.UINT64;
              default:
                throw new Error(`unsupported data type: ${e2}`);
            }
          }
          static tensorDimsFromProto(e2) {
            return e2.map((e3) => o.default.isLong(e3) ? e3.toNumber() : e3);
          }
          static tensorValueTypeFromProto(e2) {
            return { tensorType: c.tensorDataTypeFromProto(e2.elemType), shape: { dims: c.tensorDimsFromProto(e2.shape.dim.map((e3) => e3.dimValue)) } };
          }
          static tensorDimsFromORTFormat(e2) {
            const t2 = [];
            for (let n2 = 0; n2 < e2.dimsLength(); n2++)
              t2.push(p.longToNumber(e2.dims(n2)));
            return t2;
          }
          static tensorAttributesFromORTFormat(e2) {
            const t2 = [];
            for (let n2 = 0; n2 < e2.attributesLength(); n2++)
              t2.push(e2.attributes(n2));
            return t2;
          }
        }
        t.ProtoUtil = c;
        class p {
          static longToNumber(e2, t2) {
            return o.default.isLong(e2) ? e2.toNumber() : e2 instanceof i.flatbuffers.Long ? o.default.fromValue({ low: e2.low, high: e2.high, unsigned: null != t2 && t2 }).toNumber() : e2;
          }
          static isLong(e2) {
            return o.default.isLong(e2) || e2 instanceof i.flatbuffers.Long;
          }
        }
        t.LongUtil = p;
        class d {
          static size(e2) {
            return d.getSizeFromDimensionRange(e2, 0, e2.length);
          }
          static sizeFromDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeFromDimension as Tensor has ${e2.length} dimensions.`);
            return d.getSizeFromDimensionRange(e2, t2, e2.length);
          }
          static sizeToDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeToDimension as Tensor has ${e2.length} dimensions.`);
            return d.getSizeFromDimensionRange(e2, 0, t2);
          }
          static getSizeFromDimensionRange(e2, t2, n2) {
            let r2 = 1;
            for (let i2 = t2; i2 < n2; i2++) {
              if (e2[i2] <= 0)
                throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
              r2 *= e2[i2];
            }
            return r2;
          }
          static computeStrides(e2) {
            const t2 = e2.length;
            if (0 === t2)
              return [];
            if (1 === t2)
              return [1];
            const n2 = new Array(t2);
            n2[t2 - 1] = 1, n2[t2 - 2] = e2[t2 - 1];
            for (let r2 = t2 - 3; r2 >= 0; --r2)
              n2[r2] = n2[r2 + 1] * e2[r2 + 1];
            return n2;
          }
          static transpose(e2) {
            return e2.slice().reverse();
          }
          static indicesToOffset(e2, t2, n2) {
            void 0 === n2 && (n2 = e2.length);
            let r2 = 0;
            for (let i2 = 0; i2 < n2; ++i2)
              r2 += t2[i2] * e2[i2];
            return r2;
          }
          static offsetToIndices(e2, t2) {
            const n2 = t2.length;
            if (0 === n2)
              return [];
            if (1 === n2)
              return [e2 * t2[0]];
            const r2 = new Array(t2.length);
            for (let n3 = 0; n3 < r2.length - 1; ++n3)
              r2[n3] = Math.floor(e2 / t2[n3]), e2 -= r2[n3] * t2[n3];
            return r2[r2.length - 1] = e2, r2;
          }
          static normalizeAxis(e2, t2) {
            if (e2 < -t2 && e2 >= t2)
              throw new Error("unsupported axis for this operation.");
            return e2 < 0 ? e2 + t2 : e2;
          }
          static normalizeAxes(e2, t2) {
            return e2.map((e3) => this.normalizeAxis(e3, t2));
          }
          static incrementIndex(e2, t2, n2) {
            if (0 === t2.length || 0 === e2.length)
              throw new Error("Index incrementing unsupported for scalar Tensor");
            if (void 0 === n2)
              n2 = t2.length;
            else if (n2 <= 0 || n2 > t2.length)
              throw new Error("Incorrect axis to increment on");
            for (let r2 = n2 - 1; r2 >= 0 && (e2[r2]++, !(e2[r2] < t2[r2])); --r2)
              e2[r2] = 0;
          }
          static calculateReshapedDims(e2, t2) {
            if (0 === t2.length) {
              if (0 === e2.length || 1 === d.size(e2))
                return [];
              throw new Error("cannot reshape to a scalar Tensor");
            }
            const n2 = t2.length, r2 = new Array(n2);
            let i2 = -1, o2 = 1;
            for (let a3 = 0; a3 < n2; a3++) {
              if (t2[a3] < -1)
                throw new Error("a dimension in shape hints cannot be less than -1");
              if (-1 === t2[a3]) {
                if (-1 !== i2)
                  throw new Error("at most one dimension in shape hints can be -1");
                i2 = a3;
              } else {
                if (0 === t2[a3]) {
                  if (a3 >= e2.length)
                    throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                  r2[a3] = e2[a3];
                } else
                  r2[a3] = t2[a3];
                o2 *= r2[a3];
              }
            }
            const a2 = d.size(e2);
            if (-1 !== i2) {
              if (a2 % o2 != 0)
                throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e2}] Output shape: [${t2}]`);
              r2[i2] = a2 / o2;
            } else if (o2 !== a2)
              throw new Error("reshapedDims and originalDims don't have matching sizes");
            return r2;
          }
          static sortBasedOnPerm(e2, t2) {
            return t2 ? t2.map((t3) => e2[t3]) : e2.slice().reverse();
          }
          static padShape(e2, t2) {
            const n2 = e2.length;
            return e2.map((e3, r2) => e3 + t2[r2] + t2[r2 + n2]);
          }
          static areEqual(e2, t2) {
            return e2.length === t2.length && e2.every((e3, n2) => e3 === t2[n2]);
          }
          static validateDimsAndCalcSize(e2) {
            if (e2.length > 6)
              throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
            let t2 = 1;
            for (const n2 of e2) {
              if (!Number.isInteger(n2))
                throw new TypeError(`Invalid shape: ${n2} is not an integer`);
              if (n2 < 0 || n2 > 2147483647)
                throw new TypeError(`Invalid shape: length ${n2} is not allowed`);
              t2 *= n2;
            }
            return t2;
          }
          static flattenShape(e2, t2) {
            t2 < 0 && (t2 += e2.length);
            const n2 = e2.reduce((e3, t3) => e3 * t3, 1), r2 = e2.slice(t2).reduce((e3, t3) => e3 * t3, 1);
            return [n2 / r2, r2];
          }
          static squeezeShape(e2, t2) {
            const n2 = new Array();
            t2 = d.normalizeAxes(t2, e2.length);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const i2 = t2.indexOf(r2) >= 0;
              if (i2 && 1 !== e2[r2])
                throw new Error("squeeze an axis of size different than 1");
              (0 === t2.length && e2[r2] > 1 || t2.length > 0 && !i2) && n2.push(e2[r2]);
            }
            return n2;
          }
          static unsqueezeShape(e2, t2) {
            const n2 = new Array(e2.length + t2.length);
            n2.fill(0);
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r3 = d.normalizeAxis(t2[e3], n2.length);
              if (r3 >= n2.length)
                throw new Error("'axes' has an out of range axis");
              if (0 !== n2[r3])
                throw new Error("'axes' has a duplicate axis");
              n2[r3] = 1;
            }
            let r2 = 0;
            for (let t3 = 0; t3 < n2.length; t3++)
              0 === n2[t3] && (n2[t3] = e2[r2++]);
            if (r2 !== e2.length)
              throw new Error("the unsqueezed dimension could not be established");
            return n2;
          }
        }
        t.ShapeUtil = d, t.MathUtil = class {
          static sqr(e2, t2, n2, r2, i2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + i2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + i2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let o2 = 0; o2 < i2; o2++)
              e2[n2 + o2] += Math.pow(t2[r2 + o2], 2);
          }
          static axpy(e2, t2, n2, r2, i2, o2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + i2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + i2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let a2 = 0; a2 < i2; a2++)
              e2[n2 + a2] += o2 * t2[r2 + a2];
          }
          static powx(e2, t2, n2, r2, i2, o2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + i2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + i2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let a2 = 0; a2 < i2; a2++)
              e2[n2 + a2] = Math.pow(t2[r2 + a2], o2);
          }
          static mul(e2, t2, n2, r2, i2) {
            if (r2 < 0 || r2 >= t2.length)
              throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= e2.length)
              throw new Error("targetIndex out of bounds");
            if (r2 + i2 > t2.length)
              throw new Error("source indices to be copied are outside bounds");
            if (n2 + i2 > e2.length)
              throw new Error("target array is too small to hold result");
            for (let o2 = 0; o2 < i2; o2++)
              e2[n2 + o2] = t2[r2 + o2] * e2[n2 + o2];
          }
        };
        class f {
          static splitShape(e2, t2, n2, r2) {
            if (0 === n2.length) {
              if (!r2)
                throw new Error("need to know number of outputs when the 'split' attribute is not specified");
              f.determineSplit(e2[t2], r2, n2);
            }
            const i2 = [], o2 = [0];
            for (let r3 = 0; r3 < n2.length; ++r3) {
              0 !== r3 && o2.push(o2[r3 - 1] + n2[r3 - 1]);
              const a2 = e2.slice();
              a2[t2] = n2[r3], i2.push(a2);
            }
            return [i2, o2];
          }
          static determineSplit(e2, t2, n2) {
            if (e2 % t2 != 0)
              throw new Error("cannot split tensor to equal sized parts");
            for (let r2 = 0; r2 < t2; ++r2)
              n2.push(e2 / t2);
          }
        }
        t.SplitUtil = f;
        class h {
          static calcReduce(e2, t2, n2, r2, i2) {
            const o2 = e2.dims.slice(0);
            0 === t2.length && o2.forEach((e3, n3) => t2.push(n3));
            const a2 = h.calcReduceShape(o2, t2, true), u2 = d.size(a2), c2 = new s.Tensor(a2, e2.type), p2 = d.computeStrides(a2), f2 = d.computeStrides(o2), g2 = new Array(o2.length);
            for (let n3 = 0; n3 < u2; n3++) {
              const a3 = d.offsetToIndices(n3, p2);
              l.fillIndex(a3, o2, g2), c2.set(a3, h.calcReduceByAxis(e2.numberData, t2, o2, 0, d.indicesToOffset(g2, f2), r2, i2));
            }
            return n2 ? c2 : new s.Tensor(h.calcReduceShape(o2, t2, n2), c2.type, void 0, void 0, c2.data, c2.dataId);
          }
          static calcReduceByAxis(e2, t2, n2, r2, i2, o2, a2) {
            let s2 = 0;
            if (r2 >= t2.length)
              return o2(e2[i2]);
            const u2 = t2[r2], l2 = u2 >= n2.length ? 1 : d.size(n2.slice(u2 + 1));
            for (let c2 = 0; c2 < n2[u2]; c2++)
              s2 = 0 === c2 ? h.calcReduceByAxis(e2, t2, n2, r2 + 1, i2, o2, a2) : a2(s2, h.calcReduceByAxis(e2, t2, n2, r2 + 1, i2, o2, a2)), i2 += l2;
            return s2;
          }
          static calcReduceShape(e2, t2, n2) {
            const r2 = e2.slice();
            for (let e3 = 0; e3 < t2.length; e3++)
              r2[t2[e3]] = n2 ? 1 : 0;
            return r2.filter((e3) => 0 !== e3);
          }
        }
        t.ReduceUtil = h;
        class g {
          static adjustPoolAttributes(e2, t2, n2, r2, i2, o2) {
            if (!e2 && n2.length !== t2.length - 2)
              throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                e3 >= n2.length ? n2.push(t2[e3 + 2]) : n2[e3] = t2[e3 + 2];
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < r2.length) {
                if (r2[e3] < 0)
                  throw new Error("strides should be greater than or equal to 1");
              } else
                r2.push(1);
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < i2.length) {
                if (i2[e3] < 0)
                  throw new Error("dilations should be greater than or equal to 1");
              } else
                i2.push(1);
            for (let e3 = 0; e3 < 2 * n2.length; e3++)
              if (e3 < o2.length) {
                if (o2[e3] < 0)
                  throw new Error("pad should be greater than or equal to 1");
              } else
                o2.push(0);
            for (let e3 = 0; e3 < n2.length; e3++) {
              if (n2[e3] <= 0)
                throw new Error("kernel shapes need to be greater than 0");
              if (o2[e3] >= n2[e3] || o2[e3 + n2.length] >= n2[e3])
                throw new Error("pads should be smaller than kernel");
            }
          }
          static adjustPadsBasedOnAutoPad(e2, t2, n2, r2, i2, o2) {
            if (o2) {
              if (i2.length !== 2 * (e2.length - 2))
                throw new Error("length of pads should be twice the length of data dimensions");
              if (t2.length !== e2.length - 2)
                throw new Error("length of strides should be the length of data dimensions");
              if (r2.length !== e2.length - 2)
                throw new Error("length of kernel shapes should be the length of data dimensions");
              for (let a2 = 0; a2 < e2.length - 2; a2++)
                g.adjustPadAndReturnShape(e2[a2 + 2], t2[a2], n2[a2], r2[a2], i2, a2, a2 + e2.length - 2, o2);
            }
          }
          static computePoolOutputShape(e2, t2, n2, r2, i2, o2, a2) {
            if (t2.length <= 0)
              throw new Error("input shape must be of size greater than 0");
            const s2 = [t2[0], t2[1]];
            return g.computeShapeHelper(e2, t2, s2, n2, r2, i2, o2, a2), s2;
          }
          static computeConvOutputShape(e2, t2, n2, r2, i2, o2, a2) {
            if (e2.length <= 0 || t2.length <= 0)
              throw new Error("invalid input tensor dims or invalid filter tensor dims");
            const s2 = [e2[0], t2[0]];
            return g.computeShapeHelper(false, e2, s2, n2, r2, i2, o2, a2), s2;
          }
          static computeShapeHelper(e2, t2, n2, r2, i2, o2, a2, s2) {
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(1);
            else
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(g.adjustPadAndReturnShape(t2[e3 + 2], r2[e3], i2[e3], o2[e3], a2, e3, e3 + t2.length - 2, s2));
          }
          static adjustPadAndReturnShape(e2, t2, n2, r2, i2, o2, a2, s2) {
            const u2 = n2 * (r2 - 1) + 1;
            if (!s2 || "NOTSET" === s2)
              return Math.floor((e2 + i2[o2] + i2[a2] - u2) / t2 + 1);
            switch (s2) {
              case "VALID":
                return i2[o2] = 0, i2[a2] = 0, Math.floor((e2 - u2) / t2 + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (1 !== n2)
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                {
                  const n3 = ((e2 + t2 - 1) / t2 - 1) * t2 + r2 - e2;
                  return i2[o2] = "SAME_LOWER" === s2 ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), i2[a2] = n3 - i2[o2], Math.floor((e2 + n3 - r2) / t2 + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          }
        }
        t.PoolConvUtil = g, t.MIN_CLIP = -34028234663852886e22, t.MAX_CLIP = 34028234663852886e22, t.decodeUtf8String = function(e2) {
          return new TextDecoder().decode(e2);
        };
      }, 8408: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.version = void 0, t.version = "1.16.3";
      }, 3838: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WebGpuBackend = void 0;
        const r = n(4955), i = n(7771), o = n(8510), a = n(8305);
        t.WebGpuBackend = class {
          constructor() {
            this.currentKernelId = null, this.commandEncoder = null, this.computePassEncoder = null, this.pendingDispatchNumber = 0, this.supportTimestampQuery = false;
          }
          get currentKernelCustomData() {
            if (null === this.currentKernelId)
              throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
            let e2 = this.kernelCustomData.get(this.currentKernelId);
            return e2 || (e2 = {}, this.kernelCustomData.set(this.currentKernelId, e2)), e2;
          }
          async initialize(e2) {
            if (!navigator.gpu)
              throw new Error("WebGpuBackend: WebGPU is not available.");
            const t2 = await navigator.gpu.requestAdapter();
            if (!t2)
              throw new Error("WebGpuBackend: Failed to get GPU adapter.");
            this.env = e2;
            const n2 = { requiredLimits: { maxComputeWorkgroupStorageSize: t2.limits.maxComputeWorkgroupStorageSize, maxComputeWorkgroupsPerDimension: t2.limits.maxComputeWorkgroupsPerDimension, maxStorageBufferBindingSize: t2.limits.maxStorageBufferBindingSize, maxBufferSize: t2.limits.maxBufferSize, maxComputeInvocationsPerWorkgroup: t2.limits.maxComputeInvocationsPerWorkgroup, maxComputeWorkgroupSizeX: t2.limits.maxComputeWorkgroupSizeX, maxComputeWorkgroupSizeY: t2.limits.maxComputeWorkgroupSizeY, maxComputeWorkgroupSizeZ: t2.limits.maxComputeWorkgroupSizeZ } };
            t2.features.has("timestamp-query-inside-passes") && (this.supportTimestampQuery = true, n2.requiredFeatures = ["timestamp-query-inside-passes"]), this.device = await t2.requestDevice(n2), this.gpuDataManager = (0, i.createGpuDataManager)(this), this.programManager = new a.ProgramManager(this), this.kernels = /* @__PURE__ */ new Map(), this.kernelPersistentData = /* @__PURE__ */ new Map(), this.kernelCustomData = /* @__PURE__ */ new Map(), (0, r.configureLogger)(e2.logLevel, !!e2.debug), this.device.onuncapturederror = (e3) => {
              e3.error instanceof GPUValidationError && console.error(`An uncaught WebGPU validation error was raised: ${e3.error.message}`);
            }, this.supportTimestampQuery && (this.profilingQuerySet = this.device.createQuerySet({ type: "timestamp", count: 2 }));
          }
          dispose() {
          }
          getCommandEncoder() {
            return this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder()), this.commandEncoder;
          }
          getComputePassEncoder() {
            return this.computePassEncoder || (this.computePassEncoder = this.getCommandEncoder().beginComputePass()), this.computePassEncoder;
          }
          endComputePass() {
            this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
          }
          flush() {
            this.endComputePass(), this.device.queue.submit([this.getCommandEncoder().finish()]), this.gpuDataManager.refreshPendingBuffers(), this.commandEncoder = null, this.pendingDispatchNumber = 0;
          }
          run(e2, t2, n2, i2, o2) {
            if (t2.length !== e2.inputTypes.length)
              throw new Error(`Input size must be equal to ${e2.inputTypes.length}.`);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; ++e3) {
              const n3 = this.gpuDataManager.get(t2[e3].data);
              if (!n3)
                throw new Error(`no GPU data for input: ${t2[e3].data}`);
              a2[e3] = n3;
            }
            const s = ((e3, t3) => {
              const n3 = t3.map((e4) => `${e4.dataType};${e4.dims.join(",")}`).join("|");
              let r2 = e3.name;
              return e3.cacheHint && (r2 += "[" + e3.cacheHint + "]"), r2 += ":" + n3, r2;
            })(e2, t2);
            let u = this.programManager.getArtifact(s);
            const l = u ? u.programInfo : "function" == typeof e2.get ? e2.get() : e2, c = 0 === n2.length ? l.outputs.map((e3, t3) => t3) : n2;
            if (c.length !== l.outputs.length)
              throw new Error(`Output size ${c.length} must be equal to ${l.outputs.length}.`);
            const p = [], d = [];
            for (let e3 = 0; e3 < l.outputs.length; ++e3) {
              if (!Number.isInteger(c[e3]) || c[e3] < -3 || c[e3] >= l.outputs.length)
                throw new Error(`Invalid output index: ${c[e3]}`);
              if (-3 === c[e3])
                continue;
              const t3 = -1 === c[e3], n3 = -2 === c[e3], r2 = t3 || n3 ? o2(l.outputs[e3].dataType, l.outputs[e3].dims) : i2(c[e3], l.outputs[e3].dataType, l.outputs[e3].dims), a3 = this.gpuDataManager.get(r2.data);
              if (!a3)
                throw new Error(`no GPU data for output: ${r2.data}`);
              if (t3 && this.temporaryData.push(a3), n3) {
                let e4 = this.kernelPersistentData.get(this.currentKernelId);
                e4 || (e4 = [], this.kernelPersistentData.set(this.currentKernelId, e4)), e4.push(a3);
              }
              p.push(r2), d.push(a3);
            }
            const f = this.programManager.normalizeDispatchGroupSize(l.dispatchGroup(t2));
            return u || (u = this.programManager.build(l, f), this.programManager.setArtifact(s, u)), (0, r.LOG_DEBUG)("info", () => `[ProgramManager] run "${l.name}" (key=${s}) with ${f[0]}x${f[1]}x${f[2]}`), this.programManager.run(u, a2, d, f), p;
          }
          upload(e2, t2) {
            this.gpuDataManager.upload(e2, t2);
          }
          memcpy(e2, t2) {
            this.gpuDataManager.memcpy(e2, t2);
          }
          async download(e2, t2) {
            const n2 = await this.gpuDataManager.download(e2), r2 = t2();
            r2.set(new Uint8Array(n2, 0, r2.byteLength));
          }
          alloc(e2) {
            return this.gpuDataManager.create(e2).id;
          }
          free(e2) {
            return this.gpuDataManager.release(e2);
          }
          createKernel(e2, t2, n2) {
            const r2 = o.WEBGPU_OP_RESOLVE_RULES.get(e2);
            if (!r2)
              throw new Error(`kernel not implemented: ${e2}`);
            this.kernels.set(t2, [e2, r2[0], [r2[1], n2]]);
          }
          releaseKernel(e2) {
            const t2 = this.kernelPersistentData.get(e2);
            if (t2) {
              for (const e3 of t2)
                this.gpuDataManager.release(e3.id);
              this.kernelPersistentData.delete(e2);
            }
            this.kernelCustomData.delete(e2), this.kernels.delete(e2);
          }
          computeKernel(e2, t2) {
            const n2 = this.kernels.get(e2);
            if (!n2)
              throw new Error(`kernel not created: ${e2}`);
            const [i2, o2, a2] = n2;
            if (null !== this.currentKernelId)
              throw new Error(`kernel "${i2}" is not allowed to be called recursively`);
            this.currentKernelId = e2, a2[0] && (a2[1] = a2[0](a2[1]), a2[0] = void 0), (0, r.LOG_DEBUG)("info", () => `[WebGPU] Start to run kernel "${i2}"...`), this.temporaryData = [];
            try {
              return o2(t2, a2[1]), 0;
            } catch (e3) {
              return (0, r.LOG_DEBUG)("warning", `[WebGPU] Kernel "${i2}" failed. Error: ${e3}`), 1;
            } finally {
              for (const e3 of this.temporaryData)
                this.gpuDataManager.release(e3.id);
              this.temporaryData = [], this.currentKernelId = null;
            }
          }
        };
      }, 7675: (e, t, n) => {
        "use strict";
        t.S = void 0;
        const r = n(7917), i = n(3838), o = n(4955), a = n(6952);
        class s {
          constructor(e2, t2, n2, r2) {
            this.module = e2, this.dataType = t2, this.data = n2, this.dims = r2;
          }
          getFloat32Array() {
            if (1 !== this.dataType)
              throw new Error("Invalid data type");
            const e2 = a.ShapeUtil.size(this.dims);
            return 0 === e2 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, e2);
          }
          getBigInt64Array() {
            if (7 !== this.dataType)
              throw new Error("Invalid data type");
            const e2 = a.ShapeUtil.size(this.dims);
            return 0 === e2 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, e2);
          }
          getInt32Array() {
            if (6 !== this.dataType)
              throw new Error("Invalid data type");
            const e2 = a.ShapeUtil.size(this.dims);
            return 0 === e2 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, e2);
          }
          reshape(e2) {
            if (a.ShapeUtil.size(e2) !== a.ShapeUtil.size(this.dims))
              throw new Error("Invalid new shape");
            return new s(this.module, this.dataType, this.data, e2);
          }
        }
        class u {
          get kernelCustomData() {
            return this.backend.currentKernelCustomData;
          }
          get customDataBuffer() {
            return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
          }
          constructor(e2, t2, n2) {
            this.module = e2, this.backend = t2, this.customDataOffset = 0, this.customDataSize = 0;
            const r2 = e2.HEAPU32;
            let i2 = n2 >> 2;
            this.opKernelContext = r2[i2++];
            const o2 = r2[i2++];
            this.outputCount = r2[i2++], this.customDataOffset = r2[i2++], this.customDataSize = r2[i2++];
            const a2 = [];
            for (let t3 = 0; t3 < o2; t3++) {
              const t4 = r2[i2++], n3 = r2[i2++], o3 = r2[i2++], u2 = [];
              for (let e3 = 0; e3 < o3; e3++)
                u2.push(r2[i2++]);
              a2.push(new s(e2, t4, n3, u2));
            }
            this.inputs = a2;
          }
          compute(e2, t2) {
            var n2, i2, o2;
            const u2 = null !== (i2 = null === (n2 = null == t2 ? void 0 : t2.inputs) || void 0 === n2 ? void 0 : n2.map((e3) => "number" == typeof e3 ? this.inputs[e3] : e3)) && void 0 !== i2 ? i2 : this.inputs, l = null !== (o2 = null == t2 ? void 0 : t2.outputs) && void 0 !== o2 ? o2 : [];
            return this.backend.run(e2, u2, l, (e3, t3, n3) => new s(this.module, t3, this.output(e3, n3), n3), (e3, t3) => {
              const n3 = (0, r.getTensorElementSize)(e3);
              if (!n3)
                throw new Error(`Unsupported data type: ${e3}`);
              const i3 = n3 * a.ShapeUtil.size(t3);
              return new s(this.module, e3, this.backend.gpuDataManager.create(i3).id, t3);
            });
          }
          output(e2, t2) {
            const n2 = this.module.stackSave();
            try {
              const n3 = this.module.stackAlloc(4 * (1 + t2.length));
              let r2 = n3 >> 2;
              this.module.HEAPU32[r2++] = t2.length;
              for (let e3 = 0; e3 < t2.length; e3++)
                this.module.HEAPU32[r2++] = t2[e3];
              return this.module._JsepOutput(this.opKernelContext, e2, n3);
            } finally {
              this.module.stackRestore(n2);
            }
          }
        }
        t.S = async (e2, t2) => {
          const n2 = e2.jsepInit;
          if (n2 && navigator.gpu) {
            if (!t2.wasm.simd)
              throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");
            const r2 = new i.WebGpuBackend();
            await r2.initialize(t2), n2({ backend: r2 }, (e3) => r2.alloc(e3), (e3) => r2.free(e3), (t3, n3, i2, a2 = false) => {
              if (a2)
                (0, o.LOG_DEBUG)("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${t3}, dst=${n3}, size=${i2}`), r2.memcpy(t3, n3);
              else {
                (0, o.LOG_DEBUG)("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${t3}, gpuDataId=${n3}, size=${i2}`);
                const a3 = e2.HEAPU8.subarray(t3, t3 + i2);
                r2.upload(n3, a3);
              }
            }, async (t3, n3, i2) => {
              (0, o.LOG_DEBUG)("verbose", () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t3}, dataOffset=${n3}, size=${i2}`), await r2.download(t3, () => e2.HEAPU8.subarray(n3, n3 + i2));
            }, (e3, t3, n3) => r2.createKernel(e3, t3, n3), (e3) => r2.releaseKernel(e3), (t3, n3) => {
              (0, o.LOG_DEBUG)("verbose", () => `[WebGPU] jsepRun: kernel=${t3}, contextDataOffset=${n3}`);
              const i2 = new u(e2, r2, n3);
              return r2.computeKernel(t3, i2);
            });
          }
        };
      }, 4955: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.LOG_DEBUG = t.LOG = t.configureLogger = void 0;
        const r = n(7917), i = ["V", "I", "W", "E", "F"];
        let o, a;
        t.configureLogger = (e2, t2) => {
          o = e2, a = t2;
        }, t.LOG = (e2, t2) => {
          const n2 = (0, r.logLevelStringToEnum)(e2);
          var a2, s;
          n2 >= (0, r.logLevelStringToEnum)(o) && (a2 = n2, s = "function" == typeof t2 ? t2() : t2, console.log(`[${i[a2]},${(/* @__PURE__ */ new Date()).toISOString()}]${s}`));
        }, t.LOG_DEBUG = (...e2) => {
          a && (0, t.LOG)(...e2);
        };
      }, 6952: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.MAX_CLIP = t.MIN_CLIP = t.GemmUtil = t.PoolConvUtil = t.ShapeUtil = t.BroadcastUtil = t.MatMulUtil = void 0;
        class n {
          static calcMatMulShape(e2, t2) {
            return e2[1] !== t2[0] ? void 0 : [e2[0], t2[1]];
          }
        }
        t.MatMulUtil = n;
        class r {
          static calcShape(e2, t2, r2 = false) {
            const i2 = e2.length, o2 = t2.length;
            if (0 === i2)
              return t2;
            if (0 === o2)
              return e2;
            const a = Math.max(e2.length, t2.length), s = new Array(a);
            if (r2) {
              if (i2 < 2 || o2 < 2)
                return;
              const r3 = n.calcMatMulShape([e2[i2 - 2], e2[i2 - 1]], [t2[o2 - 2], t2[o2 - 1]]);
              if (void 0 === r3)
                return;
              [s[a - 2], s[a - 1]] = r3;
            }
            for (let n2 = r2 ? 3 : 1; n2 <= a; n2++) {
              const r3 = i2 - n2 < 0 ? 1 : e2[i2 - n2], u = o2 - n2 < 0 ? 1 : t2[o2 - n2];
              if (r3 !== u && r3 > 1 && u > 1)
                return;
              s[a - n2] = Math.max(r3, u);
            }
            return s;
          }
          static isValidBroadcast(e2, t2) {
            const n2 = e2.length, r2 = t2.length;
            if (n2 > r2)
              return false;
            for (let i2 = 1; i2 <= n2; i2++)
              if (1 !== e2[n2 - i2] && e2[n2 - i2] !== t2[r2 - i2])
                return false;
            return true;
          }
        }
        t.BroadcastUtil = r;
        class i {
          static size(e2) {
            return i.getSizeFromDimensionRange(e2, 0, e2.length);
          }
          static sizeFromDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeFromDimension as Tensor has ${e2.length} dimensions.`);
            return i.getSizeFromDimensionRange(e2, t2, e2.length);
          }
          static sizeToDimension(e2, t2) {
            if (t2 < 0 || t2 > e2.length)
              throw new Error(`invalid dimension of ${t2} for sizeToDimension as Tensor has ${e2.length} dimensions.`);
            return i.getSizeFromDimensionRange(e2, 0, t2);
          }
          static getSizeFromDimensionRange(e2, t2, n2) {
            let r2 = 1;
            for (let i2 = t2; i2 < n2; i2++) {
              if (e2[i2] < 0)
                throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");
              r2 *= e2[i2];
            }
            return r2;
          }
          static computeStrides(e2) {
            const t2 = e2.length;
            if (0 === t2)
              return [];
            if (1 === t2)
              return [1];
            const n2 = new Array(t2);
            n2[t2 - 1] = 1, n2[t2 - 2] = e2[t2 - 1];
            for (let r2 = t2 - 3; r2 >= 0; --r2)
              n2[r2] = n2[r2 + 1] * e2[r2 + 1];
            return n2;
          }
          static normalizeAxis(e2, t2) {
            if (e2 < -t2 && e2 >= t2)
              throw new Error("unsupported axis for this operation.");
            return e2 < 0 ? e2 + t2 : e2;
          }
          static normalizeAxes(e2, t2) {
            return e2.map((n2) => this.normalizeAxis(n2, null != t2 ? t2 : e2.length));
          }
          static sortBasedOnPerm(e2, t2) {
            return t2 ? t2.map((t3) => e2[t3]) : e2.slice().reverse();
          }
          static padShape(e2, t2) {
            const n2 = e2.length;
            return e2.map((e3, r2) => e3 + t2[r2] + t2[r2 + n2]);
          }
          static areEqual(e2, t2) {
            return e2.length === t2.length && e2.every((e3, n2) => e3 === t2[n2]);
          }
        }
        t.ShapeUtil = i;
        class o {
          static adjustPoolAttributes(e2, t2, n2, r2, i2, o2) {
            if (!e2 && n2.length !== t2.length - 2)
              throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                e3 >= n2.length ? n2.push(t2[e3 + 2]) : n2[e3] = t2[e3 + 2];
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < r2.length) {
                if (r2[e3] < 0)
                  throw new Error("strides should be greater than or equal to 1");
              } else
                r2.push(1);
            for (let e3 = 0; e3 < n2.length; e3++)
              if (e3 < i2.length) {
                if (i2[e3] < 0)
                  throw new Error("dilations should be greater than or equal to 1");
              } else
                i2.push(1);
            for (let e3 = 0; e3 < 2 * n2.length; e3++)
              if (e3 < o2.length) {
                if (o2[e3] < 0)
                  throw new Error("pad should be greater than or equal to 1");
              } else
                o2.push(0);
            for (let e3 = 0; e3 < n2.length; e3++) {
              if (n2[e3] <= 0)
                throw new Error("kernel shapes need to be greater than 0");
              if (o2[e3] >= n2[e3] || o2[e3 + n2.length] >= n2[e3])
                throw new Error("pads should be smaller than kernel");
            }
          }
          static adjustPadsBasedOnAutoPad(e2, t2, n2, r2, i2, a, s) {
            if (s) {
              if (i2.length !== 2 * (e2.length - 2))
                throw new Error("length of pads should be twice the length of data dimensions");
              if (t2.length !== e2.length - 2)
                throw new Error("length of strides should be the length of data dimensions");
              if (r2.length !== e2.length - 2)
                throw new Error("length of kernel shapes should be the length of data dimensions");
              for (let u = 0; u < e2.length - 2; u++)
                o.adjustPadAndReturnShape(e2[u + (a ? 1 : 2)], t2[u], n2[u], r2[u], i2, u, u + e2.length - 2, s);
            }
          }
          static computePoolOutputShape(e2, t2, n2, r2, i2, a, s) {
            if (t2.length <= 0)
              throw new Error("input shape must be of size greater than 0");
            const u = [t2[0], t2[1]];
            return o.computeShapeHelper(e2, t2, u, n2, r2, i2, a, s), u;
          }
          static computeConvOutputShape(e2, t2, n2, r2, i2, a, s) {
            if (e2.length <= 0 || t2.length <= 0)
              throw new Error("invalid input tensor dims or invalid filter tensor dims");
            const u = [e2[0], t2[0]];
            return o.computeShapeHelper(false, e2, u, n2, r2, i2, a, s), u;
          }
          static computeShapeHelper(e2, t2, n2, r2, i2, a, s, u) {
            if (e2)
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(1);
            else
              for (let e3 = 0; e3 < t2.length - 2; e3++)
                n2.push(o.adjustPadAndReturnShape(t2[e3 + 2], r2[e3], i2[e3], a[e3], s, e3, e3 + t2.length - 2, u));
          }
          static adjustPadAndReturnShape(e2, t2, n2, r2, i2, o2, a, s) {
            const u = n2 * (r2 - 1) + 1;
            if (!s || "NOTSET" === s)
              return Math.floor((e2 + i2[o2] + i2[a] - u) / t2 + 1);
            switch (s) {
              case "VALID":
                return i2[o2] = 0, i2[a] = 0, Math.floor((e2 - u) / t2 + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (1 !== n2)
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                {
                  const n3 = ((e2 + t2 - 1) / t2 - 1) * t2 + r2 - e2;
                  return i2[o2] = "SAME_LOWER" === s ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), i2[a] = n3 - i2[o2], Math.floor((e2 + n3 - r2) / t2 + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          }
        }
        t.PoolConvUtil = o, t.GemmUtil = class {
          static getShapeOfGemmResult(e2, t2, n2, i2, o2) {
            if (2 !== e2.length || 2 !== n2.length)
              throw new Error("shape need to be of size 2");
            let a, s, u;
            t2 ? (a = e2[1], s = e2[0]) : (a = e2[0], s = e2[1]);
            let l = -1;
            if (i2 ? (u = n2[0], l = 1) : (u = n2[1], l = 0), n2[l] !== s)
              throw new Error("dimension mismatch");
            if (a <= 0 || u <= 0 || s <= 0)
              throw new Error("invalid shape specified");
            if (o2 && !r.isValidBroadcast(o2, [a, u]))
              throw new Error("gemm: invalid bias shape for broadcast");
            return [a, u, s];
          }
        }, t.MIN_CLIP = -34028234663852886e22, t.MAX_CLIP = 34028234663852886e22;
      }, 387: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createAttributeWithCacheKey = void 0;
        class n {
          constructor(e2) {
            Object.assign(this, e2);
          }
          get cacheKey() {
            return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((e2) => `${this[e2]}`).join(";")), this._cacheKey;
          }
        }
        t.createAttributeWithCacheKey = (e2) => new n(e2);
      }, 7771: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createGpuDataManager = void 0;
        const r = n(4955), i = n(1163), o = (e2) => 16 * Math.ceil(e2 / 16);
        let a = 0;
        class s {
          constructor(e2) {
            this.backend = e2, this.storageCache = /* @__PURE__ */ new Map(), this.downloadCache = /* @__PURE__ */ new Map(), this.freeBuffers = /* @__PURE__ */ new Map(), this.buffersForUploadingPending = [], this.buffersPending = [];
          }
          upload(e2, t2) {
            const n2 = t2.buffer, i2 = t2.byteOffset, a2 = t2.byteLength, s2 = o(a2), u = this.storageCache.get(e2);
            if (!u)
              throw new Error("gpu data for uploading does not exist");
            if (u.originalSize !== a2)
              throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${a2}`);
            const l = this.backend.device.createBuffer({ mappedAtCreation: true, size: s2, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }), c = l.getMappedRange();
            new Uint8Array(c).set(new Uint8Array(n2, i2, a2)), l.unmap();
            const p = this.backend.getCommandEncoder();
            this.backend.endComputePass(), p.copyBufferToBuffer(l, 0, u.gpuData.buffer, 0, s2), (0, r.LOG_DEBUG)("verbose", () => `[WebGPU] GpuDataManager.upload(id=${e2})`), this.buffersForUploadingPending.push(l);
          }
          memcpy(e2, t2) {
            const n2 = this.storageCache.get(e2);
            if (!n2)
              throw new Error("source gpu data for memcpy does not exist");
            const r2 = this.storageCache.get(t2);
            if (!r2)
              throw new Error("destination gpu data for memcpy does not exist");
            if (n2.originalSize !== r2.originalSize)
              throw new Error("inconsistent source and destination gpu data size");
            const i2 = o(n2.originalSize), a2 = this.backend.getCommandEncoder();
            this.backend.endComputePass(), a2.copyBufferToBuffer(n2.gpuData.buffer, 0, r2.gpuData.buffer, 0, i2);
          }
          create(e2, t2 = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
            const n2 = o(e2);
            let s2;
            if ((t2 & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
              let e3 = this.freeBuffers.get(n2);
              e3 || (e3 = [], this.freeBuffers.set(n2, e3)), s2 = e3.length > 0 ? e3.pop() : this.backend.device.createBuffer({ size: n2, usage: t2 });
            } else
              s2 = this.backend.device.createBuffer({ size: n2, usage: t2 });
            const u = { id: a++, type: i.GpuDataType.default, buffer: s2 };
            return this.storageCache.set(u.id, { gpuData: u, originalSize: e2 }), (0, r.LOG_DEBUG)("verbose", () => `[WebGPU] GpuDataManager.create(size=${e2}) => id=${u.id}`), u;
          }
          get(e2) {
            var t2;
            return null === (t2 = this.storageCache.get(e2)) || void 0 === t2 ? void 0 : t2.gpuData;
          }
          release(e2) {
            const t2 = this.storageCache.get(e2);
            if (!t2)
              throw new Error("releasing data does not exist");
            return (0, r.LOG_DEBUG)("verbose", () => `[WebGPU] GpuDataManager.release(id=${e2}), gpuDataId=${t2.gpuData.id}`), this.storageCache.delete(e2), this.buffersPending.push(t2.gpuData.buffer), this.downloadCache.get(e2) && this.downloadCache.delete(e2), t2.originalSize;
          }
          async download(e2) {
            const t2 = this.downloadCache.get(e2);
            if (t2)
              return t2.data;
            const n2 = this.storageCache.get(e2);
            if (!n2)
              throw new Error("data does not exist");
            const r2 = this.backend.getCommandEncoder();
            this.backend.endComputePass();
            const i2 = o(n2.originalSize), a2 = this.backend.device.createBuffer({ size: i2, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
            r2.copyBufferToBuffer(n2.gpuData.buffer, 0, a2, 0, i2), this.backend.flush();
            const s2 = new Promise((e3) => {
              a2.mapAsync(GPUMapMode.READ).then(() => {
                const t3 = a2.getMappedRange().slice(0);
                a2.destroy(), e3(t3);
              });
            });
            return this.downloadCache.set(e2, { data: s2 }), s2;
          }
          refreshPendingBuffers() {
            for (const e2 of this.buffersForUploadingPending)
              e2.destroy();
            this.buffersForUploadingPending = [];
            for (const e2 of this.buffersPending)
              (e2.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE ? this.freeBuffers.get(e2.size).push(e2) : e2.destroy();
            this.buffersPending = [];
          }
          dispose() {
            this.freeBuffers.forEach((e2) => {
              e2.forEach((e3) => {
                e3.destroy();
              });
            }), this.storageCache.forEach((e2) => {
              e2.gpuData.buffer.destroy();
            }), this.storageCache = /* @__PURE__ */ new Map(), this.downloadCache = /* @__PURE__ */ new Map(), this.freeBuffers = /* @__PURE__ */ new Map();
          }
        }
        t.createGpuDataManager = (...e2) => new s(...e2);
      }, 8510: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var i2 = Object.getOwnPropertyDescriptor(t2, n2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, i2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), o = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return i(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WEBGPU_OP_RESOLVE_RULES = void 0;
        const a = n(1868), s = o(n(504)), u = n(513), l = n(9770), c = n(7640), p = n(8856), d = n(8405), f = n(4271), h = n(1798), g = n(2915), m = n(1522), b = o(n(5262)), y = n(6031), v = n(4566), w = n(8906), x = n(5101), _ = n(6198), T = n(2067), S = n(8699), $ = n(2625), O = o(n(9302));
        t.WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([["Abs", [O.abs]], ["Acos", [O.acos]], ["Acosh", [O.acosh]], ["Add", [s.add]], ["ArgMax", [a.argMax, a.parseArgMinMaxAttributes]], ["ArgMin", [a.argMin, a.parseArgMinMaxAttributes]], ["Asin", [O.asin]], ["Asinh", [O.asinh]], ["Atan", [O.atan]], ["Atanh", [O.atanh]], ["AveragePool", [b.averagePool, b.parseAveragePoolAttributes]], ["Cast", [O.cast, O.parseCastAttributes]], ["Ceil", [O.ceil]], ["ClipV10", [O.clipV10]], ["Clip", [O.clip]], ["Concat", [u.concat, u.parseConcatAttributes]], ["Conv", [l.conv, l.parseConvAttributes]], ["ConvTranspose", [c.convTranspose, c.parseConvTransposeAttributes]], ["Cos", [O.cos]], ["Cosh", [O.cosh]], ["Div", [s.div]], ["Elu", [O.elu, O.parseAlphaAttributes]], ["Erf", [O.erf]], ["Exp", [O.exp]], ["Expand", [p.expand]], ["Floor", [O.floor]], ["Gather", [d.gather, d.parseGatherAttributes]], ["Gelu", [O.gelu]], ["Gemm", [f.gemm, f.parseGemmAttributes]], ["GlobalAveragePool", [b.globalAveragePool, b.parseGlobalAveragePoolAttributes]], ["GlobalMaxPool", [b.globalMaxPool, b.parseGlobalMaxPoolAttributes]], ["InstanceNormalization", [h.instanceNorm, h.parseInstanceNormAttributes]], ["LayerNormalization", [g.layerNorm, g.parseLayerNormAttributes]], ["LeakyRelu", [O.leakyRelu, O.parseAlphaAttributes]], ["Log", [O.log]], ["MatMul", [m.matMul]], ["MaxPool", [b.maxPool, b.parseMaxPoolAttributes]], ["Mul", [s.mul]], ["Neg", [O.neg]], ["Pow", [s.pow]], ["Reciprocal", [O.reciprocal]], ["ReduceMin", [y.reduceMin, y.parseReduceAttributes]], ["ReduceMean", [y.reduceMean, y.parseReduceAttributes]], ["ReduceMax", [y.reduceMax, y.parseReduceAttributes]], ["ReduceSum", [y.reduceSum, y.parseReduceAttributes]], ["ReduceProd", [y.reduceProd, y.parseReduceAttributes]], ["ReduceL1", [y.reduceL1, y.parseReduceAttributes]], ["ReduceL2", [y.reduceL2, y.parseReduceAttributes]], ["ReduceLogSum", [y.reduceLogSum, y.parseReduceAttributes]], ["ReduceLogSumExp", [y.reduceLogSumExp, y.parseReduceAttributes]], ["ReduceSumSquare", [y.reduceSumSquare, y.parseReduceAttributes]], ["Relu", [O.relu]], ["Resize", [v.resize, v.parseResizeAttributes]], ["Sigmoid", [O.sigmoid]], ["Sin", [O.sin]], ["Sinh", [O.sinh]], ["Slice", [x.slice, x.parseSliceAttributes]], ["SkipLayerNormalization", [w.skipLayerNorm, w.parseSkipLayerNormAttributes]], ["Split", [T.split, T.parseSplitAttributes]], ["Sqrt", [O.sqrt]], ["Softmax", [_.softmax, _.parseSoftmaxAttributes]], ["Sub", [s.sub]], ["Tan", [O.tan]], ["Tanh", [O.tanh]], ["ThresholdedRelu", [O.thresholdedRelu, O.parseAlphaAttributes]], ["Tile", [S.tile]], ["Transpose", [$.transpose, $.parseTransposeAttributes]]]);
      }, 1427: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.biasActivationSnippet = t.activationFnSnippet = t.typeSnippet = void 0, t.typeSnippet = (e2) => {
          switch (e2) {
            case 1:
              return "f32";
            case 2:
              return "vec2<f32>";
            case 3:
              return "vec3<f32>";
            case 4:
              return "vec4<f32>";
            default:
              throw new Error(`${e2}-component is not supported.`);
          }
        }, t.activationFnSnippet = (e2, t2 = false, n = false, r = 3) => "", t.biasActivationSnippet = (e2, t2) => `
      ${e2 ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${t2 ? "value = activation(value, coords);" : ""}
      `;
      }, 9456: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createConv2DMatMulProgramInfo = void 0;
        const r = n(4955), i = n(6952), o = n(1163), a = n(1427), s = n(4085), u = n(158);
        t.createConv2DMatMulProgramInfo = (e2, t2, n2, l, c, p, d, f, h) => {
          const g = "NHWC" === n2.format, m = g ? e2[0].dims[3] : e2[0].dims[1], b = l[0], y = g ? l[2] : l[3], v = g ? l[1] : l[2], w = g ? l[3] : l[1], x = ((m % 4 == 0 || m % 3 == 0) && g || y % 4 == 0 && !g) && w % 4 == 0, _ = g ? w : y * v, T = g ? y * v : w, S = x ? [8, 8, 1] : [_ <= 4 ? 4 : 16, _ > 4 && T <= 4 ? 4 : 16, 1], $ = x ? [4, 4, 1] : [_ <= 4 ? 1 : 2, _ > 4 && T <= 4 ? 1 : 2, 1], O = [Math.ceil(_ / S[0] / $[0]), Math.ceil(T / S[1] / $[1]), Math.ceil(b / S[2] / $[1])];
          (0, r.LOG_DEBUG)("verbose", () => `[conv2d_mm_webgpu] dispatch = ${O}`);
          const A = x ? g && m % 4 != 0 ? 3 : 4 : $[0], P = S[1] * $[1], I = S[0] * $[0], E = Math.max(S[0] * A, S[1]), C2 = c % P == 0, D = p % I == 0, k = d % E == 0, R = x ? [A, 4, 4] : [1, 1, 1], M = [`@group(0) @binding(0) var<storage, read> x: array<${x && 4 === A ? "vec4<f32>" : "f32"}>;`, `@group(0) @binding(1) var<storage, read> w: array<${x ? "vec4<f32>" : "f32"}>;`];
          let j = `
      fn setOutputAtIndex(flatIndex : i32, value : ${x ? "vec4<f32>" : "f32"}) {
        result[flatIndex] = ${x ? "vec4<f32>" : "f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${x ? "vec4<f32>" : "f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${x ? "/ 4" : ""}, value);
      }`;
          return f && (M.push(`@group(0) @binding(2) var<storage, read> bias: array<${x ? "vec4<f32>" : "f32"}>;`), j += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${x ? "vec4<f32>" : "f32"} {
          return bias[coords.${g ? "w" : "y"}${x ? "/ 4" : ""}];
        }`), Object.assign(Object.assign({}, t2), { outputs: [{ dims: l, dataType: e2[0].dataType, gpuDataType: o.GpuDataType.default }], dispatchGroup: () => ({ x: O[0], y: O[1], z: O[2] }), getShaderSource: () => `
        ${s.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${M.join("")}
        @group(0) @binding(${M.length}) var<storage, read_write> result: array<${x ? "vec4<f32>" : "f32"}>;
        //@group(0) @binding(${M.length + 1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${e2[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e2[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${l.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${i.ShapeUtil.computeStrides(l).slice(0, 3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${n2.kernelShape[0]}, ${n2.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${n2.pads[0]}, ${n2.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${n2.strides[0]}, ${n2.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${n2.dilations[0]}, ${n2.dilations[1]});
        const dimAOuter : i32 = ${c};
        const dimBOuter : i32 = ${p};
        const dimInner : i32 = ${d};
        ${j}
        ${((e3, t3, n3, r2, i2 = false, o2, s2 = false, u2 = 4, l2 = 4, c2 = 4) => {
            const p2 = e3 ? "\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    " : "\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ", d2 = e3 ? "\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    " : "\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ", f2 = e3 ? "xShape[1]" : "xShape[2]", h2 = e3 ? "xShape[2]" : "xShape[3]", g2 = e3 ? "row" : "col", m2 = e3 ? "col" : "row", b2 = `
    let inChannels = wShape[2];
    let outWidth = ${e3 ? "outShape[2]" : "outShape[3]"};
    let outRow = ${g2} / outWidth;
    let outCol = ${g2} % outWidth;

    let WRow = ${m2} / (filterDims[1] * inChannels);
    let WCol = ${m2} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${m2} % inChannels;
    var resData = ${(0, a.typeSnippet)(u2)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${f2} && xCol >= 0 && xCol < ${h2}) {
      ${p2}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${((e4) => {
              switch (e4) {
                case 1:
                  return "resData = x[xIndex];";
                case 3:
                  return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";
                case 4:
                  return "resData = x[xIndex / 4];";
                default:
                  throw new Error(`innerElementSize ${e4} is not supported.`);
              }
            })(u2)}
    }
    return resData;`, y2 = e3 ? t3 && r2 ? `
    let col = colIn * ${u2};
    ${b2}` : `
    let col = colIn * ${u2};
    if (row < dimAOuter && col < dimInner) {
      ${b2}
    }
    return ${(0, a.typeSnippet)(u2)}(0.0);` : r2 && n3 ? `
    let col = colIn * ${u2};
    ${b2}` : `
    let col = colIn * ${u2};
    if (row < dimInner && col < dimBOuter) {
      ${b2}
    }
    return ${(0, a.typeSnippet)(u2)}(0.0);`, v2 = `${((e4) => {
              switch (e4) {
                case 1:
                  return "return w[row * wShape[3] + colIn];";
                case 4:
                  return "return w[row * wShape[3] / 4 + colIn];";
                default:
                  throw new Error(`innerElementSize ${e4} is not supported.`);
              }
            })(l2)}`, w2 = (0, a.typeSnippet)(c2), x2 = e3 ? (0, a.typeSnippet)(u2) : (0, a.typeSnippet)(l2), _2 = e3 ? (0, a.typeSnippet)(l2) : (0, a.typeSnippet)(u2);
            return `
    ${(0, a.activationFnSnippet)(o2, s2, 4 === c2, 4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${x2} {
      ${e3 ? y2 : v2}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${_2} {
      ${e3 ? v2 : y2}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w2}) {
      let col = colIn * ${c2};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e3 ? "outShape[2]" : "outShape[3]"};
      ${d2}
      ${(0, a.biasActivationSnippet)(i2, o2)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
          })(g, C2, D, k, f, void 0, false, R[0], R[1], R[2])}
            ${x ? (0, u.makeMatMulPackedVec4Source)($, S, !g, E) : (0, u.makeMatMulPackedSource)($, S, !g, E, false, void 0, h)}` });
        };
      }, 6514: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createConvTranspose2DProgramInfo = void 0;
        const r = n(4955), i = n(6952), o = n(1163), a = n(2075);
        t.createConvTranspose2DProgramInfo = (e2, t2, n2, s) => {
          const u = e2.length > 2, l = n2.outputShape, c = i.ShapeUtil.size(l), p = [Math.ceil(c / 64), 1, 1];
          return (0, r.LOG_DEBUG)("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${p}`), Object.assign(Object.assign({}, t2), { outputs: [{ dims: s ? s(l) : l, dataType: e2[0].dataType, gpuDataType: o.GpuDataType.default }], dispatchGroup: () => ({ x: p[0], y: p[1], z: p[2] }), getShaderSource: (t3) => ((e3, t4, n3, r2, o2, s2, u2 = false) => {
            const l2 = "NHWC" === n3.format, c2 = l2 ? 1 : 2, p2 = l2 ? 2 : 3, d = l2 ? 3 : 1, f = i.ShapeUtil.size(r2), h = u2 ? 2 : 1, g = n3.group, m = t4[1].dims, b = m[0] / g, y = m[1];
            let v = `
  fn setOutputAtIndex(flatIndex : u32, value : ${u2 ? "vec4<f32>" : "f32"}) {
    result[flatIndex] = ${u2 ? "vec4<f32>" : "f32"}(value);
  }`;
            o2 && (v += `
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u2 ? "vec4<f32>" : "f32"} {
      return bias[coords.${l2 ? "w" : "y"}${u2 ? "/ 4" : ""}];
    }`);
            const w = u2 ? 4 : 1, x = (0, a.inputVariable)("W", t4[1].dataType, t4[1].dims, w), _ = (0, a.inputVariable)("Dy", t4[0].dataType, t4[0].dims, w), T = [_, x];
            o2 && T.push((0, a.inputVariable)("bias", t4[2].dataType, [r2[d]], w));
            const S = (0, a.outputVariable)("result", t4[0].dataType, r2, w), $ = `{
        let batch: u32 = ${s2 ? "global_id.z" : "workgroup_id.z"} / outShape[1];
        let r = ${s2 ? "global_id.z" : "workgroup_id.z"} % outShape[1];
        let c = ${s2 ? "global_id.y" : "workgroup_id.y"} * ${h};
        let d1: u32 = ${s2 ? "global_id.x" : "workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<f32>, ${h}>;
        for (var i = 0; i < ${h}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (f32(dyCorner.x) + f32(wR)) / f32(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (f32(dyCorner.y) + f32(wC)) / f32(strides.y);
            let dyC2 = (f32(dyCorner.y) + 1.0 + f32(wC)) / f32(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= f32(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= f32(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${_.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<f32>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${_.get("batch", "idyR", "idyC2", "d2")};

                dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${d}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${_.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<f32>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${x.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${_.get("batch", "idyR", "idyC2", "d2")};
                let tmpval = vec4<f32>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${h}; i = i + 1) {
          let value = dotProd[i] + ${o2 ? "bias[c+i]" : "0.0"};
          ${S.set("batch", "r", "c + i", "d1", "value")};
        }
      }`, O = `
          let outputIndices = ${S.offsetToIndices("global_idx")};
          let batch = ${S.indicesGet("outputIndices", 0)};
          let d1 = ${S.indicesGet("outputIndices", d)};
          let r = ${S.indicesGet("outputIndices", c2)};
          let c = ${S.indicesGet("outputIndices", p2)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${y};
          let wOutChannel = d1 - groupId * ${y};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (f32(dyRCorner) + f32(wR)) / f32(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= f32(outBackprop[${c2}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (f32(dyCCorner) + f32(wC)) / f32(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= f32(outBackprop[${p2}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);

              for (var d2: u32 = 0; d2 < ${b}; d2 = d2 + 1) {
                let inputChannel = groupId * ${b} + d2;
                let xValue = ${l2 ? _.get("batch", "idyR", "idyC", "inputChannel") : _.get("batch", "inputChannel", "idyR", "idyC")};
                let wValue = ${x.get("inputChannel", "wOutChannel", "u32(wRPerm)", "u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
              }
            }
          }
          let value = dotProd + ${o2 ? "bias[d1]" : "0.0"};
          ${S.setByOffset("global_idx", "value")};
        `;
            return `
  ${e3.declareVariables(...T, S)}
  ${v}
  const outShape : vec4<u32> = vec4<u32>(${r2.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${t4[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${n3.strides[0]}, ${n3.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${n3.kernelShape[l2 ? 1 : 2]}, ${n3.kernelShape[l2 ? 2 : 3]});
  const dilations : vec2<u32> = vec2<u32>(${n3.dilations[0]}, ${n3.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${n3.dilations[0] <= 1 ? 0 : (n3.kernelShape[l2 ? 1 : 2] - 1) * (n3.dilations[0] - 1)},
          ${n3.dilations[1] <= 1 ? 0 : (n3.kernelShape[l2 ? 2 : 3] - 1) * (n3.dilations[1] - 1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n3.pads[0] + n3.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${n3.pads[1] + n3.pads[3]})/2);
    ${e3.mainStart()}
    ${e3.guardAgainstOutOfBoundsWorkgroupSizes(f)};
  ${u2 ? $ : O}}`;
          })(t3, e2, n2, l, u, 1 === p[1] && 1 === p[2]) });
        };
      }, 4085: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.utilFunctions = void 0, t.utilFunctions = "\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n";
      }, 158: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.makeMatMulPackedSource = t.makeMatMulPackedVec4Source = void 0, t.makeMatMulPackedVec4Source = (e2, t2, n2 = false, r = 32, i = false, o = 32, a = false) => {
          const s = t2[1] * e2[1], u = t2[0] * e2[0], l = n2 ? s : r, c = n2 ? r : s, p = l / t2[0], d = r / t2[1];
          if ((!n2 || 4 !== p || 4 !== e2[1]) && (n2 || 3 !== p && 4 !== p) || l % t2[0] != 0 || r % t2[1] != 0 || 4 !== e2[0])
            throw new Error(`If transposeA ${n2} is true, innerElementSize ${p} and workPerThread[1] ${e2[1]} must be 4.
      Otherwise, innerElementSize ${p} must be 3 or 4.
  tileAWidth ${l} must be divisible by workgroupSize[0]${t2[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t2[1]}. colPerThread ${e2[0]} must be 4.`);
          return `
var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${l / p}>, ${c}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u / e2[0]}>, ${r}>;

const rowPerThread = ${e2[1]};
const colPerThread = ${e2[0]};
const innerElementSize = ${p};
const tileInner = ${r};

@compute @workgroup_size(${t2[0]}, ${t2[1]}, ${t2[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${a ? "0" : "localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${a ? "0" : "i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${i ? "0" : "i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${s};

  let numTiles = ${i ? `${Math.ceil(o / r)}` : "(dimInner - 1) / tileInner + 1"};
  var kStart = ${i ? `i32(globalId.z) * ${o}` : "0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${d};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${f = n2, f ? "\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol);\n        " : "\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol);\n        "}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${3 === p ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${/* @__PURE__ */ ((e3, t3) => e3 ? `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${3 === t3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${3 === t3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }` : `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${3 === t3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(n2, p)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
          var f;
        };
        const n = (e2) => e2 ? "\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol);\n            " : "\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol);\n            ";
        t.makeMatMulPackedSource = (e2, t2, r = false, i = 32, o = false, a = 32, s = false) => {
          const u = e2[1] * t2[1], l = e2[0] * t2[0], c = r ? u : i, p = r ? i : u;
          if (p % t2[1] != 0 || c % t2[0] != 0 || i % t2[1] != 0)
            throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t2[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t2[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t2[1]}`);
          const d = p / t2[1], f = c / t2[0], h = i / t2[1], g = s ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${u};
    let globalColStart = i32(workgroupId.x) * ${l};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t2[1]}) {
        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t2[0]}) {
          ${n(r)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t2[1]}) {
            for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t2[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t2[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${r ? `mm_Asub[k][localRow + innerRow * ${t2[1]}];` : `mm_Asub[localRow + innerRow * ${t2[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t2[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t2[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${u};

let tileRowA = i32(localId.y) * ${d};
let tileColA = i32(localId.x) * ${f};
let tileRowB = i32(localId.y) * ${h};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${n(r)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${/* @__PURE__ */ ((e3) => e3 ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];")(r)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
          return `
  var<workgroup> mm_Asub : array<array<f32, ${c}>, ${p}>;
  var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${i}>;
  const rowPerThread = ${e2[1]};
  const colPerThread = ${e2[0]};
  const tileInner = ${i};

@compute @workgroup_size(${t2[0]}, ${t2[1]}, ${t2[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${o ? "0" : "i32(globalId.z)"};
    let numTiles = ${o ? `${Math.ceil(a / i)}` : "(dimInner - 1) / tileInner + 1"};
    var kStart = ${o ? `i32(globalId.z) * ${a}` : "0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${g}
  }
`;
        };
      }, 1868: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseArgMinMaxAttributes = t.argMax = t.argMin = void 0;
        const r = n(387), i = n(1163), o = n(6031), a = (e2) => {
          if (!e2 || 0 === e2.length || e2.length > 2)
            throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
          if (1 !== e2[0].dataType)
            throw new Error("Invalid input type.");
        }, s = (e2, t2, n2, a2) => {
          const s2 = 1 === e2.length ? n2 : ((e3, t3) => (0, r.createAttributeWithCacheKey)({ axis: t3.axis, keepDims: t3.keepDims, selectLastIndex: t3.selectLastIndex }))(0, n2), u = s2.cacheKey + e2.map((e3) => e3.dims.toString()).join("_"), l = { name: t2, inputTypes: [i.GpuDataType.default], cacheHint: u };
          return Object.assign(Object.assign({}, l), { get: () => (0, o.createReduceProgramInfo)(l, [e2[0]], a2, [s2.axis], 7, s2.keepDims) });
        };
        t.argMin = (e2, t2) => {
          a(e2.inputs), e2.compute(s(e2.inputs, "ArgMin", t2, (e3, n2, r2) => {
            const i2 = [];
            for (let t3 = 0; t3 < e3.shape.length; t3++)
              (r2.indexOf(t3) >= 0 || 0 === r2.length) && i2.push(`inputIndices[${t3}] = 0;`);
            return [`${i2.join("\n")}`, `var value = ${e3.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`, `if (${e3.getByOffset("inputOffset")} ${t2.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${e3.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`, "", n2.setByOffset("global_idx", "bestIndex")];
          }), { inputs: [0] });
        }, t.argMax = (e2, t2) => {
          a(e2.inputs), e2.compute(s(e2.inputs, "argMax", t2, (e3, n2, r2) => {
            const i2 = [];
            for (let t3 = 0; t3 < e3.shape.length; t3++)
              (r2.indexOf(t3) >= 0 || 0 === r2.length) && i2.push(`inputIndices[${t3}] = 0;`);
            return [`${i2.join("\n")}`, `var value = ${e3.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`, `if (${e3.getByOffset("inputOffset")} ${t2.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${e3.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`, "", n2.setByOffset("global_idx", "bestIndex")];
          }), { inputs: [0] });
        }, t.parseArgMinMaxAttributes = (e2) => (0, r.createAttributeWithCacheKey)(e2);
      }, 504: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.sub = t.pow = t.mul = t.div = t.add = void 0;
        const r = n(6952), i = n(1163), o = n(2075), a = (e2, t2, n2, a2, s) => {
          const u = { name: t2, inputTypes: [i.GpuDataType.default, i.GpuDataType.default], cacheHint: s };
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, a3, s2, u2 = t3.dataType) => {
            var l, c;
            const p = !r.ShapeUtil.areEqual(t3.dims, n3.dims);
            let d = t3.dims, f = r.ShapeUtil.size(t3.dims), h = false;
            if (p) {
              const e4 = r.BroadcastUtil.calcShape(t3.dims, n3.dims, false);
              if (!e4)
                throw new Error("Can't perform binary op on the given tensors");
              d = e4, f = r.ShapeUtil.size(d);
              let i2 = 1;
              for (let e5 = 0; e5 < d.length; e5++) {
                const r2 = null !== (l = t3.dims[t3.dims.length - e5]) && void 0 !== l ? l : 1;
                if (r2 !== (null !== (c = n3.dims[n3.dims.length - e5]) && void 0 !== c ? c : 1))
                  break;
                i2 *= r2;
              }
              i2 % 4 == 0 && (h = true);
            } else
              h = true;
            return Object.assign(Object.assign({}, e3), { getShaderSource: (e4) => ((e5, t4, n4, i2, a4, s3, u3, l2, c2, p2, d2) => {
              const f2 = r.ShapeUtil.size(i2), h2 = Math.ceil(f2 / 4);
              let g, m;
              "string" == typeof u3 ? g = m = (e6, t5) => `${u3}((${e6}),(${t5}))` : "function" == typeof u3 ? g = m = u3 : (g = u3.scalar, m = u3.vector);
              let b = "";
              const y = (0, o.outputVariable)("outputData", p2, i2, 4), v = (0, o.inputVariable)("aData", l2, t4, 4), w = (0, o.inputVariable)("bData", c2, n4, 4);
              if (s3) {
                const e6 = (e7) => {
                  const t5 = r.ShapeUtil.computeStrides(e7), n5 = [];
                  for (let r2 = e7.length - 1; r2 >= 0; r2--) {
                    const o2 = 0 === i2.length ? "0u" : 1 === i2.length ? "outputIndices" : `outputIndices[${r2 + i2.length - e7.length}]`;
                    n5.push(`${t5[r2]}u * (${o2} % ${e7[r2]}u)`);
                  }
                  return n5.length > 0 ? n5.join("+") : "0u";
                };
                b = `
  fn calcOffsetA(outputIndices: ${y.type.indices}) -> u32 {
    return ${e6(t4)};
  }

  fn calcOffsetB(outputIndices: ${y.type.indices}) -> u32 {
    return ${e6(n4)};
  }
  `;
              }
              let x;
              if (a4)
                x = s3 ? `
      let outputIndices = ${y.offsetToIndices("global_idx * 4u")};
      let offsetA = calcOffsetA(outputIndices);
      let offsetB = calcOffsetB(outputIndices);
      ${y.setByOffset("global_idx", m(v.getByOffset("offsetA / 4u"), w.getByOffset("offsetB / 4u")))}` : y.setByOffset("global_idx", m(v.getByOffset("global_idx"), w.getByOffset("global_idx")));
              else {
                if (!s3)
                  throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
                const e6 = (e7) => {
                  const t5 = `aData[indexA${e7}][componentA${e7}]`, n5 = `bData[indexB${e7}][componentB${e7}]`;
                  return `
      let outputIndices${e7} = ${y.offsetToIndices(`global_idx * 4u + ${e7}u`)};
      let offsetA${e7} = calcOffsetA(outputIndices${e7});
      let offsetB${e7} = calcOffsetB(outputIndices${e7});
      let indexA${e7} = offsetA${e7} / 4u;
      let indexB${e7} = offsetB${e7} / 4u;
      let componentA${e7} = offsetA${e7} % 4u;
      let componentB${e7} = offsetB${e7} % 4u;
      outputData[global_idx][${e7}] = ${g(t5, n5)};`;
                };
                x = `
      ${e6(0)}
      ${e6(1)}
      ${e6(2)}
      ${e6(3)}`;
              }
              return `
  ${e5.declareVariables(v, w, y)}

  ${null != d2 ? d2 : ""}
  ${b}

  ${e5.mainStart()}
    ${e5.guardAgainstOutOfBoundsWorkgroupSizes(h2)}
    ${x}
  }`;
            })(e4, t3.dims, n3.dims, d, h, p, a3, t3.dataType, n3.dataType, u2, s2), outputs: [{ dims: d, dataType: u2, gpuDataType: i.GpuDataType.default }], dispatchGroup: () => ({ x: Math.ceil(f / 64 / (h ? 4 : 1)) }) });
          })(u, e2[0], e2[1], n2, a2) });
        };
        t.add = (e2) => {
          e2.compute(a(e2.inputs, "Add", (e3, t2) => `${e3}+${t2}`));
        }, t.div = (e2) => {
          e2.compute(a(e2.inputs, "Div", (e3, t2) => `${e3}/${t2}`));
        }, t.mul = (e2) => {
          e2.compute(a(e2.inputs, "Mul", (e3, t2) => `${e3}*${t2}`));
        }, t.pow = (e2) => {
          const t2 = (0, o.inputVariable)("input", e2.inputs[0].dataType, e2.inputs[0].dims).type.value, n2 = "i32" === t2 ? "round" : "";
          e2.compute(a(e2.inputs, "Pow", { scalar: (e3, t3) => `pow_custom(${e3},${t3})`, vector: (e3, t3) => `pow_vector_custom(${e3},${t3})` }, `
    fn pow_custom(a : ${t2}, b : ${t2}) -> ${t2} {
      if (b == ${t2}(0.0)) {
        return ${t2}(1.0);
      } else if (a < ${t2}(0.0) && f32(b) != floor(f32(b))) {
        return ${t2}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t2}(1.0), round(f32(abs(b) % ${t2}(2.0))) != 1.0) * ${t2}(${n2}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t2}>, b : vec4<${t2}>) -> vec4<${t2}> {
      // TODO: implement vectorized pow
      return vec4<${t2}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `));
        }, t.sub = (e2) => {
          e2.compute(a(e2.inputs, "Sub", (e3, t2) => `${e3}-${t2}`));
        };
      }, 2075: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createShaderHelper = t.outputVariable = t.inputVariable = t.tensorTypeToWsglStorageType = t.WORKGROUP_SIZE = void 0;
        const r = n(6952);
        t.WORKGROUP_SIZE = 64;
        const i = (e2, t2) => {
          switch (e2) {
            case 1:
              return t2 > 1 ? `vec${t2}<f32>` : "f32";
            case 6:
              return t2 > 1 ? `vec${t2}<i32>` : "i32";
            case 12:
              return t2 > 1 ? `vec${t2}<u32>` : "u32";
            case 7:
              if (t2 > 1)
                throw new Error("currently not supported vecX of uint64 yet");
              return ["vec2<u32>", "i32"];
            case 13:
              if (t2 > 1)
                throw new Error("currently not supported vecX of uint64 yet");
              return ["vec2<u32>", "u32"];
            case 9:
              if (4 !== t2)
                throw new Error("bool must be vec4");
              return ["u32", "vec4<bool>"];
            default:
              throw new Error(`Unknown data type: ${e2}`);
          }
        };
        t.tensorTypeToWsglStorageType = (e2, t2 = 1) => {
          const n2 = i(e2, t2);
          return "string" == typeof n2 ? n2 : n2[0];
        };
        const o = (e2, t2, n2, o2, a2) => {
          const s = n2.length, u = s < 2 ? "u32" : s <= 4 ? `vec${s}<u32>` : `array<u32, ${s}>`, l = i(t2, a2), c = "string" == typeof l ? l : l[1], p = "string" == typeof l ? l : l[0], d = { indices: u, value: c, storage: p, tensor: t2 }, f = (e3) => "string" == typeof e3 ? e3 : `${e3}u`, h = { offsetToIndices: false, indicesToOffset: false, set: false, setByIndices: false, get: false, getByIndices: false }, g = r.ShapeUtil.computeStrides(n2);
          let m = "";
          for (let e3 = 0; e3 < s - 1; e3++)
            m += `
    let dim${e3} = current / ${g[e3]}u;
    let rest${e3} = current % ${g[e3]}u;
    indices[${e3}] = dim${e3};
    current = rest${e3};
    `;
          m += `indices[${s - 1}] = current;`;
          const b = s < 2 ? "" : `
  fn o2i_${e2}(offset: u32) -> ${d.indices} {
    var indices: ${d.indices};
    var current = offset;
    ${m}
    return indices;
  }`, y = [];
          if (s >= 2)
            for (let e3 = s - 1; e3 >= 0; e3--)
              y.push(`${g[e3]}u * (indices[${e3}])`);
          const v = s < 2 ? "" : `
  fn i2o_${e2}(indices: ${d.indices}) -> u32 {
    return ${y.join("+")};
  }`, w = (...e3) => 0 === s ? "0u" : `${d.indices}(${e3.map(f).join(",")})`, x = (t3, n3) => (() => {
            if (d.storage === d.value)
              return `${e2}[${t3}]=${n3};`;
            if ("vec2<u32>" === d.storage && "i32" === d.value)
              return `${e2}[${t3}]=vec2<u32>(u32(${n3}), select(0u, 0xFFFFFFFFu, ${n3} < 0));`;
            if ("vec2<u32>" === d.storage && "u32" === d.value)
              return `${e2}[${t3}]=vec2<u32>(u32(${n3}), 0u);`;
            if ("u32" === d.storage && "vec4<bool>" === d.value)
              return `${e2}[${t3}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n3}));`;
            throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`);
          })(), _ = (t3) => (() => {
            if (d.storage === d.value)
              return `${e2}[${t3}]`;
            if ("vec2<u32>" === d.storage && "i32" === d.value)
              return `i32(${e2}[${t3}].x)`;
            if ("vec2<u32>" === d.storage && "u32" === d.value)
              return `u32(${e2}[${t3}].x)`;
            if ("u32" === d.storage && "vec4<bool>" === d.value)
              return `vec4<bool>(bool(${e2}[${t3}] & 0xFFu), bool(${e2}[${t3}] & 0xFF00u), bool(${e2}[${t3}] & 0xFF0000u), bool(${e2}[${t3}] & 0xFF000000u))`;
            throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`);
          })(), T = s < 2 ? "" : `
  fn get_${e2}ByIndices(indices: ${d.indices}) -> ${c} {
    return ${e2}[i2o_${e2}(indices)];
  }`, S = s < 2 ? "" : (() => {
            const t3 = n2.map((e3, t4) => `d${t4}: u32`).join(", "), r2 = n2.map((e3, t4) => `d${t4}`).join(", ");
            return `
  fn get_${e2}(${t3}) -> ${c} {
    return get_${e2}ByIndices(${w(r2)});
  }`;
          })(), $ = s < 2 ? "" : `
  fn set_${e2}ByIndices(indices: ${d.indices}, value: ${c}) {
    ${x(`i2o_${e2}(indices)`, "value")}
  }`, O = s < 2 ? "" : (() => {
            const t3 = n2.map((e3, t4) => `d${t4}: u32`).join(", "), r2 = n2.map((e3, t4) => `d${t4}`).join(", ");
            return `
  fn set_${e2}(${t3}, value: ${c}) {
    set_${e2}ByIndices(${w(r2)}, value);
  }`;
          })();
          return { impl: () => {
            const e3 = [];
            return h.offsetToIndices && e3.push(b), h.indicesToOffset && e3.push(v), h.set && e3.push(O), h.setByIndices && e3.push($), h.get && e3.push(S), h.getByIndices && e3.push(T), e3.join("\n");
          }, type: d, offsetToIndices: (t3) => (h.offsetToIndices = true, s < 2 ? t3 : `o2i_${e2}(${t3})`), indicesToOffset: (t3) => (h.indicesToOffset = true, s < 2 ? t3 : `i2o_${e2}(${t3})`), indices: w, indicesGet: (e3, t3) => s < 2 ? `${e3}` : `${e3}[${t3}]`, indicesSet: (e3, t3, n3) => s < 2 ? `${e3}=${n3};` : `${e3}[${t3}]=${n3};`, set: (...t3) => {
            if (t3.length !== s + 1)
              throw new Error(`indices length must be ${s}`);
            const n3 = t3[s];
            if ("string" != typeof n3)
              throw new Error("value must be string");
            const r2 = t3.slice(0, s).map(f).join(",");
            return 0 === s ? x("0u", n3) : 1 === s ? x(r2[0], n3) : (h.set = true, h.setByIndices = true, h.indicesToOffset = true, `set_${e2}(${r2}, ${n3})`);
          }, setByOffset: x, setByIndices: (t3, n3) => s < 2 ? x(t3, n3) : (h.setByIndices = true, h.indicesToOffset = true, `set_${e2}ByIndices(${t3}, ${n3});`), get: (...t3) => {
            if (t3.length !== s)
              throw new Error(`indices length must be ${s}`);
            const n3 = t3.map(f).join(",");
            return 0 === s ? _("0u") : 1 === s ? _(n3[0]) : (h.get = true, h.getByIndices = true, h.indicesToOffset = true, `get_${e2}(${n3})`);
          }, getByOffset: _, getByIndices: (t3) => s < 2 ? _(t3) : (h.getByIndices = true, h.indicesToOffset = true, `get_${e2}ByIndices(${t3})`), usage: o2 ? "input" : "output", name: e2, shape: n2 };
        };
        t.inputVariable = (e2, t2, n2, r2 = 1) => o(e2, t2, n2, true, r2), t.outputVariable = (e2, t2, n2, r2 = 1) => o(e2, t2, n2, false, r2);
        class a {
          constructor(e2) {
            this.normalizedDispatchGroup = e2, this.indicesHelpers = [];
          }
          guardAgainstOutOfBoundsWorkgroupSizes(e2) {
            return `if (global_idx >= ${"number" == typeof e2 ? `${e2}u` : e2}) { return; }`;
          }
          mainStart(e2 = t.WORKGROUP_SIZE) {
            const n2 = "number" == typeof e2 ? e2 : e2[0], r2 = "number" == typeof e2 ? 1 : e2[1], i2 = "number" == typeof e2 ? 1 : e2[2], o2 = 1 === this.normalizedDispatchGroup[1] && 1 === this.normalizedDispatchGroup[2];
            return `@compute @workgroup_size(${n2}, ${r2}, ${i2})
  fn main(${o2 ? "@builtin(global_invocation_id) global_id : vec3<u32>" : "@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {
    ${o2 ? "let global_idx = global_id.x;" : `let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0] * this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${n2 * r2 * i2}u + local_index;`}
  `;
          }
          declareVariable(e2, t2) {
            this.indicesHelpers.push(e2);
            const n2 = "input" === e2.usage ? "read" : "read_write", r2 = e2.type.storage;
            return `@group(0) @binding(${t2}) var<storage, ${n2}> ${e2.name}: array<${r2}>;`;
          }
          declareVariables(...e2) {
            let t2 = 0;
            return e2.filter((e3) => r.ShapeUtil.size(e3.shape) > 0).map((e3) => this.declareVariable(e3, t2++)).join("\n");
          }
          get additionalImplementations() {
            return this.indicesHelpers.map((e2) => e2.impl()).join("\n");
          }
        }
        t.createShaderHelper = (e2) => new a(e2);
      }, 513: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseConcatAttributes = t.concat = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075);
        t.concat = (e2, t2) => {
          ((e3) => {
            if (!e3 || e3.length < 1)
              throw new Error("too few inputs");
            const t3 = e3[0].dataType, n2 = e3[0].dims.length;
            for (const r2 of e3) {
              if (r2.dataType !== t3)
                throw new Error("input tensors should be one type");
              if (r2.dims.length !== n2)
                throw new Error("input tensors should have the same shape");
            }
          })(e2.inputs), e2.compute(((e3, t3) => {
            const n2 = (i2 = e3.length, s = t3.cacheKey, { name: "Concat", inputTypes: Array(i2).fill(o.GpuDataType.default), cacheHint: s });
            var i2, s;
            return Object.assign(Object.assign({}, n2), { get: () => ((e4, t4, n3) => {
              const i3 = t4[0].dims.slice();
              if (n3 >= i3.length || n3 < -1 * i3.length)
                throw new Error("axis specified for concat doesn't match input dimensionality");
              const s2 = n3 < 0 ? i3.length + n3 : n3, u = i3.slice(0);
              for (let e5 = 1; e5 < t4.length; e5++) {
                const n4 = t4[e5].dims.slice();
                for (let e6 = 0; e6 < i3.length; e6++)
                  if (e6 === s2)
                    u[s2] += n4[e6];
                  else if (i3[e6] !== n4[e6])
                    throw new Error("non concat dimensions must match");
              }
              const l = r.ShapeUtil.size(u), c = new Array(t4.length), p = new Array(t4.length), d = t4[0].dataType;
              let f = 0;
              for (let e5 = 0; e5 < t4.length; ++e5)
                f += t4[e5].dims[s2], c[e5] = f, p[e5] = (0, a.inputVariable)(`input${e5}`, d, t4[e5].dims);
              const h = (0, a.outputVariable)("output", d, u), g = h.indicesGet("indices", s2);
              return Object.assign(Object.assign({}, e4), { outputs: [{ dims: u, dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e5) => {
                return `
  ${e5.declareVariables(...p, h)}

  const sizeInConcatAxis = array<u32, ${c.length}>(${c.map((e6) => `${e6}u`).join(",")});
  ${t5 = c.length, `
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t5}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t5}u;
  }`}

  ${e5.mainStart()}
    ${e5.guardAgainstOutOfBoundsWorkgroupSizes(l)}

    var indices = ${h.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${g});
    if (inputIndex != 0u) {
      ${g} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${((e6, t6) => {
                  const n4 = e6.length, r2 = [];
                  for (let i4 = 0; i4 < n4; ++i4) {
                    const o2 = t6.setByOffset("global_idx", e6[i4].getByIndices("indices"));
                    1 === n4 ? r2.push(o2) : 0 === i4 ? r2.push(`if (inputIndex == ${i4}u) { ${o2} }`) : i4 === n4 - 1 ? r2.push(`else { ${o2} }`) : r2.push(`else if (inputIndex == ${i4}) { ${o2} }`);
                  }
                  return r2.join("\n");
                })(p, h)}
  }`;
                var t5;
              }, dispatchGroup: () => ({ x: Math.ceil(l / 64) }) });
            })(n2, e3, t3.axis) });
          })(e2.inputs, t2));
        }, t.parseConcatAttributes = (e2) => (0, i.createAttributeWithCacheKey)({ axis: e2.axis });
      }, 9192: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createGroupedConvProgramInfoLoader = void 0;
        const r = n(6952), i = n(1163), o = n(2075), a = n(9770), s = n(3997);
        t.createGroupedConvProgramInfoLoader = (e2, t2, n2) => {
          const u = (l = e2.length > 2, c = t2.cacheKey, { name: "GroupedConv", inputTypes: l ? [i.GpuDataType.default, i.GpuDataType.default, i.GpuDataType.default] : [i.GpuDataType.default, i.GpuDataType.default], cacheHint: c });
          var l, c;
          return Object.assign(Object.assign({}, u), { get: () => ((e3, t3, n3, u2) => {
            const l2 = e3.length > 2, c2 = l2 ? "value += b[output_channel];" : "", p = e3[0].dims, d = e3[1].dims, f = d[0] / n3.group, { activationFunction: h, applyActivation: g } = (0, s.getActicationSnippet)(n3), m = "NHWC" === n3.format, b = (0, a.calculateOutputShape)(p, d, n3.dilations, n3.pads, n3.strides, m), y = r.ShapeUtil.size(b), v = (0, o.outputVariable)("output", e3[0].dataType, b), w = (0, o.inputVariable)("x", e3[0].dataType, p), x = (0, o.inputVariable)("w", e3[1].dataType, d), _ = [w, x];
            return l2 && _.push((0, o.inputVariable)("b", e3[2].dataType, e3[2].dims)), Object.assign(Object.assign({}, t3), { outputs: [{ dims: u2 ? u2(b) : b, dataType: e3[0].dataType, gpuDataType: i.GpuDataType.default }], getShaderSource: (e4) => `
  const strides: vec2<u32> = vec2(${n3.strides[0]}u, ${n3.strides[1]}u);
  const pads: vec2<u32> = vec2(${n3.pads[0]}u, ${n3.pads[1]}u);

  ${e4.declareVariables(..._, v)}

  ${h}

  ${e4.mainStart()}
    ${e4.guardAgainstOutOfBoundsWorkgroupSizes(y)}

    let outputIndices = ${v.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${m ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${m ? 1 : 2}], outputIndices[${m ? 2 : 3}]) * strides - pads;
    let group_id: u32 = output_channel / ${f}u;

    var value: ${v.type.value} = ${v.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${d[1]}u; wInChannel++) {
      let input_channel = group_id * ${d[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${d[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${n3.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${p[m ? 1 : 2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${d[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${n3.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${p[m ? 2 : 3]}u) {
            continue;
          }

          let xVal = ${m ? w.get("batch", "xHeight", "xWidth", "input_channel") : w.get("batch", "input_channel", "xHeight", "xWidth")};
          let wVal = ${x.get("output_channel", "wInChannel", "wHeight", "wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${c2}
    ${g}
    ${v.setByOffset("global_idx", "value")}
  }`, dispatchGroup: () => ({ x: Math.ceil(y / 64) }) });
          })(e2, u, t2, n2) });
        };
      }, 7640: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.convTranspose = t.parseConvTransposeAttributes = void 0;
        const r = n(387), i = n(1163), o = n(6514), a = n(3997), s = (e2, t2, n2, r2, i2, o2) => (e2 - 1) * t2 + n2 + (r2 - 1) * i2 + 1 - o2, u = (e2, t2, n2, r2, i2) => {
          const o2 = Math.floor(e2 / 2);
          "SAME_UPPER" === t2 ? (n2[r2] = o2, n2[i2] = e2 - o2) : "SAME_LOWER" === t2 && (n2[r2] = e2 - o2, n2[i2] = o2);
        }, l = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          if (0 === e2.kernelShape.length || 0 === e2.kernelShape.reduce((e3, t3) => e3 * t3, 0)) {
            n2.length = 0;
            for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
              n2.push(t2[1].dims[e3]);
          }
          const r2 = "NHWC" === e2.format;
          n2.splice(0, 0, t2[1].dims[0]), n2.splice(r2 ? 3 : 1, 0, t2[1].dims[1]);
          const i2 = e2.pads.slice(), o2 = e2.outputShape.slice(), a2 = e2.outputPadding.slice(), l2 = t2[0].dims;
          let c2 = e2.dilations.slice();
          if (0 === c2.reduce((e3, t3) => e3 + t3, 0)) {
            const e3 = t2[0].dims.length - 2;
            c2 = new Array(e3).fill(1);
          }
          let p = e2.strides.slice();
          if (0 === p.reduce((e3, t3) => e3 + t3, 0)) {
            const e3 = t2[0].dims.length - 2;
            p = new Array(e3).fill(1);
          }
          ((e3, t3, n3, r3, i3, o3, a3, l3, c3, p2) => {
            const d2 = e3.length - 2, f = 0 === p2.length;
            if (0 === c3.length)
              for (let e4 = 0; e4 < d2; ++e4)
                c3.push(0);
            const h = e3[0], g = t3[l3 ? 3 : 1] * i3;
            for (let i4 = 0, h2 = e3.length - d2 - (l3 ? 1 : 0); i4 < d2; ++i4, ++h2) {
              const l4 = e3[h2], g2 = f ? l4 * a3[i4] : p2[i4], m = s(l4, a3[i4], o3[i4], t3[h2], n3[i4], g2);
              u(m, r3, o3, i4, i4 + d2), f && p2.push(a3[i4] * (l4 - 1) + c3[i4] + (t3[h2] - 1) * n3[i4] + 1 - o3[i4] - o3[i4 + d2]);
            }
            p2.splice(0, 0, h), p2.splice(l3 ? 3 : 1, 0, g);
          })(l2, n2, c2, e2.autoPad, e2.group, i2, p, r2, a2, o2);
          const d = Object.assign({}, e2);
          return Object.assign(d, { kernelShape: n2, pads: i2, outputPadding: a2, outputShape: o2, dilations: c2, strides: p, cacheKey: e2.cacheKey }), d;
        };
        t.parseConvTransposeAttributes = (e2) => {
          const t2 = (0, a.parseInternalActivationAttributes)(e2), n2 = e2.format, i2 = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][void 0 === e2.autoPad ? 0 : e2.autoPad], o2 = e2.dilations, s2 = e2.group, u2 = e2.kernelShape, l2 = e2.pads, c2 = e2.strides, p = e2.wIsConst(), d = e2.outputPadding, f = e2.outputShape;
          return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, format: n2, dilations: o2, group: s2, kernelShape: u2, outputPadding: d, outputShape: f, pads: l2, strides: c2, wIsConst: p }, t2));
        };
        const c = (e2, t2, n2) => {
          const r2 = (a2 = 3 === e2.length, s2 = t2.cacheKey, { name: "ConvTranspose2D", inputTypes: a2 ? [i.GpuDataType.default, i.GpuDataType.default, i.GpuDataType.default] : [i.GpuDataType.default, i.GpuDataType.default], cacheHint: s2 });
          var a2, s2;
          return Object.assign(Object.assign({}, r2), { get: () => (0, o.createConvTranspose2DProgramInfo)(e2, r2, t2, n2) });
        };
        t.convTranspose = (e2, t2) => {
          ((e3, t3) => {
            if (!e3 || 2 !== e3.length && 3 !== e3.length)
              throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== e3[0].dims.length && 3 !== e3[0].dims.length)
              throw new Error("currently only support 2-dimensional conv");
            if (e3[0].dims.length !== e3[1].dims.length)
              throw new Error("filter does not have same dimension as input");
            if (e3[0].dims["NHWC" === t3.format ? e3[0].dims.length - 1 : 1] !== e3[1].dims[0])
              throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            const n2 = e3[1].dims[1] * t3.group;
            if (3 === e3.length && (1 !== e3[2].dims.length || e3[2].dims[0] !== n2))
              throw new Error("invalid bias");
            const r2 = e3[0].dims.length - 2;
            if (t3.dilations.reduce((e4, t4) => e4 + t4, 0) > 0 && t3.dilations.length !== r2)
              throw new Error(`dilations should be ${r2}D`);
            if (t3.strides.reduce((e4, t4) => e4 + t4, 0) > 0 && t3.strides.length !== r2)
              throw new Error(`strides should be ${r2}D`);
            if (t3.pads.reduce((e4, t4) => e4 + t4, 0) > 0 && t3.pads.length !== 2 * r2)
              throw new Error(`pads should be ${2 * r2}D`);
            if (t3.outputPadding.length !== r2 && 0 !== t3.outputPadding.length)
              throw new Error(`output_padding should be ${r2}D`);
            if (t3.kernelShape.reduce((e4, t4) => e4 + t4, 0) > 0 && 0 !== t3.kernelShape.length && t3.kernelShape.length !== e3[1].dims.length - 2)
              throw new Error("invalid kernel shape");
            if (0 !== t3.outputShape.length && t3.outputShape.length !== e3[0].dims.length - 2)
              throw new Error("invalid output shape");
            if (1 !== e3[0].dataType || 1 !== e3[1].dataType)
              throw new Error("ConvTranspose input(X,W) should be float tensor");
            if (3 === e3.length && 1 !== e3[2].dataType)
              throw new Error("ConvTranspose input(bias) should be float tensor");
          })(e2.inputs, t2), 3 === e2.inputs[0].dims.length ? ((e3, t3) => {
            const n2 = "NHWC" === t3.format, r2 = [e3.inputs[0].reshape(n2 ? [e3.inputs[0].dims[0], 1, e3.inputs[0].dims[1], e3.inputs[0].dims[2]] : [e3.inputs[0].dims[0], e3.inputs[0].dims[1], 1, e3.inputs[0].dims[2]]), e3.inputs[1].reshape([e3.inputs[1].dims[0], e3.inputs[1].dims[1], 1, e3.inputs[1].dims[2]])];
            3 === r2.length && r2.push(e3.inputs[2]);
            let i2 = t3.kernelShape;
            0 !== i2.length && 0 !== i2[0] || (i2 = [e3.inputs[1].dims[2]]);
            let o2 = t3.dilations;
            0 !== o2.length && 0 !== o2[0] || (o2 = [1]);
            let a2 = t3.strides;
            0 !== a2.length && 0 !== a2[0] || (a2 = [1]);
            let s2 = t3.pads;
            0 === s2.length && (s2 = [0, 0]), s2 = [0, s2[0], 0, s2[1]], a2 = [1].concat(a2), o2 = [1].concat(o2), i2 = [1].concat(i2);
            const u2 = l(Object.assign(Object.assign({}, t3), { pads: s2, strides: a2, dilations: o2, kernelShape: i2 }), r2);
            e3.compute(c(r2, u2, (e4) => n2 ? [e4[0], e4[2], e4[3]] : [e4[0], e4[1], e4[3]]));
          })(e2, t2) : ((e3, t3, n2) => {
            const r2 = l(n2, t3);
            e3.compute(c(t3, r2));
          })(e2, e2.inputs, t2);
        };
      }, 9770: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.conv = t.parseConvAttributes = t.calculateOutputShape = void 0;
        const r = n(6952), i = n(387), o = n(9192), a = n(3822), s = n(3997), u = n(2625);
        t.calculateOutputShape = (e2, t2, n2, r2, i2, o2) => {
          const a2 = e2[0], s2 = e2.slice(o2 ? 1 : 2, o2 ? 3 : 4), u2 = s2.length, l2 = t2[0], c2 = t2.slice(2).map((e3, t3) => e3 + (e3 - 1) * (n2[t3] - 1)), p = s2.map((e3, t3) => e3 + r2[t3] + r2[t3 + u2]).map((e3, t3) => Math.floor((e3 - c2[t3] + i2[t3]) / i2[t3]));
          return p.splice(0, 0, a2), p.splice(o2 ? 3 : 1, 0, l2), p;
        };
        const l = (0, i.createAttributeWithCacheKey)({ perm: [2, 3, 1, 0] }), c = (e2, t2) => {
          const n2 = e2.kernelShape.slice();
          for (let e3 = 2; e3 < t2[1].dims.length; ++e3)
            0 === n2[e3 - 2] && (n2[e3 - 2] = t2[1].dims[e3]);
          const i2 = e2.pads.slice();
          r.PoolConvUtil.adjustPadsBasedOnAutoPad(t2[0].dims, e2.strides, e2.dilations, n2, i2, "NHWC" === e2.format, e2.autoPad);
          const o2 = Object.assign({}, e2);
          return Object.assign(o2, { kernelShape: n2, pads: i2, cacheKey: e2.cacheKey }), o2;
        };
        t.parseConvAttributes = (e2) => {
          const t2 = (0, s.parseInternalActivationAttributes)(e2), n2 = e2.format, r2 = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][e2.auto_pad], o2 = e2.dilations, a2 = e2.group, u2 = e2.kernel_shape, l2 = e2.pads, c2 = e2.strides, p = e2.w_is_const();
          return (0, i.createAttributeWithCacheKey)(Object.assign({ autoPad: r2, format: n2, dilations: o2, group: a2, kernelShape: u2, pads: l2, strides: c2, wIsConst: p }, t2));
        }, t.conv = (e2, n2) => {
          ((e3, t2) => {
            if (!e3 || 2 !== e3.length && 3 !== e3.length)
              throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== e3[0].dims.length && 3 !== e3[0].dims.length)
              throw new Error("currently only support conv 1D and 2D");
            if (e3[0].dims.length !== e3[1].dims.length)
              throw new Error("filter does not have same dimension as input");
            if (e3[0].dims["NHWC" === t2.format ? e3[0].dims.length - 1 : 1] !== e3[1].dims[1] * t2.group)
              throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            if (3 === e3.length && (1 !== e3[2].dims.length || e3[1].dims[0] !== e3[2].dims[0]))
              throw new Error("invalid bias");
            const n3 = e3[0].dims.length - 2;
            if (t2.dilations.length !== n3)
              throw new Error(`dilations should be ${n3}D`);
            if (t2.strides.length !== n3)
              throw new Error(`strides should be ${n3}D`);
            if (t2.pads.length !== 2 * n3)
              throw new Error(`pads should be ${2 * n3}D`);
            if (0 !== t2.kernelShape.length && t2.kernelShape.length !== e3[1].dims.length - 2)
              throw new Error("invalid kernel shape");
            if (1 !== e3[0].dataType || 1 !== e3[1].dataType)
              throw new Error("Conv input(X,W) should be float tensor");
            if (3 === e3.length && 1 !== e3[2].dataType)
              throw new Error("Conv input(bias) should be float tensor");
          })(e2.inputs, n2), 3 === e2.inputs[0].dims.length ? ((e3, t2) => {
            const n3 = "NHWC" === t2.format, r2 = [e3.inputs[0].reshape(n3 ? [e3.inputs[0].dims[0], 1, e3.inputs[0].dims[1], e3.inputs[0].dims[2]] : [e3.inputs[0].dims[0], e3.inputs[0].dims[1], 1, e3.inputs[0].dims[2]]), e3.inputs[1].reshape([e3.inputs[1].dims[0], e3.inputs[1].dims[1], 1, e3.inputs[1].dims[2]])];
            3 === e3.inputs.length && r2.push(e3.inputs[2]);
            const i2 = [0, t2.pads[0], 0, t2.pads[1]], a2 = [1].concat(t2.strides), s2 = [1].concat(t2.dilations), u2 = [1].concat(t2.kernelShape), l2 = c(Object.assign(Object.assign({}, t2), { pads: i2, strides: a2, dilations: s2, kernelShape: u2 }), r2);
            e3.compute((0, o.createGroupedConvProgramInfoLoader)(r2, l2, (e4) => n3 ? [e4[0], e4[2], e4[3]] : []));
          })(e2, n2) : ((e3, n3, r2) => {
            var i2;
            const s2 = c(r2, n3), p = 3 === n3.length, d = "NHWC" === r2.format, f = n3[0].dims[d ? 1 : 2], h = n3[0].dims[d ? 2 : 3], g = n3[0].dims[d ? 3 : 1], m = n3[1].dims[2], b = n3[1].dims[3], y = (0, t.calculateOutputShape)(n3[0].dims, n3[1].dims, r2.dilations, s2.pads, r2.strides, d), v = y[d ? 1 : 2], w = y[d ? 2 : 3], x = y[d ? 3 : 1];
            if (d && m === f && b === h && "VALID" === r2.autoPad || 1 === m && 1 === b && 1 === r2.dilations[0] && 1 === r2.dilations[1] && 1 === r2.strides[0] && 1 === r2.strides[1] && ("SAME_UPPER" === r2.autoPad || "SAME_LOWER" === r2.autoPad || "VALID" === r2.autoPad))
              return void e3.compute((0, o.createGroupedConvProgramInfoLoader)(n3, s2));
            if (!d || 1 !== r2.group)
              return void e3.compute((0, o.createGroupedConvProgramInfoLoader)(n3, s2));
            const _ = d ? v * w : x, T = d ? x : v * w, S = m * b * g, $ = null !== (i2 = e3.kernelCustomData.wT) && void 0 !== i2 ? i2 : e3.compute(Object.assign(Object.assign({}, u.transposeProgramMetadata), { cacheHint: l.cacheKey, get: () => (0, u.createTransposeProgramInfo)(n3[1], l.perm) }), { inputs: [1], outputs: [r2.wIsConst ? -2 : -1] })[0];
            r2.wIsConst && !e3.kernelCustomData.wT && (e3.kernelCustomData.wT = $);
            const O = [n3[0], $];
            p && (d || 1 !== n3[2].dims.length ? O.push(n3[2]) : O.push(n3[2].reshape([n3[2].dims[0], 1, 1]))), e3.compute((0, a.createConv2DMatMulProgramInfoLoader)(O, s2, y, _, T, S, p, true), { inputs: O });
          })(e2, e2.inputs, n2);
        };
      }, 3822: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createConv2DMatMulProgramInfoLoader = void 0;
        const r = n(1163), i = n(9456);
        t.createConv2DMatMulProgramInfoLoader = (e2, t2, n2, o, a, s, u, l) => {
          const c = ((e3, t3) => ({ name: "Conv2DMatMul", inputTypes: e3 ? [r.GpuDataType.default, r.GpuDataType.default, r.GpuDataType.default] : [r.GpuDataType.default, r.GpuDataType.default], cacheHint: t3 }))(u, t2.cacheKey);
          return Object.assign(Object.assign({}, c), { get: () => (0, i.createConv2DMatMulProgramInfo)(e2, c, t2, n2, o, a, s, u, l) });
        };
      }, 8856: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.expand = t.expandProgramMetadata = void 0;
        const r = n(6952), i = n(1163), o = n(2075);
        t.expandProgramMetadata = { name: "Expand", inputTypes: [i.GpuDataType.default] };
        const a = (e2, t2) => {
          const n2 = e2.length - t2.length, r2 = [];
          for (let t3 = 0; t3 < n2; ++t3)
            r2.push(e2[t3]);
          for (let i2 = 0; i2 < t2.length; ++i2)
            r2.push(1 === t2[i2] ? e2[i2 + n2] : t2[i2]);
          return r2;
        };
        t.expand = (e2) => {
          ((e3) => {
            if (!e3 || 2 !== e3.length)
              throw new Error("Expand requires 2 input.");
            const t2 = e3[0].dims, n3 = Array.from(e3[1].getBigInt64Array(), Number);
            let r2 = n3.length < t2.length ? 0 : n3.length - t2.length, i2 = t2.length < n3.length ? 0 : t2.length - n3.length;
            for (; r2 < n3.length && i2 < t2.length; ++r2, ++i2)
              if (n3[r2] !== t2[i2] && 1 !== n3[r2] && 1 !== t2[i2])
                throw new Error("Expand requires shape to be broadcastable to input");
          })(e2.inputs);
          const n2 = Array.from(e2.inputs[1].getBigInt64Array(), Number).toString();
          e2.compute(Object.assign(Object.assign({}, t.expandProgramMetadata), { cacheHint: n2, get: () => ((e3, t2) => {
            const n3 = t2[0].dims, s = Array.from(t2[1].getBigInt64Array(), Number), u = ((e4, t3) => e4.length > t3.length ? a(e4, t3) : a(t3, e4))(n3, s), l = r.ShapeUtil.size(u), c = t2[0].dataType, p = (0, o.inputVariable)("input", c, n3), d = (0, o.outputVariable)("output", c, u);
            return Object.assign(Object.assign({}, e3), { getShaderSource: (e4) => `
  const inputShape = ${p.indices(...n3)};
  ${e4.declareVariables(p, d)}
  ${e4.mainStart()}
  ${e4.guardAgainstOutOfBoundsWorkgroupSizes(l)}
    let outputIndices = ${d.offsetToIndices("global_idx")};
    var inputIndices: ${p.type.indices};
    for (var i = 0; i < ${n3.length}; i++) {
      if (${p.indicesGet("inputShape", "i")} == 1) {
        ${p.indicesSet("inputIndices", "i", 0)}
      } else {
        ${p.indicesSet("inputIndices", "i", d.indicesGet("outputIndices", "i + " + (u.length - n3.length)))}
      }
    }
    ${d.setByOffset("global_idx", p.getByIndices("inputIndices"))}
  }`, outputs: [{ dims: u, dataType: t2[0].dataType, gpuDataType: i.GpuDataType.default }], dispatchGroup: () => ({ x: Math.ceil(l / 64) }) });
          })(t.expandProgramMetadata, e2.inputs) }), { inputs: [0] });
        };
      }, 3997: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseInternalActivationAttributes = t.getActicationSnippet = void 0;
        const r = n(6952);
        t.getActicationSnippet = (e2) => {
          switch (e2.activation) {
            case "Relu":
              return { activationFunction: "", applyActivation: "value = max(value, 0.0);" };
            case "Sigmoid":
              return { activationFunction: "", applyActivation: "value = (1.0 / (1.0 + exp(-value)));" };
            case "Clip":
              return { activationFunction: `const clip_min_=f32(${e2.clipMin});const clip_max_=f32(${e2.clipMax});`, applyActivation: "value = clamp(value, clip_min_, clip_max_);" };
            default:
              return { activationFunction: "", applyActivation: "" };
          }
        }, t.parseInternalActivationAttributes = (e2) => {
          const t2 = (null == e2 ? void 0 : e2.activation) || "";
          if ("Clip" === t2) {
            const [n2, i] = (null == e2 ? void 0 : e2.activation_params) || [r.MIN_CLIP, r.MAX_CLIP];
            return { activation: t2, clipMax: i, clipMin: n2, activationCacheKey: `${t2}:${n2},${i}` };
          }
          return { activation: t2, activationCacheKey: t2 };
        };
      }, 8405: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.gather = t.parseGatherAttributes = void 0;
        const r = n(6952), i = n(387), o = n(1163);
        t.parseGatherAttributes = (e2) => (0, i.createAttributeWithCacheKey)({ axis: e2.axis }), t.gather = (e2, t2) => {
          ((e3) => {
            if (!e3 || 2 !== e3.length)
              throw new Error("Gather requires 2 inputs.");
          })(e2.inputs);
          const n2 = { name: "Gather", inputTypes: [o.GpuDataType.default, o.GpuDataType.default], cacheHint: t2.cacheKey };
          e2.compute(((e3, t3, n3) => {
            const i2 = t3[0].dims, a = t3[1].dims, s = i2.length, u = r.ShapeUtil.normalizeAxis(n3.axis, s), l = i2.slice(0);
            l.splice(u, 1, ...a);
            const c = t3[0].dataType, p = r.ShapeUtil.sizeFromDimension(i2, u + 1), d = [7, 13, 11].includes(c) ? 2 : 1, f = 7 === t3[1].dataType ? 2 : 1, h = d * p, g = r.ShapeUtil.sizeToDimension(i2, u), m = r.ShapeUtil.size(a), b = r.ShapeUtil.sizeFromDimension(i2, u) * d, y = m * p * d, v = i2[u], w = r.ShapeUtil.size(i2) * d, x = r.ShapeUtil.size(l) * d, _ = g * m;
            return Object.assign(Object.assign({}, e3), { outputs: [{ dims: l, dataType: t3[0].dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e4) => `
  const N: u32 = ${m};
  const elementSize: u32 = ${d};
  const indicesElementSize: u32 = ${f};

  @group(0) @binding(0) var<storage, read> input : array<u32>;
  @group(0) @binding(1) var<storage, read> inputIndices : array<i32>;
  @group(0) @binding(2) var<storage, read_write> output: array<u32>;

  ${e4.mainStart()}
    let batch: u32 = global_idx / N;
    let i: u32 = global_idx % N;

    let srcOffsetBatch: u32 = batch * ${b};
    let dstOffsetBatch: u32 = batch * ${y};
    var idx = inputIndices[i * indicesElementSize];
    if (idx < 0) {
        idx = idx + ${v};
    }

    let srcOffset = srcOffsetBatch + u32(idx) * ${h};
    let dstOffset = dstOffsetBatch + i * ${h};
    if (srcOffset >= ${w}) {
        return;
    }
    if (dstOffset >= ${x}) {
        return;
    }
    for (var j: u32 = 0; j < ${h}; j++) {
        output[dstOffset + j] = input[srcOffset + j];
    }
  }`, dispatchGroup: () => ({ x: Math.ceil(_ / 64) }) });
          })(n2, e2.inputs, t2));
        };
      }, 4271: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseGemmAttributes = t.gemm = void 0;
        const r = n(6952), i = n(387), o = n(1163);
        t.gemm = (e2, t2) => {
          ((e3) => {
            if (!e3)
              throw new Error("Input is missing");
            if (e3.length < 2 || e3.length > 3)
              throw new Error("Invaid input number.");
            if (3 === e3.length && e3[2].dims.length > 2)
              throw new Error("Invalid input shape of C");
            if (1 !== e3[0].dataType || 1 !== e3[1].dataType || 3 === e3.length && 1 !== e3[2].dataType)
              throw new Error("Invalid input type.");
            if (e3[0].dataType !== e3[1].dataType || 3 === e3.length && e3[0].dataType !== e3[2].dataType)
              throw new Error("Input types are mismatched");
          })(e2.inputs), e2.compute(((e3, t3) => {
            const n2 = { name: "Gemm", inputTypes: 3 === e3.length ? [o.GpuDataType.default, o.GpuDataType.default, o.GpuDataType.default] : [o.GpuDataType.default, o.GpuDataType.default], cacheHint: t3.cacheKey };
            return Object.assign(Object.assign({}, n2), { get: () => ((e4, t4, n3) => {
              const i2 = t4[0].dims.slice(), a = t4[1].dims.slice(), [s, u, l] = r.GemmUtil.getShapeOfGemmResult(i2, n3.transA, a, n3.transB, 3 === t4.length ? t4[2].dims : void 0), c = [s, u];
              if (!c)
                throw new Error("Can't use gemm on the given tensors");
              const p = r.ShapeUtil.size(c);
              let d = "";
              n3.transA && n3.transB ? d = "value += a[k * M + m] * b[n * K + k];" : n3.transA && !n3.transB ? d = "value += a[k * M + m] * b[k * N + n];" : !n3.transA && n3.transB ? d = "value += a[m * K + k] * b[n * K + k];" : n3.transA || n3.transB || (d = "value += a[m * K + k] * b[k * N + n];");
              const f = "f32", h = 1 === n3.alpha ? "" : "value *= alpha;", g = 3 === t4.length ? `value += beta * c[${((e5, t5, n4) => {
                if (0 === n4.length)
                  return "0u";
                const r2 = 1 === n4.length && 1 !== e5 || 2 === n4.length && n4[0] !== e5, i3 = n4[n4.length - 1] !== t5;
                let o2 = "0u";
                return r2 || (o2 += `+ m * ${n4[n4.length - 1]}u`), i3 || (o2 += "+n"), o2;
              })(s, u, t4[2].dims)}];` : "", m = [`@group(0) @binding(0) var<storage, read> a : array<${f}>;`, `@group(0) @binding(1) var<storage, read> b : array<${f}>;`];
              return 3 === t4.length && m.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`), Object.assign(Object.assign({}, e4), { outputs: [{ dims: c, dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e5) => `
  const M: u32 = ${s}u;
  const N: u32 = ${u}u;
  const K: u32 = ${l}u;
  const alpha = ${f}(${n3.alpha});
  const beta = ${f}(${n3.beta});

  ${m.join("\n")}
  @group(0) @binding(${t4.length}) var<storage, read_write> output : array<${f}>;

  ${e5.mainStart()}
    ${e5.guardAgainstOutOfBoundsWorkgroupSizes(p)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${f}(0);
    for (var k: u32 = 0u; k<${l}u; k++) {
      ${d}
    }

    ${h}
    ${g}
    output[global_id.x] = value;

  }`, dispatchGroup: () => ({ x: Math.ceil(p / 64) }) });
            })(n2, e3, t3) });
          })(e2.inputs, t2));
        }, t.parseGemmAttributes = (e2) => (0, i.createAttributeWithCacheKey)(e2);
      }, 1798: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.instanceNorm = t.parseInstanceNormAttributes = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075);
        t.parseInstanceNormAttributes = (e2) => (0, i.createAttributeWithCacheKey)({ epsilon: e2.epsilon, format: e2.format }), t.instanceNorm = (e2, t2) => {
          ((e3) => {
            if (!e3 || 3 !== e3.length)
              throw new Error("instanceNorm requires 3 inputs.");
            if (1 !== e3[0].dataType || 1 !== e3[1].dataType)
              throw new Error("inputs should be float type");
          })(e2.inputs);
          const n2 = { name: "InstanceNormalization", inputTypes: [o.GpuDataType.default, o.GpuDataType.default, o.GpuDataType.default], cacheHint: t2.cacheKey };
          "NHWC" === t2.format ? e2.compute(((e3, t3, n3) => {
            const i2 = t3[0].dims, s = i2, u = r.ShapeUtil.size(s), l = i2[0], c = i2[i2.length - 1], p = r.ShapeUtil.sizeFromDimension(i2, 1) / c, d = (0, a.tensorTypeToWsglStorageType)(t3[0].dataType), f = c * l;
            return Object.assign(Object.assign({}, e3), { outputs: [{ dims: s, dataType: t3[0].dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e4) => `
  const N: u32 = ${l};
  const H: u32 = ${p};
  const C: u32 = ${c};
  const normSizeTyped: ${d} = ${p};
  const imageSize: u32 = ${p * c};
  const epsilon: f32 = ${n3.epsilon};

  @group(0) @binding(0) var<storage, read> x : array<${d}>;
  @group(0) @binding(1) var<storage, read> scale : array<${d}>;
  @group(0) @binding(2) var<storage, read> bias : array<${d}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${d}>;

  ${e4.mainStart()}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;
    
    // offset is channel num * N
    let offset = currentImageNumber * imageSize;
    if (offset >= ${u}) { return; }
    var mean: ${d} = 0;

    for (var i: u32 = 0u; i < H; i++) {
        mean = mean + x[offset + i * C + currentChannelNumber];
    }
    mean = mean / normSizeTyped;

    var squaredNorm: ${d} = 0;
    for (var i: u32 = 0u; i < H; i++) {
        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;
        squaredNorm = squaredNorm + deviation * deviation;
    }
    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);
    let channelScale = invStdDev * scale[currentChannelNumber];
    let channelShift = bias[currentChannelNumber] - mean * channelScale;
    for (var i: u32 = 0u; i < H; i++) {
        let currentOffset = offset + i * C + currentChannelNumber;
        output[currentOffset] = x[currentOffset] * channelScale + channelShift;
    }
  }`, dispatchGroup: () => ({ x: Math.ceil(f / 64) }) });
          })(n2, e2.inputs, t2)) : e2.compute(((e3, t3, n3) => {
            const i2 = t3[0].dims, s = t3[1], u = t3[2], l = i2, c = r.ShapeUtil.size(l), p = r.ShapeUtil.sizeToDimension(i2, 2), d = r.ShapeUtil.sizeFromDimension(i2, 2), f = i2[1], h = r.ShapeUtil.size(s.dims), g = u ? r.ShapeUtil.size(u.dims) : 0;
            if (h !== d || u && g !== d)
              throw new Error(`Size of X.shape()[axis:] == ${d}.
             Size of scale and bias (if provided) must match this. 
             Got scale size of ${h} and bias size of ${g}`);
            const m = (0, a.tensorTypeToWsglStorageType)(t3[0].dataType);
            return Object.assign(Object.assign({}, e3), { outputs: [{ dims: l, dataType: t3[0].dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e4) => `
  const C: u32 = ${f};
  const normSize: u32 = ${d};
  const normSizeTyped: ${m} = ${d};
  const epsilon: f32 = ${n3.epsilon};

  @group(0) @binding(0) var<storage, read> x : array<${m}>;
  @group(0) @binding(1) var<storage, read> scale : array<${m}>;
  @group(0) @binding(2) var<storage, read> bias : array<${m}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${m}>;

  ${e4.mainStart()}
    let offset = global_idx * normSize;
    if (offset + normSize >= ${c}) { return; }
    var mean: ${m} = 0;

    for (var h: u32 = 0u; h < normSize; h++) {
        mean = mean + x[h + offset];
    }
    mean = mean / normSizeTyped;

    var squaredNorm: ${m} = 0;
    for (var h: u32 = 0u; h < normSize; h++) {
        let deviation: f32 = x[h + offset] - mean;
        squaredNorm = squaredNorm + deviation * deviation;
    }
    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);
    let channelScale = invStdDev * scale[global_idx % C];
    let channelShift = bias[global_idx % C] - mean * channelScale;
    for (var j: u32 = 0; j < normSize; j++) {
        output[j + offset] = x[j + offset] * channelScale + channelShift;
    }
  }`, dispatchGroup: () => ({ x: Math.ceil(p / 64) }) });
          })(n2, e2.inputs, t2));
        };
      }, 2915: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.layerNorm = t.parseLayerNormAttributes = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075);
        t.parseLayerNormAttributes = (e2) => (0, i.createAttributeWithCacheKey)({ axis: e2.axis, epsilon: e2.epsilon }), t.layerNorm = (e2, t2) => {
          ((e3) => {
            if (!e3 || e3.length < 2)
              throw new Error("layerNorm requires at least 2 inputs.");
            if (1 !== e3[0].dataType || 1 !== e3[1].dataType)
              throw new Error("inputs should be float type");
          })(e2.inputs);
          const n2 = { name: "LayerNormalization", inputTypes: 2 === e2.inputs.length ? [o.GpuDataType.default, o.GpuDataType.default] : [o.GpuDataType.default, o.GpuDataType.default, o.GpuDataType.default], cacheHint: t2.cacheKey + e2.outputCount.toString(10) + e2.inputs.length.toString(10) };
          e2.compute(((e3, t3, n3, i2) => {
            const s = t3[0].dims, u = t3[1], l = t3[2], c = s, p = r.ShapeUtil.size(c), d = r.ShapeUtil.normalizeAxis(n3.axis, s.length), f = r.ShapeUtil.sizeToDimension(s, d), h = r.ShapeUtil.sizeFromDimension(s, d), g = r.ShapeUtil.size(u.dims), m = l ? r.ShapeUtil.size(l.dims) : 0;
            if (g !== h || l && m !== h)
              throw new Error(`Size of X.shape()[axis:] == ${h}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${g} and bias size of ${m}`);
            const b = [];
            for (let e4 = 0; e4 < s.length; ++e4)
              e4 < d ? b.push(s[e4]) : b.push(1);
            const y = (0, a.tensorTypeToWsglStorageType)(t3[0].dataType), v = i2 > 1, w = i2 > 2;
            let x = 0;
            const _ = [{ dims: c, dataType: t3[0].dataType, gpuDataType: o.GpuDataType.default }];
            return v && _.push({ dims: b, dataType: t3[0].dataType, gpuDataType: o.GpuDataType.default }), w && _.push({ dims: b, dataType: t3[0].dataType, gpuDataType: o.GpuDataType.default }), Object.assign(Object.assign({}, e3), { outputs: _, getShaderSource: (e4) => `
  const normSize: u32 = ${h};
  const normSizeTyped: ${y} = ${h};
  const epsilon: f32 = ${n3.epsilon};

  @group(0) @binding(${x++}) var<storage, read> x : array<${y}>;
  @group(0) @binding(${x++}) var<storage, read> scale : array<${y}>;
  ${l ? `@group(0) @binding(${x++}) var<storage, read> bias : array<${y}>;` : ""}
  @group(0) @binding(${x++}) var<storage, read_write> output : array<${y}>;
  ${v ? `@group(0) @binding(${x++}) var<storage, read_write> meanDataOutput : array<${y}>` : ""};
  ${w ? `@group(0) @binding(${x++}) var<storage, read_write> invStdOutput : array<${y}>` : ""};

  ${e4.mainStart()}
    let offset = global_idx * normSize;
    if (offset >= ${p}) { return; }
    var mean: ${y} = 0;
    var meanSquare: ${y} = 0;

    for (var h: u32 = 0u; h < normSize; h++) {
      mean = mean + x[h + offset];
      meanSquare = meanSquare + x[h + offset] * x[h + offset];
    }
    mean = mean / normSizeTyped;
    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSize; j++) {
      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${l ? "+ bias[j]" : ""};
    }

    ${v ? "meanDataOutput[global_idx] = mean" : ""};
    ${w ? "invStdOutput[global_idx] = 1 / meanSquare" : ""};
  }`, dispatchGroup: () => ({ x: Math.ceil(f / 64) }) });
          })(n2, e2.inputs, t2, e2.outputCount));
        };
      }, 1522: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.matMul = t.createMatmulProgramInfoLoader = void 0;
        const r = n(6952), i = n(1163), o = n(3997);
        t.createMatmulProgramInfoLoader = (e2, t2) => {
          const n2 = (a = e2.length > 2, s = t2.activationCacheKey, { name: "MatMul", inputTypes: a ? [i.GpuDataType.default, i.GpuDataType.default, i.GpuDataType.default] : [i.GpuDataType.default, i.GpuDataType.default], cacheHint: s });
          var a, s;
          return Object.assign(Object.assign({}, n2), { get: () => ((e3, t3, n3) => {
            const a2 = t3[0].dims, s2 = t3[1].dims, u = r.BroadcastUtil.calcShape(a2, s2, true);
            if (!u)
              throw new Error("Can't use matmul on the given tensors");
            const l = r.ShapeUtil.size(u), c = "f32", { activationFunction: p, applyActivation: d } = (0, o.getActicationSnippet)(n3), f = u[u.length - 2], h = a2[a2.length - 1], g = u[u.length - 1];
            return Object.assign(Object.assign({}, e3), { outputs: [{ dims: u, dataType: t3[0].dataType, gpuDataType: i.GpuDataType.default }], getShaderSource: (e4) => `
  const M: u32 = ${f}u;
  const N: u32 = ${g}u;
  const K: u32 = ${h}u;

  @group(0) @binding(0) var<storage, read> a : array<${c}>;
  @group(0) @binding(1) var<storage, read> b : array<${c}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${c}>;

  ${p}

  ${e4.mainStart()}
    ${e4.guardAgainstOutOfBoundsWorkgroupSizes(l)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${c}(0);
    for (var k: u32 = 0u; k<${h}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${d}
    output[global_idx] = value;
  }`, dispatchGroup: () => ({ x: Math.ceil(l / 64) }) });
          })(n2, e2, t2) });
        }, t.matMul = (e2) => {
          ((e3) => {
            if (!e3 || 2 !== e3.length)
              throw new Error("MatMul requires 2 inputs.");
            if (e3[0].dims[e3[0].dims.length - 1] !== e3[1].dims[e3[1].dims.length - 2])
              throw new Error("shared dimension does not match.");
            if (1 !== e3[0].dataType || 1 !== e3[1].dataType)
              throw new Error("inputs should be float type");
          })(e2.inputs), e2.compute((0, t.createMatmulProgramInfoLoader)(e2.inputs, { activation: "", activationCacheKey: "" }));
        };
      }, 5262: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.globalMaxPool = t.parseGlobalMaxPoolAttributes = t.parseMaxPoolAttributes = t.maxPool = t.globalAveragePool = t.parseGlobalAveragePoolAttributes = t.averagePool = t.parseAveragePoolAttributes = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075), s = (e2) => {
          if (!e2 || 1 !== e2.length)
            throw new Error("Pool ops requires 1 input.");
          if (4 !== e2[0].dims.length)
            throw new Error("Pool ops supports 2-D inputs only for now.");
          if (1 !== e2[0].dataType)
            throw new Error("Invalid input type.");
        }, u = (e2, t2, n2) => {
          const i2 = "NHWC" === t2.format, o2 = i2 ? [e2.dims[0], e2.dims[3], e2.dims[1], e2.dims[2]] : e2.dims.slice(), a2 = Object.hasOwnProperty.call(t2, "dilations"), s2 = t2.kernelShape.slice(), u2 = t2.strides.slice(), l2 = a2 ? t2.dilations.slice() : [], c2 = t2.pads.slice();
          r.PoolConvUtil.adjustPoolAttributes(n2, o2, s2, u2, l2, c2);
          const p2 = r.PoolConvUtil.computePoolOutputShape(n2, o2, u2, l2, s2, c2, t2.autoPad), d2 = Object.assign({}, t2);
          return a2 ? Object.assign(d2, { kernelShape: s2, strides: u2, pads: c2, dilations: l2, cacheKey: t2.cacheKey }) : Object.assign(d2, { kernelShape: s2, strides: u2, pads: c2, cacheKey: t2.cacheKey }), [d2, i2 ? [p2[0], p2[2], p2[3], p2[1]] : p2];
        }, l = (e2, t2, n2, i2, o2, s2, u2) => {
          const l2 = "NHWC" === i2.format, c2 = t2.shape, p2 = t2.type.value, d2 = c2.length, f2 = r.ShapeUtil.size(n2), h = (0, a.outputVariable)("output", t2.type.tensor, n2);
          if (i2.kernelShape.length <= 2) {
            const n3 = i2.kernelShape[i2.kernelShape.length - 1], r2 = i2.strides[i2.strides.length - 1], a2 = i2.pads[i2.pads.length / 2 - 1], g = d2 - (l2 ? 2 : 1);
            let m = "", b = "", y = "";
            if (m = a2 + i2.pads[i2.pads.length - 1] !== 0 ? `
              for (var i: u32 = 0u; i < ${n3}u; i++) {
                xIndices[${g}] = indices[${g}] * ${r2} - ${a2} + i;
                if (xIndices[${g}] < 0 || xIndices[${g}] >= ${c2[g]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${t2.indicesToOffset("xIndices")}];
                ${o2}
              }` : `
              for (var i: u32 = 0u; i < ${n3}u; i++) {
                xIndices[${g}] = indices[${g}] * ${r2} - ${a2} + i;
                let x_val = x[${t2.indicesToOffset("xIndices")}];
                ${o2}
              }`, 2 === i2.kernelShape.length) {
              const e3 = i2.kernelShape[i2.kernelShape.length - 2], t3 = i2.strides[i2.strides.length - 2], r3 = i2.pads[i2.pads.length / 2 - 2], o3 = i2.pads[i2.pads.length - 2], a3 = d2 - (l2 ? 3 : 2), s3 = c2[a3];
              b = r3 + o3 !== 0 ? `
                for (var j: u32 = 0u; j < ${e3}u; j++) {
                  xIndices[${a3}] = indices[${a3}] * ${t3} - ${r3} + j;
                  if (xIndices[${a3}] < 0 || xIndices[${a3}] >= ${s3}) {
                    pad+= ${n3};
                    continue;
                  }
              ` : `
                for (var j: u32 = 0u; j < ${e3}u; j++) {
                  xIndices[${a3}] = indices[${a3}] * ${t3} - ${r3} + j;
                `, y = "\n              }\n            ";
            }
            return `
            ${e2.declareVariables(t2, h)}

            ${e2.mainStart()}
              ${e2.guardAgainstOutOfBoundsWorkgroupSizes(f2)}

              let indices = ${h.offsetToIndices("global_idx")};
              var xIndices = ${h.offsetToIndices("global_idx")};

              var value: ${p2} = ${p2}(${u2});
              var pad = 0;
              ${b}
              ${m}
              ${y}
              ${s2}

              output[global_idx] = value;
            }`;
          }
          {
            if (l2)
              throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
            const n3 = r.ShapeUtil.size(i2.kernelShape), a2 = r.ShapeUtil.computeStrides(i2.kernelShape), p3 = a2.length, g = i2.pads.length;
            let m = "";
            return m = i2.pads.reduce((e3, t3) => e3 + t3) ? `
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t2.indicesToOffset("xIndices")}];
                ${o2}
              }` : `
              }
              let x_val = x[${t2.indicesToOffset("xIndices")}];
              ${o2}
            `, `
            ${e2.declareVariables(t2, h)}

            const pads = array<u32, ${g}>(${i2.pads.map((e3) => `${e3}u`).join(",")});
            const inputDims = array<u32, ${d2}>(${c2.map((e3) => `${e3}u`).join(",")});
            const kernelStrides = array<u32, ${p3}>(${a2.map((e3) => `${e3}u`).join(",")});
            const strides = array<u32, ${p3}>(${i2.strides.map((e3) => `${e3}u`).join(",")});

            ${e2.mainStart()}
              ${e2.guardAgainstOutOfBoundsWorkgroupSizes(f2)}

              let indices = ${h.offsetToIndices("global_idx")};
              let xIndices = ${h.offsetToIndices("global_idx")};

              var offsets: array<u32, ${p3}>;

              var value = ${h.type.value}(${u2});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${n3}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${p3 - 1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${p3 - 1}] = offset;

                isPad = false;
                for (var j = ${d2 - p3}u; j < ${d2}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${d2 - p3}u]
                    + offsets[j - ${d2 - p3}u] - pads[j - 2u];
                  ${m}
              }
              ${s2}

              output[global_idx] = value;
            }`;
          }
        }, c = (e2) => ({ format: e2.format, autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][e2.auto_pad], ceilMode: e2.ceil_mode, kernelShape: e2.kernel_shape, strides: e2.strides, pads: e2.pads }), p = (e2, t2, n2, i2) => {
          const [s2, c2] = u(e2, i2, n2), p2 = r.ShapeUtil.size(s2.kernelShape), d2 = (0, a.inputVariable)("x", e2.dataType, e2.dims);
          let f2 = "";
          return s2.countIncludePad ? f2 += `value /= f32(${p2});` : f2 += `value /= f32(${p2} - pad);`, Object.assign(Object.assign({}, t2), { outputs: [{ dims: c2, dataType: e2.dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e3) => l(e3, d2, c2, s2, "value += x_val;", f2, "0.0"), dispatchGroup: () => ({ x: Math.ceil(r.ShapeUtil.size(c2) / 64) }) });
        };
        t.parseAveragePoolAttributes = (e2) => {
          const t2 = 0 !== e2.count_include_pad, n2 = c(e2);
          if (0 !== n2.ceilMode)
            throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
          return (0, i.createAttributeWithCacheKey)(Object.assign({ countIncludePad: t2 }, n2));
        }, t.averagePool = (e2, t2) => {
          s(e2.inputs);
          const n2 = { name: "AveragePool", inputTypes: [o.GpuDataType.default], cacheHint: t2.cacheKey };
          e2.compute(Object.assign(Object.assign({}, n2), { get: () => p(e2.inputs[0], n2, false, t2) }));
        };
        const d = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" };
        t.parseGlobalAveragePoolAttributes = (e2) => {
          const t2 = e2.format;
          return Object.assign(Object.assign({ format: t2 }, d), { cacheKey: t2 });
        }, t.globalAveragePool = (e2, t2) => {
          s(e2.inputs);
          const n2 = { name: "GlobalAveragePool", inputTypes: [o.GpuDataType.default], cacheHint: t2.cacheKey };
          e2.compute(Object.assign(Object.assign({}, n2), { get: () => p(e2.inputs[0], n2, true, t2) }));
        };
        const f = (e2, t2, n2, i2) => {
          const [s2, c2] = u(e2, i2, n2), p2 = (0, a.inputVariable)("x", e2.dataType, e2.dims);
          return Object.assign(Object.assign({}, t2), { outputs: [{ dims: c2, dataType: e2.dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e3) => l(e3, p2, c2, s2, "\n      value = max(x_val, value);\n    ", "", "-1e5"), dispatchGroup: () => ({ x: Math.ceil(r.ShapeUtil.size(c2) / 64) }) });
        };
        t.maxPool = (e2, t2) => {
          s(e2.inputs);
          const n2 = { name: "MaxPool", inputTypes: [o.GpuDataType.default], cacheHint: t2.cacheKey };
          e2.compute(Object.assign(Object.assign({}, n2), { get: () => f(e2.inputs[0], n2, false, t2) }));
        }, t.parseMaxPoolAttributes = (e2) => {
          const t2 = e2.storage_order, n2 = e2.dilations, r2 = c(e2);
          if (0 !== t2)
            throw new Error("column major storage order is not yet supported for MaxPool");
          if (0 !== r2.ceilMode)
            throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
          return (0, i.createAttributeWithCacheKey)(Object.assign({ storageOrder: t2, dilations: n2 }, r2));
        }, t.parseGlobalMaxPoolAttributes = (e2) => {
          const t2 = e2.format;
          return Object.assign(Object.assign({ format: t2 }, d), { cacheKey: t2 });
        }, t.globalMaxPool = (e2, t2) => {
          s(e2.inputs);
          const n2 = { name: "GlobalMaxPool", inputTypes: [o.GpuDataType.default], cacheHint: t2.cacheKey };
          e2.compute(Object.assign(Object.assign({}, n2), { get: () => f(e2.inputs[0], n2, true, t2) }));
        };
      }, 6031: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseReduceAttributes = t.reduceSumSquare = t.reduceSum = t.reduceProd = t.reduceMin = t.reduceMean = t.reduceMax = t.reduceLogSumExp = t.reduceL2 = t.reduceL1 = t.reduceLogSum = t.createReduceProgramInfo = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075), s = (e2) => {
          if (!e2 || 0 === e2.length || e2.length > 2)
            throw new Error("Reduce op requires 1 or 2 inputs.");
          if (2 === e2.length && 1 !== e2[1].dims.length)
            throw new Error("Invalid axes input dims.");
          if (1 !== e2[0].dataType)
            throw new Error("Invalid input type.");
        }, u = (e2) => ["", "", `var value = ${e2.getByOffset("inputOffset")};`, ""];
        t.createReduceProgramInfo = (e2, t2, n2, i2, s2, u2 = false, l2 = false) => {
          const c = [], p = t2[0].dims, d = r.ShapeUtil.normalizeAxes(i2, t2[0].dims.length), f = !l2 && 0 === d.length;
          p.forEach((e3, t3) => {
            f || d.indexOf(t3) >= 0 ? u2 && c.push(1) : c.push(e3);
          });
          const h = [], g = (0, a.inputVariable)("_A", t2[0].dataType, p), m = (0, a.outputVariable)("output", s2, c), b = n2(g, m, d), y = `inputOffset = ${g.indicesToOffset("inputIndices")};`, v = `let ${y};`, w = `var ${y};`, x = "" === b[1] ? "" : w;
          let _ = ("" === b[1] ? v : y) + "\n" + b[2];
          for (let e3 = 0, n3 = 0; e3 < t2[0].dims.length; e3++)
            f || d.indexOf(e3) >= 0 ? (u2 && n3++, _ = `for(var j${e3}: u32 = 0; j${e3} < ${t2[0].dims[e3]}; j${e3}++) {
                ${b[2].includes("lastIndex") ? `let lastIndex = j${e3};` : ""}
                ${g.indicesSet("inputIndices", e3, `j${e3}`)}
                ${_}
              }`) : (h.push(`${g.indicesSet("inputIndices", e3, m.indicesGet("outputIndices", n3))};`), n3++);
          const T = r.ShapeUtil.size(c);
          return Object.assign(Object.assign({}, e2), { getShaderSource: (e3) => `
        ${e3.declareVariables(g, m)}

        ${e3.mainStart()}
          ${e3.guardAgainstOutOfBoundsWorkgroupSizes(T)}
          var inputIndices: ${g.type.indices};
          let outputIndices = ${m.offsetToIndices("global_idx")};

          ${h.join("\n")}
          ${b[0]}       // init ops for reduce max/min
          ${x}
          ${b[1]}
          ${_}
          ${b[3]}
          ${4 === b.length ? m.setByOffset("global_idx", "value") : b.slice(4).join("\n")}
        }`, outputs: [{ dims: c, dataType: s2, gpuDataType: o.GpuDataType.default }], dispatchGroup: () => ({ x: Math.ceil(T / 64) }) });
        };
        const l = (e2, n2, r2, a2) => {
          const s2 = 1 === e2.length ? r2 : ((e3, t2) => {
            const n3 = [];
            return e3[1].dims[0] > 0 && e3[1].getBigInt64Array().forEach((e4) => n3.push(Number(e4))), (0, i.createAttributeWithCacheKey)({ axes: n3, keepDims: t2.keepDims, noopWithEmptyAxes: t2.noopWithEmptyAxes });
          })(e2, r2), l2 = { name: n2, inputTypes: [o.GpuDataType.default], cacheHint: s2.cacheKey + "_" + e2[0].dims.map((e3) => e3.toString()).join(",") };
          return Object.assign(Object.assign({}, l2), { get: () => (0, t.createReduceProgramInfo)(l2, [e2[0]], s2.noopWithEmptyAxes && 0 === s2.axes.length ? u : a2, s2.axes, e2[0].dataType, s2.keepDims, s2.noopWithEmptyAxes) });
        };
        t.reduceLogSum = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceLogSum", t2, (e3, t3) => [`var value = ${t3.type.storage}(0);`, "", `value += ${e3.getByOffset("inputOffset")};`, "value = log(value);"]), { inputs: [0] });
        }, t.reduceL1 = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceL1", t2, (e3, t3) => [`var value = ${t3.type.storage}(0);`, "", `value += abs(${e3.getByOffset("inputOffset")});`, ""]), { inputs: [0] });
        }, t.reduceL2 = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceL2", t2, (e3, t3) => [`var t = f32(0); var value = ${t3.type.storage}(0);`, "", `t = ${e3.getByOffset("inputOffset")}; value += (t * t);`, "value = sqrt(value);"]), { inputs: [0] });
        }, t.reduceLogSumExp = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceLogSumExp", t2, (e3, t3) => [`var value = ${t3.type.storage}(0);`, "", `value += exp(${e3.getByOffset("inputOffset")});`, "value = log(value);"]), { inputs: [0] });
        }, t.reduceMax = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceMax", t2, (e3, t3, n2) => {
            const r2 = [];
            for (let t4 = 0; t4 < e3.shape.length; t4++)
              (n2.indexOf(t4) >= 0 || 0 === n2.length) && r2.push(e3.indicesSet("inputIndices", t4, 0));
            return [`${r2.join("\n")}`, `var value = ${e3.getByOffset("inputOffset")};`, `value = max(value, ${e3.getByOffset("inputOffset")});`, ""];
          }), { inputs: [0] });
        }, t.reduceMean = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceMean", t2, (e3, t3, n2) => {
            let r2 = 1;
            for (let t4 = 0; t4 < e3.shape.length; t4++)
              (n2.indexOf(t4) >= 0 || 0 === n2.length) && (r2 *= e3.shape[t4]);
            return [`var value = ${t3.type.storage}(0);`, "", `value += ${e3.getByOffset("inputOffset")};`, `value = value / ${r2}.;`];
          }), { inputs: [0] });
        }, t.reduceMin = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceMin", t2, (e3, t3, n2) => {
            const r2 = [];
            for (let t4 = 0; t4 < e3.shape.length; t4++)
              (n2.indexOf(t4) >= 0 || 0 === n2.length) && r2.push(`inputIndices[${t4}] = 0;`);
            return [`${r2.join("\n")}`, `var value = ${e3.getByOffset("inputOffset")};`, `value = min(value, ${e3.getByOffset("inputOffset")});`, ""];
          }), { inputs: [0] });
        }, t.reduceProd = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceProd", t2, (e3, t3) => [`var value = ${t3.type.storage}(1);`, "", `value *= ${e3.getByOffset("inputOffset")};`, ""]), { inputs: [0] });
        }, t.reduceSum = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceSum", t2, (e3, t3) => [`var value = ${t3.type.storage}(0);`, "", `value += ${e3.getByOffset("inputOffset")};`, ""]), { inputs: [0] });
        }, t.reduceSumSquare = (e2, t2) => {
          s(e2.inputs), e2.compute(l(e2.inputs, "ReduceSumSquare", t2, (e3, t3) => [`var t = f32(0); var value = ${t3.type.storage}(0);`, "", `t = ${e3.getByOffset("inputOffset")}; value += t * t;`, ""]), { inputs: [0] });
        }, t.parseReduceAttributes = (e2) => (0, i.createAttributeWithCacheKey)(e2);
      }, 4566: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseResizeAttributes = t.resize = t.createResizeProgramInfoLoader = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075);
        t.createResizeProgramInfoLoader = (e2, t2, n2, i2, s, u) => {
          const l = { name: "Resize", inputTypes: [o.GpuDataType.default], cacheHint: t2.cacheKey + n2.toString() + (i2.length > 0 ? "_scales_" + i2.toString() : "") + (s.length > 0 ? "_sizes_" + s.toString() : "") };
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, i3, s2, u2, l2) => {
            const c = t3.dims, p = ((e4, t4, n4) => {
              const r2 = new Array(n4).fill(0).concat(new Array(n4).fill(1)), i4 = 0 === e4.length ? r2 : e4.slice();
              return t4.length > 0 ? (t4.forEach((e5, o2) => {
                r2[e5] = i4[o2], r2[o2 + n4] = i4[t4.length + o2];
              }), r2) : i4;
            })(l2, n3.axes, c.length);
            let d = ((e4, t4, n4, r2) => {
              let i4 = [];
              if (n4.length > 0)
                if (r2.length > 0) {
                  if (e4.forEach((e5) => i4.push(e5)), Math.max(...r2) > e4.length)
                    throw new Error("axes is out of bound");
                  r2.forEach((e5, t5) => i4[e5] = n4[t5]);
                } else
                  n4.forEach((e5) => i4.push(e5));
              else {
                if (0 === t4.length)
                  throw new Error("Resize requires either scales or sizes.");
                i4 = e4.map((e5, n5) => Math.round(e5 * t4[n5]));
              }
              return i4;
            })(c, s2, u2, n3.axes), f = s2.slice();
            0 === s2.length && (f = c.map((e4, t4) => 0 === e4 ? 1 : d[t4] / e4), "stretch" !== n3.keepAspectRatioPolicy && (d = ((e4, t4, n4, r2) => {
              const i4 = (() => {
                switch (r2.keepAspectRatioPolicy) {
                  case "not_larger":
                    return r2.axes.length > 0 ? Math.min(...r2.axes.map((e5) => n4[e5]), Number.MAX_VALUE) : Math.min(...n4, Number.MAX_VALUE);
                  case "not_smaller":
                    return r2.axes.length > 0 ? Math.max(...r2.axes.map((e5) => n4[e5]), Number.MIN_VALUE) : Math.max(...n4, Number.MIN_VALUE);
                  default:
                    throw new Error(`Keep aspect ratio policy ${r2.keepAspectRatioPolicy} is not supported`);
                }
              })();
              n4.fill(1, 0, n4.length);
              const o2 = e4.slice();
              return r2.axes.length > 0 ? (r2.axes.forEach((e5) => n4[e5] = i4), r2.axes.forEach((t5) => o2[t5] = Math.round(e4[t5] * n4[t5]))) : (n4.fill(i4, 0, n4.length), o2.forEach((e5, t5) => o2[t5] = Math.round(e5 * n4[t5]))), o2;
            })(c, 0, f, n3)));
            const h = (0, a.outputVariable)("output", t3.dataType, d), g = (0, a.inputVariable)("input", t3.dataType, c), m = r.ShapeUtil.size(d), b = c.length === d.length && c.every((e4, t4) => e4 === d[t4]), y = "tf_crop_and_resize" === n3.coordinateTransformMode;
            return Object.assign(Object.assign({}, e3), { getShaderSource: (e4) => {
              return `
      ${t4 = n3.coordinateTransformMode, "fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { " + (() => {
                switch (t4) {
                  case "asymmetric":
                    return "return xResized / xScale;";
                  case "pytorch_half_pixel":
                    return "if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";
                  case "tf_half_pixel_for_nn":
                    return "return (xResized + 0.5) / xScale;";
                  case "align_corners":
                    return "if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";
                  case "tf_crop_and_resize":
                    return "if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";
                  case "half_pixel_symmetric":
                    return ["const outputWidth = xScale * lengthResized;", "const adjustment = lengthResized / outputWidth;", "const center = lengthOriginal / 2;", "const offset = center * (1 - adjustment);", "return offset + ((xResized + 0.5) / xScale) - 0.5;"].join("\n");
                  case "half_pixel":
                    return "return ((xResized + 0.5) / xScale) - 0.5;";
                  default:
                    throw new Error(`Coordinate transform mode ${t4} is not supported`);
                }
              })() + "}"};
      ${(() => {
                switch (n3.mode) {
                  case "nearest":
                    return `
              ${((e5, t5) => `
    fn checkInputIndices(inputIndices: ${e5.type.indices}) -> bool {
      const inputShape = array<u32, ${t5.length}>(${t5.map((e6) => `${e6}u`).join(",")});
      for (var i:u32 = 0; i < ${t5.length}; i++) {
        var inputIndex = ${1 === t5.length ? "inputIndices" : "inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`)(g, c)};
              ${((e5, t5) => "fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {" + (() => {
                      switch (e5) {
                        case "round_prefer_ceil":
                          return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
                        case "floor":
                          return "return floor(xOriginal);";
                        case "ceil":
                          return "return ceil(xOriginal);";
                        case "round_prefer_floor":
                          return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
                        default:
                          if (t5 < 11)
                            return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
                          throw new Error(`Nearest mode ${e5} is not supported`);
                      }
                    })() + "}")(n3.nearestMode, i3)};
              ${((e5, t5, n4, r2, i4, o2, a2) => `
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t5.type.indices}) -> ${e5.type.indices} {
        const inputShape = array<u32, ${n4.length}>(${n4.map((e6) => `${e6}u`).join(",")});
        const outputShape = array<u32, ${r2.length}>(${r2.map((e6) => `${e6}u`).join(",")});
        const scales = array<f32, ${i4.length}>(${i4.map((e6) => `${e6}f`).join(",")});
        const roi = array<f32, ${o2.length}>(${o2.map((e6) => `${e6}f`).join(",")});
        var inputIndices: ${e5.type.indices};
        for (var i:u32 = 0; i < ${r2.length}; i++) {
          var outputIndex = ${1 === r2.length ? "outputIndices" : "outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${n4.length}]);
            if (!${a2} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${e5.indicesSet("inputIndices", "i", "inputIndex")}
        }
        return inputIndices;
    }`)(g, h, c, d, f, p, y)};
              `;
                  case "linear":
                    return `
              ${((e5, t5, n4, r2, i4) => `
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e5.type.indices}) -> array<f32, ${n4.length}> {
      const inputShape = array<u32, ${t5.length}>(${t5.map((e6) => `${e6}u`).join(",")});
      const outputShape = array<u32, ${n4.length}>(${n4.map((e6) => `${e6}u`).join(",")});
      const scales = array<f32, ${r2.length}>(${r2.map((e6) => `${e6}f`).join(",")});
      const roi = array<f32, ${i4.length}>(${i4.map((e6) => `${e6}f`).join(",")});
      var originalIndices: array<f32, ${n4.length}>;
      for (var i:u32 = 0; i < ${n4.length}; i++) {
        var outputIndex = ${1 === n4.length ? "outputIndices" : "outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t5.length}]);
        }
      }
      return originalIndices;
    }`)(h, c, d, f, p)};
              ${((e5, t5, n4, r2, i4, o2, a2) => {
                      const [s3, u3, l3, c2] = 2 === n4.length ? [-1, 0, 1, -1] : 1 === i4[1] ? [0, 2, 3, 1] : [0, 1, 2, 3];
                      return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${e5.type.indices};
      inputIndices[${u3}] = max(0, min(row, ${n4[u3]} - 1));
      inputIndices[${l3}] = max(0, min(col, ${n4[l3]} - 1));
      if (${n4.length} > 2) {
        inputIndices[${c2}] = channel;
        inputIndices[${s3}] = batch;
      };
      return input[${e5.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${t5.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${u3}];
      var col:f32 = originalIndices[${l3}];
      if (${o2} && (row < 0 || row > (${n4[u3]} - 1) || col < 0 || col > ${n4[l3]} - 1)) {
        return ${a2};
      }
      row = max(0, min(row, ${n4[u3]} - 1));
      col = max(0, min(col, ${n4[l3]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${n4.length > 2}) {
        channel = u32(originalIndices[${c2}]);
        batch = u32(originalIndices[${s3}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
                    })(g, h, c, 0, f, y, n3.extrapolationValue)};
              `;
                  case "cubic":
                    return `
            ${((e5, t5, n4, r2, i4, o2, a2, s3, u3, l3) => {
                      const [c2, p2] = 2 === n4.length ? [0, 1] : 1 === i4[1] ? [2, 3] : [1, 2], d2 = (a3) => {
                        const p3 = a3 === c2 ? "row" : "col";
                        return `
      fn ${p3}CubicInterpolation(inputIndices: ${e5.type.indices}, outputIndices: ${t5.type.indices}) -> f32 {
        var outputIndex = ${1 === r2.length ? "outputIndices" : `outputIndices[${a3}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${i4[a3]},
        f32(${r2[a3]}), f32(${n4[a3]}), ${o2[a3]}, ${o2[a3]} + ${n4.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${s3} && (originalIdx < 0 || originalIdx > (${n4[a3]} - 1))) {
          return ${u3};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${p3}: f32 = originalIdx + f32(i);
          if (${p3} < 0 || ${p3} >= ${n4[a3]}) {
            if (${l3}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${s3}) {
              return ${u3};
            } else {
              ${p3} = max(0, min(${p3}, ${n4[a3]} - 1));
            }
          }
          var inputIndicesCopy: ${e5.type.indices} = inputIndices;
          inputIndicesCopy[${a3}] = u32(${p3});
          data[i + 1] = ${a3 === c2 ? `input[${e5.indicesToOffset("inputIndicesCopy")}];` : "\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);"}
        }
        return cubicInterpolation1D(data, coefs);
      }`;
                      };
                      return `
    ${d2(c2)};
    ${d2(p2)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${a2} * onePlusAbsS - 5 * ${a2}) * onePlusAbsS + 8 * ${a2}) * onePlusAbsS - 4 * ${a2};
    coeffs[1] = ((${a2} + 2) * absS - (${a2} + 3)) * absS * absS + 1;
    coeffs[2] = ((${a2} + 2) * oneMinusAbsS - (${a2} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${a2} * twoMinusAbsS - 5 * ${a2}) * twoMinusAbsS + 8 * ${a2}) * twoMinusAbsS - 4 * ${a2};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${t5.type.indices}) -> f32 {
    var inputIndices: ${e5.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `;
                    })(g, h, c, d, f, p, n3.cubicCoeffA, y, n3.extrapolationValue, n3.excludeOutside)};
            `;
                  default:
                    throw Error("Invalid resize mode");
                }
              })()};
      ${e4.declareVariables(g, h)}
      ${e4.mainStart()}
        ${e4.guardAgainstOutOfBoundsWorkgroupSizes(m)}
        if (${b}) {
          output[global_idx] = input[global_idx];
        } else {
          let outputIndices = ${h.offsetToIndices("global_idx")};
          var inputIndices: ${g.type.indices};
          ${(() => {
                switch (n3.mode) {
                  case "nearest":
                    return `inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                  if (checkInputIndices(inputIndices)) {
                    output[global_idx] = input[${g.indicesToOffset("inputIndices")}];
                  } else {
                    output[global_idx] = ${n3.extrapolationValue};
                  }`;
                  case "linear":
                    return "output[global_idx] = bilinearInterpolation(outputIndices);";
                  case "cubic":
                    return "output[global_idx] = bicubicInterpolation(outputIndices);";
                  default:
                    throw Error(`Unsupported resize mode: ${n3.mode}`);
                }
              })()};
        }
      }`;
              var t4;
            }, outputs: [{ dims: d, dataType: t3.dataType, gpuDataType: o.GpuDataType.default }], dispatchGroup: () => ({ x: Math.ceil(m / 64) }) });
          })(l, e2, t2, n2, i2, s, u) });
        }, t.resize = (e2, n2) => {
          const r2 = [], i2 = [], o2 = [], a2 = ((e3) => {
            const t2 = e3.customDataBuffer;
            return new Uint32Array(t2, t2.byteOffset, 1)[0];
          })(e2);
          ((e3, t2, n3, r3, i3, o3) => {
            const [a3, s, u] = n3 > 10 ? [1, 2, 3] : [-1, e3.length > 1 ? 1 : -1, -1], l = e3[0].dims.length;
            if (a3 > 0 && e3.length > a3 && e3[a3].dims.length > 0)
              e3[a3].getFloat32Array().forEach((e4) => o3.push(e4));
            else if ("tf_crop_and_resize" === t2.coordinateTransformMode)
              throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
            if (s > 0 && e3.length > s && e3[s].dims.length > 0) {
              if (e3[s].getFloat32Array().forEach((e4) => r3.push(e4)), 0 !== r3.length && r3.length !== l && n3 >= 18 && r3.length !== t2.axes.length)
                throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
              ((e4, t3) => {
                if (e4.every((e5) => e5 > 0 || (() => {
                  throw new Error("Resize requires scales input values to be positive");
                })), e4.length > 0) {
                  if ("linear" === t3.mode) {
                    if (!(2 === e4.length || 4 === e4.length && 1 === e4[0] && 1 === e4[1] || 4 === e4.length && 1 === e4[0] && 1 === e4[3]))
                      throw new Error("Resize requires scales input size to be 2 or 4 for linear mode");
                  } else if ("cubic" === t3.mode && !(2 === e4.length || 4 === e4.length && 1 === e4[0] && 1 === e4[1] || 4 === e4.length && 1 === e4[0] && 1 === e4[3]))
                    throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
                }
              })(r3, t2), t2.axes.length > 0 && ((e4, t3, n4) => {
                t3.every((e5) => e5 >= 0 && e5 < n4 || (() => {
                  throw new Error("Resize requires axes input values to be positive and less than rank");
                }));
                const r4 = new Array(n4).fill(1);
                return t3.forEach((t4, n5) => r4[t4] = e4[n5]), r4;
              })(r3, t2.axes, l).forEach((e4, t3) => r3[t3] = e4);
            }
            if (u > 0 && e3.length > u && (e3[u].getBigInt64Array().forEach((e4) => i3.push(Number(e4))), i3.length !== l || n3 >= 18 && i3.length === t2.axes.length))
              throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
            if (t2.axes.length > 0) {
              if (r3.length !== t2.axes.length)
                throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
              if (i3.length !== t2.axes.length)
                throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
            }
            if (void 0 !== r3 && void 0 !== i3 && r3.length > 0 && i3.length > l)
              throw new Error("Resize requires only of scales or sizes to be specified");
          })(e2.inputs, n2, a2, r2, i2, o2), e2.compute((0, t.createResizeProgramInfoLoader)(e2.inputs[0], n2, a2, r2, i2, o2), { inputs: [0] });
        }, t.parseResizeAttributes = (e2) => {
          const t2 = e2.antialias, n2 = e2.axes, r2 = e2.coordinateTransformMode, o2 = e2.cubicCoeffA, a2 = 0 !== e2.excludeOutside, s = e2.extrapolationValue, u = e2.keepAspectRatioPolicy, l = e2.mode, c = "" === e2.nearestMode ? "simple" : e2.nearestMode;
          return (0, i.createAttributeWithCacheKey)({ antialias: t2, axes: n2, coordinateTransformMode: r2, cubicCoeffA: o2, excludeOutside: a2, extrapolationValue: s, keepAspectRatioPolicy: u, mode: l, nearestMode: c });
        };
      }, 8906: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSkipLayerNormAttributes = t.skipLayerNorm = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075);
        t.skipLayerNorm = (e2, t2) => {
          ((e3) => {
            if (!e3 || e3.length < 3)
              throw new Error("layerNorm requires at least 3 inputs.");
            if (1 !== e3[0].dataType || 1 !== e3[1].dataType)
              throw new Error("inputs should be float type");
            const t3 = e3[0], n3 = e3[1], r2 = e3[2];
            if (t3.dataType !== n3.dataType || t3.dataType !== r2.dataType)
              throw new Error("All inputs must have the same data type");
            if (3 !== t3.dims.length && 2 !== t3.dims.length)
              throw new Error("Input must be 2D or 3D");
            if (3 !== n3.dims.length && 2 !== n3.dims.length)
              throw new Error("Skip must be 2D or 3D");
            const i2 = t3.dims[t3.dims.length - 1], o2 = t3.dims[t3.dims.length - 2];
            if (n3.dims[n3.dims.length - 1] !== i2)
              throw new Error("Skip must have the same hidden size as input");
            if (n3.dims[n3.dims.length - 2] !== o2)
              throw new Error("Skip must have the same sequence length as input");
            if (1 !== r2.dims.length)
              throw new Error("Gamma must be 1D");
            if (r2.dims[r2.dims.length - 1] !== i2)
              throw new Error("Gamma must have the same hidden size as input");
            if (e3.length > 3) {
              const t4 = e3[3];
              if (1 !== t4.dims.length)
                throw new Error("Beta must be 1D");
              if (t4.dims[t4.dims.length - 1] !== i2)
                throw new Error("Beta must have the same hidden size as input");
            }
            if (e3.length > 4) {
              const t4 = e3[4];
              if (1 !== t4.dims.length)
                throw new Error("Bias must be 1D");
              if (t4.dims[t4.dims.length - 1] !== i2)
                throw new Error("Bias must have the same hidden size as input");
            }
          })(e2.inputs);
          const n2 = [0];
          e2.outputCount > 1 && n2.push(-3), e2.outputCount > 2 && n2.push(-3), e2.outputCount > 3 && n2.push(3), e2.compute(((e3, t3, n3, i2) => {
            const s = { name: "SkipLayerNormalization", inputTypes: new Array(e3.length).fill(o.GpuDataType.default), cacheHint: t3.cacheKey };
            return Object.assign(Object.assign({}, s), { get: () => ((e4, t4, n4, i3, s2) => {
              const u = t4[0].dims, l = u, c = r.ShapeUtil.size(u), p = u.slice(-1)[0], d = s2 ? u.slice(0, -1).concat(1) : [], f = t4.length > 3, h = t4.length > 4, g = (0, a.tensorTypeToWsglStorageType)(t4[0].dataType), m = s2 && i3 > 1, b = s2 && i3 > 2, y = i3 > 3;
              let v = 0;
              const w = [{ dims: l, dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default }];
              return i3 > 1 && w.push({ dims: d, dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default }), i3 > 2 && w.push({ dims: d, dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default }), i3 > 3 && w.push({ dims: u, dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default }), Object.assign(Object.assign({}, e4), { getShaderSource: (e5) => `
      const hiddenSize: u32 = ${p};
      const epsilon: f32 = ${n4.epsilon};

      @group(0) @binding(${v++}) var<storage, read> x : array<${g}>;
      @group(0) @binding(${v++}) var<storage, read> skip : array<${g}>;
      @group(0) @binding(${v++}) var<storage, read> gamma : array<${g}>;
      ${f ? `@group(0) @binding(${v++}) var<storage, read> beta : array<${g}>;` : ""}
      ${h ? `@group(0) @binding(${v++}) var<storage, read> bias : array<${g}>;` : ""}
      @group(0) @binding(${v++}) var<storage, read_write> output : array<${g}>;
      ${m ? `@group(0) @binding(${v++}) var<storage, read_write> meanOutput : array<${g}>;` : ""}
      ${b ? `@group(0) @binding(${v++}) var<storage, read_write> invStdOutput : array<${g}>;` : ""}
      ${y ? `@group(0) @binding(${v++}) var<storage, read_write> inputSkipBiasSum : array<${g}>;` : ""}

      ${e5.mainStart()}
        ${e5.guardAgainstOutOfBoundsWorkgroupSizes(c / p)}
        let offset = global_idx * hiddenSize;
        var sum: f32 = 0.0;
        var squareSum: f32 = 0.0;
        for (var i: u32 = 0; i < hiddenSize; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${h ? "bias[i]" : "0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${y ? "inputSkipBiasSum[offset + i] = value;" : ""}
          output[offset + i] = value;
          sum += value;
          squareSum += value * value;
        }
        let mean: f32 = sum / f32(hiddenSize);
        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);
        ${m ? "meanOutput[global_idx] = mean;" : ""}
        ${b ? "invStdOutput[global_idx] = 1.0 / variance;" : ""}
        for (var i: u32 = 0; i < hiddenSize; i++) {
          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${f ? "beta[i]" : "0.0"};
        }
      }`, outputs: w, dispatchGroup: () => ({ x: Math.ceil(c / p / 64) }) });
            })(s, e3, t3, n3, i2) });
          })(e2.inputs, t2, e2.outputCount, false), { outputs: n2 });
        }, t.parseSkipLayerNormAttributes = (e2) => {
          const t2 = e2.epsilon;
          return (0, i.createAttributeWithCacheKey)({ epsilon: t2 });
        };
      }, 5101: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSliceAttributes = t.slice = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075), s = (e2, t2) => {
          const n2 = [];
          if (e2.length > t2)
            if (7 === e2[t2].dataType)
              e2[t2].getBigInt64Array().forEach((e3) => n2.push(Number(e3)));
            else {
              if (6 !== e2[t2].dataType)
                throw new Error(`Input ${t2} must be an array of int32 or int64`);
              e2[t2].getInt32Array().forEach((e3) => n2.push(Number(e3)));
            }
          return n2;
        }, u = (e2, t2, n2, r2, i2) => {
          let o2 = e2;
          return e2 < 0 && (o2 += n2[r2[t2]]), i2[t2] < 0 ? Math.max(0, Math.min(o2, n2[r2[t2]] - 1)) : Math.max(0, Math.min(o2, n2[r2[t2]]));
        };
        t.slice = (e2, t2) => {
          ((e3, t3) => {
            if (!e3 || e3.length < 1)
              throw new Error("too few inputs");
            if (0 !== t3.axes.length) {
              if (t3.axes.length !== t3.starts.length || t3.axes.length !== t3.ends.length)
                throw new Error("axes, starts and ends must have the same length");
            } else if (t3.starts.length !== t3.ends.length)
              throw new Error("starts and ends must have the same length");
            e3.slice(1).forEach((t4, n3) => {
              if (6 !== e3[n3 + 1].dataType && 7 !== e3[n3 + 1].dataType)
                throw new Error(`Input ${n3} must be an array of int32 or int64`);
            });
          })(e2.inputs, t2);
          const n2 = ((e3, t3) => {
            const n3 = ((e4, t4) => {
              if (e4.length > 1) {
                const t5 = s(e4, 1), n4 = s(e4, 2);
                let r2 = s(e4, 3);
                return 0 === r2.length && (r2 = [...Array(e4[0].dims.length).keys()]), (0, i.createAttributeWithCacheKey)({ starts: t5, ends: n4, axes: r2 });
              }
              return t4;
            })(e3, t3), l2 = { name: "Slice", inputTypes: [o.GpuDataType.default], cacheHint: n3.cacheKey + (e3.length > 4 ? "steps_" + e3[4].dims.toString() : "") };
            return Object.assign(Object.assign({}, l2), { get: () => ((e4, t4, n4) => {
              const i2 = t4[0].dims, l3 = r.ShapeUtil.size(i2), c = n4.axes.length > 0 ? r.ShapeUtil.normalizeAxes(n4.axes, i2.length) : [...Array(i2.length).keys()];
              let p = s(t4, 4);
              p.forEach((e5) => 0 !== e5 || (() => {
                throw new Error("step cannot be 0");
              })), 0 === p.length && (p = Array(c.length).fill(1));
              const d = n4.starts.map((e5, t5) => u(e5, t5, i2, c, p)), f = n4.ends.map((e5, t5) => u(e5, t5, i2, c, p));
              if (c.length !== i2.length)
                for (let e5 = 0; e5 < i2.length; ++e5)
                  c.includes(e5) || (d.splice(e5, 0, 0), f.splice(e5, 0, i2[e5]), p.splice(e5, 0, 1));
              const h = p.map((e5) => Math.sign(e5));
              p.forEach((e5, t5, n5) => {
                if (e5 < 0) {
                  const r2 = (f[t5] - d[t5]) / e5, i3 = d[t5], o2 = i3 + r2 * p[t5];
                  d[t5] = o2, f[t5] = i3, n5[t5] = -e5;
                }
              });
              const g = i2.slice(0);
              c.forEach((e5, t5) => {
                g[e5] = Math.ceil((f[e5] - d[e5]) / p[e5]);
              });
              const m = { dims: g, dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default }, b = (0, a.outputVariable)("output", t4[0].dataType, g), y = (0, a.inputVariable)("input", t4[0].dataType, i2), v = r.ShapeUtil.size(g);
              return Object.assign(Object.assign({}, e4), { getShaderSource: (e5) => `
      ${e5.declareVariables(y, b)}
        const signs = array<i32, ${h.length}>(${h.map((e6) => `${e6}i`).join(",")});
        const starts = array<u32, ${d.length}>(${d.map((e6) => `${e6}u`).join(",")});
        const ends = array<u32, ${f.length}>(${f.map((e6) => `${e6}u`).join(",")});
        const steps = array<u32, ${p.length}>(${p.map((e6) => `${e6}u`).join(",")});
        const inputShape = array<u32, ${i2.length}>(${i2.map((e6) => `${e6}u`).join(",")});

        ${((e6, t5, n5, r2) => `fn calculateInputIndices(outputIndices: ${t5.type.indices}) -> ${e6.type.indices} {
          var inputIndices: ${e6.type.indices};
          var carry = 0u;
          for (var i = ${n5.length}; i >= 0; i--) {
            var outputIndex = ${1 === r2.length ? "outputIndices" : "outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${1 === n5.length ? "inputIndices" : "inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`)(y, b, i2, g)}
        ${e5.mainStart()}
          ${e5.guardAgainstOutOfBoundsWorkgroupSizes(v)}
          let outputIndices = ${b.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${b.setByOffset("global_idx", y.getByIndices("inputIndices"))}
      }`, outputs: [m], dispatchGroup: () => ({ x: Math.ceil(l3 / 64) }) });
            })(l2, e3, n3) });
          })(e2.inputs, t2), l = n2.get();
          if (!(r.ShapeUtil.size(l.outputs[0].dims) > 0))
            throw new Error("slice: output size is 0");
          e2.compute(n2, { inputs: [0] });
        }, t.parseSliceAttributes = (e2) => {
          const t2 = e2.starts, n2 = e2.ends, r2 = e2.axes;
          return (0, i.createAttributeWithCacheKey)({ starts: t2, ends: n2, axes: r2 });
        };
      }, 6198: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSoftmaxAttributes = t.softmax = t.softmaxProgramMetadata = void 0;
        const r = n(6952), i = n(387), o = n(1163);
        t.softmaxProgramMetadata = { name: "Softmax", inputTypes: [o.GpuDataType.default] }, t.softmax = (e2, n2) => {
          ((e3) => {
            if (!e3 || 1 !== e3.length)
              throw new Error("Softmax op requires 1 input.");
            if (1 !== e3[0].dataType)
              throw new Error("Softmax input needs to be float.");
          })(e2.inputs), e2.compute(Object.assign(Object.assign({}, t.softmaxProgramMetadata), { cacheHint: n2.cacheKey, get: () => ((e3, n3) => {
            const i2 = "f32", a = e3.dims, s = r.ShapeUtil.size(a);
            let u = n3.axis;
            if (u < 0 && (u = a.length + u), u < a.length - 1)
              throw new Error("softmax only supports last axis for now.");
            const l = a[u], c = s / l;
            return Object.assign(Object.assign({}, t.softmaxProgramMetadata), { outputs: [{ dims: a, dataType: e3.dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e4) => `
      var<workgroup> rowMaxShared : ${i2};
      var<workgroup> rowSumShared : ${i2};
      var<workgroup> threadShared : array<${i2}, 64>;

      @group(0) @binding(0) var<storage, read> x : array<${i2}>;
      @group(0) @binding(1) var<storage, read_write> result : array<${i2}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${i2} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${i2}) {
        let index = row * row_stride + col;
        result[index] = value;
      }

      @compute @workgroup_size(64, 1, 1)
      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = 64;
        let row = gindex / wg;
        let cols = ${l};
        let row_stride : i32 = ${l};

        // find the rows max
        var threadMax = -3.402823e+38f; // 6.2.4 in wgsl spec
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = threadShared[0];
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = 0.0;
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = threadShared[0];
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`, dispatchGroup: () => ({ x: c }) });
          })(e2.inputs[0], n2) }));
        }, t.parseSoftmaxAttributes = (e2) => (0, i.createAttributeWithCacheKey)({ axis: e2.axis });
      }, 2067: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseSplitAttributes = t.split = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075);
        t.split = (e2, t2) => {
          ((e3) => {
            if (!e3 || e3.length < 1)
              throw new Error("too few inputs");
          })(e2.inputs), e2.compute(((e3, t3) => {
            const n2 = 1 === e3.length ? t3 : ((e4, t4) => {
              const n3 = [];
              let r2 = t4.numOutputs;
              return e4[1].dims[0] > 0 && (e4[1].getBigInt64Array().forEach((e5) => n3.push(Number(e5))), r2 = n3.length), (0, i.createAttributeWithCacheKey)({ numOutputs: r2, axis: t4.axis, splitSizes: n3 });
            })(e3, t3), s = { name: "Split", inputTypes: [o.GpuDataType.default], cacheHint: n2.cacheKey };
            return Object.assign(Object.assign({}, s), { get: () => ((e4, t4, n3) => {
              const i2 = t4[0].dims, s2 = r.ShapeUtil.size(i2), u = t4[0].dataType, l = i2.length, c = n3.axis, p = c < 0 ? i2.length + c : c, d = new Array(n3.numOutputs), f = (0, a.inputVariable)("input", u, i2), h = new Array(n3.numOutputs), g = [], m = [];
              let b = 0;
              for (let e5 = 0; e5 < n3.numOutputs; e5++) {
                b += n3.splitSizes[e5], h[e5] = b;
                const r2 = i2.slice();
                r2[n3.axis] = n3.splitSizes[e5], m.push(r2), d[e5] = (0, a.outputVariable)(`output${e5}`, u, m[e5]), g.push({ dims: m[e5], dataType: t4[0].dataType, gpuDataType: o.GpuDataType.default });
              }
              const y = l < 2 ? "indices" : `indices[${p}]`;
              return Object.assign(Object.assign({}, e4), { getShaderSource: (e5) => {
                return `
  ${e5.declareVariables(f, ...d)}
  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map((e6) => `${e6}u`).join(",")});
  ${t5 = h.length, `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t5}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${t5}u;
}`}
  ${((e6) => {
                  const t6 = e6.length, n4 = [];
                  for (let r2 = 0; r2 < t6; ++r2) {
                    const i3 = e6[r2].setByIndices("indices", "input[global_idx]");
                    1 === t6 ? n4.push(i3) : 0 === r2 ? n4.push(`if (outputNumber == ${r2}u) { ${i3} }`) : r2 === t6 - 1 ? n4.push(`else { ${i3} }`) : n4.push(`else if (outputNumber == ${r2}) { ${i3} }`);
                  }
                  return `
      fn writeBufferData(outputNumber: u32, indices: ${e6[0].type.indices}, global_idx: u32) {
        ${n4.join("\n")}
      }`;
                })(d)}

  ${e5.mainStart()}
    ${e5.guardAgainstOutOfBoundsWorkgroupSizes(s2)}

    var indices = ${f.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${y});
    if (outputNumber != 0) {
        ${y} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;
                var t5;
              }, outputs: g, dispatchGroup: () => ({ x: Math.ceil(s2 / 64) }) });
            })(s, [e3[0]], n2) });
          })(e2.inputs, t2), { inputs: [0] });
        }, t.parseSplitAttributes = (e2) => {
          const t2 = e2.axis, n2 = e2.splitSizes, r2 = e2.numOutputs < 0 ? n2.length : e2.numOutputs;
          if (r2 !== n2.length)
            throw new Error("numOutputs and splitSizes lengh must be equal");
          return (0, i.createAttributeWithCacheKey)({ axis: t2, numOutputs: r2, splitSizes: n2 });
        };
      }, 8699: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tile = t.createTileProgramInfo = t.tileProgramMetadata = void 0;
        const r = n(6952), i = n(1163), o = n(2075);
        t.tileProgramMetadata = { name: "Tile", inputTypes: [i.GpuDataType.default] };
        const a = (e2) => Array.from(e2.getBigInt64Array(), Number);
        t.createTileProgramInfo = (e2, t2) => {
          const n2 = t2[0].dims, s = a(t2[1]), u = ((e3, t3) => {
            const n3 = [];
            for (let r2 = 0; r2 < e3.length; ++r2)
              n3.push(e3[r2] * t3[r2]);
            return n3;
          })(n2, s), l = r.ShapeUtil.size(u), c = t2[0].dataType, p = (0, o.inputVariable)("input", c, n2), d = (0, o.outputVariable)("output", c, u);
          return Object.assign(Object.assign({}, e2), { outputs: [{ dims: u, dataType: t2[0].dataType, gpuDataType: i.GpuDataType.default }], getShaderSource: (e3) => `
      const inputShape = ${p.indices(...n2)};
      ${e3.declareVariables(p, d)}
      ${e3.mainStart()}
      ${e3.guardAgainstOutOfBoundsWorkgroupSizes(l)}
      let outputIndices = ${d.offsetToIndices("global_idx")};
      var inputIndices: ${p.type.indices};
      for (var i = 0; i < ${n2.length}; i++) {
        let inputDimValue = ${d.indicesGet("outputIndices", "i")}  % ${p.indicesGet("inputShape", "i")};

        ${p.indicesSet("inputIndices", "i", "inputDimValue")}
      }
      ${d.setByOffset("global_idx", p.getByIndices("inputIndices"))}
    }`, dispatchGroup: () => ({ x: Math.ceil(l / 64) }) });
        }, t.tile = (e2) => {
          ((e3) => {
            if (!e3 || 2 !== e3.length)
              throw new Error("Tile requires 2 inputs.");
            if (1 !== e3[0].dataType && 6 !== e3[0].dataType && 12 !== e3[0].dataType)
              throw new Error("Tile only support float, int32, and uint32 data types");
            if (7 !== e3[1].dataType)
              throw new Error("Tile `repeats` input should be of int64 data type");
            if (1 !== e3[1].dims.length)
              throw new Error("Tile `repeats` input should be 1-D");
            if (a(e3[1]).length !== e3[0].dims.length)
              throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
          })(e2.inputs);
          const n2 = a(e2.inputs[1]).toString();
          e2.compute(Object.assign(Object.assign({}, t.tileProgramMetadata), { cacheHint: n2, get: () => (0, t.createTileProgramInfo)(t.tileProgramMetadata, e2.inputs) }), { inputs: [0] });
        };
      }, 2625: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseTransposeAttributes = t.transpose = t.createTransposeProgramInfo = t.transposeProgramMetadata = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075);
        t.transposeProgramMetadata = { name: "Transpose", inputTypes: [o.GpuDataType.default] };
        const s = (e2, t2) => t2 && t2.length !== e2.length ? [...e2.keys()].reverse() : t2;
        t.createTransposeProgramInfo = (e2, n2) => {
          const i2 = e2.dataType, u = e2.dims, l = s(u, n2), c = ((e3, t2) => r.ShapeUtil.sortBasedOnPerm(e3, s(e3, t2)))(u, l), p = u.length, d = r.ShapeUtil.size(c), f = (0, a.outputVariable)("output", i2, c), h = (0, a.inputVariable)("a", i2, u);
          return Object.assign(Object.assign({}, t.transposeProgramMetadata), { outputs: [{ dims: c, dataType: e2.dataType, gpuDataType: o.GpuDataType.default }], getShaderSource: (e3) => `
  ${e3.declareVariables(h, f)}

  ${((e4, t2, n3, r2) => {
            const i3 = [];
            i3.push(`fn perm(i: ${r2.type.indices}) -> ${n3.type.indices} {
    var a: ${n3.type.indices};`);
            for (let r3 = 0; r3 < t2; ++r3)
              i3.push(n3.indicesSet("a", e4[r3], `i[${r3}]`));
            return i3.push("return a;}"), i3.join("\n");
          })(l, p, h, f)}

  ${e3.mainStart()}
    ${e3.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    let indices = ${f.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${f.setByOffset("global_idx", h.getByIndices("aIndices"))}
  }`, dispatchGroup: () => ({ x: Math.ceil(d / 64) }) });
        }, t.transpose = (e2, n2) => {
          ((e3) => {
            if (!e3 || 1 !== e3.length)
              throw new Error("Transpose requires 1 input.");
            if (1 !== e3[0].dataType && 6 !== e3[0].dataType && 12 !== e3[0].dataType)
              throw new Error("Transpose only support float, int32, and uint32 data types");
          })(e2.inputs), e2.compute(Object.assign(Object.assign({}, t.transposeProgramMetadata), { cacheHint: n2.cacheKey, get: () => (0, t.createTransposeProgramInfo)(e2.inputs[0], n2.perm) }));
        }, t.parseTransposeAttributes = (e2) => (0, i.createAttributeWithCacheKey)({ perm: e2.perm });
      }, 9302: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.log = t.thresholdedRelu = t.tanh = t.tan = t.sqrt = t.sinh = t.sin = t.sigmoid = t.relu = t.reciprocal = t.neg = t.leakyRelu = t.gelu = t.floor = t.exp = t.erf = t.erfImpl = t.elu = t.parseAlphaAttributes = t.cosh = t.cos = t.ceil = t.clip = t.clipV10 = t.cast = t.parseCastAttributes = t.atanh = t.atan = t.asinh = t.asin = t.acosh = t.acos = t.abs = void 0;
        const r = n(6952), i = n(387), o = n(1163), a = n(2075), s = (e2, t2, n2, i2, s2, u = e2.dataType) => {
          const l = { name: t2, inputTypes: [o.GpuDataType.default], cacheHint: s2 };
          return Object.assign(Object.assign({}, l), { get: () => ((e3, t3, n3, i3, s3) => Object.assign(Object.assign({}, e3), { getShaderSource: (e4) => ((e5, t4, n4, r2, i4, o2) => {
            const s4 = Math.ceil(t4 / 4);
            let u2 = "";
            u2 = "string" == typeof i4 ? `${i4}(a)` : i4("a");
            const l2 = (0, a.inputVariable)("inputData", n4, [s4], 4), c = (0, a.outputVariable)("outputData", r2, [s4], 4);
            return `
  ${e5.declareVariables(l2, c)}

  ${null != o2 ? o2 : ""}

  ${e5.mainStart()}
    ${e5.guardAgainstOutOfBoundsWorkgroupSizes(s4)}

    let a = ${l2.getByOffset("global_idx")};
    ${c.setByOffset("global_idx", u2)}
  }`;
          })(e4, r.ShapeUtil.size(t3.dims), t3.dataType, n3, i3, s3), outputs: [{ dims: t3.dims, dataType: n3, gpuDataType: o.GpuDataType.default }], dispatchGroup: (e4) => ({ x: Math.ceil(r.ShapeUtil.size(e4[0].dims) / 64 / 4) }) }))(l, e2, u, n2, i2) });
        };
        t.abs = (e2) => {
          e2.compute(s(e2.inputs[0], "Abs", "abs"));
        }, t.acos = (e2) => {
          e2.compute(s(e2.inputs[0], "Acos", "acos"));
        }, t.acosh = (e2) => {
          e2.compute(s(e2.inputs[0], "Acosh", "acosh"));
        }, t.asin = (e2) => {
          e2.compute(s(e2.inputs[0], "Asin", "asin"));
        }, t.asinh = (e2) => {
          e2.compute(s(e2.inputs[0], "Asinh", "asinh"));
        }, t.atan = (e2) => {
          e2.compute(s(e2.inputs[0], "Atan", "atan"));
        }, t.atanh = (e2) => {
          e2.compute(s(e2.inputs[0], "Atanh", "atanh"));
        }, t.parseCastAttributes = (e2) => (0, i.createAttributeWithCacheKey)(e2), t.cast = (e2, t2) => {
          let n2;
          switch (t2.to) {
            case 1:
              n2 = "vec4<f32>";
              break;
            case 12:
              n2 = "vec4<u32>";
              break;
            case 6:
              n2 = "vec4<i32>";
              break;
            case 9:
              n2 = "vec4<bool>";
              break;
            default:
              throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t2.to}`);
          }
          e2.compute(s(e2.inputs[0], "Cast", n2, void 0, t2.cacheKey, t2.to));
        }, t.clipV10 = (e2, t2) => {
          e2.compute(s(e2.inputs[0], "Clip", (e3) => `clamp(${e3}, clip_min_, clip_max_)`, `
    const clip_min_: vec4<f32> = vec4(f32(${t2.min}));
    const clip_max_: vec4<f32> = vec4(f32(${t2.max}));
`, t2.cacheKey), { inputs: [0] });
        }, t.clip = (e2) => {
          const n2 = ((e3) => {
            const t2 = e3.length >= 2 ? e3[1].getFloat32Array()[0] : r.MIN_CLIP, n3 = e3.length >= 3 ? e3[2].getFloat32Array()[0] : r.MAX_CLIP;
            return (0, i.createAttributeWithCacheKey)({ min: t2, max: n3 });
          })(e2.inputs);
          (0, t.clipV10)(e2, n2);
        }, t.ceil = (e2) => {
          e2.compute(s(e2.inputs[0], "Ceil", "ceil"));
        }, t.cos = (e2) => {
          e2.compute(s(e2.inputs[0], "Cos", "cos"));
        }, t.cosh = (e2) => {
          e2.compute(s(e2.inputs[0], "Cosh", "cosh"));
        }, t.parseAlphaAttributes = (e2) => (0, i.createAttributeWithCacheKey)(e2), t.elu = (e2, t2) => {
          e2.compute(s(e2.inputs[0], "Elu", (e3) => `elu_vf32(${e3})`, `
  const elu_alpha_: f32 = f32(${t2.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`, t2.cacheKey));
        }, t.erfImpl = (e2) => `
const r0: f32 = 0.3275911;
const r1: f32 = 0.254829592;
const r2: f32 = -0.284496736;
const r3: f32 = 1.421413741;
const r4: f32 = -1.453152027;
const r5: f32 = 1.061405429;

fn erf_vf32(v: ${e2}) -> ${e2} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`, t.erf = (e2) => {
          e2.compute(s(e2.inputs[0], "Erf", (e3) => `erf_vf32(${e3})`, (0, t.erfImpl)("vec4<f32>")));
        }, t.exp = (e2) => {
          e2.compute(s(e2.inputs[0], "Exp", "exp"));
        }, t.floor = (e2) => {
          e2.compute(s(e2.inputs[0], "Floor", "floor"));
        }, t.gelu = (e2) => {
          e2.compute(s(e2.inputs[0], "Gelu", (e3) => `0.5 * ${e3} * (1.0 + erf_vf32(${e3} * 0.7071067811865475))`, (0, t.erfImpl)("vec4<f32>")));
        }, t.leakyRelu = (e2, t2) => {
          e2.compute(s(e2.inputs[0], "LeakyRelu", (e3) => `select(leaky_relu_alpha_ * ${e3}, ${e3}, ${e3} >= vec4<f32>(0.0))`, `const leaky_relu_alpha_: f32 = f32(${t2.alpha});`, t2.cacheKey));
        }, t.neg = (e2) => {
          e2.compute(s(e2.inputs[0], "Neg", (e3) => `-${e3}`));
        }, t.reciprocal = (e2) => {
          e2.compute(s(e2.inputs[0], "Reciprocal", (e3) => `1.0/${e3}`));
        }, t.relu = (e2) => {
          e2.compute(s(e2.inputs[0], "Relu", (e3) => `select(vec4<f32>(0.0), ${e3}, ${e3} > vec4<f32>(0.0))`));
        }, t.sigmoid = (e2) => {
          e2.compute(s(e2.inputs[0], "Sigmoid", (e3) => `(1.0 / (1.0 + exp(-${e3})))`));
        }, t.sin = (e2) => {
          e2.compute(s(e2.inputs[0], "Sin", "sin"));
        }, t.sinh = (e2) => {
          e2.compute(s(e2.inputs[0], "Sinh", "sinh"));
        }, t.sqrt = (e2) => {
          e2.compute(s(e2.inputs[0], "Sqrt", "sqrt"));
        }, t.tan = (e2) => {
          e2.compute(s(e2.inputs[0], "Tan", "tan"));
        }, t.tanh = (e2) => {
          e2.compute(s(e2.inputs[0], "Tanh", "tanh"));
        }, t.thresholdedRelu = (e2, t2) => (e2.compute(s(e2.inputs[0], "ThresholdedRelu", (e3) => `select(vec4<f32>(0.0), ${e3}, ${e3} > thresholded_relu_alpha_)`, `const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t2.alpha});`, t2.cacheKey)), 0), t.log = (e2) => {
          e2.compute(s(e2.inputs[0], "Log", "log"));
        };
      }, 8305: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ProgramManager = void 0;
        const r = n(4955), i = n(2075);
        t.ProgramManager = class {
          constructor(e2) {
            this.backend = e2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
          }
          getArtifact(e2) {
            return this.repo.get(e2);
          }
          setArtifact(e2, t2) {
            this.repo.set(e2, t2);
          }
          run(e2, t2, n2, r2) {
            const i2 = this.backend.device, o = this.backend.getComputePassEncoder(), a = this.backend.supportTimestampQuery && "default" === this.backend.env.webgpu.profilingMode;
            a && o.writeTimestamp(this.backend.profilingQuerySet, 0), o.setPipeline(e2.computePipeline);
            const s = [];
            for (const e3 of t2)
              s.push({ binding: s.length, resource: { buffer: e3.buffer } });
            for (const e3 of n2)
              s.push({ binding: s.length, resource: { buffer: e3.buffer } });
            const u = i2.createBindGroup({ layout: e2.computePipeline.getBindGroupLayout(0), entries: s });
            if (o.setBindGroup(0, u), o.dispatchWorkgroups(...r2), this.backend.pendingDispatchNumber++, a) {
              o.writeTimestamp(this.backend.profilingQuerySet, 1), null == this.backend.profilingQueryData && (this.backend.profilingQueryData = this.backend.gpuDataManager.create(16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE));
              const e3 = this.backend.gpuDataManager.create(16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
              this.backend.endComputePass(), this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet, 0, 2, this.backend.profilingQueryData.buffer, 0), this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer, 0, e3.buffer, 0, 16), this.backend.flush();
              const t3 = this.backend.currentKernelId, n3 = this.backend.kernels.get(t3)[0];
              e3.buffer.mapAsync(GPUMapMode.READ).then(() => {
                const r3 = new BigUint64Array(e3.buffer.getMappedRange()), i3 = r3[0], o2 = r3[1];
                e3.buffer.unmap(), void 0 === this.backend.profilingTimeBase && (this.backend.profilingTimeBase = i3);
                const a2 = Number(i3 - this.backend.profilingTimeBase), s2 = Number(o2 - this.backend.profilingTimeBase);
                if (!Number.isSafeInteger(a2) || !Number.isSafeInteger(s2))
                  throw new RangeError("incorrect timestamp range");
                this.backend.gpuDataManager.release(e3.id), console.log(`[profiling] kernel "${t3}|${n3}" execution time: ${s2 - a2} ns`);
              });
            }
            this.backend.pendingDispatchNumber >= 16 && this.backend.flush();
          }
          dispose() {
          }
          build(e2, t2) {
            const n2 = this.backend.device, o = (0, i.createShaderHelper)(t2), a = e2.getShaderSource(o), s = `${o.additionalImplementations}
${a}`, u = n2.createShaderModule({ code: s });
            return (0, r.LOG_DEBUG)("verbose", () => `[WebGPU] shader code: ${s}`), { programInfo: e2, computePipeline: n2.createComputePipeline({ compute: { module: u, entryPoint: "main" }, layout: "auto" }) };
          }
          normalizeDispatchGroupSize(e2) {
            const t2 = "number" == typeof e2 ? e2 : e2.x, n2 = "number" == typeof e2 ? 1 : e2.y || 1, r2 = "number" == typeof e2 ? 1 : e2.z || 1, i2 = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
            if (t2 <= i2 && n2 <= i2 && r2 <= i2)
              return [t2, n2, r2];
            const o = t2 * n2 * r2;
            let a = Math.ceil(Math.sqrt(o));
            if (a > i2) {
              if (a = Math.ceil(Math.cbrt(o)), a > i2)
                throw new Error("Total dispatch size exceeds WebGPU maximum.");
              return [a, a, a];
            }
            return [a, a, 1];
          }
        };
      }, 1163: (e, t) => {
        "use strict";
        var n;
        Object.defineProperty(t, "__esModule", { value: true }), t.GpuDataType = void 0, (n = t.GpuDataType || (t.GpuDataType = {}))[n.default = 0] = "default", n[n.upload = 1] = "upload", n[n.profile = 2] = "profile";
      }, 9544: function(e, t, n) {
        "use strict";
        var r, i = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var i2 = Object.getOwnPropertyDescriptor(t2, n2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, i2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), o = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && i(t2, e2, n2);
          return o(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initializeRuntime = t.initializeWebAssemblyInstance = void 0;
        const s = n(2235), u = a(n(1259)), l = n(263), c = () => !!s.env.wasm.proxy && "undefined" != typeof document;
        let p, d, f, h = false, g = false, m = false;
        const b = [], y = [], v = [], w = [], x = [], _ = [], T = () => {
          if (h || !g || m || !p)
            throw new Error("worker not ready");
        }, S = (e2) => {
          switch (e2.data.type) {
            case "init-wasm":
              h = false, e2.data.err ? (m = true, d[1](e2.data.err)) : (g = true, d[0]());
              break;
            case "init-ort":
              e2.data.err ? f[1](e2.data.err) : f[0]();
              break;
            case "create_allocate":
              e2.data.err ? b.shift()[1](e2.data.err) : b.shift()[0](e2.data.out);
              break;
            case "create_finalize":
              e2.data.err ? y.shift()[1](e2.data.err) : y.shift()[0](e2.data.out);
              break;
            case "create":
              e2.data.err ? v.shift()[1](e2.data.err) : v.shift()[0](e2.data.out);
              break;
            case "release":
              e2.data.err ? w.shift()[1](e2.data.err) : w.shift()[0]();
              break;
            case "run":
              e2.data.err ? x.shift()[1](e2.data.err) : x.shift()[0](e2.data.out);
              break;
            case "end-profiling":
              e2.data.err ? _.shift()[1](e2.data.err) : _.shift()[0]();
          }
        }, $ = "undefined" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;
        t.initializeWebAssemblyInstance = async () => {
          if (c()) {
            if (g)
              return;
            if (h)
              throw new Error("multiple calls to 'initWasm()' detected.");
            if (m)
              throw new Error("previous call to 'initWasm()' failed.");
            return h = true, void 0 === s.env.wasm.wasmPaths && $ && 0 !== $.indexOf("blob:") && (s.env.wasm.wasmPaths = $.substr(0, +$.lastIndexOf("/") + 1)), new Promise((e2, t2) => {
              null == p || p.terminate(), p = n(8050).Z(), p.onmessage = S, d = [e2, t2];
              const r2 = { type: "init-wasm", in: s.env.wasm };
              p.postMessage(r2);
            });
          }
          return (0, l.initializeWebAssembly)(s.env.wasm);
        }, t.initializeRuntime = async (e2) => {
          if (c())
            return T(), new Promise((t2, n2) => {
              f = [t2, n2];
              const r2 = { type: "init-ort", in: e2 };
              p.postMessage(r2);
            });
          await u.initRuntime(e2);
        }, t.createSessionAllocate = async (e2) => c() ? (T(), new Promise((t2, n2) => {
          b.push([t2, n2]);
          const r2 = { type: "create_allocate", in: { model: e2 } };
          p.postMessage(r2, [e2.buffer]);
        })) : u.createSessionAllocate(e2), t.createSessionFinalize = async (e2, t2) => c() ? (T(), new Promise((n2, r2) => {
          y.push([n2, r2]);
          const i2 = { type: "create_finalize", in: { modeldata: e2, options: t2 } };
          p.postMessage(i2);
        })) : u.createSessionFinalize(e2, t2), t.createSession = async (e2, t2) => c() ? (T(), new Promise((n2, r2) => {
          v.push([n2, r2]);
          const i2 = { type: "create", in: { model: e2, options: t2 } };
          p.postMessage(i2, [e2.buffer]);
        })) : u.createSession(e2, t2), t.releaseSession = async (e2) => {
          if (c())
            return T(), new Promise((t2, n2) => {
              w.push([t2, n2]);
              const r2 = { type: "release", in: e2 };
              p.postMessage(r2);
            });
          u.releaseSession(e2);
        }, t.run = async (e2, t2, n2, r2, i2) => c() ? (T(), new Promise((o2, a2) => {
          x.push([o2, a2]);
          const s2 = { type: "run", in: { sessionId: e2, inputIndices: t2, inputs: n2, outputIndices: r2, options: i2 } };
          p.postMessage(s2, u.extractTransferableBuffers(n2));
        })) : u.run(e2, t2, n2, r2, i2), t.endProfiling = async (e2) => {
          if (c())
            return T(), new Promise((t2, n2) => {
              _.push([t2, n2]);
              const r2 = { type: "end-profiling", in: e2 };
              p.postMessage(r2);
            });
          u.endProfiling(e2);
        };
      }, 7918: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.setRunOptions = void 0;
        const r = n(263), i = n(1497);
        t.setRunOptions = (e2) => {
          const t2 = (0, r.getInstance)();
          let n2 = 0;
          const o = [], a = e2 || {};
          try {
            if (void 0 === (null == e2 ? void 0 : e2.logSeverityLevel))
              a.logSeverityLevel = 2;
            else if ("number" != typeof e2.logSeverityLevel || !Number.isInteger(e2.logSeverityLevel) || e2.logSeverityLevel < 0 || e2.logSeverityLevel > 4)
              throw new Error(`log serverity level is not valid: ${e2.logSeverityLevel}`);
            if (void 0 === (null == e2 ? void 0 : e2.logVerbosityLevel))
              a.logVerbosityLevel = 0;
            else if ("number" != typeof e2.logVerbosityLevel || !Number.isInteger(e2.logVerbosityLevel))
              throw new Error(`log verbosity level is not valid: ${e2.logVerbosityLevel}`);
            void 0 === (null == e2 ? void 0 : e2.terminate) && (a.terminate = false);
            let r2 = 0;
            return void 0 !== (null == e2 ? void 0 : e2.tag) && (r2 = (0, i.allocWasmString)(e2.tag, o)), n2 = t2._OrtCreateRunOptions(a.logSeverityLevel, a.logVerbosityLevel, !!a.terminate, r2), 0 === n2 && (0, i.checkLastError)("Can't create run options."), void 0 !== (null == e2 ? void 0 : e2.extra) && (0, i.iterateExtraOptions)(e2.extra, "", /* @__PURE__ */ new WeakSet(), (e3, r3) => {
              const a2 = (0, i.allocWasmString)(e3, o), s = (0, i.allocWasmString)(r3, o);
              0 !== t2._OrtAddRunConfigEntry(n2, a2, s) && (0, i.checkLastError)(`Can't set a run config entry: ${e3} - ${r3}.`);
            }), [n2, o];
          } catch (e3) {
            throw 0 !== n2 && t2._OrtReleaseRunOptions(n2), o.forEach((e4) => t2._free(e4)), e3;
          }
        };
      }, 6640: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.OnnxruntimeWebAssemblySessionHandler = void 0;
        const r = n(2806), i = n(2235), o = n(2850), a = n(9544);
        let s;
        t.OnnxruntimeWebAssemblySessionHandler = class {
          async createSessionAllocate(e2) {
            const t2 = await fetch(e2);
            if (200 !== t2.status)
              throw new Error(`failed to load model: ${e2}`);
            const n2 = await t2.arrayBuffer();
            return (0, a.createSessionAllocate)(new Uint8Array(n2));
          }
          async loadModel(e2, t2) {
            if (s || (await (0, a.initializeRuntime)(i.env), s = true), "string" == typeof e2)
              if ("undefined" != typeof process && process.versions && process.versions.node) {
                const n2 = await (0, o.promisify)(r.readFile)(e2);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(n2, t2);
              } else {
                const n2 = await this.createSessionAllocate(e2);
                [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSessionFinalize)(n2, t2);
              }
            else
              [this.sessionId, this.inputNames, this.outputNames] = await (0, a.createSession)(e2, t2);
          }
          async dispose() {
            return (0, a.releaseSession)(this.sessionId);
          }
          async run(e2, t2, n2) {
            const r2 = [], o2 = [];
            Object.entries(e2).forEach((e3) => {
              const t3 = e3[0], n3 = e3[1], i2 = this.inputNames.indexOf(t3);
              if (-1 === i2)
                throw new Error(`invalid input '${t3}'`);
              r2.push(n3), o2.push(i2);
            });
            const s2 = [];
            Object.entries(t2).forEach((e3) => {
              const t3 = e3[0], n3 = this.outputNames.indexOf(t3);
              if (-1 === n3)
                throw new Error(`invalid output '${t3}'`);
              s2.push(n3);
            });
            const u = await (0, a.run)(this.sessionId, o2, r2.map((e3) => [e3.type, e3.dims, e3.data]), s2, n2), l = {};
            for (let e3 = 0; e3 < u.length; e3++)
              l[this.outputNames[s2[e3]]] = new i.Tensor(u[e3][0], u[e3][2], u[e3][1]);
            return l;
          }
          startProfiling() {
          }
          endProfiling() {
            (0, a.endProfiling)(this.sessionId);
          }
        };
      }, 7622: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.setSessionOptions = void 0;
        const r = n(263), i = n(1497);
        t.setSessionOptions = (e2) => {
          var t2, n2, o, a;
          const s = (0, r.getInstance)();
          let u = 0;
          const l = [], c = e2 || {};
          ((e3) => {
            e3.extra || (e3.extra = {}), e3.extra.session || (e3.extra.session = {});
            const t3 = e3.extra.session;
            t3.use_ort_model_bytes_directly || (t3.use_ort_model_bytes_directly = "1"), e3.executionProviders && e3.executionProviders.some((e4) => "webgpu" === ("string" == typeof e4 ? e4 : e4.name)) && (e3.enableMemPattern = false);
          })(c);
          try {
            const e3 = ((e4) => {
              switch (e4) {
                case "disabled":
                  return 0;
                case "basic":
                  return 1;
                case "extended":
                  return 2;
                case "all":
                  return 99;
                default:
                  throw new Error(`unsupported graph optimization level: ${e4}`);
              }
            })(null !== (t2 = c.graphOptimizationLevel) && void 0 !== t2 ? t2 : "all"), p = ((e4) => {
              switch (e4) {
                case "sequential":
                  return 0;
                case "parallel":
                  return 1;
                default:
                  throw new Error(`unsupported execution mode: ${e4}`);
              }
            })(null !== (n2 = c.executionMode) && void 0 !== n2 ? n2 : "sequential"), d = "string" == typeof c.logId ? (0, i.allocWasmString)(c.logId, l) : 0, f = null !== (o = c.logSeverityLevel) && void 0 !== o ? o : 2;
            if (!Number.isInteger(f) || f < 0 || f > 4)
              throw new Error(`log serverity level is not valid: ${f}`);
            const h = null !== (a = c.logVerbosityLevel) && void 0 !== a ? a : 0;
            if (!Number.isInteger(h) || h < 0 || h > 4)
              throw new Error(`log verbosity level is not valid: ${h}`);
            const g = "string" == typeof c.optimizedModelFilePath ? (0, i.allocWasmString)(c.optimizedModelFilePath, l) : 0;
            return u = s._OrtCreateSessionOptions(e3, !!c.enableCpuMemArena, !!c.enableMemPattern, p, !!c.enableProfiling, 0, d, f, h, g), 0 === u && (0, i.checkLastError)("Can't create session options."), c.executionProviders && ((e4, t3, n3) => {
              for (const o2 of t3) {
                let t4 = "string" == typeof o2 ? o2 : o2.name;
                switch (t4) {
                  case "xnnpack":
                    t4 = "XNNPACK";
                    break;
                  case "webnn":
                    if (t4 = "WEBNN", "string" != typeof o2) {
                      const t5 = o2;
                      if (null == t5 ? void 0 : t5.deviceType) {
                        const o3 = (0, i.allocWasmString)("deviceType", n3), a3 = (0, i.allocWasmString)(t5.deviceType, n3);
                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e4, o3, a3) && (0, i.checkLastError)(`Can't set a session config entry: 'deviceType' - ${t5.deviceType}.`);
                      }
                      if (null == t5 ? void 0 : t5.powerPreference) {
                        const o3 = (0, i.allocWasmString)("powerPreference", n3), a3 = (0, i.allocWasmString)(t5.powerPreference, n3);
                        0 !== (0, r.getInstance)()._OrtAddSessionConfigEntry(e4, o3, a3) && (0, i.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${t5.powerPreference}.`);
                      }
                    }
                    break;
                  case "webgpu":
                    t4 = "JS";
                    break;
                  case "wasm":
                  case "cpu":
                    continue;
                  default:
                    throw new Error(`not supported execution provider: ${t4}`);
                }
                const a2 = (0, i.allocWasmString)(t4, n3);
                0 !== (0, r.getInstance)()._OrtAppendExecutionProvider(e4, a2) && (0, i.checkLastError)(`Can't append execution provider: ${t4}.`);
              }
            })(u, c.executionProviders, l), void 0 !== c.extra && (0, i.iterateExtraOptions)(c.extra, "", /* @__PURE__ */ new WeakSet(), (e4, t3) => {
              const n3 = (0, i.allocWasmString)(e4, l), r2 = (0, i.allocWasmString)(t3, l);
              0 !== s._OrtAddSessionConfigEntry(u, n3, r2) && (0, i.checkLastError)(`Can't set a session config entry: ${e4} - ${t3}.`);
            }), [u, l];
          } catch (e3) {
            throw 0 !== u && s._OrtReleaseSessionOptions(u), l.forEach((e4) => s._free(e4)), e3;
          }
        };
      }, 7917: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.logLevelStringToEnum = t.tensorTypeToTypedArrayConstructor = t.getTensorElementSize = t.tensorDataTypeEnumToString = t.tensorDataTypeStringToEnum = void 0, t.tensorDataTypeStringToEnum = (e2) => {
          switch (e2) {
            case "int8":
              return 3;
            case "uint8":
              return 2;
            case "bool":
              return 9;
            case "int16":
              return 5;
            case "uint16":
              return 4;
            case "int32":
              return 6;
            case "uint32":
              return 12;
            case "float16":
              return 10;
            case "float32":
              return 1;
            case "float64":
              return 11;
            case "string":
              return 8;
            case "int64":
              return 7;
            case "uint64":
              return 13;
            default:
              throw new Error(`unsupported data type: ${e2}`);
          }
        }, t.tensorDataTypeEnumToString = (e2) => {
          switch (e2) {
            case 3:
              return "int8";
            case 2:
              return "uint8";
            case 9:
              return "bool";
            case 5:
              return "int16";
            case 4:
              return "uint16";
            case 6:
              return "int32";
            case 12:
              return "uint32";
            case 10:
              return "float16";
            case 1:
              return "float32";
            case 11:
              return "float64";
            case 8:
              return "string";
            case 7:
              return "int64";
            case 13:
              return "uint64";
            default:
              throw new Error(`unsupported data type: ${e2}`);
          }
        }, t.getTensorElementSize = (e2) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][e2], t.tensorTypeToTypedArrayConstructor = (e2) => {
          switch (e2) {
            case "float16":
            case "uint16":
              return Uint16Array;
            case "float32":
              return Float32Array;
            case "uint8":
            case "bool":
              return Uint8Array;
            case "int8":
              return Int8Array;
            case "int16":
              return Int16Array;
            case "int32":
              return Int32Array;
            case "float64":
              return Float64Array;
            case "uint32":
              return Uint32Array;
            case "int64":
              return BigInt64Array;
            case "uint64":
              return BigUint64Array;
            default:
              throw new Error(`unsupported type: ${e2}`);
          }
        }, t.logLevelStringToEnum = (e2) => {
          switch (e2) {
            case "verbose":
              return 0;
            case "info":
              return 1;
            case "warning":
              return 2;
            case "error":
              return 3;
            case "fatal":
              return 4;
            default:
              throw new Error(`unsupported logging level: ${e2}`);
          }
        };
      }, 1259: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.extractTransferableBuffers = t.endProfiling = t.run = t.releaseSession = t.createSession = t.createSessionFinalize = t.createSessionAllocate = t.initRuntime = void 0;
        const r = n(7918), i = n(7622), o = n(7917), a = n(263), s = n(1497);
        t.initRuntime = async (e2) => {
          var t2, r2;
          t2 = e2.wasm.numThreads, r2 = (0, o.logLevelStringToEnum)(e2.logLevel), 0 !== (0, a.getInstance)()._OrtInit(t2, r2) && (0, s.checkLastError)("Can't initialize onnxruntime.");
          {
            const t3 = n(7675).S;
            await t3((0, a.getInstance)(), e2);
          }
        };
        const u = /* @__PURE__ */ new Map();
        t.createSessionAllocate = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = t2._malloc(e2.byteLength);
          if (0 === n2)
            throw new Error(`Can't create a session. failed to allocate a buffer of size ${e2.byteLength}.`);
          return t2.HEAPU8.set(e2, n2), [n2, e2.byteLength];
        }, t.createSessionFinalize = (e2, t2) => {
          const n2 = (0, a.getInstance)();
          let r2 = 0, o2 = 0, l = [];
          const c = [], p = [];
          try {
            [o2, l] = (0, i.setSessionOptions)(t2), r2 = n2._OrtCreateSession(e2[0], e2[1], o2), 0 === r2 && (0, s.checkLastError)("Can't create a session.");
            const [d, f] = ((e3) => {
              const t3 = (0, a.getInstance)(), n3 = t3.stackSave();
              try {
                const n4 = t3.stackAlloc(8);
                return 0 !== t3._OrtGetInputOutputCount(e3, n4, n4 + 4) && (0, s.checkLastError)("Can't get session input/output count."), [t3.HEAP32[n4 / 4], t3.HEAP32[n4 / 4 + 1]];
              } finally {
                t3.stackRestore(n3);
              }
            })(r2), h = [], g = [];
            for (let e3 = 0; e3 < d; e3++) {
              const t3 = n2._OrtGetInputName(r2, e3);
              0 === t3 && (0, s.checkLastError)("Can't get an input name."), c.push(t3), h.push(n2.UTF8ToString(t3));
            }
            for (let e3 = 0; e3 < f; e3++) {
              const t3 = n2._OrtGetOutputName(r2, e3);
              0 === t3 && (0, s.checkLastError)("Can't get an output name."), p.push(t3), g.push(n2.UTF8ToString(t3));
            }
            return u.set(r2, [r2, c, p]), [r2, h, g];
          } catch (e3) {
            throw c.forEach((e4) => n2._OrtFree(e4)), p.forEach((e4) => n2._OrtFree(e4)), 0 !== r2 && n2._OrtReleaseSession(r2), e3;
          } finally {
            n2._free(e2[0]), 0 !== o2 && n2._OrtReleaseSessionOptions(o2), l.forEach((e3) => n2._free(e3));
          }
        }, t.createSession = (e2, n2) => {
          const r2 = (0, t.createSessionAllocate)(e2);
          return (0, t.createSessionFinalize)(r2, n2);
        }, t.releaseSession = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = u.get(e2);
          if (!n2)
            throw new Error(`cannot release session. invalid session id: ${e2}`);
          const [r2, i2, o2] = n2;
          i2.forEach((e3) => t2._OrtFree(e3)), o2.forEach((e3) => t2._OrtFree(e3)), t2._OrtReleaseSession(r2), u.delete(e2);
        }, t.run = async (e2, t2, n2, i2, l) => {
          const c = (0, a.getInstance)(), p = u.get(e2);
          if (!p)
            throw new Error(`cannot run inference. invalid session id: ${e2}`);
          const [d, f, h] = p, g = t2.length, m = i2.length;
          let b = 0, y = [];
          const v = [], w = [];
          try {
            [b, y] = (0, r.setRunOptions)(l);
            for (let e4 = 0; e4 < g; e4++) {
              const t3 = n2[e4][0], r2 = n2[e4][1], i3 = n2[e4][2];
              let a3, u3;
              if (Array.isArray(i3)) {
                u3 = 4 * i3.length, a3 = c._malloc(u3), w.push(a3);
                let e5 = a3 / 4;
                for (let t4 = 0; t4 < i3.length; t4++) {
                  if ("string" != typeof i3[t4])
                    throw new TypeError(`tensor data at index ${t4} is not a string`);
                  c.HEAPU32[e5++] = (0, s.allocWasmString)(i3[t4], w);
                }
              } else
                u3 = i3.byteLength, a3 = c._malloc(u3), w.push(a3), c.HEAPU8.set(new Uint8Array(i3.buffer, i3.byteOffset, u3), a3);
              const l2 = c.stackSave(), p3 = c.stackAlloc(4 * r2.length);
              try {
                let n3 = p3 / 4;
                r2.forEach((e5) => c.HEAP32[n3++] = e5);
                const i4 = c._OrtCreateTensor((0, o.tensorDataTypeStringToEnum)(t3), a3, u3, p3, r2.length);
                0 === i4 && (0, s.checkLastError)(`Can't create tensor for input[${e4}].`), v.push(i4);
              } finally {
                c.stackRestore(l2);
              }
            }
            const e3 = c.stackSave(), a2 = c.stackAlloc(4 * g), u2 = c.stackAlloc(4 * g), p2 = c.stackAlloc(4 * m), x = c.stackAlloc(4 * m);
            try {
              let e4 = a2 / 4, n3 = u2 / 4, r2 = p2 / 4, l2 = x / 4;
              for (let r3 = 0; r3 < g; r3++)
                c.HEAPU32[e4++] = v[r3], c.HEAPU32[n3++] = f[t2[r3]];
              for (let e5 = 0; e5 < m; e5++)
                c.HEAPU32[r2++] = 0, c.HEAPU32[l2++] = h[i2[e5]];
              let y2 = c._OrtRun(d, u2, a2, g, x, m, p2, b);
              const w2 = c.jsepRunPromise;
              w2 && void 0 !== w2.then && (y2 = await w2);
              const _ = [];
              0 !== y2 && (0, s.checkLastError)("failed to call OrtRun().");
              for (let e5 = 0; e5 < m; e5++) {
                const t3 = c.HEAPU32[p2 / 4 + e5], n4 = c.stackSave(), r3 = c.stackAlloc(16);
                let i3, a3 = 0;
                try {
                  y2 = c._OrtGetTensorData(t3, r3, r3 + 4, r3 + 8, r3 + 12), 0 !== y2 && (0, s.checkLastError)(`Can't access output tensor data on index ${e5}.`);
                  let n5 = r3 / 4;
                  const u3 = c.HEAPU32[n5++];
                  a3 = c.HEAPU32[n5++];
                  const l3 = c.HEAPU32[n5++], p3 = c.HEAPU32[n5++], d2 = [];
                  for (let e6 = 0; e6 < p3; e6++)
                    d2.push(c.HEAPU32[l3 / 4 + e6]);
                  c._OrtFree(l3);
                  const f2 = 0 === d2.length ? 1 : d2.reduce((e6, t4) => e6 * t4);
                  if (i3 = (0, o.tensorDataTypeEnumToString)(u3), "string" === i3) {
                    const e6 = [];
                    let t4 = a3 / 4;
                    for (let n6 = 0; n6 < f2; n6++) {
                      const r4 = c.HEAPU32[t4++], i4 = n6 === f2 - 1 ? void 0 : c.HEAPU32[t4] - r4;
                      e6.push(c.UTF8ToString(r4, i4));
                    }
                    _.push([i3, d2, e6]);
                  } else {
                    const e6 = new ((0, o.tensorTypeToTypedArrayConstructor)(i3))(f2);
                    new Uint8Array(e6.buffer, e6.byteOffset, e6.byteLength).set(c.HEAPU8.subarray(a3, a3 + e6.byteLength)), _.push([i3, d2, e6]);
                  }
                } finally {
                  c.stackRestore(n4), "string" === i3 && a3 && c._free(a3), c._OrtReleaseTensor(t3);
                }
              }
              return _;
            } finally {
              c.stackRestore(e3);
            }
          } finally {
            v.forEach((e3) => c._OrtReleaseTensor(e3)), w.forEach((e3) => c._free(e3)), 0 !== b && c._OrtReleaseRunOptions(b), y.forEach((e3) => c._free(e3));
          }
        }, t.endProfiling = (e2) => {
          const t2 = (0, a.getInstance)(), n2 = u.get(e2);
          if (!n2)
            throw new Error("invalid session id");
          const r2 = n2[0], i2 = t2._OrtEndProfiling(r2);
          0 === i2 && (0, s.checkLastError)("Can't get an profile file name."), t2._OrtFree(i2);
        }, t.extractTransferableBuffers = (e2) => {
          const t2 = [];
          for (const n2 of e2) {
            const e3 = n2[2];
            !Array.isArray(e3) && e3.buffer && t2.push(e3.buffer);
          }
          return t2;
        };
      }, 263: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var i2 = Object.getOwnPropertyDescriptor(t2, n2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, i2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), o = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var t2 = {};
          if (null != e2)
            for (var n2 in e2)
              "default" !== n2 && Object.prototype.hasOwnProperty.call(e2, n2) && r(t2, e2, n2);
          return i(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.dispose = t.getInstance = t.initializeWebAssembly = void 0;
        const a = o(n(6449)), s = n(9377), u = n(5711);
        let l, c = false, p = false, d = false;
        t.initializeWebAssembly = async (e2) => {
          if (c)
            return Promise.resolve();
          if (p)
            throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
          if (d)
            throw new Error("previous call to 'initializeWebAssembly()' failed.");
          p = true;
          const t2 = e2.initTimeout, r2 = e2.numThreads, i2 = e2.simd, o2 = r2 > 1 && (() => {
            try {
              return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
            } catch (e3) {
              return false;
            }
          })(), f = i2 && (() => {
            try {
              return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
            } catch (e3) {
              return false;
            }
          })(), h = e2.wasmPaths, g = "string" == typeof h ? h : void 0, m = /* @__PURE__ */ ((e3, t3) => t3 ? e3 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : e3 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm")(f, o2), b = "object" == typeof h ? h[m] : void 0;
          let y = false;
          const v = [];
          if (t2 > 0 && v.push(new Promise((e3) => {
            setTimeout(() => {
              y = true, e3();
            }, t2);
          })), v.push(new Promise((e3, t3) => {
            const r3 = o2 ? u : s, i3 = { locateFile: (e4, t4) => {
              if (o2 && e4.endsWith(".worker.js") && "undefined" != typeof Blob)
                return URL.createObjectURL(new Blob([n(4154)], { type: "text/javascript" }));
              if (e4.endsWith(".wasm")) {
                if (b)
                  return b;
                const e5 = null != g ? g : t4;
                return "ort-wasm-simd.wasm" === m ? e5 + "ort-wasm-simd.jsep.wasm" : "ort-wasm-simd-threaded.wasm" === m ? e5 + "ort-wasm-simd-threaded.jsep.wasm" : e5 + m;
              }
              return t4 + e4;
            } };
            if (o2)
              if ("undefined" == typeof Blob)
                i3.mainScriptUrlOrBlob = a.join(__dirname, "ort-wasm-threaded.js");
              else {
                const e4 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r3.toString()}})();`;
                i3.mainScriptUrlOrBlob = new Blob([e4], { type: "text/javascript" });
              }
            r3(i3).then((t4) => {
              p = false, c = true, l = t4, e3();
            }, (e4) => {
              p = false, d = true, t3(e4);
            });
          })), await Promise.race(v), y)
            throw new Error(`WebAssembly backend initializing failed due to timeout: ${t2}ms`);
        }, t.getInstance = () => {
          if (c && l)
            return l;
          throw new Error("WebAssembly is not initialized yet.");
        }, t.dispose = () => {
          var e2;
          !c || p || d || (p = true, null === (e2 = l.PThread) || void 0 === e2 || e2.terminateAllThreads(), l = void 0, p = false, c = false, d = true);
        };
      }, 1497: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.checkLastError = t.iterateExtraOptions = t.allocWasmString = void 0;
        const r = n(263);
        t.allocWasmString = (e2, t2) => {
          const n2 = (0, r.getInstance)(), i = n2.lengthBytesUTF8(e2) + 1, o = n2._malloc(i);
          return n2.stringToUTF8(e2, o, i), t2.push(o), o;
        }, t.iterateExtraOptions = (e2, n2, r2, i) => {
          if ("object" == typeof e2 && null !== e2) {
            if (r2.has(e2))
              throw new Error("Circular reference in options");
            r2.add(e2);
          }
          Object.entries(e2).forEach(([e3, o]) => {
            const a = n2 ? n2 + e3 : e3;
            if ("object" == typeof o)
              (0, t.iterateExtraOptions)(o, a + ".", r2, i);
            else if ("string" == typeof o || "number" == typeof o)
              i(a, o.toString());
            else {
              if ("boolean" != typeof o)
                throw new Error("Can't handle extra config type: " + typeof o);
              i(a, o ? "1" : "0");
            }
          });
        }, t.checkLastError = (e2) => {
          const t2 = (0, r.getInstance)(), n2 = t2.stackSave();
          try {
            const n3 = t2.stackAlloc(8);
            t2._OrtGetLastError(n3, n3 + 4);
            const r2 = t2.HEAP32[n3 / 4], i = t2.HEAPU32[n3 / 4 + 1], o = i ? t2.UTF8ToString(i) : "";
            throw new Error(`${e2} ERROR_CODE: ${r2}, ERROR_MESSAGE: ${o}`);
          } finally {
            t2.stackRestore(n2);
          }
        };
      }, 8050: (e, t, n) => {
        "use strict";
        n.d(t, { Z: () => o });
        var r = n(6614), i = n.n(r);
        function o() {
          return i()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={3838:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGpuBackend=void 0;const r=n(4955),a=n(7771),i=n(8510),o=n(8305);t.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.supportTimestampQuery=!1}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;const n={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ}};t.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,n.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await t.requestDevice(n),this.gpuDataManager=(0,a.createGpuDataManager)(this),this.programManager=new o.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,(0,r.configureLogger)(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(e,t,n,a,i){if(t.length!==e.inputTypes.length)throw new Error(`Input size must be equal to ${e.inputTypes.length}.`);const o=[];for(let e=0;e<t.length;++e){const n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);o[e]=n}const s=((e,t)=>{const n=t.map((e=>`${e.dataType};${e.dims.join(",")}`)).join("|");let r=e.name;return e.cacheHint&&(r+="["+e.cacheHint+"]"),r+=":"+n,r})(e,t);let u=this.programManager.getArtifact(s);const l=u?u.programInfo:"function"==typeof e.get?e.get():e,c=0===n.length?l.outputs.map(((e,t)=>t)):n;if(c.length!==l.outputs.length)throw new Error(`Output size ${c.length} must be equal to ${l.outputs.length}.`);const d=[],p=[];for(let e=0;e<l.outputs.length;++e){if(!Number.isInteger(c[e])||c[e]<-3||c[e]>=l.outputs.length)throw new Error(`Invalid output index: ${c[e]}`);if(-3===c[e])continue;const t=-1===c[e],n=-2===c[e],r=t||n?i(l.outputs[e].dataType,l.outputs[e].dims):a(c[e],l.outputs[e].dataType,l.outputs[e].dims),o=this.gpuDataManager.get(r.data);if(!o)throw new Error(`no GPU data for output: ${r.data}`);if(t&&this.temporaryData.push(o),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(o)}d.push(r),p.push(o)}const f=this.programManager.normalizeDispatchGroupSize(l.dispatchGroup(t));return u||(u=this.programManager.build(l,f),this.programManager.setArtifact(s,u)),(0,r.LOG_DEBUG)("info",(()=>`[ProgramManager] run "${l.name}" (key=${s}) with ${f[0]}x${f[1]}x${f[2]}`)),this.programManager.run(u,o,p,f),d}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){const n=await this.gpuDataManager.download(e),r=t();r.set(new Uint8Array(n,0,r.byteLength))}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n){const r=i.WEBGPU_OP_RESOLVE_RULES.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r[0],[r[1],n]])}releaseKernel(e){const t=this.kernelPersistentData.get(e);if(t){for(const e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t){const n=this.kernels.get(e);if(!n)throw new Error(`kernel not created: ${e}`);const[a,i,o]=n;if(null!==this.currentKernelId)throw new Error(`kernel "${a}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),(0,r.LOG_DEBUG)("info",(()=>`[WebGPU] Start to run kernel "${a}"...`)),this.temporaryData=[];try{return i(t,o[1]),0}catch(e){return(0,r.LOG_DEBUG)("warning",`[WebGPU] Kernel "${a}" failed. Error: ${e}`),1}finally{for(const e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(e,t,n)=>{"use strict";t.S=void 0;const r=n(7917),a=n(3838),i=n(4955),o=n(6952);class s{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");const e=o.ShapeUtil.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");const e=o.ShapeUtil.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");const e=o.ShapeUtil.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(o.ShapeUtil.size(e)!==o.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new s(this.module,this.dataType,this.data,e)}}class u{get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0;const r=e.HEAPU32;let a=n>>2;this.opKernelContext=r[a++];const i=r[a++];this.outputCount=r[a++],this.customDataOffset=r[a++],this.customDataSize=r[a++];const o=[];for(let t=0;t<i;t++){const t=r[a++],n=r[a++],i=r[a++],u=[];for(let e=0;e<i;e++)u.push(r[a++]);o.push(new s(e,t,n,u))}this.inputs=o}compute(e,t){var n,a,i;const u=null!==(a=null===(n=null==t?void 0:t.inputs)||void 0===n?void 0:n.map((e=>"number"==typeof e?this.inputs[e]:e)))&&void 0!==a?a:this.inputs,l=null!==(i=null==t?void 0:t.outputs)&&void 0!==i?i:[];return this.backend.run(e,u,l,((e,t,n)=>new s(this.module,t,this.output(e,n),n)),((e,t)=>{const n=(0,r.getTensorElementSize)(e);if(!n)throw new Error(`Unsupported data type: ${e}`);const a=n*o.ShapeUtil.size(t);return new s(this.module,e,this.backend.gpuDataManager.create(a).id,t)}))}output(e,t){const n=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+t.length));let r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}finally{this.module.stackRestore(n)}}}t.S=async(e,t)=>{const n=e.jsepInit;if(n&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");const r=new a.WebGpuBackend;await r.initialize(t),n({backend:r},(e=>r.alloc(e)),(e=>r.free(e)),((t,n,a,o=!1)=>{if(o)(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${a}`)),r.memcpy(t,n);else{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${a}`));const o=e.HEAPU8.subarray(t,t+a);r.upload(n,o)}}),(async(t,n,a)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${a}`)),await r.download(t,(()=>e.HEAPU8.subarray(n,n+a)))}),((e,t,n)=>r.createKernel(e,t,n)),(e=>r.releaseKernel(e)),((t,n)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepRun: kernel=${t}, contextDataOffset=${n}`));const a=new u(e,r,n);return r.computeKernel(t,a)}))}}},4955:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LOG_DEBUG=t.LOG=t.configureLogger=void 0;const r=n(7917),a=["V","I","W","E","F"];let i,o;t.configureLogger=(e,t)=>{i=e,o=t},t.LOG=(e,t)=>{const n=(0,r.logLevelStringToEnum)(e);var o,s;n>=(0,r.logLevelStringToEnum)(i)&&(o=n,s="function"==typeof t?t():t,console.log(`[${a[o]},${(new Date).toISOString()}]${s}`))},t.LOG_DEBUG=(...e)=>{o&&(0,t.LOG)(...e)}},6952:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAX_CLIP=t.MIN_CLIP=t.GemmUtil=t.PoolConvUtil=t.ShapeUtil=t.BroadcastUtil=t.MatMulUtil=void 0;class n{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=n;class r{static calcShape(e,t,r=!1){const a=e.length,i=t.length;if(0===a)return t;if(0===i)return e;const o=Math.max(e.length,t.length),s=new Array(o);if(r){if(a<2||i<2)return;const r=n.calcMatMulShape([e[a-2],e[a-1]],[t[i-2],t[i-1]]);if(void 0===r)return;[s[o-2],s[o-1]]=r}for(let n=r?3:1;n<=o;n++){const r=a-n<0?1:e[a-n],u=i-n<0?1:t[i-n];if(r!==u&&r>1&&u>1)return;s[o-n]=Math.max(r,u)}return s}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(1!==e[n-a]&&e[n-a]!==t[r-a])return!1;return!0}}t.BroadcastUtil=r;class a{static size(e){return a.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let a=t;a<n;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=e[a]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,null!=t?t:e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}}t.ShapeUtil=a;class i{static adjustPoolAttributes(e,t,n,r,a,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,a,o,s){if(s){if(a.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)i.adjustPadAndReturnShape(e[u+(o?1:2)],t[u],n[u],r[u],a,u,u+e.length-2,s)}}static computePoolOutputShape(e,t,n,r,a,o,s){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const u=[t[0],t[1]];return i.computeShapeHelper(e,t,u,n,r,a,o,s),u}static computeConvOutputShape(e,t,n,r,a,o,s){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const u=[e[0],t[0]];return i.computeShapeHelper(!1,e,u,n,r,a,o,s),u}static computeShapeHelper(e,t,n,r,a,o,s,u){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(i.adjustPadAndReturnShape(t[e+2],r[e],a[e],o[e],s,e,e+t.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,a,i,o,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[i]+a[o]-u)/t+1);switch(s){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return a[i]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),a[o]=n-a[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=i,t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,a,i){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let o,s,u;t?(o=e[1],s=e[0]):(o=e[0],s=e[1]);let l=-1;if(a?(u=n[0],l=1):(u=n[1],l=0),n[l]!==s)throw new Error("dimension mismatch");if(o<=0||u<=0||s<=0)throw new Error("invalid shape specified");if(i&&!r.isValidBroadcast(i,[o,u]))throw new Error("gemm: invalid bias shape for broadcast");return[o,u,s]}},t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22},387:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},7771:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGpuDataManager=void 0;const r=n(4955),a=n(1163),i=e=>16*Math.ceil(e/16);let o=0;class s{constructor(e){this.backend=e,this.storageCache=new Map,this.downloadCache=new Map,this.freeBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(e,t){const n=t.buffer,a=t.byteOffset,o=t.byteLength,s=i(o),u=this.storageCache.get(e);if(!u)throw new Error("gpu data for uploading does not exist");if(u.originalSize!==o)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${o}`);const l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=l.getMappedRange();new Uint8Array(c).set(new Uint8Array(n,a,o)),l.unmap();const d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(l,0,u.gpuData.buffer,0,s),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(l)}memcpy(e,t){const n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");const r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");const a=i(n.originalSize),o=this.backend.getCommandEncoder();this.backend.endComputePass(),o.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const n=i(e);let s;if((t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let e=this.freeBuffers.get(n);e||(e=[],this.freeBuffers.set(n,e)),s=e.length>0?e.pop():this.backend.device.createBuffer({size:n,usage:t})}else s=this.backend.device.createBuffer({size:n,usage:t});const u={id:o++,type:a.GpuDataType.default,buffer:s};return this.storageCache.set(u.id,{gpuData:u,originalSize:e}),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${u.id}`)),u}get(e){var t;return null===(t=this.storageCache.get(e))||void 0===t?void 0:t.gpuData}release(e){const t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),this.downloadCache.get(e)&&this.downloadCache.delete(e),t.originalSize}async download(e){const t=this.downloadCache.get(e);if(t)return t.data;const n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");const r=this.backend.getCommandEncoder();this.backend.endComputePass();const a=i(n.originalSize),o=this.backend.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});r.copyBufferToBuffer(n.gpuData.buffer,0,o,0,a),this.backend.flush();const s=new Promise((e=>{o.mapAsync(GPUMapMode.READ).then((()=>{const t=o.getMappedRange().slice(0);o.destroy(),e(t)}))}));return this.downloadCache.set(e,{data:s}),s}refreshPendingBuffers(){for(const e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(const e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map,this.downloadCache=new Map,this.freeBuffers=new Map}}t.createGpuDataManager=(...e)=>new s(...e)},8510:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGPU_OP_RESOLVE_RULES=void 0;const o=n(1868),s=i(n(504)),u=n(513),l=n(9770),c=n(7640),d=n(8856),p=n(8405),f=n(4271),h=n(1798),g=n(6145),m=n(1522),y=i(n(5262)),b=n(6031),v=n(4566),w=n(8906),$=n(5101),x=n(6198),S=n(2067),_=n(8699),A=n(2625),C=i(n(9302));t.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[C.abs]],["Acos",[C.acos]],["Acosh",[C.acosh]],["Add",[s.add]],["ArgMax",[o.argMax,o.parseArgMinMaxAttributes]],["ArgMin",[o.argMin,o.parseArgMinMaxAttributes]],["Asin",[C.asin]],["Asinh",[C.asinh]],["Atan",[C.atan]],["Atanh",[C.atanh]],["AveragePool",[y.averagePool,y.parseAveragePoolAttributes]],["Cast",[C.cast,C.parseCastAttributes]],["Ceil",[C.ceil]],["ClipV10",[C.clipV10]],["Clip",[C.clip]],["Concat",[u.concat,u.parseConcatAttributes]],["Conv",[l.conv,l.parseConvAttributes]],["ConvTranspose",[c.convTranspose,c.parseConvTransposeAttributes]],["Cos",[C.cos]],["Cosh",[C.cosh]],["Div",[s.div]],["Elu",[C.elu,C.parseAlphaAttributes]],["Erf",[C.erf]],["Exp",[C.exp]],["Expand",[d.expand]],["Floor",[C.floor]],["Gather",[p.gather,p.parseGatherAttributes]],["Gelu",[C.gelu]],["Gemm",[f.gemm,f.parseGemmAttributes]],["GlobalAveragePool",[y.globalAveragePool,y.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[y.globalMaxPool,y.parseGlobalMaxPoolAttributes]],["InstanceNormalization",[h.instanceNorm,h.parseInstanceNormAttributes]],["LayerNormalization",[g.layerNorm,g.parseLayerNormAttributes]],["LeakyRelu",[C.leakyRelu,C.parseAlphaAttributes]],["Log",[C.log]],["MatMul",[m.matMul]],["MaxPool",[y.maxPool,y.parseMaxPoolAttributes]],["Mul",[s.mul]],["Neg",[C.neg]],["Pow",[s.pow]],["Reciprocal",[C.reciprocal]],["ReduceMin",[b.reduceMin,b.parseReduceAttributes]],["ReduceMean",[b.reduceMean,b.parseReduceAttributes]],["ReduceMax",[b.reduceMax,b.parseReduceAttributes]],["ReduceSum",[b.reduceSum,b.parseReduceAttributes]],["ReduceProd",[b.reduceProd,b.parseReduceAttributes]],["ReduceL1",[b.reduceL1,b.parseReduceAttributes]],["ReduceL2",[b.reduceL2,b.parseReduceAttributes]],["ReduceLogSum",[b.reduceLogSum,b.parseReduceAttributes]],["ReduceLogSumExp",[b.reduceLogSumExp,b.parseReduceAttributes]],["ReduceSumSquare",[b.reduceSumSquare,b.parseReduceAttributes]],["Relu",[C.relu]],["Resize",[v.resize,v.parseResizeAttributes]],["Sigmoid",[C.sigmoid]],["Sin",[C.sin]],["Sinh",[C.sinh]],["Slice",[$.slice,$.parseSliceAttributes]],["SkipLayerNormalization",[w.skipLayerNorm,w.parseSkipLayerNormAttributes]],["Split",[S.split,S.parseSplitAttributes]],["Sqrt",[C.sqrt]],["Softmax",[x.softmax,x.parseSoftmaxAttributes]],["Sub",[s.sub]],["Tan",[C.tan]],["Tanh",[C.tanh]],["ThresholdedRelu",[C.thresholdedRelu,C.parseAlphaAttributes]],["Tile",[_.tile]],["Transpose",[A.transpose,A.parseTransposeAttributes]]])},1427:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.biasActivationSnippet=t.activationFnSnippet=t.typeSnippet=void 0,t.typeSnippet=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}},t.activationFnSnippet=(e,t=!1,n=!1,r=3)=>"",t.biasActivationSnippet=(e,t)=>`\\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\\n      ${t?"value = activation(value, coords);":""}\\n      `},9456:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfo=void 0;const r=n(4955),a=n(6952),i=n(1163),o=n(1427),s=n(4085),u=n(158);t.createConv2DMatMulProgramInfo=(e,t,n,l,c,d,p,f,h)=>{const g="NHWC"===n.format,m=g?e[0].dims[3]:e[0].dims[1],y=l[0],b=g?l[2]:l[3],v=g?l[1]:l[2],w=g?l[3]:l[1],$=((m%4==0||m%3==0)&&g||b%4==0&&!g)&&w%4==0,x=g?w:b*v,S=g?b*v:w,_=$?[8,8,1]:[x<=4?4:16,x>4&&S<=4?4:16,1],A=$?[4,4,1]:[x<=4?1:2,x>4&&S<=4?1:2,1],C=[Math.ceil(x/_[0]/A[0]),Math.ceil(S/_[1]/A[1]),Math.ceil(y/_[2]/A[1])];(0,r.LOG_DEBUG)("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${C}`));const O=$?g&&m%4!=0?3:4:A[0],T=_[1]*A[1],I=_[0]*A[0],E=Math.max(_[0]*O,_[1]),P=c%T==0,M=d%I==0,R=p%E==0,k=$?[O,4,4]:[1,1,1],D=[`@group(0) @binding(0) var<storage, read> x: array<${$&&4===O?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?"vec4<f32>":"f32"}>;`];let z=`\\n      fn setOutputAtIndex(flatIndex : i32, value : ${$?"vec4<f32>":"f32"}) {\\n        result[flatIndex] = ${$?"vec4<f32>":"f32"}(value);\\n      }\\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?"vec4<f32>":"f32"}) {\\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\\n        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);\\n      }`;return f&&(D.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),z+=`\\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {\\n          return bias[coords.${g?"w":"y"}${$?"/ 4":""}];\\n        }`),Object.assign(Object.assign({},t),{outputs:[{dims:l,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:C[0],y:C[1],z:C[2]}),getShaderSource:()=>`\\n        ${s.utilFunctions}\\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\\n        ${D.join("")}\\n        @group(0) @binding(${D.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;\\n        //@group(0) @binding(${D.length+1}) var<uniform> uniforms: Uniforms;\\n\\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\\n        const outShape : vec4<i32> = vec4<i32>(${l.join(",")});\\n        const outShapeStrides : vec3<i32> = vec3<i32>(${a.ShapeUtil.computeStrides(l).slice(0,3).join(",")});\\n        const filterDims : vec2<i32> = vec2<i32>(${n.kernelShape[0]}, ${n.kernelShape[1]});\\n        const pad : vec2<i32> = vec2<i32>(${n.pads[0]}, ${n.pads[1]});\\n        const stride : vec2<i32> = vec2<i32>(${n.strides[0]}, ${n.strides[1]});\\n        const dilation : vec2<i32> = vec2<i32>(${n.dilations[0]}, ${n.dilations[1]});\\n        const dimAOuter : i32 = ${c};\\n        const dimBOuter : i32 = ${d};\\n        const dimInner : i32 = ${p};\\n        ${z}\\n        ${((e,t,n,r,a=!1,i,s=!1,u=4,l=4,c=4)=>{const d=e?"\\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\\n    ":"\\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\\n    ",p=e?"\\n    let coords = vec4<i32>(\\n      batch,\\n      row / outWidth,\\n      row % outWidth,\\n      col);\\n    ":"\\n    let coords = vec4<i32>(\\n      batch,\\n      row,\\n      col / outWidth,\\n      col % outWidth);\\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",g=e?"row":"col",m=e?"col":"row",y=`\\n    let inChannels = wShape[2];\\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\\n    let outRow = ${g} / outWidth;\\n    let outCol = ${g} % outWidth;\\n\\n    let WRow = ${m} / (filterDims[1] * inChannels);\\n    let WCol = ${m} / inChannels % filterDims[1];\\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\\n    let xCh = ${m} % inChannels;\\n    var resData = ${(0,o.typeSnippet)(u)}(0.0);\\n    // The bounds checking is always needed since we use it to pad zero for\\n    // the \'same\' padding type.\\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\\n      ${d}\\n      let xIndex = getIndexFromCoords4D(coord, xShape);\\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}\\n    }\\n    return resData;`,b=e?t&&r?`\\n    let col = colIn * ${u};\\n    ${y}`:`\\n    let col = colIn * ${u};\\n    if (row < dimAOuter && col < dimInner) {\\n      ${y}\\n    }\\n    return ${(0,o.typeSnippet)(u)}(0.0);`:r&&n?`\\n    let col = colIn * ${u};\\n    ${y}`:`\\n    let col = colIn * ${u};\\n    if (row < dimInner && col < dimBOuter) {\\n      ${y}\\n    }\\n    return ${(0,o.typeSnippet)(u)}(0.0);`,v=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(l)}`,w=(0,o.typeSnippet)(c),$=e?(0,o.typeSnippet)(u):(0,o.typeSnippet)(l),x=e?(0,o.typeSnippet)(l):(0,o.typeSnippet)(u);return`\\n    ${(0,o.activationFnSnippet)(i,s,4===c,4)}\\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$} {\\n      ${e?b:v}\\n    }\\n\\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\\n      ${e?v:b}\\n    }\\n\\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\\n      let col = colIn * ${c};\\n      if (row < dimAOuter && col < dimBOuter)\\n      {\\n      var value = valueIn;\\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\\n      ${p}\\n      ${(0,o.biasActivationSnippet)(a,i)}\\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\\n      }\\n    }`})(g,P,M,R,f,void 0,!1,k[0],k[1],k[2])}\\n            ${$?(0,u.makeMatMulPackedVec4Source)(A,_,!g,E):(0,u.makeMatMulPackedSource)(A,_,!g,E,!1,void 0,h)}`})}},6514:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConvTranspose2DProgramInfo=void 0;const r=n(4955),a=n(6952),i=n(1163),o=n(2075);t.createConvTranspose2DProgramInfo=(e,t,n,s)=>{const u=e.length>2,l=n.outputShape,c=a.ShapeUtil.size(l),d=[Math.ceil(c/64),1,1];return(0,r.LOG_DEBUG)("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${d}`)),Object.assign(Object.assign({},t),{outputs:[{dims:s?s(l):l,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:d[0],y:d[1],z:d[2]}),getShaderSource:t=>((e,t,n,r,i,s,u=!1)=>{const l="NHWC"===n.format,c=l?1:2,d=l?2:3,p=l?3:1,f=a.ShapeUtil.size(r),h=u?2:1,g=n.group,m=t[1].dims,y=m[0]/g,b=m[1];let v=`\\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?"vec4<f32>":"f32"}) {\\n    result[flatIndex] = ${u?"vec4<f32>":"f32"}(value);\\n  }`;i&&(v+=`\\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?"vec4<f32>":"f32"} {\\n      return bias[coords.${l?"w":"y"}${u?"/ 4":""}];\\n    }`);const w=u?4:1,$=(0,o.inputVariable)("W",t[1].dataType,t[1].dims,w),x=(0,o.inputVariable)("Dy",t[0].dataType,t[0].dims,w),S=[x,$];i&&S.push((0,o.inputVariable)("bias",t[2].dataType,[r[p]],w));const _=(0,o.outputVariable)("result",t[0].dataType,r,w),A=`{\\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${h};\\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\\n\\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        var dotProd: array<vec4<f32>, ${h}>;\\n        for (var i = 0; i < ${h}; i++) {\\n          dotProd[i] = vec4<f32>(0.0);\\n        }\\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\\n          var dyR = (f32(dyCorner.x) + f32(wR)) / f32(strides.x);\\n          let wRPerm = filterDims[0] - 1 - wR;\\n          if (dyR < 0.0 || dyR >= f32(outBackprop[1]) ||\\n              fract(dyR) > 0.0 || wRPerm < 0) {\\n            continue;\\n          }\\n          let idyR: u32 = u32(dyR);\\n\\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\\n            let dyC = (f32(dyCorner.y) + f32(wC)) / f32(strides.y);\\n            let dyC2 = (f32(dyCorner.y) + 1.0 + f32(wC)) / f32(strides.y);\\n            let wCPerm = filterDims[1] - 1 - wC;\\n            if (wCPerm < 0) {\\n              continue;\\n            }\\n            var bDyCVal = true;\\n            var bDyCVal2 = true;\\n            if (dyC < 0.0 || dyC >= f32(outBackprop[2]) ||\\n                fract(dyC) > 0.0) {\\n              bDyCVal = false;\\n            }\\n            if (dyC2 < 0.0 || dyC2 >= f32(outBackprop[2]) ||\\n                fract(dyC2) > 0.0) {\\n              bDyCVal2 = false;\\n            }\\n\\n            let idyC: u32 = u32(dyC);\\n            let idyC2: u32 = u32(dyC2);\\n            if (bDyCVal && bDyCVal2) {\\n              let d2Length = outBackprop[3];\\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\\n\\n                var xValue = ${x.get("batch","idyR","idyC","d2")};\\n                let tmpval = vec4<f32>(dot(xValue, wValue0),\\n                                      dot(xValue, wValue1),\\n                                      dot(xValue, wValue2),\\n                                      dot(xValue, wValue3));\\n                dotProd[0] = dotProd[0] + tmpval;\\n\\n                xValue =  ${x.get("batch","idyR","idyC2","d2")};\\n\\n                dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\\n                                                    dot(xValue, wValue1),\\n                                                    dot(xValue, wValue2),\\n                                                    dot(xValue, wValue3));\\n              }\\n            } else if (bDyCVal) {\\n              let d2Length = outBackprop[${p}];\\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\\n\\n                var xValue = ${x.get("batch","idyR","idyC","d2")};\\n                let tmpval = vec4<f32>(dot(xValue, wValue0),\\n                                      dot(xValue, wValue1),\\n                                      dot(xValue, wValue2),\\n                                      dot(xValue, wValue3));\\n                dotProd[0] = dotProd[0] + tmpval;\\n              }\\n            } else if (bDyCVal2) {\\n              let d2Length = outBackprop[3];\\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\\n\\n                var xValue = ${x.get("batch","idyR","idyC2","d2")};\\n                let tmpval = vec4<f32>(dot(xValue, wValue0),\\n                                      dot(xValue, wValue1),\\n                                      dot(xValue, wValue2),\\n                                      dot(xValue, wValue3));\\n                dotProd[1] = dotProd[1] + tmpval;\\n              }\\n            }\\n          }\\n        }\\n\\n        for (var i: u32 = 0; i < ${h}; i = i + 1) {\\n          let value = dotProd[i] + ${i?"bias[c+i]":"0.0"};\\n          ${_.set("batch","r","c + i","d1","value")};\\n        }\\n      }`,C=`\\n          let outputIndices = ${_.offsetToIndices("global_idx")};\\n          let batch = ${_.indicesGet("outputIndices",0)};\\n          let d1 = ${_.indicesGet("outputIndices",p)};\\n          let r = ${_.indicesGet("outputIndices",c)};\\n          let c = ${_.indicesGet("outputIndices",d)};\\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\\n          let dyRCorner = dyCorner.x;\\n          let dyCCorner = dyCorner.y;\\n          let groupId = d1 / ${b};\\n          let wOutChannel = d1 - groupId * ${b};\\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n          // ? = to be determined. : = across all values in that axis.\\n          var dotProd = 0.0;\\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\\n            if (wR % dilations.x != 0) {\\n              continue;\\n            }\\n            let dyR = (f32(dyRCorner) + f32(wR)) / f32(strides[0]);\\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\\n            if (dyR < 0.0 || dyR >= f32(outBackprop[${c}]) || fract(dyR) > 0.0 ||\\n                wRPerm < 0) {\\n              continue;\\n            }\\n            let idyR: u32 = u32(dyR);\\n\\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\\n              if (wC % dilations.y != 0) {\\n                continue;\\n              }\\n              let dyC = (f32(dyCCorner) + f32(wC)) / f32(strides.y);\\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\\n              if (dyC < 0.0 || dyC >= f32(outBackprop[${d}]) ||\\n                  fract(dyC) > 0.0 || wCPerm < 0) {\\n                continue;\\n              }\\n              let idyC: u32 = u32(dyC);\\n\\n              for (var d2: u32 = 0; d2 < ${y}; d2 = d2 + 1) {\\n                let inputChannel = groupId * ${y} + d2;\\n                let xValue = ${l?x.get("batch","idyR","idyC","inputChannel"):x.get("batch","inputChannel","idyR","idyC")};\\n                let wValue = ${$.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\\n                dotProd = dotProd + xValue * wValue;\\n              }\\n            }\\n          }\\n          let value = dotProd + ${i?"bias[d1]":"0.0"};\\n          ${_.setByOffset("global_idx","value")};\\n        `;return`\\n  ${e.declareVariables(...S,_)}\\n  ${v}\\n  const outShape : vec4<u32> = vec4<u32>(${r.join(",")});\\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\\n  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});\\n  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[l?1:2]}, ${n.kernelShape[l?2:3]});\\n  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});\\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\\n          ${n.dilations[0]<=1?0:(n.kernelShape[l?1:2]-1)*(n.dilations[0]-1)},\\n          ${n.dilations[1]<=1?0:(n.kernelShape[l?2:3]-1)*(n.dilations[1]-1)});\\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,\\n                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);\\n    ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)};\\n  ${u?A:C}}`})(t,e,n,l,u,1===d[1]&&1===d[2])})}},4085:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.utilFunctions=void 0,t.utilFunctions="\\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n}\\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\\n}\\n"},158:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeMatMulPackedSource=t.makeMatMulPackedVec4Source=void 0,t.makeMatMulPackedVec4Source=(e,t,n=!1,r=32,a=!1,i=32,o=!1)=>{const s=t[1]*e[1],u=t[0]*e[0],l=n?s:r,c=n?r:s,d=l/t[0],p=r/t[1];if((!n||4!==d||4!==e[1])&&(n||3!==d&&4!==d)||l%t[0]!=0||r%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${n} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.\\n      Otherwise, innerElementSize ${d} must be 3 or 4.\\n  tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\\nvar<workgroup> mm_Asub : array<array<vec${d}<f32>, ${l/d}>, ${c}>;\\nvar<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/e[0]}>, ${r}>;\\n\\nconst rowPerThread = ${e[1]};\\nconst colPerThread = ${e[0]};\\nconst innerElementSize = ${d};\\nconst tileInner = ${r};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n  let localRow = i32(localId.y);\\n  let tileRow = ${o?"0":"localRow * rowPerThread"};\\n  let tileCol = i32(localId.x);\\n\\n  let globalRow = ${o?"0":"i32(globalId.y) * rowPerThread"};\\n  let globalCol = i32(globalId.x);\\n  let batch = ${a?"0":"i32(globalId.z)"};\\n  let globalRowStart = i32(workgroupId.y) * ${s};\\n\\n  let numTiles = ${a?`${Math.ceil(i/r)}`:"(dimInner - 1) / tileInner + 1"};\\n  var kStart = ${a?`i32(globalId.z) * ${i}`:"0"};\\n\\n  var acc: array<vec4<f32>, rowPerThread>;\\n\\n  // Loop over shared dimension.\\n  let tileRowB = localRow * ${p};\\n  for (var t = 0; t < numTiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let inputRow = tileRow + innerRow;\\n          let inputCol = tileCol;\\n          ${f=n,f?"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          kStart + inputRow,\\n          globalRowStart / innerElementSize + inputCol);\\n        ":"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          globalRow + innerRow,\\n          kStart / innerElementSize + inputCol);\\n        "}\\n      }\\n\\n      // Load one tile of B into local memory.\\n      for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\\n          let inputRow = tileRowB + innerRow;\\n          let inputCol = tileCol;\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\\n          ${3===d?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\\n\\n          ${((e,t)=>e?`\\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          acc[i] = BCached0 * ACached0[i] + acc[i];\\n          acc[i] = BCached1 * ACached1[i] + acc[i];\\n          acc[i] = BCached2 * ACached2[i] + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\\n        }`:`\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          let ACached = mm_Asub[tileRow + i][k];\\n          acc[i] = BCached0 * ACached.x + acc[i];\\n          acc[i] = BCached1 * ACached.y + acc[i];\\n          acc[i] = BCached2 * ACached.z + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\\n        }`)(n,d)}\\n      }\\n\\n      workgroupBarrier();\\n  }\\n\\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\\n  }\\n}`;var f};const n=e=>e?"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              kStart + inputRow,\\n              globalRowStart + inputCol);\\n            ":"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              globalRowStart + inputRow,\\n              kStart + inputCol);\\n            ";t.makeMatMulPackedSource=(e,t,r=!1,a=32,i=!1,o=32,s=!1)=>{const u=e[1]*t[1],l=e[0]*t[0],c=r?u:a,d=r?a:u;if(d%t[1]!=0||c%t[0]!=0||a%t[1]!=0)throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);const p=d/t[1],f=c/t[0],h=a/t[1],g=s?`\\n    let localRow = i32(localId.y);\\n    let localCol = i32(localId.x);\\n    let globalRowStart = i32(workgroupId.y) * ${u};\\n    let globalColStart = i32(workgroupId.x) * ${l};\\n\\n    // Loop over shared dimension.\\n    for (var t = 0; t < numTiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {\\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\\n          ${n(r)}\\n        }\\n      }\\n      // Load one tile of B into local memory.\\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\\n            for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n            kStart + inputRow,\\n            globalColStart + inputCol);\\n        }\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      var BCached : array<f32, colPerThread>;\\n      for (var k = 0; k < tileInner; k = k + 1) {\\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\\n        }\\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\\n                ACached * BCached[innerCol];\\n          }\\n        }\\n      }\\n      workgroupBarrier();\\n    }\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\\n      }\\n    }\\n    `:`\\nlet tileRow = i32(localId.y) * rowPerThread;\\nlet tileCol = i32(localId.x) * colPerThread;\\n\\nlet globalRow = i32(globalId.y) * rowPerThread;\\nlet globalCol = i32(globalId.x) * colPerThread;\\nlet globalRowStart = i32(workgroupId.y) * ${u};\\n\\nlet tileRowA = i32(localId.y) * ${p};\\nlet tileColA = i32(localId.x) * ${f};\\nlet tileRowB = i32(localId.y) * ${h};\\n// Loop over shared dimension.\\nfor (var t = 0; t < numTiles; t = t + 1) {\\n  // Load one tile of A into local memory.\\n  for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\\n      let inputRow = tileRowA + innerRow;\\n      let inputCol = tileColA + innerCol;\\n      ${n(r)}\\n    }\\n  }\\n\\n  // Load one tile of B into local memory.\\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n      let inputRow = tileRowB + innerRow;\\n      let inputCol = tileCol + innerCol;\\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n        kStart + inputRow,\\n        globalCol + innerCol);\\n    }\\n  }\\n  kStart = kStart + tileInner;\\n  workgroupBarrier();\\n\\n  // Compute acc values for a single thread.\\n  var BCached : array<f32, colPerThread>;\\n  for (var k = 0; k < tileInner; k = k + 1) {\\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\\n    }\\n\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(r)}\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\\n      }\\n    }\\n  }\\n\\n  workgroupBarrier();\\n}\\n\\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\\n        acc[innerRow][innerCol]);\\n  }\\n}\\n`;return`\\n  var<workgroup> mm_Asub : array<array<f32, ${c}>, ${d}>;\\n  var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${a}>;\\n  const rowPerThread = ${e[1]};\\n  const colPerThread = ${e[0]};\\n  const tileInner = ${a};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n    let batch = ${i?"0":"i32(globalId.z)"};\\n    let numTiles = ${i?`${Math.ceil(o/a)}`:"(dimInner - 1) / tileInner + 1"};\\n    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};\\n\\n    var acc : array<array<f32, colPerThread>, rowPerThread>;\\n\\n    // Without this initialization strange values show up in acc.\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = 0.0;\\n      }\\n    }\\n    ${g}\\n  }\\n`}},1868:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseArgMinMaxAttributes=t.argMax=t.argMin=void 0;const r=n(387),a=n(1163),i=n(6031),o=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},s=(e,t,n,o)=>{const s=1===e.length?n:((e,t)=>(0,r.createAttributeWithCacheKey)({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}))(0,n),u=s.cacheKey+e.map((e=>e.dims.toString())).join("_"),l={name:t,inputTypes:[a.GpuDataType.default],cacheHint:u};return Object.assign(Object.assign({},l),{get:()=>(0,i.createReduceProgramInfo)(l,[e[0]],o,[s.axis],7,s.keepDims)})};t.argMin=(e,t)=>{o(e.inputs),e.compute(s(e.inputs,"ArgMin",t,((e,n,r)=>{const a=[];for(let t=0;t<e.shape.length;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};\\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\\n         value = ${e.getByOffset("inputOffset")};\\n         bestIndex = i32(lastIndex);\\n       }`,"",n.setByOffset("global_idx","bestIndex")]})),{inputs:[0]})},t.argMax=(e,t)=>{o(e.inputs),e.compute(s(e.inputs,"argMax",t,((e,n,r)=>{const a=[];for(let t=0;t<e.shape.length;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};\\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\\n         value = ${e.getByOffset("inputOffset")};\\n         bestIndex = i32(lastIndex);\\n       }`,"",n.setByOffset("global_idx","bestIndex")]})),{inputs:[0]})},t.parseArgMinMaxAttributes=e=>(0,r.createAttributeWithCacheKey)(e)},504:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sub=t.pow=t.mul=t.div=t.add=void 0;const r=n(6952),a=n(1163),i=n(2075),o=(e,t,n,o,s)=>{const u={name:t,inputTypes:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},u),{get:()=>((e,t,n,o,s,u=t.dataType)=>{var l,c;const d=!r.ShapeUtil.areEqual(t.dims,n.dims);let p=t.dims,f=r.ShapeUtil.size(t.dims),h=!1;if(d){const e=r.BroadcastUtil.calcShape(t.dims,n.dims,!1);if(!e)throw new Error("Can\'t perform binary op on the given tensors");p=e,f=r.ShapeUtil.size(p);let a=1;for(let e=0;e<p.length;e++){const r=null!==(l=t.dims[t.dims.length-e])&&void 0!==l?l:1;if(r!==(null!==(c=n.dims[n.dims.length-e])&&void 0!==c?c:1))break;a*=r}a%4==0&&(h=!0)}else h=!0;return Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,a,o,s,u,l,c,d,p)=>{const f=r.ShapeUtil.size(a),h=Math.ceil(f/4);let g,m;"string"==typeof u?g=m=(e,t)=>`${u}((${e}),(${t}))`:"function"==typeof u?g=m=u:(g=u.scalar,m=u.vector);let y="";const b=(0,i.outputVariable)("outputData",d,a,4),v=(0,i.inputVariable)("aData",l,t,4),w=(0,i.inputVariable)("bData",c,n,4);if(s){const e=e=>{const t=r.ShapeUtil.computeStrides(e),n=[];for(let r=e.length-1;r>=0;r--){const i=0===a.length?"0u":1===a.length?"outputIndices":`outputIndices[${r+a.length-e.length}]`;n.push(`${t[r]}u * (${i} % ${e[r]}u)`)}return n.length>0?n.join("+"):"0u"};y=`\\n  fn calcOffsetA(outputIndices: ${b.type.indices}) -> u32 {\\n    return ${e(t)};\\n  }\\n\\n  fn calcOffsetB(outputIndices: ${b.type.indices}) -> u32 {\\n    return ${e(n)};\\n  }\\n  `}let $;if(o)$=s?`\\n      let outputIndices = ${b.offsetToIndices("global_idx * 4u")};\\n      let offsetA = calcOffsetA(outputIndices);\\n      let offsetB = calcOffsetB(outputIndices);\\n      ${b.setByOffset("global_idx",m(v.getByOffset("offsetA / 4u"),w.getByOffset("offsetB / 4u")))}`:b.setByOffset("global_idx",m(v.getByOffset("global_idx"),w.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const e=e=>{const t=`aData[indexA${e}][componentA${e}]`,n=`bData[indexB${e}][componentB${e}]`;return`\\n      let outputIndices${e} = ${b.offsetToIndices(`global_idx * 4u + ${e}u`)};\\n      let offsetA${e} = calcOffsetA(outputIndices${e});\\n      let offsetB${e} = calcOffsetB(outputIndices${e});\\n      let indexA${e} = offsetA${e} / 4u;\\n      let indexB${e} = offsetB${e} / 4u;\\n      let componentA${e} = offsetA${e} % 4u;\\n      let componentB${e} = offsetB${e} % 4u;\\n      outputData[global_idx][${e}] = ${g(t,n)};`};$=`\\n      ${e(0)}\\n      ${e(1)}\\n      ${e(2)}\\n      ${e(3)}`}return`\\n  ${e.declareVariables(v,w,b)}\\n\\n  ${null!=p?p:""}\\n  ${y}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\\n    ${$}\\n  }`})(e,t.dims,n.dims,p,h,d,o,t.dataType,n.dataType,u,s),outputs:[{dims:p,dataType:u,gpuDataType:a.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(f/64/(h?4:1))})})})(u,e[0],e[1],n,o)})};t.add=e=>{e.compute(o(e.inputs,"Add",((e,t)=>`${e}+${t}`)))},t.div=e=>{e.compute(o(e.inputs,"Div",((e,t)=>`${e}/${t}`)))},t.mul=e=>{e.compute(o(e.inputs,"Mul",((e,t)=>`${e}*${t}`)))},t.pow=e=>{const t=(0,i.inputVariable)("input",e.inputs[0].dataType,e.inputs[0].dims).type.value,n="i32"===t?"round":"";e.compute(o(e.inputs,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\\n      if (b == ${t}(0.0)) {\\n        return ${t}(1.0);\\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\\n        return ${t}(pow(f32(a), f32(b))); // NaN\\n      }\\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${n}(pow(f32(abs(a)), f32(b))));\\n    }\\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\\n      // TODO: implement vectorized pow\\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\\n    }\\n      `))},t.sub=e=>{e.compute(o(e.inputs,"Sub",((e,t)=>`${e}-${t}`)))}},2075:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createShaderHelper=t.outputVariable=t.inputVariable=t.tensorTypeToWsglStorageType=t.WORKGROUP_SIZE=void 0;const r=n(6952);t.WORKGROUP_SIZE=64;const a=(e,t)=>{switch(e){case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}};t.tensorTypeToWsglStorageType=(e,t=1)=>{const n=a(e,t);return"string"==typeof n?n:n[0]};const i=(e,t,n,i,o)=>{const s=n.length,u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,l=a(t,o),c="string"==typeof l?l:l[1],d="string"==typeof l?l:l[0],p={indices:u,value:c,storage:d,tensor:t},f=e=>"string"==typeof e?e:`${e}u`,h={offsetToIndices:!1,indicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},g=r.ShapeUtil.computeStrides(n);let m="";for(let e=0;e<s-1;e++)m+=`\\n    let dim${e} = current / ${g[e]}u;\\n    let rest${e} = current % ${g[e]}u;\\n    indices[${e}] = dim${e};\\n    current = rest${e};\\n    `;m+=`indices[${s-1}] = current;`;const y=s<2?"":`\\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\\n    var indices: ${p.indices};\\n    var current = offset;\\n    ${m}\\n    return indices;\\n  }`,b=[];if(s>=2)for(let e=s-1;e>=0;e--)b.push(`${g[e]}u * (indices[${e}])`);const v=s<2?"":`\\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\\n    return ${b.join("+")};\\n  }`,w=(...e)=>0===s?"0u":`${p.indices}(${e.map(f).join(",")})`,$=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),x=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),S=s<2?"":`\\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${c} {\\n    return ${e}[i2o_${e}(indices)];\\n  }`,_=s<2?"":(()=>{const t=n.map(((e,t)=>`d${t}: u32`)).join(", "),r=n.map(((e,t)=>`d${t}`)).join(", ");return`\\n  fn get_${e}(${t}) -> ${c} {\\n    return get_${e}ByIndices(${w(r)});\\n  }`})(),A=s<2?"":`\\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${c}) {\\n    ${$(`i2o_${e}(indices)`,"value")}\\n  }`,C=s<2?"":(()=>{const t=n.map(((e,t)=>`d${t}: u32`)).join(", "),r=n.map(((e,t)=>`d${t}`)).join(", ");return`\\n  fn set_${e}(${t}, value: ${c}) {\\n    set_${e}ByIndices(${w(r)}, value);\\n  }`})();return{impl:()=>{const e=[];return h.offsetToIndices&&e.push(y),h.indicesToOffset&&e.push(v),h.set&&e.push(C),h.setByIndices&&e.push(A),h.get&&e.push(_),h.getByIndices&&e.push(S),e.join("\\n")},type:p,offsetToIndices:t=>(h.offsetToIndices=!0,s<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(h.indicesToOffset=!0,s<2?t:`i2o_${e}(${t})`),indices:w,indicesGet:(e,t)=>s<2?`${e}`:`${e}[${t}]`,indicesSet:(e,t,n)=>s<2?`${e}=${n};`:`${e}[${t}]=${n};`,set:(...t)=>{if(t.length!==s+1)throw new Error(`indices length must be ${s}`);const n=t[s];if("string"!=typeof n)throw new Error("value must be string");const r=t.slice(0,s).map(f).join(",");return 0===s?$("0u",n):1===s?$(r[0],n):(h.set=!0,h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:$,setByIndices:(t,n)=>s<2?$(t,n):(h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==s)throw new Error(`indices length must be ${s}`);const n=t.map(f).join(",");return 0===s?x("0u"):1===s?x(n[0]):(h.get=!0,h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:x,getByIndices:t=>s<2?x(t):(h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:i?"input":"output",name:e,shape:n}};t.inputVariable=(e,t,n,r=1)=>i(e,t,n,!0,r),t.outputVariable=(e,t,n,r=1)=>i(e,t,n,!1,r);class o{constructor(e){this.normalizedDispatchGroup=e,this.indicesHelpers=[]}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=t.WORKGROUP_SIZE){const n="number"==typeof e?e:e[0],r="number"==typeof e?1:e[1],a="number"==typeof e?1:e[2],i=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${n}, ${r}, ${a})\\n  fn main(${i?"@builtin(global_invocation_id) global_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\\n    ${i?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${n*r*a}u + local_index;`}\\n  `}declareVariable(e,t){this.indicesHelpers.push(e);const n="input"===e.usage?"read":"read_write",r=e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){let t=0;return e.filter((e=>r.ShapeUtil.size(e.shape)>0)).map((e=>this.declareVariable(e,t++))).join("\\n")}get additionalImplementations(){return this.indicesHelpers.map((e=>e.impl())).join("\\n")}}t.createShaderHelper=e=>new o(e)},513:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.concat=(e,t)=>{(e=>{if(!e||e.length<1)throw new Error("too few inputs");const t=e[0].dataType,n=e[0].dims.length;for(const r of e){if(r.dataType!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}})(e.inputs),e.compute(((e,t)=>{const n=(a=e.length,s=t.cacheKey,{name:"Concat",inputTypes:Array(a).fill(i.GpuDataType.default),cacheHint:s});var a,s;return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const a=t[0].dims.slice();if(n>=a.length||n<-1*a.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");const s=n<0?a.length+n:n,u=a.slice(0);for(let e=1;e<t.length;e++){const n=t[e].dims.slice();for(let e=0;e<a.length;e++)if(e===s)u[s]+=n[e];else if(a[e]!==n[e])throw new Error("non concat dimensions must match")}const l=r.ShapeUtil.size(u),c=new Array(t.length),d=new Array(t.length),p=t[0].dataType;let f=0;for(let e=0;e<t.length;++e)f+=t[e].dims[s],c[e]=f,d[e]=(0,o.inputVariable)(`input${e}`,p,t[e].dims);const h=(0,o.outputVariable)("output",p,u),g=h.indicesGet("indices",s);return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>{return`\\n  ${e.declareVariables(...d,h)}\\n\\n  const sizeInConcatAxis = array<u32, ${c.length}>(${c.map((e=>`${e}u`)).join(",")});\\n  ${t=c.length,`\\n  fn calculateInputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\\n      if (index < sizeInConcatAxis[i]) {\\n        return i;\\n      }\\n    }\\n    return ${t}u;\\n  }`}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n\\n    var indices = ${h.offsetToIndices("global_idx")};\\n\\n    let inputIndex = calculateInputIndex(${g});\\n    if (inputIndex != 0u) {\\n      ${g} -= sizeInConcatAxis[inputIndex - 1u];\\n    }\\n\\n    ${((e,t)=>{const n=e.length,r=[];for(let a=0;a<n;++a){const i=t.setByOffset("global_idx",e[a].getByIndices("indices"));1===n?r.push(i):0===a?r.push(`if (inputIndex == ${a}u) { ${i} }`):a===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${a}) { ${i} }`)}return r.join("\\n")})(d,h)}\\n  }`;var t},dispatchGroup:()=>({x:Math.ceil(l/64)})})})(n,e,t.axis)})})(e.inputs,t))},t.parseConcatAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis})},9192:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGroupedConvProgramInfoLoader=void 0;const r=n(6952),a=n(1163),i=n(2075),o=n(9770),s=n(3997);t.createGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=e.length>2,c=t.cacheKey,{name:"GroupedConv",inputTypes:l?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=e.length>2,c=l?"value += b[output_channel];":"",d=e[0].dims,p=e[1].dims,f=p[0]/n.group,{activationFunction:h,applyActivation:g}=(0,s.getActicationSnippet)(n),m="NHWC"===n.format,y=(0,o.calculateOutputShape)(d,p,n.dilations,n.pads,n.strides,m),b=r.ShapeUtil.size(y),v=(0,i.outputVariable)("output",e[0].dataType,y),w=(0,i.inputVariable)("x",e[0].dataType,d),$=(0,i.inputVariable)("w",e[1].dataType,p),x=[w,$];return l&&x.push((0,i.inputVariable)("b",e[2].dataType,e[2].dims)),Object.assign(Object.assign({},t),{outputs:[{dims:u?u(y):y,dataType:e[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\\n  const strides: vec2<u32> = vec2(${n.strides[0]}u, ${n.strides[1]}u);\\n  const pads: vec2<u32> = vec2(${n.pads[0]}u, ${n.pads[1]}u);\\n\\n  ${e.declareVariables(...x,v)}\\n\\n  ${h}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\\n\\n    let outputIndices = ${v.offsetToIndices("global_idx")};\\n    let batch: u32 = outputIndices[0];\\n    let output_channel: u32 = outputIndices[${m?3:1}];\\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${m?1:2}], outputIndices[${m?2:3}]) * strides - pads;\\n    let group_id: u32 = output_channel / ${f}u;\\n\\n    var value: ${v.type.value} = ${v.type.value}(0);\\n    for (var wInChannel: u32 = 0u; wInChannel < ${p[1]}u; wInChannel++) {\\n      let input_channel = group_id * ${p[1]}u + wInChannel;\\n      for (var wHeight: u32 = 0u; wHeight < ${p[2]}u; wHeight++) {\\n        let xHeight = xRCCorner.x + wHeight * ${n.dilations[0]}u;\\n\\n        if (xHeight < 0u || xHeight >= ${d[m?1:2]}u) {\\n          continue;\\n        }\\n\\n        for (var wWidth: u32 = 0u; wWidth < ${p[3]}u; wWidth++) {\\n          let xWidth = xRCCorner.y + wWidth * ${n.dilations[1]}u;\\n          if (xWidth < 0u || xWidth >= ${d[m?2:3]}u) {\\n            continue;\\n          }\\n\\n          let xVal = ${m?w.get("batch","xHeight","xWidth","input_channel"):w.get("batch","input_channel","xHeight","xWidth")};\\n          let wVal = ${$.get("output_channel","wInChannel","wHeight","wWidth")};\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${c}\\n    ${g}\\n    ${v.setByOffset("global_idx","value")}\\n  }`,dispatchGroup:()=>({x:Math.ceil(b/64)})})})(e,u,t,n)})}},7640:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.convTranspose=t.parseConvTransposeAttributes=void 0;const r=n(387),a=n(1163),i=n(6514),o=n(3997),s=(e,t,n,r,a,i)=>(e-1)*t+n+(r-1)*a+1-i,u=(e,t,n,r,a)=>{const i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[a]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[a]=i)},l=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),0)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}const r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);const a=e.pads.slice(),i=e.outputShape.slice(),o=e.outputPadding.slice(),l=t[0].dims;let c=e.dilations.slice();if(0===c.reduce(((e,t)=>e+t),0)){const e=t[0].dims.length-2;c=new Array(e).fill(1)}let d=e.strides.slice();if(0===d.reduce(((e,t)=>e+t),0)){const e=t[0].dims.length-2;d=new Array(e).fill(1)}((e,t,n,r,a,i,o,l,c,d)=>{const p=e.length-2,f=0===d.length;if(0===c.length)for(let e=0;e<p;++e)c.push(0);const h=e[0],g=t[l?3:1]*a;for(let a=0,h=e.length-p-(l?1:0);a<p;++a,++h){const l=e[h],g=f?l*o[a]:d[a],m=s(l,o[a],i[a],t[h],n[a],g);u(m,r,i,a,a+p),f&&d.push(o[a]*(l-1)+c[a]+(t[h]-1)*n[a]+1-i[a]-i[a+p])}d.splice(0,0,h),d.splice(l?3:1,0,g)})(l,n,c,e.autoPad,e.group,a,d,r,o,i);const p=Object.assign({},e);return Object.assign(p,{kernelShape:n,pads:a,outputPadding:o,outputShape:i,dilations:c,strides:d,cacheKey:e.cacheKey}),p};t.parseConvTransposeAttributes=e=>{const t=(0,o.parseInternalActivationAttributes)(e),n=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][void 0===e.autoPad?0:e.autoPad],i=e.dilations,s=e.group,u=e.kernelShape,l=e.pads,c=e.strides,d=e.wIsConst(),p=e.outputPadding,f=e.outputShape;return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:a,format:n,dilations:i,group:s,kernelShape:u,outputPadding:p,outputShape:f,pads:l,strides:c,wIsConst:d},t))};const c=(e,t,n)=>{const r=(o=3===e.length,s=t.cacheKey,{name:"ConvTranspose2D",inputTypes:o?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s});var o,s;return Object.assign(Object.assign({},r),{get:()=>(0,i.createConvTranspose2DProgramInfo)(e,r,t,n)})};t.convTranspose=(e,t)=>{((e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");const r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===e.length&&1!==e[2].dataType)throw new Error("ConvTranspose input(bias) should be float tensor")})(e.inputs,t),3===e.inputs[0].dims.length?((e,t)=>{const n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===r.length&&r.push(e.inputs[2]);let a=t.kernelShape;0!==a.length&&0!==a[0]||(a=[e.inputs[1].dims[2]]);let i=t.dilations;0!==i.length&&0!==i[0]||(i=[1]);let o=t.strides;0!==o.length&&0!==o[0]||(o=[1]);let s=t.pads;0===s.length&&(s=[0,0]),s=[0,s[0],0,s[1]],o=[1].concat(o),i=[1].concat(i),a=[1].concat(a);const u=l(Object.assign(Object.assign({},t),{pads:s,strides:o,dilations:i,kernelShape:a}),r);e.compute(c(r,u,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])))})(e,t):((e,t,n)=>{const r=l(n,t);e.compute(c(t,r))})(e,e.inputs,t)}},9770:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv=t.parseConvAttributes=t.calculateOutputShape=void 0;const r=n(6952),a=n(387),i=n(9192),o=n(3822),s=n(3997),u=n(2625);t.calculateOutputShape=(e,t,n,r,a,i)=>{const o=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],c=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),d=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-c[t]+a[t])/a[t])));return d.splice(0,0,o),d.splice(i?3:1,0,l),d};const l=(0,a.createAttributeWithCacheKey)({perm:[2,3,1,0]}),c=(e,t)=>{const n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);const a=e.pads.slice();r.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,a,"NHWC"===e.format,e.autoPad);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:a,cacheKey:e.cacheKey}),i};t.parseConvAttributes=e=>{const t=(0,s.parseInternalActivationAttributes)(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,o=e.group,u=e.kernel_shape,l=e.pads,c=e.strides,d=e.w_is_const();return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:n,dilations:i,group:o,kernelShape:u,pads:l,strides:c,wIsConst:d},t))},t.conv=(e,n)=>{((e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&1!==e[2].dataType)throw new Error("Conv input(bias) should be float tensor")})(e.inputs,n),3===e.inputs[0].dims.length?((e,t)=>{const n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);const a=[0,t.pads[0],0,t.pads[1]],o=[1].concat(t.strides),s=[1].concat(t.dilations),u=[1].concat(t.kernelShape),l=c(Object.assign(Object.assign({},t),{pads:a,strides:o,dilations:s,kernelShape:u}),r);e.compute((0,i.createGroupedConvProgramInfoLoader)(r,l,(e=>n?[e[0],e[2],e[3]]:[])))})(e,n):((e,n,r)=>{var a;const s=c(r,n),d=3===n.length,p="NHWC"===r.format,f=n[0].dims[p?1:2],h=n[0].dims[p?2:3],g=n[0].dims[p?3:1],m=n[1].dims[2],y=n[1].dims[3],b=(0,t.calculateOutputShape)(n[0].dims,n[1].dims,r.dilations,s.pads,r.strides,p),v=b[p?1:2],w=b[p?2:3],$=b[p?3:1];if(p&&m===f&&y===h&&"VALID"===r.autoPad||1===m&&1===y&&1===r.dilations[0]&&1===r.dilations[1]&&1===r.strides[0]&&1===r.strides[1]&&("SAME_UPPER"===r.autoPad||"SAME_LOWER"===r.autoPad||"VALID"===r.autoPad))return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));if(!p||1!==r.group)return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));const x=p?v*w:$,S=p?$:v*w,_=m*y*g,A=null!==(a=e.kernelCustomData.wT)&&void 0!==a?a:e.compute(Object.assign(Object.assign({},u.transposeProgramMetadata),{cacheHint:l.cacheKey,get:()=>(0,u.createTransposeProgramInfo)(n[1],l.perm)}),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);const C=[n[0],A];d&&(p||1!==n[2].dims.length?C.push(n[2]):C.push(n[2].reshape([n[2].dims[0],1,1]))),e.compute((0,o.createConv2DMatMulProgramInfoLoader)(C,s,b,x,S,_,d,!0),{inputs:C})})(e,e.inputs,n)}},3822:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfoLoader=void 0;const r=n(1163),a=n(9456);t.createConv2DMatMulProgramInfoLoader=(e,t,n,i,o,s,u,l)=>{const c=((e,t)=>({name:"Conv2DMatMul",inputTypes:e?[r.GpuDataType.default,r.GpuDataType.default,r.GpuDataType.default]:[r.GpuDataType.default,r.GpuDataType.default],cacheHint:t}))(u,t.cacheKey);return Object.assign(Object.assign({},c),{get:()=>(0,a.createConv2DMatMulProgramInfo)(e,c,t,n,i,o,s,u,l)})}},8856:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.expand=t.expandProgramMetadata=void 0;const r=n(6952),a=n(1163),i=n(2075);t.expandProgramMetadata={name:"Expand",inputTypes:[a.GpuDataType.default]};const o=(e,t)=>{const n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let a=0;a<t.length;++a)r.push(1===t[a]?e[a+n]:t[a]);return r};t.expand=e=>{(e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");const t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number);let r=n.length<t.length?0:n.length-t.length,a=t.length<n.length?0:t.length-n.length;for(;r<n.length&&a<t.length;++r,++a)if(n[r]!==t[a]&&1!==n[r]&&1!==t[a])throw new Error("Expand requires shape to be broadcastable to input")})(e.inputs);const n=Array.from(e.inputs[1].getBigInt64Array(),Number).toString();e.compute(Object.assign(Object.assign({},t.expandProgramMetadata),{cacheHint:n,get:()=>((e,t)=>{const n=t[0].dims,s=Array.from(t[1].getBigInt64Array(),Number),u=((e,t)=>e.length>t.length?o(e,t):o(t,e))(n,s),l=r.ShapeUtil.size(u),c=t[0].dataType,d=(0,i.inputVariable)("input",c,n),p=(0,i.outputVariable)("output",c,u);return Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n  const inputShape = ${d.indices(...n)};\\n  ${e.declareVariables(d,p)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n    let outputIndices = ${p.offsetToIndices("global_idx")};\\n    var inputIndices: ${d.type.indices};\\n    for (var i = 0; i < ${n.length}; i++) {\\n      if (${d.indicesGet("inputShape","i")} == 1) {\\n        ${d.indicesSet("inputIndices","i",0)}\\n      } else {\\n        ${d.indicesSet("inputIndices","i",p.indicesGet("outputIndices","i + "+(u.length-n.length)))}\\n      }\\n    }\\n    ${p.setByOffset("global_idx",d.getByIndices("inputIndices"))}\\n  }`,outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:a.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(l/64)})})})(t.expandProgramMetadata,e.inputs)}),{inputs:[0]})}},3997:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActicationSnippet=void 0;const r=n(6952);t.getActicationSnippet=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},t.parseInternalActivationAttributes=e=>{const t=(null==e?void 0:e.activation)||"";if("Clip"===t){const[n,a]=(null==e?void 0:e.activation_params)||[r.MIN_CLIP,r.MAX_CLIP];return{activation:t,clipMax:a,clipMin:n,activationCacheKey:`${t}:${n},${a}`}}return{activation:t,activationCacheKey:t}}},8405:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.gather=t.parseGatherAttributes=void 0;const r=n(6952),a=n(387),i=n(1163);t.parseGatherAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis}),t.gather=(e,t)=>{(e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")})(e.inputs);const n={name:"Gather",inputTypes:[i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(((e,t,n)=>{const a=t[0].dims,o=t[1].dims,s=a.length,u=r.ShapeUtil.normalizeAxis(n.axis,s),l=a.slice(0);l.splice(u,1,...o);const c=t[0].dataType,d=r.ShapeUtil.sizeFromDimension(a,u+1),p=[7,13,11].includes(c)?2:1,f=7===t[1].dataType?2:1,h=p*d,g=r.ShapeUtil.sizeToDimension(a,u),m=r.ShapeUtil.size(o),y=r.ShapeUtil.sizeFromDimension(a,u)*p,b=m*d*p,v=a[u],w=r.ShapeUtil.size(a)*p,$=r.ShapeUtil.size(l)*p,x=g*m;return Object.assign(Object.assign({},e),{outputs:[{dims:l,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const N: u32 = ${m};\\n  const elementSize: u32 = ${p};\\n  const indicesElementSize: u32 = ${f};\\n\\n  @group(0) @binding(0) var<storage, read> input : array<u32>;\\n  @group(0) @binding(1) var<storage, read> inputIndices : array<i32>;\\n  @group(0) @binding(2) var<storage, read_write> output: array<u32>;\\n\\n  ${e.mainStart()}\\n    let batch: u32 = global_idx / N;\\n    let i: u32 = global_idx % N;\\n\\n    let srcOffsetBatch: u32 = batch * ${y};\\n    let dstOffsetBatch: u32 = batch * ${b};\\n    var idx = inputIndices[i * indicesElementSize];\\n    if (idx < 0) {\\n        idx = idx + ${v};\\n    }\\n\\n    let srcOffset = srcOffsetBatch + u32(idx) * ${h};\\n    let dstOffset = dstOffsetBatch + i * ${h};\\n    if (srcOffset >= ${w}) {\\n        return;\\n    }\\n    if (dstOffset >= ${$}) {\\n        return;\\n    }\\n    for (var j: u32 = 0; j < ${h}; j++) {\\n        output[dstOffset + j] = input[srcOffset + j];\\n    }\\n  }`,dispatchGroup:()=>({x:Math.ceil(x/64)})})})(n,e.inputs,t))}},4271:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributes=t.gemm=void 0;const r=n(6952),a=n(387),i=n(1163);t.gemm=(e,t)=>{(e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(1!==e[0].dataType||1!==e[1].dataType||3===e.length&&1!==e[2].dataType)throw new Error("Invalid input type.");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")})(e.inputs),e.compute(((e,t)=>{const n={name:"Gemm",inputTypes:3===e.length?[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default]:[i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const a=t[0].dims.slice(),o=t[1].dims.slice(),[s,u,l]=r.GemmUtil.getShapeOfGemmResult(a,n.transA,o,n.transB,3===t.length?t[2].dims:void 0),c=[s,u];if(!c)throw new Error("Can\'t use gemm on the given tensors");const d=r.ShapeUtil.size(c);let p="";n.transA&&n.transB?p="value += a[k * M + m] * b[n * K + k];":n.transA&&!n.transB?p="value += a[k * M + m] * b[k * N + n];":!n.transA&&n.transB?p="value += a[m * K + k] * b[n * K + k];":n.transA||n.transB||(p="value += a[m * K + k] * b[k * N + n];");const f="f32",h=1===n.alpha?"":"value *= alpha;",g=3===t.length?`value += beta * c[${((e,t,n)=>{if(0===n.length)return"0u";const r=1===n.length&&1!==e||2===n.length&&n[0]!==e,a=n[n.length-1]!==t;let i="0u";return r||(i+=`+ m * ${n[n.length-1]}u`),a||(i+="+n"),i})(s,u,t[2].dims)}];`:"",m=[`@group(0) @binding(0) var<storage, read> a : array<${f}>;`,`@group(0) @binding(1) var<storage, read> b : array<${f}>;`];return 3===t.length&&m.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`),Object.assign(Object.assign({},e),{outputs:[{dims:c,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const M: u32 = ${s}u;\\n  const N: u32 = ${u}u;\\n  const K: u32 = ${l}u;\\n  const alpha = ${f}(${n.alpha});\\n  const beta = ${f}(${n.beta});\\n\\n  ${m.join("\\n")}\\n  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${f}>;\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\\n\\n    let m = global_id.x / N;\\n    let n = global_id.x % N;\\n\\n    var value = ${f}(0);\\n    for (var k: u32 = 0u; k<${l}u; k++) {\\n      ${p}\\n    }\\n\\n    ${h}\\n    ${g}\\n    output[global_id.x] = value;\\n\\n  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(n,e,t)})})(e.inputs,t))},t.parseGemmAttributes=e=>(0,a.createAttributeWithCacheKey)(e)},1798:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.instanceNorm=t.parseInstanceNormAttributes=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.parseInstanceNormAttributes=e=>(0,a.createAttributeWithCacheKey)({epsilon:e.epsilon,format:e.format}),t.instanceNorm=(e,t)=>{(e=>{if(!e||3!==e.length)throw new Error("instanceNorm requires 3 inputs.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs);const n={name:"InstanceNormalization",inputTypes:[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};"NHWC"===t.format?e.compute(((e,t,n)=>{const a=t[0].dims,s=a,u=r.ShapeUtil.size(s),l=a[0],c=a[a.length-1],d=r.ShapeUtil.sizeFromDimension(a,1)/c,p=(0,o.tensorTypeToWsglStorageType)(t[0].dataType),f=c*l;return Object.assign(Object.assign({},e),{outputs:[{dims:s,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const N: u32 = ${l};\\n  const H: u32 = ${d};\\n  const C: u32 = ${c};\\n  const normSizeTyped: ${p} = ${d};\\n  const imageSize: u32 = ${d*c};\\n  const epsilon: f32 = ${n.epsilon};\\n\\n  @group(0) @binding(0) var<storage, read> x : array<${p}>;\\n  @group(0) @binding(1) var<storage, read> scale : array<${p}>;\\n  @group(0) @binding(2) var<storage, read> bias : array<${p}>;\\n  @group(0) @binding(3) var<storage, read_write> output : array<${p}>;\\n\\n  ${e.mainStart()}\\n    let currentImageNumber = global_idx / C;\\n    let currentChannelNumber = global_idx % C;\\n    \\n    // offset is channel num * N\\n    let offset = currentImageNumber * imageSize;\\n    if (offset >= ${u}) { return; }\\n    var mean: ${p} = 0;\\n\\n    for (var i: u32 = 0u; i < H; i++) {\\n        mean = mean + x[offset + i * C + currentChannelNumber];\\n    }\\n    mean = mean / normSizeTyped;\\n\\n    var squaredNorm: ${p} = 0;\\n    for (var i: u32 = 0u; i < H; i++) {\\n        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;\\n        squaredNorm = squaredNorm + deviation * deviation;\\n    }\\n    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);\\n    let channelScale = invStdDev * scale[currentChannelNumber];\\n    let channelShift = bias[currentChannelNumber] - mean * channelScale;\\n    for (var i: u32 = 0u; i < H; i++) {\\n        let currentOffset = offset + i * C + currentChannelNumber;\\n        output[currentOffset] = x[currentOffset] * channelScale + channelShift;\\n    }\\n  }`,dispatchGroup:()=>({x:Math.ceil(f/64)})})})(n,e.inputs,t)):e.compute(((e,t,n)=>{const a=t[0].dims,s=t[1],u=t[2],l=a,c=r.ShapeUtil.size(l),d=r.ShapeUtil.sizeToDimension(a,2),p=r.ShapeUtil.sizeFromDimension(a,2),f=a[1],h=r.ShapeUtil.size(s.dims),g=u?r.ShapeUtil.size(u.dims):0;if(h!==p||u&&g!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.\\n             Size of scale and bias (if provided) must match this. \\n             Got scale size of ${h} and bias size of ${g}`);const m=(0,o.tensorTypeToWsglStorageType)(t[0].dataType);return Object.assign(Object.assign({},e),{outputs:[{dims:l,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const C: u32 = ${f};\\n  const normSize: u32 = ${p};\\n  const normSizeTyped: ${m} = ${p};\\n  const epsilon: f32 = ${n.epsilon};\\n\\n  @group(0) @binding(0) var<storage, read> x : array<${m}>;\\n  @group(0) @binding(1) var<storage, read> scale : array<${m}>;\\n  @group(0) @binding(2) var<storage, read> bias : array<${m}>;\\n  @group(0) @binding(3) var<storage, read_write> output : array<${m}>;\\n\\n  ${e.mainStart()}\\n    let offset = global_idx * normSize;\\n    if (offset + normSize >= ${c}) { return; }\\n    var mean: ${m} = 0;\\n\\n    for (var h: u32 = 0u; h < normSize; h++) {\\n        mean = mean + x[h + offset];\\n    }\\n    mean = mean / normSizeTyped;\\n\\n    var squaredNorm: ${m} = 0;\\n    for (var h: u32 = 0u; h < normSize; h++) {\\n        let deviation: f32 = x[h + offset] - mean;\\n        squaredNorm = squaredNorm + deviation * deviation;\\n    }\\n    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);\\n    let channelScale = invStdDev * scale[global_idx % C];\\n    let channelShift = bias[global_idx % C] - mean * channelScale;\\n    for (var j: u32 = 0; j < normSize; j++) {\\n        output[j + offset] = x[j + offset] * channelScale + channelShift;\\n    }\\n  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(n,e.inputs,t))}},6145:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.layerNorm=t.parseLayerNormAttributes=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.parseLayerNormAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis,epsilon:e.epsilon}),t.layerNorm=(e,t)=>{(e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs);const n={name:"LayerNormalization",inputTypes:2===e.inputs.length?[i.GpuDataType.default,i.GpuDataType.default]:[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey+e.outputCount.toString(10)+e.inputs.length.toString(10)};e.compute(((e,t,n,a)=>{const s=t[0].dims,u=t[1],l=t[2],c=s,d=r.ShapeUtil.size(c),p=r.ShapeUtil.normalizeAxis(n.axis,s.length),f=r.ShapeUtil.sizeToDimension(s,p),h=r.ShapeUtil.sizeFromDimension(s,p),g=r.ShapeUtil.size(u.dims),m=l?r.ShapeUtil.size(l.dims):0;if(g!==h||l&&m!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.\\n       Size of scale and bias (if provided) must match this.\\n       Got scale size of ${g} and bias size of ${m}`);const y=[];for(let e=0;e<s.length;++e)e<p?y.push(s[e]):y.push(1);const b=(0,o.tensorTypeToWsglStorageType)(t[0].dataType),v=a>1,w=a>2;let $=0;const x=[{dims:c,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}];return v&&x.push({dims:y,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),w&&x.push({dims:y,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),Object.assign(Object.assign({},e),{outputs:x,getShaderSource:e=>`\\n  const normSize: u32 = ${h};\\n  const normSizeTyped: ${b} = ${h};\\n  const epsilon: f32 = ${n.epsilon};\\n\\n  @group(0) @binding(${$++}) var<storage, read> x : array<${b}>;\\n  @group(0) @binding(${$++}) var<storage, read> scale : array<${b}>;\\n  ${l?`@group(0) @binding(${$++}) var<storage, read> bias : array<${b}>;`:""}\\n  @group(0) @binding(${$++}) var<storage, read_write> output : array<${b}>;\\n  ${v?`@group(0) @binding(${$++}) var<storage, read_write> meanDataOutput : array<${b}>`:""};\\n  ${w?`@group(0) @binding(${$++}) var<storage, read_write> invStdOutput : array<${b}>`:""};\\n\\n  ${e.mainStart()}\\n    let offset = global_idx * normSize;\\n    if (offset >= ${d}) { return; }\\n    var mean: ${b} = 0;\\n    var meanSquare: ${b} = 0;\\n\\n    for (var h: u32 = 0u; h < normSize; h++) {\\n      mean = mean + x[h + offset];\\n      meanSquare = meanSquare + x[h + offset] * x[h + offset];\\n    }\\n    mean = mean / normSizeTyped;\\n    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);\\n\\n    for (var j: u32 = 0; j < normSize; j++) {\\n      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${l?"+ bias[j]":""};\\n    }\\n\\n    ${v?"meanDataOutput[global_idx] = mean":""};\\n    ${w?"invStdOutput[global_idx] = 1 / meanSquare":""};\\n  }`,dispatchGroup:()=>({x:Math.ceil(f/64)})})})(n,e.inputs,t,e.outputCount))}},1522:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.matMul=t.createMatmulProgramInfoLoader=void 0;const r=n(6952),a=n(1163),i=n(3997);t.createMatmulProgramInfoLoader=(e,t)=>{const n=(o=e.length>2,s=t.activationCacheKey,{name:"MatMul",inputTypes:o?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s});var o,s;return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const o=t[0].dims,s=t[1].dims,u=r.BroadcastUtil.calcShape(o,s,!0);if(!u)throw new Error("Can\'t use matmul on the given tensors");const l=r.ShapeUtil.size(u),c="f32",{activationFunction:d,applyActivation:p}=(0,i.getActicationSnippet)(n),f=u[u.length-2],h=o[o.length-1],g=u[u.length-1];return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\\n  const M: u32 = ${f}u;\\n  const N: u32 = ${g}u;\\n  const K: u32 = ${h}u;\\n\\n  @group(0) @binding(0) var<storage, read> a : array<${c}>;\\n  @group(0) @binding(1) var<storage, read> b : array<${c}>;\\n  @group(0) @binding(2) var<storage, read_write> output : array<${c}>;\\n\\n  ${d}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n\\n    let stack = global_idx / (M * N);\\n    let mn = global_idx % (M * N);\\n    let n = global_idx % N;\\n    let m = mn / N;\\n\\n    let offsetA = stack * (M * K);\\n    let offsetB = stack * (K * N);\\n\\n    var value = ${c}(0);\\n    for (var k: u32 = 0u; k<${h}u; k++) {\\n      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];\\n    }\\n    ${p}\\n    output[global_idx] = value;\\n  }`,dispatchGroup:()=>({x:Math.ceil(l/64)})})})(n,e,t)})},t.matMul=e=>{(e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs),e.compute((0,t.createMatmulProgramInfoLoader)(e.inputs,{activation:"",activationCacheKey:""}))}},5262:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseGlobalMaxPoolAttributes=t.parseMaxPoolAttributes=t.maxPool=t.globalAveragePool=t.parseGlobalAveragePoolAttributes=t.averagePool=t.parseAveragePoolAttributes=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length)throw new Error("Pool ops supports 2-D inputs only for now.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=(e,t,n)=>{const a="NHWC"===t.format,i=a?[e.dims[0],e.dims[3],e.dims[1],e.dims[2]]:e.dims.slice(),o=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),u=t.strides.slice(),l=o?t.dilations.slice():[],c=t.pads.slice();r.PoolConvUtil.adjustPoolAttributes(n,i,s,u,l,c);const d=r.PoolConvUtil.computePoolOutputShape(n,i,u,l,s,c,t.autoPad),p=Object.assign({},t);return o?Object.assign(p,{kernelShape:s,strides:u,pads:c,dilations:l,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:s,strides:u,pads:c,cacheKey:t.cacheKey}),[p,a?[d[0],d[2],d[3],d[1]]:d]},l=(e,t,n,a,i,s,u)=>{const l="NHWC"===a.format,c=t.shape,d=t.type.value,p=c.length,f=r.ShapeUtil.size(n),h=(0,o.outputVariable)("output",t.type.tensor,n);if(a.kernelShape.length<=2){const n=a.kernelShape[a.kernelShape.length-1],r=a.strides[a.strides.length-1],o=a.pads[a.pads.length/2-1],g=p-(l?2:1);let m="",y="",b="";if(m=o+a.pads[a.pads.length-1]!==0?`\\n              for (var i: u32 = 0u; i < ${n}u; i++) {\\n                xIndices[${g}] = indices[${g}] * ${r} - ${o} + i;\\n                if (xIndices[${g}] < 0 || xIndices[${g}] >= ${c[g]}) {\\n                  pad++;\\n                  continue;\\n                }\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`:`\\n              for (var i: u32 = 0u; i < ${n}u; i++) {\\n                xIndices[${g}] = indices[${g}] * ${r} - ${o} + i;\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`,2===a.kernelShape.length){const e=a.kernelShape[a.kernelShape.length-2],t=a.strides[a.strides.length-2],r=a.pads[a.pads.length/2-2],i=a.pads[a.pads.length-2],o=p-(l?3:2),s=c[o];y=r+i!==0?`\\n                for (var j: u32 = 0u; j < ${e}u; j++) {\\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\\n                  if (xIndices[${o}] < 0 || xIndices[${o}] >= ${s}) {\\n                    pad+= ${n};\\n                    continue;\\n                  }\\n              `:`\\n                for (var j: u32 = 0u; j < ${e}u; j++) {\\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\\n                `,b="\\n              }\\n            "}return`\\n            ${e.declareVariables(t,h)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\\n\\n              let indices = ${h.offsetToIndices("global_idx")};\\n              var xIndices = ${h.offsetToIndices("global_idx")};\\n\\n              var value: ${d} = ${d}(${u});\\n              var pad = 0;\\n              ${y}\\n              ${m}\\n              ${b}\\n              ${s}\\n\\n              output[global_idx] = value;\\n            }`}{if(l)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const n=r.ShapeUtil.size(a.kernelShape),o=r.ShapeUtil.computeStrides(a.kernelShape),d=o.length,g=a.pads.length;let m="";return m=a.pads.reduce(((e,t)=>e+t))?`\\n                if (xIndices[j] >= inputDims[j]) {\\n                  pad++;\\n                  isPad = true;\\n                  break;\\n                }\\n              }\\n              if (!isPad) {\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`:`\\n              }\\n              let x_val = x[${t.indicesToOffset("xIndices")}];\\n              ${i}\\n            `,`\\n            ${e.declareVariables(t,h)}\\n\\n            const pads = array<u32, ${g}>(${a.pads.map((e=>`${e}u`)).join(",")});\\n            const inputDims = array<u32, ${p}>(${c.map((e=>`${e}u`)).join(",")});\\n            const kernelStrides = array<u32, ${d}>(${o.map((e=>`${e}u`)).join(",")});\\n            const strides = array<u32, ${d}>(${a.strides.map((e=>`${e}u`)).join(",")});\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\\n\\n              let indices = ${h.offsetToIndices("global_idx")};\\n              let xIndices = ${h.offsetToIndices("global_idx")};\\n\\n              var offsets: array<u32, ${d}>;\\n\\n              var value = ${h.type.value}(${u});\\n              var pad = 0;\\n              var isPad = false;\\n\\n              for (var i: u32 = 0u; i < ${n}u; i++) {\\n                var offset = i;\\n                for (var j = 0u; j < ${d-1}u; j++) {\\n                  offsets[j] = offset / kernelStrides[j];\\n                  offset -= offsets[j] * kernelStrides[j];\\n                }\\n                offsets[${d-1}] = offset;\\n\\n                isPad = false;\\n                for (var j = ${p-d}u; j < ${p}u; j++) {\\n                  xIndices[j] = indices[j] * strides[j - ${p-d}u]\\n                    + offsets[j - ${p-d}u] - pads[j - 2u];\\n                  ${m}\\n              }\\n              ${s}\\n\\n              output[global_idx] = value;\\n            }`}},c=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),d=(e,t,n,a)=>{const[s,c]=u(e,a,n),d=r.ShapeUtil.size(s.kernelShape),p=(0,o.inputVariable)("x",e.dataType,e.dims);let f="";return s.countIncludePad?f+=`value /= f32(${d});`:f+=`value /= f32(${d} - pad);`,Object.assign(Object.assign({},t),{outputs:[{dims:c,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>l(e,p,c,s,"value += x_val;",f,"0.0"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(c)/64)})})};t.parseAveragePoolAttributes=e=>{const t=0!==e.count_include_pad,n=c(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,a.createAttributeWithCacheKey)(Object.assign({countIncludePad:t},n))},t.averagePool=(e,t)=>{s(e.inputs);const n={name:"AveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>d(e.inputs[0],n,!1,t)}))};const p={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};t.parseGlobalAveragePoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},p),{cacheKey:t})},t.globalAveragePool=(e,t)=>{s(e.inputs);const n={name:"GlobalAveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>d(e.inputs[0],n,!0,t)}))};const f=(e,t,n,a)=>{const[s,c]=u(e,a,n),d=(0,o.inputVariable)("x",e.dataType,e.dims);return Object.assign(Object.assign({},t),{outputs:[{dims:c,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>l(e,d,c,s,"\\n      value = max(x_val, value);\\n    ","","-1e5"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(c)/64)})})};t.maxPool=(e,t)=>{s(e.inputs);const n={name:"MaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs[0],n,!1,t)}))},t.parseMaxPoolAttributes=e=>{const t=e.storage_order,n=e.dilations,r=c(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,a.createAttributeWithCacheKey)(Object.assign({storageOrder:t,dilations:n},r))},t.parseGlobalMaxPoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},p),{cacheKey:t})},t.globalMaxPool=(e,t)=>{s(e.inputs);const n={name:"GlobalMaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs[0],n,!0,t)}))}},6031:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseReduceAttributes=t.reduceSumSquare=t.reduceSum=t.reduceProd=t.reduceMin=t.reduceMean=t.reduceMax=t.reduceLogSumExp=t.reduceL2=t.reduceL1=t.reduceLogSum=t.createReduceProgramInfo=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""];t.createReduceProgramInfo=(e,t,n,a,s,u=!1,l=!1)=>{const c=[],d=t[0].dims,p=r.ShapeUtil.normalizeAxes(a,t[0].dims.length),f=!l&&0===p.length;d.forEach(((e,t)=>{f||p.indexOf(t)>=0?u&&c.push(1):c.push(e)}));const h=[],g=(0,o.inputVariable)("_A",t[0].dataType,d),m=(0,o.outputVariable)("output",s,c),y=n(g,m,p),b=`inputOffset = ${g.indicesToOffset("inputIndices")};`,v=`let ${b};`,w=`var ${b};`,$=""===y[1]?"":w;let x=(""===y[1]?v:b)+"\\n"+y[2];for(let e=0,n=0;e<t[0].dims.length;e++)f||p.indexOf(e)>=0?(u&&n++,x=`for(var j${e}: u32 = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\\n                ${y[2].includes("lastIndex")?`let lastIndex = j${e};`:""}\\n                ${g.indicesSet("inputIndices",e,`j${e}`)}\\n                ${x}\\n              }`):(h.push(`${g.indicesSet("inputIndices",e,m.indicesGet("outputIndices",n))};`),n++);const S=r.ShapeUtil.size(c);return Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n        ${e.declareVariables(g,m)}\\n\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(S)}\\n          var inputIndices: ${g.type.indices};\\n          let outputIndices = ${m.offsetToIndices("global_idx")};\\n\\n          ${h.join("\\n")}\\n          ${y[0]}       // init ops for reduce max/min\\n          ${$}\\n          ${y[1]}\\n          ${x}\\n          ${y[3]}\\n          ${4===y.length?m.setByOffset("global_idx","value"):y.slice(4).join("\\n")}\\n        }`,outputs:[{dims:c,dataType:s,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(S/64)})})};const l=(e,n,r,o)=>{const s=1===e.length?r:((e,t)=>{const n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),(0,a.createAttributeWithCacheKey)({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})})(e,r),l={name:n,inputTypes:[i.GpuDataType.default],cacheHint:s.cacheKey+"_"+e[0].dims.map((e=>e.toString())).join(",")};return Object.assign(Object.assign({},l),{get:()=>(0,t.createReduceProgramInfo)(l,[e[0]],s.noopWithEmptyAxes&&0===s.axes.length?u:o,s.axes,e[0].dataType,s.keepDims,s.noopWithEmptyAxes)})};t.reduceLogSum=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,"value = log(value);"])),{inputs:[0]})},t.reduceL1=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByOffset("inputOffset")});`,""])),{inputs:[0]})},t.reduceL2=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceL2",t,((e,t)=>[`var t = f32(0); var value = ${t.type.storage}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])),{inputs:[0]})},t.reduceLogSumExp=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByOffset("inputOffset")});`,"value = log(value);"])),{inputs:[0]})},t.reduceMax=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMax",t,((e,t,n)=>{const r=[];for(let t=0;t<e.shape.length;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("inputIndices",t,0));return[`${r.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = max(value, ${e.getByOffset("inputOffset")});`,""]})),{inputs:[0]})},t.reduceMean=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMean",t,((e,t,n)=>{let r=1;for(let t=0;t<e.shape.length;t++)(n.indexOf(t)>=0||0===n.length)&&(r*=e.shape[t]);return[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,`value = value / ${r}.;`]})),{inputs:[0]})},t.reduceMin=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMin",t,((e,t,n)=>{const r=[];for(let t=0;t<e.shape.length;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`inputIndices[${t}] = 0;`);return[`${r.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = min(value, ${e.getByOffset("inputOffset")});`,""]})),{inputs:[0]})},t.reduceProd=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByOffset("inputOffset")};`,""])),{inputs:[0]})},t.reduceSum=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,""])),{inputs:[0]})},t.reduceSumSquare=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceSumSquare",t,((e,t)=>[`var t = f32(0); var value = ${t.type.storage}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += t * t;`,""])),{inputs:[0]})},t.parseReduceAttributes=e=>(0,a.createAttributeWithCacheKey)(e)},4566:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributes=t.resize=t.createResizeProgramInfoLoader=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.createResizeProgramInfoLoader=(e,t,n,a,s,u)=>{const l={name:"Resize",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey+n.toString()+(a.length>0?"_scales_"+a.toString():"")+(s.length>0?"_sizes_"+s.toString():"")};return Object.assign(Object.assign({},l),{get:()=>((e,t,n,a,s,u,l)=>{const c=t.dims,d=((e,t,n)=>{const r=new Array(n).fill(0).concat(new Array(n).fill(1)),a=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=a[i],r[i+n]=a[t.length+i]})),r):a})(l,n.axes,c.length);let p=((e,t,n,r)=>{let a=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>a.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>a[e]=n[t]))}else n.forEach((e=>a.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");a=e.map(((e,n)=>Math.round(e*t[n])))}return a})(c,s,u,n.axes),f=s.slice();0===s.length&&(f=c.map(((e,t)=>0===e?1:p[t]/e)),"stretch"!==n.keepAspectRatioPolicy&&(p=((e,t,n,r)=>{const a=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map((e=>n[e])),Number.MAX_VALUE):Math.min(...n,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map((e=>n[e])),Number.MIN_VALUE):Math.max(...n,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();n.fill(1,0,n.length);const i=e.slice();return r.axes.length>0?(r.axes.forEach((e=>n[e]=a)),r.axes.forEach((t=>i[t]=Math.round(e[t]*n[t])))):(n.fill(a,0,n.length),i.forEach(((e,t)=>i[t]=Math.round(e*n[t])))),i})(c,0,f,n)));const h=(0,o.outputVariable)("output",t.dataType,p),g=(0,o.inputVariable)("input",t.dataType,c),m=r.ShapeUtil.size(p),y=c.length===p.length&&c.every(((e,t)=>e===p[t])),b="tf_crop_and_resize"===n.coordinateTransformMode;return Object.assign(Object.assign({},e),{getShaderSource:e=>{return`\\n      ${t=n.coordinateTransformMode,"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(t){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join("\\n");case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}"};\\n      ${(()=>{switch(n.mode){case"nearest":return`\\n              ${((e,t)=>`\\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\\n      for (var i:u32 = 0; i < ${t.length}; i++) {\\n        var inputIndex = ${1===t.length?"inputIndices":"inputIndices[i]"};\\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }`)(g,c)};\\n              ${((e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}")(n.nearestMode,a)};\\n              ${((e,t,n,r,a,i,o)=>`\\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\\n        const outputShape = array<u32, ${r.length}>(${r.map((e=>`${e}u`)).join(",")});\\n        const scales = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\\n        const roi = array<f32, ${i.length}>(${i.map((e=>`${e}f`)).join(",")});\\n        var inputIndices: ${e.type.indices};\\n        for (var i:u32 = 0; i < ${r.length}; i++) {\\n          var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\\n          var inputIndex: u32;\\n          if (scales[i] == 1.0) {\\n            inputIndex = outputIndex;\\n          } else {\\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${n.length}]);\\n            if (!${o} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\\n              if (original_idx < 0) {\\n                inputIndex = 0;\\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\\n                inputIndex = inputShape[i] - 1;\\n              } else {\\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\\n              }\\n            } else {\\n              inputIndex = u32(original_idx);\\n            }\\n          }\\n          ${e.indicesSet("inputIndices","i","inputIndex")}\\n        }\\n        return inputIndices;\\n    }`)(g,h,c,p,f,d,b)};\\n              `;case"linear":return`\\n              ${((e,t,n,r,a)=>`\\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${n.length}> {\\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\\n      const outputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\\n      const scales = array<f32, ${r.length}>(${r.map((e=>`${e}f`)).join(",")});\\n      const roi = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\\n      var originalIndices: array<f32, ${n.length}>;\\n      for (var i:u32 = 0; i < ${n.length}; i++) {\\n        var outputIndex = ${1===n.length?"outputIndices":"outputIndices[i]"};\\n        if (scales[i] == 1.0) {\\n          originalIndices[i] = f32(outputIndex);\\n        } else {\\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\\n        }\\n      }\\n      return originalIndices;\\n    }`)(h,c,p,f,d)};\\n              ${((e,t,n,r,a,i,o)=>{const[s,u,l,c]=2===n.length?[-1,0,1,-1]:1===a[1]?[0,2,3,1]:[0,1,2,3];return`\\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\\n      var inputIndices: ${e.type.indices};\\n      inputIndices[${u}] = max(0, min(row, ${n[u]} - 1));\\n      inputIndices[${l}] = max(0, min(col, ${n[l]} - 1));\\n      if (${n.length} > 2) {\\n        inputIndices[${c}] = channel;\\n        inputIndices[${s}] = batch;\\n      };\\n      return input[${e.indicesToOffset("inputIndices")}];\\n    }\\n\\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\\n      var row:f32 = originalIndices[${u}];\\n      var col:f32 = originalIndices[${l}];\\n      if (${i} && (row < 0 || row > (${n[u]} - 1) || col < 0 || col > ${n[l]} - 1)) {\\n        return ${o};\\n      }\\n      row = max(0, min(row, ${n[u]} - 1));\\n      col = max(0, min(col, ${n[l]} - 1));\\n      var row1: u32 = u32(row);\\n      var col1: u32 = u32(col);\\n      var row2: u32 = u32(row + 1);\\n      var col2: u32 = u32(col + 1);\\n      var channel: u32 = 0;\\n      var batch: u32 = 0;\\n      if (${n.length>2}) {\\n        channel = u32(originalIndices[${c}]);\\n        batch = u32(originalIndices[${s}]);\\n      }\\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\\n      var dx1: f32 = row - f32(row1);\\n      var dx2: f32 = f32(row2 ) - row;\\n      var dy1 = col - f32(col1);\\n      var dy2 = f32(col2) - col;\\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\\n    }`})(g,h,c,0,f,b,n.extrapolationValue)};\\n              `;case"cubic":return`\\n            ${((e,t,n,r,a,i,o,s,u,l)=>{const[c,d]=2===n.length?[0,1]:1===a[1]?[2,3]:[1,2],p=o=>{const d=o===c?"row":"col";return`\\n      fn ${d}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\\n        var outputIndex = ${1===r.length?"outputIndices":`outputIndices[${o}]`};\\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[o]},\\n        f32(${r[o]}), f32(${n[o]}), ${i[o]}, ${i[o]} + ${n.length});\\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\\n\\n        if (${s} && (originalIdx < 0 || originalIdx > (${n[o]} - 1))) {\\n          return ${u};\\n        }\\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\\n        for (var i: i32 = -1; i < 3; i++) {\\n          var ${d}: f32 = originalIdx + f32(i);\\n          if (${d} < 0 || ${d} >= ${n[o]}) {\\n            if (${l}) {\\n              coefs[i + 1] = 0.0;\\n              continue;\\n            } else if (${s}) {\\n              return ${u};\\n            } else {\\n              ${d} = max(0, min(${d}, ${n[o]} - 1));\\n            }\\n          }\\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\\n          inputIndicesCopy[${o}] = u32(${d});\\n          data[i + 1] = ${o===c?`input[${e.indicesToOffset("inputIndicesCopy")}];`:"\\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);"}\\n        }\\n        return cubicInterpolation1D(data, coefs);\\n      }`};return`\\n    ${p(c)};\\n    ${p(d)};\\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\\n    var absS = abs(s);\\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\\n    var oneMinusAbsS: f32 = 1.0 - absS;\\n    var twoMinusAbsS: f32 = 2.0 - absS;\\n    var onePlusAbsS: f32 = 1.0 + absS;\\n    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};\\n    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;\\n    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\\n    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};\\n    return coeffs;\\n  }\\n\\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\\n  }\\n\\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\\n    var inputIndices: ${e.type.indices} = outputIndices;\\n    return colCubicInterpolation(inputIndices, outputIndices);\\n  }\\n    `})(g,h,c,p,f,d,n.cubicCoeffA,b,n.extrapolationValue,n.excludeOutside)};\\n            `;default:throw Error("Invalid resize mode")}})()};\\n      ${e.declareVariables(g,h)}\\n      ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)}\\n        if (${y}) {\\n          output[global_idx] = input[global_idx];\\n        } else {\\n          let outputIndices = ${h.offsetToIndices("global_idx")};\\n          var inputIndices: ${g.type.indices};\\n          ${(()=>{switch(n.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\\n                  if (checkInputIndices(inputIndices)) {\\n                    output[global_idx] = input[${g.indicesToOffset("inputIndices")}];\\n                  } else {\\n                    output[global_idx] = ${n.extrapolationValue};\\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${n.mode}`)}})()};\\n        }\\n      }`;var t},outputs:[{dims:p,dataType:t.dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(m/64)})})})(l,e,t,n,a,s,u)})},t.resize=(e,n)=>{const r=[],a=[],i=[],o=(e=>{const t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]})(e);((e,t,n,r,a,i)=>{const[o,s,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(s>0&&e.length>s&&e[s].dims.length>0){if(e[s].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");((e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")})(r,t),t.axes.length>0&&((e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));const r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r})(r,t.axes,l).forEach(((e,t)=>r[t]=e))}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach((e=>a.push(Number(e)))),a.length!==l||n>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(a.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(void 0!==r&&void 0!==a&&r.length>0&&a.length>l)throw new Error("Resize requires only of scales or sizes to be specified")})(e.inputs,n,o,r,a,i),e.compute((0,t.createResizeProgramInfoLoader)(e.inputs[0],n,o,r,a,i),{inputs:[0]})},t.parseResizeAttributes=e=>{const t=e.antialias,n=e.axes,r=e.coordinateTransformMode,i=e.cubicCoeffA,o=0!==e.excludeOutside,s=e.extrapolationValue,u=e.keepAspectRatioPolicy,l=e.mode,c=""===e.nearestMode?"simple":e.nearestMode;return(0,a.createAttributeWithCacheKey)({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:i,excludeOutside:o,extrapolationValue:s,keepAspectRatioPolicy:u,mode:l,nearestMode:c})}},8906:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSkipLayerNormAttributes=t.skipLayerNorm=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.skipLayerNorm=(e,t)=>{(e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type");const t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");const a=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){const t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){const t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}})(e.inputs);const n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(((e,t,n,a)=>{const s={name:"SkipLayerNormalization",inputTypes:new Array(e.length).fill(i.GpuDataType.default),cacheHint:t.cacheKey};return Object.assign(Object.assign({},s),{get:()=>((e,t,n,a,s)=>{const u=t[0].dims,l=u,c=r.ShapeUtil.size(u),d=u.slice(-1)[0],p=s?u.slice(0,-1).concat(1):[],f=t.length>3,h=t.length>4,g=(0,o.tensorTypeToWsglStorageType)(t[0].dataType),m=s&&a>1,y=s&&a>2,b=a>3;let v=0;const w=[{dims:l,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}];return a>1&&w.push({dims:p,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),a>2&&w.push({dims:p,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),a>3&&w.push({dims:u,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n      const hiddenSize: u32 = ${d};\\n      const epsilon: f32 = ${n.epsilon};\\n\\n      @group(0) @binding(${v++}) var<storage, read> x : array<${g}>;\\n      @group(0) @binding(${v++}) var<storage, read> skip : array<${g}>;\\n      @group(0) @binding(${v++}) var<storage, read> gamma : array<${g}>;\\n      ${f?`@group(0) @binding(${v++}) var<storage, read> beta : array<${g}>;`:""}\\n      ${h?`@group(0) @binding(${v++}) var<storage, read> bias : array<${g}>;`:""}\\n      @group(0) @binding(${v++}) var<storage, read_write> output : array<${g}>;\\n      ${m?`@group(0) @binding(${v++}) var<storage, read_write> meanOutput : array<${g}>;`:""}\\n      ${y?`@group(0) @binding(${v++}) var<storage, read_write> invStdOutput : array<${g}>;`:""}\\n      ${b?`@group(0) @binding(${v++}) var<storage, read_write> inputSkipBiasSum : array<${g}>;`:""}\\n\\n      ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(c/d)}\\n        let offset = global_idx * hiddenSize;\\n        var sum: f32 = 0.0;\\n        var squareSum: f32 = 0.0;\\n        for (var i: u32 = 0; i < hiddenSize; i++) {\\n          let skipValue = skip[offset + i];\\n          let biasValue = ${h?"bias[i]":"0.0"};\\n          let inputValue = x[offset + i];\\n          let value = inputValue + skipValue + biasValue;\\n          ${b?"inputSkipBiasSum[offset + i] = value;":""}\\n          output[offset + i] = value;\\n          sum += value;\\n          squareSum += value * value;\\n        }\\n        let mean: f32 = sum / f32(hiddenSize);\\n        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);\\n        ${m?"meanOutput[global_idx] = mean;":""}\\n        ${y?"invStdOutput[global_idx] = 1.0 / variance;":""}\\n        for (var i: u32 = 0; i < hiddenSize; i++) {\\n          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${f?"beta[i]":"0.0"};\\n        }\\n      }`,outputs:w,dispatchGroup:()=>({x:Math.ceil(c/d/64)})})})(s,e,t,n,a)})})(e.inputs,t,e.outputCount,!1),{outputs:n})},t.parseSkipLayerNormAttributes=e=>{const t=e.epsilon;return(0,a.createAttributeWithCacheKey)({epsilon:t})}},5101:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSliceAttributes=t.slice=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=(e,t)=>{const n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},u=(e,t,n,r,a)=>{let i=e;return e<0&&(i+=n[r[t]]),a[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))};t.slice=(e,t)=>{((e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))})(e.inputs,t);const n=((e,t)=>{const n=((e,t)=>{if(e.length>1){const t=s(e,1),n=s(e,2);let r=s(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),(0,a.createAttributeWithCacheKey)({starts:t,ends:n,axes:r})}return t})(e,t),l={name:"Slice",inputTypes:[i.GpuDataType.default],cacheHint:n.cacheKey+(e.length>4?"steps_"+e[4].dims.toString():"")};return Object.assign(Object.assign({},l),{get:()=>((e,t,n)=>{const a=t[0].dims,l=r.ShapeUtil.size(a),c=n.axes.length>0?r.ShapeUtil.normalizeAxes(n.axes,a.length):[...Array(a.length).keys()];let d=s(t,4);d.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===d.length&&(d=Array(c.length).fill(1));const p=n.starts.map(((e,t)=>u(e,t,a,c,d))),f=n.ends.map(((e,t)=>u(e,t,a,c,d)));if(c.length!==a.length)for(let e=0;e<a.length;++e)c.includes(e)||(p.splice(e,0,0),f.splice(e,0,a[e]),d.splice(e,0,1));const h=d.map((e=>Math.sign(e)));d.forEach(((e,t,n)=>{if(e<0){const r=(f[t]-p[t])/e,a=p[t],i=a+r*d[t];p[t]=i,f[t]=a,n[t]=-e}}));const g=a.slice(0);c.forEach(((e,t)=>{g[e]=Math.ceil((f[e]-p[e])/d[e])}));const m={dims:g,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default},y=(0,o.outputVariable)("output",t[0].dataType,g),b=(0,o.inputVariable)("input",t[0].dataType,a),v=r.ShapeUtil.size(g);return Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n      ${e.declareVariables(b,y)}\\n        const signs = array<i32, ${h.length}>(${h.map((e=>`${e}i`)).join(",")});\\n        const starts = array<u32, ${p.length}>(${p.map((e=>`${e}u`)).join(",")});\\n        const ends = array<u32, ${f.length}>(${f.map((e=>`${e}u`)).join(",")});\\n        const steps = array<u32, ${d.length}>(${d.map((e=>`${e}u`)).join(",")});\\n        const inputShape = array<u32, ${a.length}>(${a.map((e=>`${e}u`)).join(",")});\\n\\n        ${((e,t,n,r)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\\n          var inputIndices: ${e.type.indices};\\n          var carry = 0u;\\n          for (var i = ${n.length}; i >= 0; i--) {\\n            var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\\n            carry = inputIndex / inputShape[i];\\n            inputIndex = inputIndex % inputShape[i];\\n            if (signs[i] < 0) {\\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\\n            }\\n            ${1===n.length?"inputIndices":"inputIndices[i]"} = inputIndex;\\n          }\\n          return inputIndices;\\n      }`)(b,y,a,g)}\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(v)}\\n          let outputIndices = ${y.offsetToIndices("global_idx")};\\n          let inputIndices = calculateInputIndices(outputIndices);\\n          ${y.setByOffset("global_idx",b.getByIndices("inputIndices"))}\\n      }`,outputs:[m],dispatchGroup:()=>({x:Math.ceil(l/64)})})})(l,e,n)})})(e.inputs,t),l=n.get();if(!(r.ShapeUtil.size(l.outputs[0].dims)>0))throw new Error("slice: output size is 0");e.compute(n,{inputs:[0]})},t.parseSliceAttributes=e=>{const t=e.starts,n=e.ends,r=e.axes;return(0,a.createAttributeWithCacheKey)({starts:t,ends:n,axes:r})}},6198:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSoftmaxAttributes=t.softmax=t.softmaxProgramMetadata=void 0;const r=n(6952),a=n(387),i=n(1163);t.softmaxProgramMetadata={name:"Softmax",inputTypes:[i.GpuDataType.default]},t.softmax=(e,n)=>{(e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.");if(1!==e[0].dataType)throw new Error("Softmax input needs to be float.")})(e.inputs),e.compute(Object.assign(Object.assign({},t.softmaxProgramMetadata),{cacheHint:n.cacheKey,get:()=>((e,n)=>{const a="f32",o=e.dims,s=r.ShapeUtil.size(o);let u=n.axis;if(u<0&&(u=o.length+u),u<o.length-1)throw new Error("softmax only supports last axis for now.");const l=o[u],c=s/l;return Object.assign(Object.assign({},t.softmaxProgramMetadata),{outputs:[{dims:o,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n      var<workgroup> rowMaxShared : ${a};\\n      var<workgroup> rowSumShared : ${a};\\n      var<workgroup> threadShared : array<${a}, 64>;\\n\\n      @group(0) @binding(0) var<storage, read> x : array<${a}>;\\n      @group(0) @binding(1) var<storage, read_write> result : array<${a}>;\\n\\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${a} {\\n        let index = row * row_stride + col;\\n        return x[index];\\n      }\\n\\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${a}) {\\n        let index = row * row_stride + col;\\n        result[index] = value;\\n      }\\n\\n      @compute @workgroup_size(64, 1, 1)\\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\\n        let gindex = i32(global_id.x);\\n        let lindex = i32(local_id.x);\\n        const wg = 64;\\n        let row = gindex / wg;\\n        let cols = ${l};\\n        let row_stride : i32 = ${l};\\n\\n        // find the rows max\\n        var threadMax = -3.402823e+38f; // 6.2.4 in wgsl spec\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = getValue(row, col, row_stride);\\n          threadMax = max(threadMax, value);\\n        }\\n        if (lindex < cols) {\\n          threadShared[lindex] = threadMax;\\n        }\\n        workgroupBarrier();\\n\\n        var reduceSize = min(cols, wg);\\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\\n          reduceSize = currSize + (reduceSize & 1);\\n          if (lindex < currSize) {\\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowMaxShared = threadShared[0];\\n        }\\n        workgroupBarrier();\\n\\n        // find the rows sum\\n        var threadSum = 0.0;\\n        for (var col = lindex; col < cols; col += wg) {\\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\\n          threadSum += subExp;\\n        }\\n        threadShared[lindex] = threadSum;\\n        workgroupBarrier();\\n\\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\\n          if (lindex < currSize) {\\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowSumShared = threadShared[0];\\n        }\\n        workgroupBarrier();\\n\\n        // calculate final value for each element in the row\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\\n          setValue(row, col, row_stride, value);\\n        }\\n      }`,dispatchGroup:()=>({x:c})})})(e.inputs[0],n)}))},t.parseSoftmaxAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis})},2067:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.split=(e,t)=>{(e=>{if(!e||e.length<1)throw new Error("too few inputs")})(e.inputs),e.compute(((e,t)=>{const n=1===e.length?t:((e,t)=>{const n=[];let r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),(0,a.createAttributeWithCacheKey)({numOutputs:r,axis:t.axis,splitSizes:n})})(e,t),s={name:"Split",inputTypes:[i.GpuDataType.default],cacheHint:n.cacheKey};return Object.assign(Object.assign({},s),{get:()=>((e,t,n)=>{const a=t[0].dims,s=r.ShapeUtil.size(a),u=t[0].dataType,l=a.length,c=n.axis,d=c<0?a.length+c:c,p=new Array(n.numOutputs),f=(0,o.inputVariable)("input",u,a),h=new Array(n.numOutputs),g=[],m=[];let y=0;for(let e=0;e<n.numOutputs;e++){y+=n.splitSizes[e],h[e]=y;const r=a.slice();r[n.axis]=n.splitSizes[e],m.push(r),p[e]=(0,o.outputVariable)(`output${e}`,u,m[e]),g.push({dims:m[e],dataType:t[0].dataType,gpuDataType:i.GpuDataType.default})}const b=l<2?"indices":`indices[${d}]`;return Object.assign(Object.assign({},e),{getShaderSource:e=>{return`\\n  ${e.declareVariables(f,...p)}\\n  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map((e=>`${e}u`)).join(",")});\\n  ${t=h.length,`\\nfn calculateOutputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\\n    if (index < sizeInConcatAxis[i]) {\\n        return i;\\n    }\\n    }\\n    return ${t}u;\\n}`}\\n  ${(e=>{const t=e.length,n=[];for(let r=0;r<t;++r){const a=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(a):0===r?n.push(`if (outputNumber == ${r}u) { ${a} }`):r===t-1?n.push(`else { ${a} }`):n.push(`else if (outputNumber == ${r}) { ${a} }`)}return`\\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\\n        ${n.join("\\n")}\\n      }`})(p)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(s)}\\n\\n    var indices = ${f.offsetToIndices("global_idx")};\\n    let outputNumber = calculateOutputIndex(${b});\\n    if (outputNumber != 0) {\\n        ${b} -= sizeInConcatAxis[outputNumber - 1u];\\n    }\\n    writeBufferData(outputNumber, indices, global_idx);\\n  }`;var t},outputs:g,dispatchGroup:()=>({x:Math.ceil(s/64)})})})(s,[e[0]],n)})})(e.inputs,t),{inputs:[0]})},t.parseSplitAttributes=e=>{const t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return(0,a.createAttributeWithCacheKey)({axis:t,numOutputs:r,splitSizes:n})}},8699:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tile=t.createTileProgramInfo=t.tileProgramMetadata=void 0;const r=n(6952),a=n(1163),i=n(2075);t.tileProgramMetadata={name:"Tile",inputTypes:[a.GpuDataType.default]};const o=e=>Array.from(e.getBigInt64Array(),Number);t.createTileProgramInfo=(e,t)=>{const n=t[0].dims,s=o(t[1]),u=((e,t)=>{const n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n})(n,s),l=r.ShapeUtil.size(u),c=t[0].dataType,d=(0,i.inputVariable)("input",c,n),p=(0,i.outputVariable)("output",c,u);return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\\n      const inputShape = ${d.indices(...n)};\\n      ${e.declareVariables(d,p)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n      let outputIndices = ${p.offsetToIndices("global_idx")};\\n      var inputIndices: ${d.type.indices};\\n      for (var i = 0; i < ${n.length}; i++) {\\n        let inputDimValue = ${p.indicesGet("outputIndices","i")}  % ${d.indicesGet("inputShape","i")};\\n\\n        ${d.indicesSet("inputIndices","i","inputDimValue")}\\n      }\\n      ${p.setByOffset("global_idx",d.getByIndices("inputIndices"))}\\n    }`,dispatchGroup:()=>({x:Math.ceil(l/64)})})},t.tile=e=>{(e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(o(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")})(e.inputs);const n=o(e.inputs[1]).toString();e.compute(Object.assign(Object.assign({},t.tileProgramMetadata),{cacheHint:n,get:()=>(0,t.createTileProgramInfo)(t.tileProgramMetadata,e.inputs)}),{inputs:[0]})}},2625:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=t.createTransposeProgramInfo=t.transposeProgramMetadata=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.transposeProgramMetadata={name:"Transpose",inputTypes:[i.GpuDataType.default]};const s=(e,t)=>t&&t.length!==e.length?[...e.keys()].reverse():t;t.createTransposeProgramInfo=(e,n)=>{const a=e.dataType,u=e.dims,l=s(u,n),c=((e,t)=>r.ShapeUtil.sortBasedOnPerm(e,s(e,t)))(u,l),d=u.length,p=r.ShapeUtil.size(c),f=(0,o.outputVariable)("output",a,c),h=(0,o.inputVariable)("a",a,u);return Object.assign(Object.assign({},t.transposeProgramMetadata),{outputs:[{dims:c,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  ${e.declareVariables(h,f)}\\n\\n  ${((e,t,n,r)=>{const a=[];a.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)a.push(n.indicesSet("a",e[r],`i[${r}]`));return a.push("return a;}"),a.join("\\n")})(l,d,h,f)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\\n\\n    let indices = ${f.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${f.setByOffset("global_idx",h.getByIndices("aIndices"))}\\n  }`,dispatchGroup:()=>({x:Math.ceil(p/64)})})},t.transpose=(e,n)=>{(e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Transpose only support float, int32, and uint32 data types")})(e.inputs),e.compute(Object.assign(Object.assign({},t.transposeProgramMetadata),{cacheHint:n.cacheKey,get:()=>(0,t.createTransposeProgramInfo)(e.inputs[0],n.perm)}))},t.parseTransposeAttributes=e=>(0,a.createAttributeWithCacheKey)({perm:e.perm})},9302:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.log=t.thresholdedRelu=t.tanh=t.tan=t.sqrt=t.sinh=t.sin=t.sigmoid=t.relu=t.reciprocal=t.neg=t.leakyRelu=t.gelu=t.floor=t.exp=t.erf=t.erfImpl=t.elu=t.parseAlphaAttributes=t.cosh=t.cos=t.ceil=t.clip=t.clipV10=t.cast=t.parseCastAttributes=t.atanh=t.atan=t.asinh=t.asin=t.acosh=t.acos=t.abs=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=(e,t,n,a,s,u=e.dataType)=>{const l={name:t,inputTypes:[i.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},l),{get:()=>((e,t,n,a,s)=>Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,r,a,i)=>{const s=Math.ceil(t/4);let u="";u="string"==typeof a?`${a}(a)`:a("a");const l=(0,o.inputVariable)("inputData",n,[s],4),c=(0,o.outputVariable)("outputData",r,[s],4);return`\\n  ${e.declareVariables(l,c)}\\n\\n  ${null!=i?i:""}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(s)}\\n\\n    let a = ${l.getByOffset("global_idx")};\\n    ${c.setByOffset("global_idx",u)}\\n  }`})(e,r.ShapeUtil.size(t.dims),t.dataType,n,a,s),outputs:[{dims:t.dims,dataType:n,gpuDataType:i.GpuDataType.default}],dispatchGroup:e=>({x:Math.ceil(r.ShapeUtil.size(e[0].dims)/64/4)})}))(l,e,u,n,a)})};t.abs=e=>{e.compute(s(e.inputs[0],"Abs","abs"))},t.acos=e=>{e.compute(s(e.inputs[0],"Acos","acos"))},t.acosh=e=>{e.compute(s(e.inputs[0],"Acosh","acosh"))},t.asin=e=>{e.compute(s(e.inputs[0],"Asin","asin"))},t.asinh=e=>{e.compute(s(e.inputs[0],"Asinh","asinh"))},t.atan=e=>{e.compute(s(e.inputs[0],"Atan","atan"))},t.atanh=e=>{e.compute(s(e.inputs[0],"Atanh","atanh"))},t.parseCastAttributes=e=>(0,a.createAttributeWithCacheKey)(e),t.cast=(e,t)=>{let n;switch(t.to){case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(s(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},t.clipV10=(e,t)=>{e.compute(s(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\\n    const clip_min_: vec4<f32> = vec4(f32(${t.min}));\\n    const clip_max_: vec4<f32> = vec4(f32(${t.max}));\\n`,t.cacheKey),{inputs:[0]})},t.clip=e=>{const n=(e=>{const t=e.length>=2?e[1].getFloat32Array()[0]:r.MIN_CLIP,n=e.length>=3?e[2].getFloat32Array()[0]:r.MAX_CLIP;return(0,a.createAttributeWithCacheKey)({min:t,max:n})})(e.inputs);(0,t.clipV10)(e,n)},t.ceil=e=>{e.compute(s(e.inputs[0],"Ceil","ceil"))},t.cos=e=>{e.compute(s(e.inputs[0],"Cos","cos"))},t.cosh=e=>{e.compute(s(e.inputs[0],"Cosh","cosh"))},t.parseAlphaAttributes=e=>(0,a.createAttributeWithCacheKey)(e),t.elu=(e,t)=>{e.compute(s(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\\n  const elu_alpha_: f32 = f32(${t.alpha});\\n\\n  fn elu_f32(a: f32) -> f32 {\\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\\n  }\\n\\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\\n  }`,t.cacheKey))},t.erfImpl=e=>`\\nconst r0: f32 = 0.3275911;\\nconst r1: f32 = 0.254829592;\\nconst r2: f32 = -0.284496736;\\nconst r3: f32 = 1.421413741;\\nconst r4: f32 = -1.453152027;\\nconst r5: f32 = 1.061405429;\\n\\nfn erf_vf32(v: ${e}) -> ${e} {\\n  let absv = abs(v);\\n  let x = 1.0 / (1.0 + r0 * absv);\\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\\n}`,t.erf=e=>{e.compute(s(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),(0,t.erfImpl)("vec4<f32>")))},t.exp=e=>{e.compute(s(e.inputs[0],"Exp","exp"))},t.floor=e=>{e.compute(s(e.inputs[0],"Floor","floor"))},t.gelu=e=>{e.compute(s(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),(0,t.erfImpl)("vec4<f32>")))},t.leakyRelu=(e,t)=>{e.compute(s(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},t.neg=e=>{e.compute(s(e.inputs[0],"Neg",(e=>`-${e}`)))},t.reciprocal=e=>{e.compute(s(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},t.relu=e=>{e.compute(s(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},t.sigmoid=e=>{e.compute(s(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},t.sin=e=>{e.compute(s(e.inputs[0],"Sin","sin"))},t.sinh=e=>{e.compute(s(e.inputs[0],"Sinh","sinh"))},t.sqrt=e=>{e.compute(s(e.inputs[0],"Sqrt","sqrt"))},t.tan=e=>{e.compute(s(e.inputs[0],"Tan","tan"))},t.tanh=e=>{e.compute(s(e.inputs[0],"Tanh","tanh"))},t.thresholdedRelu=(e,t)=>(e.compute(s(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),t.log=e=>{e.compute(s(e.inputs[0],"Log","log"))}},8305:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(4955),a=n(2075);t.ProgramManager=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r){const a=this.backend.device,i=this.backend.getComputePassEncoder(),o=this.backend.supportTimestampQuery&&"default"===this.backend.env.webgpu.profilingMode;o&&i.writeTimestamp(this.backend.profilingQuerySet,0),i.setPipeline(e.computePipeline);const s=[];for(const e of t)s.push({binding:s.length,resource:{buffer:e.buffer}});for(const e of n)s.push({binding:s.length,resource:{buffer:e.buffer}});const u=a.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:s});if(i.setBindGroup(0,u),i.dispatchWorkgroups(...r),this.backend.pendingDispatchNumber++,o){i.writeTimestamp(this.backend.profilingQuerySet,1),null==this.backend.profilingQueryData&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));const e=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,e.buffer,0,16),this.backend.flush();const t=this.backend.currentKernelId,n=this.backend.kernels.get(t)[0];e.buffer.mapAsync(GPUMapMode.READ).then((()=>{const r=new BigUint64Array(e.buffer.getMappedRange()),a=r[0],i=r[1];e.buffer.unmap(),void 0===this.backend.profilingTimeBase&&(this.backend.profilingTimeBase=a);const o=Number(a-this.backend.profilingTimeBase),s=Number(i-this.backend.profilingTimeBase);if(!Number.isSafeInteger(o)||!Number.isSafeInteger(s))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id),console.log(`[profiling] kernel "${t}|${n}" execution time: ${s-o} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){const n=this.backend.device,i=(0,a.createShaderHelper)(t),o=e.getShaderSource(i),s=`${i.additionalImplementations}\\n${o}`,u=n.createShaderModule({code:s});return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] shader code: ${s}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:u,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(e){const t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&n<=a&&r<=a)return[t,n,r];const i=t*n*r;let o=Math.ceil(Math.sqrt(i));if(o>a){if(o=Math.ceil(Math.cbrt(i)),o>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}return[o,o,1]}}},1163:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.GpuDataType=void 0,(n=t.GpuDataType||(t.GpuDataType={}))[n.default=0]="default",n[n.upload=1]="upload",n[n.profile=2]="profile"},7918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(263),a=n(1497);t.setRunOptions=e=>{const t=(0,r.getInstance)();let n=0;const i=[],o=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(o.terminate=!1);let r=0;return void 0!==(null==e?void 0:e.tag)&&(r=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,r),0===n&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);0!==t._OrtAddRunConfigEntry(n,o,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${r}.`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach((e=>t._free(e))),e}}},7622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(263),a=n(1497);t.setSessionOptions=e=>{var t,n,i,o;const s=(0,r.getInstance)();let u=0;const l=[],c=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(c);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=c.graphOptimizationLevel)&&void 0!==t?t:"all"),d=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=c.executionMode)&&void 0!==n?n:"sequential"),p="string"==typeof c.logId?(0,a.allocWasmString)(c.logId,l):0,f=null!==(i=c.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log serverity level is not valid: ${f}`);const h=null!==(o=c.logVerbosityLevel)&&void 0!==o?o:0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);const g="string"==typeof c.optimizedModelFilePath?(0,a.allocWasmString)(c.optimizedModelFilePath,l):0;return u=s._OrtCreateSessionOptions(e,!!c.enableCpuMemArena,!!c.enableMemPattern,d,!!c.enableProfiling,0,p,f,h,g),0===u&&(0,a.checkLastError)("Can\'t create session options."),c.executionProviders&&((e,t,n)=>{for(const i of t){let t="string"==typeof i?i:i.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof i){const t=i;if(null==t?void 0:t.deviceType){const i=(0,a.allocWasmString)("deviceType",n),o=(0,a.allocWasmString)(t.deviceType,n);0!==(0,r.getInstance)()._OrtAddSessionConfigEntry(e,i,o)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const i=(0,a.allocWasmString)("powerPreference",n),o=(0,a.allocWasmString)(t.powerPreference,n);0!==(0,r.getInstance)()._OrtAddSessionConfigEntry(e,i,o)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const o=(0,a.allocWasmString)(t,n);0!==(0,r.getInstance)()._OrtAppendExecutionProvider(e,o)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,c.executionProviders,l),void 0!==c.extra&&(0,a.iterateExtraOptions)(c.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);0!==s._OrtAddSessionConfigEntry(u,n,r)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,l]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),l.forEach((e=>s._free(e))),e}}},7917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},1259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const r=n(7918),a=n(7622),i=n(7917),o=n(263),s=n(1497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,i.logLevelStringToEnum)(e.logLevel),0!==(0,o.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.");{const t=n(7675).S;await t((0,o.getInstance)(),e)}};const u=new Map;t.createSessionAllocate=e=>{const t=(0,o.getInstance)(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,o.getInstance)();let r=0,i=0,l=[];const c=[],d=[];try{[i,l]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],i),0===r&&(0,s.checkLastError)("Can\'t create a session.");const[p,f]=(e=>{const t=(0,o.getInstance)(),n=t.stackSave();try{const n=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,n,n+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(n)}})(r),h=[],g=[];for(let e=0;e<p;e++){const t=n._OrtGetInputName(r,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),c.push(t),h.push(n.UTF8ToString(t))}for(let e=0;e<f;e++){const t=n._OrtGetOutputName(r,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),d.push(t),g.push(n.UTF8ToString(t))}return u.set(r,[r,c,d]),[r,h,g]}catch(e){throw c.forEach((e=>n._OrtFree(e))),d.forEach((e=>n._OrtFree(e))),0!==r&&n._OrtReleaseSession(r),e}finally{n._free(e[0]),0!==i&&n._OrtReleaseSessionOptions(i),l.forEach((e=>n._free(e)))}},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,o.getInstance)(),n=u.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);const[r,a,i]=n;a.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,l)=>{const c=(0,o.getInstance)(),d=u.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);const[p,f,h]=d,g=t.length,m=a.length;let y=0,b=[];const v=[],w=[];try{[y,b]=(0,r.setRunOptions)(l);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=c._malloc(u),w.push(o);let e=o/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);c.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,o=c._malloc(u),w.push(o),c.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const l=c.stackSave(),d=c.stackAlloc(4*r.length);try{let n=d/4;r.forEach((e=>c.HEAP32[n++]=e));const a=c._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),o,u,d,r.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),v.push(a)}finally{c.stackRestore(l)}}const e=c.stackSave(),o=c.stackAlloc(4*g),u=c.stackAlloc(4*g),d=c.stackAlloc(4*m),$=c.stackAlloc(4*m);try{let e=o/4,n=u/4,r=d/4,l=$/4;for(let r=0;r<g;r++)c.HEAPU32[e++]=v[r],c.HEAPU32[n++]=f[t[r]];for(let e=0;e<m;e++)c.HEAPU32[r++]=0,c.HEAPU32[l++]=h[a[e]];let b=c._OrtRun(p,u,o,g,$,m,d,y);const w=c.jsepRunPromise;w&&void 0!==w.then&&(b=await w);const x=[];0!==b&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=c.HEAPU32[d/4+e],n=c.stackSave(),r=c.stackAlloc(16);let a,o=0;try{b=c._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==b&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let n=r/4;const u=c.HEAPU32[n++];o=c.HEAPU32[n++];const l=c.HEAPU32[n++],d=c.HEAPU32[n++],p=[];for(let e=0;e<d;e++)p.push(c.HEAPU32[l/4+e]);c._OrtFree(l);const f=0===p.length?1:p.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=o/4;for(let n=0;n<f;n++){const r=c.HEAPU32[t++],a=n===f-1?void 0:c.HEAPU32[t]-r;e.push(c.UTF8ToString(r,a))}x.push([a,p,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(f);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(c.HEAPU8.subarray(o,o+e.byteLength)),x.push([a,p,e])}}finally{c.stackRestore(n),"string"===a&&o&&c._free(o),c._OrtReleaseTensor(t)}}return x}finally{c.stackRestore(e)}}finally{v.forEach((e=>c._OrtReleaseTensor(e))),w.forEach((e=>c._free(e))),0!==y&&c._OrtReleaseRunOptions(y),b.forEach((e=>c._free(e)))}},t.endProfiling=e=>{const t=(0,o.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const o=i(n(6449)),s=n(9377),u=n(5711);let l,c=!1,d=!1,p=!1;t.initializeWebAssembly=async e=>{if(c)return Promise.resolve();if(d)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");d=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),f=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),h=e.wasmPaths,g="string"==typeof h?h:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(f,i),y="object"==typeof h?h[m]:void 0;let b=!1;const v=[];if(t>0&&v.push(new Promise((e=>{setTimeout((()=>{b=!0,e()}),t)}))),v.push(new Promise(((e,t)=>{const r=i?u:s,a={locateFile:(e,t)=>{if(i&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob)return URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"}));if(e.endsWith(".wasm")){if(y)return y;const e=null!=g?g:t;return"ort-wasm-simd.wasm"===m?e+"ort-wasm-simd.jsep.wasm":"ort-wasm-simd-threaded.wasm"===m?e+"ort-wasm-simd-threaded.jsep.wasm":e+m}return t+e}};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=o.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{d=!1,c=!0,l=t,e()}),(e=>{d=!1,p=!0,t(e)}))}))),await Promise.race(v),b)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(c&&l)return l;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!c||d||p||(d=!0,null===(e=l.PThread)||void 0===e||e.terminateAllThreads(),l=void 0,d=!1,c=!1,p=!0)}},1497:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,i=n._malloc(a);return n.stringToUTF8(e,i,a),t.push(i),i},t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,i])=>{const o=n?n+e:e;if("object"==typeof i)(0,t.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))},t.checkLastError=e=>{const t=(0,r.getInstance)(),n=t.stackSave();try{const n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);const r=t.HEAP32[n/4],a=t.HEAPU32[n/4+1],i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}},5711:(e,t,n)=>{var _scriptDir,r=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return E.buffer!=k.buffer&&G(),k}function r(){return E.buffer!=k.buffer&&G(),D}function a(){return E.buffer!=k.buffer&&G(),z}function i(){return E.buffer!=k.buffer&&G(),j}function o(){return E.buffer!=k.buffer&&G(),B}var s,u,l=e;l.ready=new Promise(((e,t)=>{s=e,u=t})),l.jsepInit=function(e,t,n,r,a,i,o,s){l.Ib=e,l.ob=t,l.qb=n,l.ab=r,l.pb=a,l.xa=i,l.rb=o,l.sb=s};var c,d,p,f=Object.assign({},l),h="./this.program",g=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,v=l.ENVIRONMENT_IS_PTHREAD||!1,w="";function $(e){return l.locateFile?l.locateFile(e,w):w+e}if(b){var x=n(1384),S=n(908);let e;w=y?S.dirname(w)+"/":__dirname+"/",c=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),x.readFileSync(e,t?void 0:"utf8")),p=e=>((e=c(e,!0)).buffer||(e=new Uint8Array(e)),e),d=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),x.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!l.thisProgram&&1<process.argv.length&&(h=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),g=(e,t)=>{throw process.exitCode=e,t},l.inspect=()=>"[Emscripten Module object]";try{e=n(9925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=e.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",b||(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),d=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));b&&"undefined"==typeof performance&&(global.performance=n(6953).performance);var _=console.log.bind(console),A=console.error.bind(console);b&&(_=(...e)=>x.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>x.writeSync(2,e.join(" ")+"\\n"));var C,O=l.print||_,T=l.printErr||A;Object.assign(l,f),f=null,l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit),l.wasmBinary&&(C=l.wasmBinary);var I=l.noExitRuntime||!0;"object"!=typeof WebAssembly&&Z("no native wasm support detected");var E,P,M,R,k,D,z,j,B,W=!1;function G(){var e=E.buffer;l.HEAP8=k=new Int8Array(e),l.HEAP16=new Int16Array(e),l.HEAP32=z=new Int32Array(e),l.HEAPU8=D=new Uint8Array(e),l.HEAPU16=new Uint16Array(e),l.HEAPU32=j=new Uint32Array(e),l.HEAPF32=new Float32Array(e),l.HEAPF64=B=new Float64Array(e)}var U=l.INITIAL_MEMORY||16777216;if(5242880<=U||Z("INITIAL_MEMORY should be larger than STACK_SIZE, was "+U+"! (STACK_SIZE=5242880)"),v)E=l.wasmMemory;else if(l.wasmMemory)E=l.wasmMemory;else if(!((E=new WebAssembly.Memory({initial:U/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw T("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&T("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");G(),U=E.buffer.byteLength;var N=[],L=[],H=[],F=0;function V(){return I||0<F}var K,q=0,Y=null,X=null;function J(){q++,l.monitorRunDependencies&&l.monitorRunDependencies(q)}function Q(){if(q--,l.monitorRunDependencies&&l.monitorRunDependencies(q),0==q&&(null!==Y&&(clearInterval(Y),Y=null),X)){var e=X;X=null,e()}}function Z(e){throw l.onAbort&&l.onAbort(e),T(e="Aborted("+e+")"),W=!0,R=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function ee(e){return e.startsWith("data:application/octet-stream;base64,")}function te(e){if(e==K&&C)return new Uint8Array(C);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}function ne(e,t,n){return function(e){if(!C&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>te(e)));if(d)return new Promise(((t,n)=>{d(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>te(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{T("failed to asynchronously prepare wasm: "+e),Z(e)}))}ee(K="ort-wasm-simd-threaded.wasm")||(K=$(K));var re,ae={898348:()=>{l.jsepRunPromise=new Promise((function(e){l.tb=e}))},898443:e=>{l.tb(e)},898481:e=>l.ob(e),898514:e=>l.qb(e),898546:(e,t,n)=>{l.ab(e,t,n,!0)},898585:(e,t,n)=>{l.ab(e,t,n)},898618:e=>{l.xa("Abs",e,void 0)},898669:e=>{l.xa("Neg",e,void 0)},898720:e=>{l.xa("Floor",e,void 0)},898773:e=>{l.xa("Ceil",e,void 0)},898825:e=>{l.xa("Reciprocal",e,void 0)},898883:e=>{l.xa("Sqrt",e,void 0)},898935:e=>{l.xa("Exp",e,void 0)},898986:e=>{l.xa("Erf",e,void 0)},899037:e=>{l.xa("Sigmoid",e,void 0)},899092:e=>{l.xa("Log",e,void 0)},899143:e=>{l.xa("Sin",e,void 0)},899194:e=>{l.xa("Cos",e,void 0)},899245:e=>{l.xa("Tan",e,void 0)},899296:e=>{l.xa("Asin",e,void 0)},899348:e=>{l.xa("Acos",e,void 0)},899400:e=>{l.xa("Atan",e,void 0)},899452:e=>{l.xa("Sinh",e,void 0)},899504:e=>{l.xa("Cosh",e,void 0)},899556:e=>{l.xa("Asinh",e,void 0)},899609:e=>{l.xa("Acosh",e,void 0)},899662:e=>{l.xa("Atanh",e,void 0)},899715:e=>{l.xa("Tanh",e,void 0)},899767:(e,t,n)=>{l.xa("ClipV10",e,{min:t,max:n})},899839:e=>{l.xa("Clip",e,void 0)},899891:(e,t)=>{l.xa("Elu",e,{alpha:t})},899949:e=>{l.xa("Relu",e,void 0)},900001:(e,t)=>{l.xa("LeakyRelu",e,{alpha:t})},900065:(e,t)=>{l.xa("ThresholdedRelu",e,{alpha:t})},900135:(e,t)=>{l.xa("Cast",e,{to:t})},900193:e=>{l.xa("Add",e,void 0)},900244:e=>{l.xa("Sub",e,void 0)},900295:e=>{l.xa("Mul",e,void 0)},900346:e=>{l.xa("Div",e,void 0)},900397:e=>{l.xa("Pow",e,void 0)},900448:(e,t,n,r,i)=>{l.xa("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},900612:(e,t,n,r,i)=>{l.xa("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},900775:(e,t,n,r,i)=>{l.xa("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},900938:(e,t,n,r,i)=>{l.xa("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901102:(e,t,n,r,i)=>{l.xa("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901265:(e,t,n,r,i)=>{l.xa("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901427:(e,t,n,r,i)=>{l.xa("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901589:(e,t,n,r,i)=>{l.xa("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901755:(e,t,n,r,i)=>{l.xa("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901924:(e,t,n,r,i)=>{l.xa("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},902093:(e,t,n)=>{l.xa("Transpose",e,{perm:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[]})},902206:(e,n,r,a,i,o,s,u,c,d)=>{l.xa("Conv",e,{format:c?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:a,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!t()[d>>>0]})},902434:(e,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("Conv",e,{format:g?"NHWC":"NCHW",auto_pad:n,dilations:[r,a],group:i,kernel_shape:[o,s],pads:[u,c,d,p],strides:[f,h],w_is_const:()=>!!t()[m>>>0]})},902693:(e,n,r,a,i,o,s,u,c,d)=>{l.xa("Conv",e,{format:c?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:a,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!t()[d>>>0]})},902921:(e,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("Conv",e,{format:g?"NHWC":"NCHW",auto_pad:n,dilations:[r,a],group:i,kernel_shape:[o,s],pads:[u,c,d,p],strides:[f,h],w_is_const:()=>!!t()[m>>>0]})},903180:(e,n,r,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[c],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:g?Array.from(a().subarray(m>>>0,m+g>>>0)):[]})},903560:(e,n,r,i,o,s,u,c,d,p,f,h,g)=>{l.xa("ConvTranspose",e,{format:c?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(g>>>0,g+h>>>0)):[]})},904083:(e,n,r,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[c],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:g?Array.from(a().subarray(m>>>0,m+g>>>0)):[]})},904463:(e,n,r,i,o,s,u,c,d,p,f,h,g)=>{l.xa("ConvTranspose",e,{format:c?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(g>>>0,g+h>>>0)):[]})},904986:(e,t)=>{l.xa("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},905077:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},905361:(e,t)=>{l.xa("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},905452:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},905736:(e,t)=>{l.xa("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},905823:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},906103:(e,t)=>{l.xa("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},906190:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},906470:(e,t,n,r,a)=>{l.xa("Gemm",e,{alpha:t,beta:n,transA:r,transB:a})},906574:e=>{l.xa("MatMul",e,void 0)},906628:(e,t,n,r)=>{l.xa("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},906736:(e,t,n,r)=>{l.xa("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},906844:(e,t)=>{l.xa("Softmax",e,{axis:t})},906907:(e,t)=>{l.xa("Concat",e,{axis:t})},906967:(e,t,n,r,i)=>{l.xa("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},907112:e=>{l.xa("Expand",e,void 0)},907166:(e,t)=>{l.xa("Gather",e,{axis:Number(t)})},907237:(e,t,n,r,i,o,s,u,c,d,p)=>{l.xa("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(r>>>0,r+n>>>0)):[],coordinateTransformMode:de(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:de(c),mode:de(d),nearestMode:de(p)})},907588:(e,t,n,r,i,o,s)=>{l.xa("Slice",e,{starts:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[],ends:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[],axes:o?Array.from(a().subarray(s>>>0,s+o>>>0)):[]})},907819:e=>{l.xa("Tile",e,void 0)},907871:(e,t,n)=>{l.xa("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},907978:(e,t,n)=>{l.xa("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},908092:(e,t,n)=>{l.xa("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},908206:e=>{l.xa("Gelu",e,void 0)},908258:(e,t)=>{l.xa("SkipLayerNormalization",e,{epsilon:t})},908339:e=>{l.rb(e)},908373:(e,t)=>l.sb(e,t)};function ie(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function oe(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=he.Ja[e])||Z(),he.xb(e)}function ue(e){var t=he.lb();if(!t)return 6;he.Ra.push(t),he.Ja[e.Qa]=t,t.Qa=e.Qa;var n={cmd:"run",start_routine:e.yb,arg:e.jb,pthread_ptr:e.Qa};return b&&t.unref(),t.postMessage(n,e.Eb),0}var le="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,ce=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&le)return le.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},de=(e,t)=>(e>>>=0)?ce(r(),e,t):"";function pe(e){if(v)return qe(1,1,e);R=e,V()||(he.zb(),l.onExit&&l.onExit(e),W=!0),g(e,new ie(e))}var fe=e=>{if(R=e,v)throw me(e),"unwind";pe(e)},he={Ua:[],Ra:[],eb:[],Ja:{},Xa:function(){v?he.nb():he.mb()},mb:function(){N.unshift((()=>{J(),he.ub((()=>Q()))}))},nb:function(){he.receiveObjectTransfer=he.wb,he.threadInitTLS=he.cb,he.setExitStatus=he.bb,I=!1},bb:function(e){R=e},Kb:["$terminateWorker"],zb:function(){for(var e of he.Ra)oe(e);for(e of he.Ua)oe(e);he.Ua=[],he.Ra=[],he.Ja=[]},xb:function(e){var t=e.Qa;delete he.Ja[t],he.Ua.push(e),he.Ra.splice(he.Ra.indexOf(e),1),e.Qa=0,It(t)},wb:function(){},cb:function(){he.eb.forEach((e=>e()))},vb:e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=St()){var a=he.Ja[n.Jb];a?a.postMessage(n,n.transferList):T(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"checkMailbox"===r?Be():"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=he.Ja[n],delete he.Ja[n],oe(r),It(n),he.Ra.splice(he.Ra.indexOf(r),1),r.Qa=0):"cancelThread"===r?he.Ja[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?l[n.handler](...n.args):r&&T("worker sent an unknown command "+r)},e.onerror=e=>{throw T("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},b&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var n,r=[];for(n of["onExit","onAbort","print","printErr"])l.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,urlOrBlob:l.mainScriptUrlOrBlob||_scriptDir,wasmMemory:E,wasmModule:M})})),ub:function(e){e()},ib:function(){var e=$("ort-wasm-simd-threaded.worker.js");e=new Worker(e),he.Ua.push(e)},lb:function(){return 0==he.Ua.length&&(he.ib(),he.vb(he.Ua[0])),he.Ua.pop()}};l.PThread=he;var ge=e=>{for(;0<e.length;)e.shift()(l)};function me(e){if(v)return qe(2,0,e);fe(e)}function ye(e){this.$a=e-24,this.hb=function(e){i()[this.$a+4>>2>>>0]=e},this.gb=function(e){i()[this.$a+8>>2>>>0]=e},this.Xa=function(e,t){this.fb(),this.hb(e),this.gb(t)},this.fb=function(){i()[this.$a+16>>2>>>0]=0}}function be(e,t,n,r){return v?qe(3,1,e,t,n,r):ve(e,t,n,r)}function ve(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,"undefined"==typeof SharedArrayBuffer)return T("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return v&&0===a.length?be(e,t,n,r):(e={yb:n,Qa:e,jb:r,Eb:a},v?(e.Gb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return v?qe(4,1,e,t,n):0}function $e(e,t){if(v)return qe(5,1,e,t)}l.establishStackSpace=function(){var e=St(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],Rt(t,t-e),Dt(t)},l.invokeEntryPoint=function(e,t){e=jt.apply(null,[e,t]),V()?he.bb(e):Et(e)};var xe=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Se=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},_e=(e,t,n)=>Se(e,r(),t,n);function Ae(e,t){if(v)return qe(6,1,e,t)}function Ce(e,t,n){if(v)return qe(7,1,e,t,n)}function Oe(e,t,n){return v?qe(8,1,e,t,n):0}function Te(e,t){if(v)return qe(9,1,e,t)}function Ie(e,t,n){if(v)return qe(10,1,e,t,n)}function Ee(e,t,n,r){if(v)return qe(11,1,e,t,n,r)}function Pe(e,t,n,r){if(v)return qe(12,1,e,t,n,r)}function Me(e,t,n,r){if(v)return qe(13,1,e,t,n,r)}function Re(e){if(v)return qe(14,1,e)}function ke(e,t){if(v)return qe(15,1,e,t)}function De(e,t,n){if(v)return qe(16,1,e,t,n)}var ze=e=>{if(!W)try{if(e(),!V())try{v?Et(R):fe(R)}catch(e){e instanceof ie||"unwind"==e||g(1,e)}}catch(e){e instanceof ie||"unwind"==e||g(1,e)}};function je(e){e>>>=0,"function"==typeof Atomics.Fb&&(Atomics.Fb(a(),e>>2,e).value.then(Be),e+=128,Atomics.store(a(),e>>2,1))}function Be(){var e=St();e&&(je(e),ze((()=>Pt())))}l.__emscripten_thread_mailbox_await=je,l.checkMailbox=Be;var We=e=>0==e%4&&(0!=e%100||0==e%400),Ge=[0,31,60,91,121,152,182,213,244,274,305,335],Ue=[0,31,59,90,120,151,181,212,243,273,304,334];function Ne(e,t,n,r,a,i,o,s){return v?qe(17,1,e,t,n,r,a,i,o,s):-52}function Le(e,t,n,r,a,i,o){if(v)return qe(18,1,e,t,n,r,a,i,o)}var He=e=>{var t=xe(e)+1,n=_t(t);return n&&_e(e,n,t),n},Fe=[],Ve=(e,t)=>{var n;for(Fe.length=0,t>>=2;n=r()[e++>>>0];)t+=105!=n&t,Fe.push(105==n?a()[t>>>0]:o()[t++>>>1]),++t;return Fe},Ke=e=>{var t=kt();return e=e(),Dt(t),e};function qe(e,t){var n=arguments.length-2,r=arguments;return Ke((()=>{for(var a=zt(8*n),i=a>>3,s=0;s<n;s++){var u=r[2+s];o()[i+s>>>0]=u}return Tt(e,n,a,t)}))}var Ye,Xe=[],Je={},Qe=()=>{if(!Ye){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:h||"./this.program"};for(e in Je)void 0===Je[e]?delete t[e]:t[e]=Je[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Ye=n}return Ye};function Ze(e,n){if(v)return qe(19,1,e,n);e>>>=0,n>>>=0;var r=0;return Qe().forEach((function(a,o){var s=n+r;for(o=i()[e+4*o>>2>>>0]=s,s=0;s<a.length;++s)t()[o++>>0>>>0]=a.charCodeAt(s);t()[o>>0>>>0]=0,r+=a.length+1})),0}function et(e,t){if(v)return qe(20,1,e,t);e>>>=0,t>>>=0;var n=Qe();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function tt(e){return v?qe(21,1,e):52}function nt(e,t,n,r){return v?qe(22,1,e,t,n,r):52}function rt(e,t,n,r,a){return v?qe(23,1,e,t,n,r,a):70}var at=[null,[],[]];function it(e,t,n,a){if(v)return qe(24,1,e,t,n,a);t>>>=0,n>>>=0,a>>>=0;for(var o=0,s=0;s<n;s++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var c=0;c<l;c++){var d=r()[u+c>>>0],p=at[e];0===d||10===d?((1===e?O:T)(ce(p,0)),p.length=0):p.push(d)}o+=l}return i()[a>>2>>>0]=o,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(b)try{var e=n(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}Z("initRandomDevice")})())(e),st=[31,29,31,30,31,30,31,31,30,31,30,31],ut=[31,28,31,30,31,30,31,31,30,31,30,31],lt=(e,n)=>{t().set(e,n>>>0)};function ct(e,t,n,r){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return i(e,t,"0")}function s(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Sa;for(e=new Date(new Date(e.Ta+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(We(e.getFullYear())?st:ut)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),n=u(n),0>=s(t,e)?0>=s(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,r>>>=0;var c=a()[r+40>>2>>>0];for(var d in r={Cb:a()[r>>2>>>0],Bb:a()[r+4>>2>>>0],Va:a()[r+8>>2>>>0],Za:a()[r+12>>2>>>0],Wa:a()[r+16>>2>>>0],Ta:a()[r+20>>2>>>0],Pa:a()[r+24>>2>>>0],Sa:a()[r+28>>2>>>0],Lb:a()[r+32>>2>>>0],Ab:a()[r+36>>2>>>0],Db:c?de(c):""},n=de(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(d,"g"),c[d]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),f="January February March April May June July August September October November December".split(" ");for(d in c={"%a":e=>p[e.Pa].substring(0,3),"%A":e=>p[e.Pa],"%b":e=>f[e.Wa].substring(0,3),"%B":e=>f[e.Wa],"%C":e=>o((e.Ta+1900)/100|0,2),"%d":e=>o(e.Za,2),"%e":e=>i(e.Za,2," "),"%g":e=>l(e).toString().substring(2),"%G":e=>l(e),"%H":e=>o(e.Va,2),"%I":e=>(0==(e=e.Va)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Wa-1;t+=(We(e.Ta+1900)?st:ut)[n++]);return o(e.Za+t,3)},"%m":e=>o(e.Wa+1,2),"%M":e=>o(e.Bb,2),"%n":()=>"\\n","%p":e=>0<=e.Va&&12>e.Va?"AM":"PM","%S":e=>o(e.Cb,2),"%t":()=>"\\t","%u":e=>e.Pa||7,"%U":e=>o(Math.floor((e.Sa+7-e.Pa)/7),2),"%V":e=>{var t=Math.floor((e.Sa+7-(e.Pa+6)%7)/7);if(2>=(e.Pa+371-e.Sa-2)%7&&t++,t)53==t&&(4==(n=(e.Pa+371-e.Sa)%7)||3==n&&We(e.Ta)||(t=1));else{t=52;var n=(e.Pa+7-e.Sa-1)%7;(4==n||5==n&&We(e.Ta%400-1))&&t++}return o(t,2)},"%w":e=>e.Pa,"%W":e=>o(Math.floor((e.Sa+7-(e.Pa+6)%7)/7),2),"%y":e=>(e.Ta+1900).toString().substring(2),"%Y":e=>e.Ta+1900,"%z":e=>{var t=0<=(e=e.Ab);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.Db,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(d)&&(n=n.replace(new RegExp(d,"g"),c[d](r)));return d=function(e){var t=Array(xe(e)+1);return Se(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),d.length>t?0:(lt(d,e),d.length-1)}function dt(e){try{e()}catch(e){Z(e)}}var pt=0,ft=null,ht=0,gt=[],mt={},yt={},bt=0,vt=null,wt=[];he.Xa();var $t=[null,pe,me,be,we,$e,Ae,Ce,Oe,Te,Ie,Ee,Pe,Me,Re,ke,De,Ne,Le,Ze,et,tt,nt,rt,it],xt={r:function(e,t,n){return function(e){return function(e){if(!W){if(0===pt){var t=!1,n=!1;e(((e=0)=>{if(!W&&(ht=e,t=!0,n)){pt=2,dt((()=>Gt(ft))),"undefined"!=typeof Browser&&Browser.Ya.kb&&Browser.Ya.resume(),e=!1;try{var r=function(){var e=a()[ft+8>>2>>>0];return e=P[yt[e]],--F,e()}()}catch(t){r=t,e=!0}var i=!1;if(!ft){var o=vt;o&&(vt=null,(e?o.reject:o.resolve)(r),i=!0)}if(e&&!i)throw r}})),n=!0,t||(pt=1,ft=function(){var e=_t(65548),t=e+12;i()[e>>2>>>0]=t,i()[e+4>>2>>>0]=t+65536,t=gt[0];var n=mt[t];return void 0===n&&(n=bt++,mt[t]=n,yt[n]=t),t=n,a()[e+8>>2>>>0]=t,e}(),"undefined"!=typeof Browser&&Browser.Ya.kb&&Browser.Ya.pause(),dt((()=>Bt(ft))))}else 2===pt?(pt=0,dt(Ut),At(ft),ft=null,wt.forEach((e=>ze(e)))):Z(`invalid state: ${pt}`);return ht}}((t=>{e().then(t)}))}((async()=>{await l.pb(e,t,n)}))},b:function(e,t,n){throw new ye(e>>>=0).Xa(t>>>0,n>>>0),e},O:function(e){Ct(e>>>0,!y,1,!m,131072,!1),he.cb()},m:function(e){e>>>=0,v?postMessage({cmd:"cleanupThread",thread:e}):se(e)},J:ve,i:we,U:$e,G:Ae,I:Ce,V:Oe,S:Te,K:Ie,R:Ee,q:Pe,H:Me,E:Re,T:ke,F:De,Y:()=>!0,C:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>Be())):v?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=he.Ja[e])&&e.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:je,X:function(e){b&&he.Ja[e>>>0].ref()},u:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getUTCSeconds(),a()[n+4>>2>>>0]=e.getUTCMinutes(),a()[n+8>>2>>>0]=e.getUTCHours(),a()[n+12>>2>>>0]=e.getUTCDate(),a()[n+16>>2>>>0]=e.getUTCMonth(),a()[n+20>>2>>>0]=e.getUTCFullYear()-1900,a()[n+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[n+28>>2>>>0]=e},v:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getSeconds(),a()[n+4>>2>>>0]=e.getMinutes(),a()[n+8>>2>>>0]=e.getHours(),a()[n+12>>2>>>0]=e.getDate(),a()[n+16>>2>>>0]=e.getMonth(),a()[n+20>>2>>>0]=e.getFullYear()-1900,a()[n+24>>2>>>0]=e.getDay(),t=(We(e.getFullYear())?Ge:Ue)[e.getMonth()]+e.getDate()-1|0,a()[n+28>>2>>>0]=t,a()[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t)),a()[n+32>>2>>>0]=e},w:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(o,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=o&&s==r):0<n!=(s==r)&&(i=Math.max(o,i),t.setTime(t.getTime()+6e4*((0<n?s:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(We(t.getFullYear())?Ge:Ue)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Mt((re=e,1<=+Math.abs(re)?0<re?+Math.floor(re/4294967296)>>>0:~~+Math.ceil((re-+(~~re>>>0))/4294967296)>>>0:0)),e>>>0},s:Ne,t:Le,A:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var o=(new Date).getFullYear(),s=new Date(o,0,1),u=new Date(o,6,1);o=s.getTimezoneOffset();var l=u.getTimezoneOffset(),c=Math.max(o,l);i()[e>>2>>>0]=60*c,a()[t>>2>>>0]=Number(o!=l),e=r(s),t=r(u),e=He(e),t=He(t),l<o?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)},d:()=>{Z("")},c:function(e,t,n){return e>>>=0,t=Ve(t>>>0,n>>>0),ae[e].apply(null,t)},l:function(e,t,n){return e>>>=0,t=Ve(t>>>0,n>>>0),ae[e].apply(null,t)},n:function(){},j:function(){return Date.now()},W:()=>{throw F+=1,"unwind"},D:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return b?n(3993).cpus().length:navigator.hardwareConcurrency},L:function(e,t,n,r){for(he.Hb=t>>>0,Xe.length=n,t=r>>>0>>3,r=0;r<n;r++)Xe[r]=o()[t+r>>>0];return(0>e?ae[-e-1]:$t[e]).apply(null,Xe)},z:function(e){e>>>=0;var t=r().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var i=Math;a=Math.max(e,a);e:{i=i.min.call(i,4294901760,a+(65536-a%65536)%65536)-E.buffer.byteLength+65535>>>16;try{E.grow(i),G();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},P:Ze,Q:et,k:fe,h:tt,p:nt,x:rt,o:it,y:function(e,t){return e>>>=0,t>>>=0,ot(r().subarray(e>>>0,e+t>>>0)),0},a:E||l.wasmMemory,B:ct,e:function(e,t,n,r){return ct(e>>>0,t>>>0,n>>>0,r>>>0)}};!function(){function e(e,t){return e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){gt.push(t);try{return r.apply(null,arguments)}finally{W||(gt.pop()===t||Z(),ft&&1===pt&&0===gt.length&&(pt=0,F+=1,dt(Wt),"undefined"!=typeof Fibers&&Fibers.Mb()))}}:r}(t);return n}(e=e.exports),P=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),he.eb.push(P.wa),L.unshift(P.Z),M=t,Q(),e}var t={a:xt};if(J(),l.instantiateWasm)try{return l.instantiateWasm(t,e)}catch(e){T("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var n=K;return C||"function"!=typeof WebAssembly.instantiateStreaming||ee(n)||n.startsWith("file://")||b||"function"!=typeof fetch?ne(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return T("wasm streaming compile failed: "+r),T("falling back to ArrayBuffer instantiation"),ne(n,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),l._OrtInit=(e,t)=>(l._OrtInit=P._)(e,t),l._OrtGetLastError=(e,t)=>(l._OrtGetLastError=P.$)(e,t),l._OrtCreateSessionOptions=(e,t,n,r,a,i,o,s,u,c)=>(l._OrtCreateSessionOptions=P.aa)(e,t,n,r,a,i,o,s,u,c),l._OrtAppendExecutionProvider=(e,t)=>(l._OrtAppendExecutionProvider=P.ba)(e,t),l._OrtAddSessionConfigEntry=(e,t,n)=>(l._OrtAddSessionConfigEntry=P.ca)(e,t,n),l._OrtReleaseSessionOptions=e=>(l._OrtReleaseSessionOptions=P.da)(e),l._OrtCreateSession=(e,t,n)=>(l._OrtCreateSession=P.ea)(e,t,n),l._OrtReleaseSession=e=>(l._OrtReleaseSession=P.fa)(e),l._OrtGetInputOutputCount=(e,t,n)=>(l._OrtGetInputOutputCount=P.ga)(e,t,n),l._OrtGetInputName=(e,t)=>(l._OrtGetInputName=P.ha)(e,t),l._OrtGetOutputName=(e,t)=>(l._OrtGetOutputName=P.ia)(e,t),l._OrtFree=e=>(l._OrtFree=P.ja)(e),l._OrtCreateTensor=(e,t,n,r,a)=>(l._OrtCreateTensor=P.ka)(e,t,n,r,a),l._OrtGetTensorData=(e,t,n,r,a)=>(l._OrtGetTensorData=P.la)(e,t,n,r,a),l._OrtReleaseTensor=e=>(l._OrtReleaseTensor=P.ma)(e),l._OrtCreateRunOptions=(e,t,n,r)=>(l._OrtCreateRunOptions=P.na)(e,t,n,r),l._OrtAddRunConfigEntry=(e,t,n)=>(l._OrtAddRunConfigEntry=P.oa)(e,t,n),l._OrtReleaseRunOptions=e=>(l._OrtReleaseRunOptions=P.pa)(e),l._OrtRun=(e,t,n,r,a,i,o,s)=>(l._OrtRun=P.qa)(e,t,n,r,a,i,o,s),l._OrtEndProfiling=e=>(l._OrtEndProfiling=P.ra)(e),l._JsepOutput=(e,t,n)=>(l._JsepOutput=P.sa)(e,t,n);var St=l._pthread_self=()=>(St=l._pthread_self=P.ta)(),_t=l._malloc=e=>(_t=l._malloc=P.ua)(e),At=l._free=e=>(At=l._free=P.va)(e);l.__emscripten_tls_init=()=>(l.__emscripten_tls_init=P.wa)();var Ct=l.__emscripten_thread_init=(e,t,n,r,a,i)=>(Ct=l.__emscripten_thread_init=P.ya)(e,t,n,r,a,i);l.__emscripten_thread_crashed=()=>(l.__emscripten_thread_crashed=P.za)();var Ot,Tt=(e,t,n,r)=>(Tt=P.Aa)(e,t,n,r),It=e=>(It=P.Ba)(e),Et=l.__emscripten_thread_exit=e=>(Et=l.__emscripten_thread_exit=P.Ca)(e),Pt=l.__emscripten_check_mailbox=()=>(Pt=l.__emscripten_check_mailbox=P.Da)(),Mt=e=>(Mt=P.Ea)(e),Rt=(e,t)=>(Rt=P.Fa)(e,t),kt=()=>(kt=P.Ga)(),Dt=e=>(Dt=P.Ha)(e),zt=e=>(zt=P.Ia)(e),jt=l.dynCall_ii=(e,t)=>(jt=l.dynCall_ii=P.Ka)(e,t),Bt=e=>(Bt=P.La)(e),Wt=()=>(Wt=P.Ma)(),Gt=e=>(Gt=P.Na)(e),Ut=()=>(Ut=P.Oa)();function Nt(){function e(){if(!Ot&&(Ot=!0,l.calledRun=!0,!W)&&(v||ge(L),s(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),!v)){if(l.postRun)for("function"==typeof l.postRun&&(l.postRun=[l.postRun]);l.postRun.length;){var e=l.postRun.shift();H.unshift(e)}ge(H)}}if(!(0<q))if(v)s(l),v||ge(L),startWorker(l);else{if(l.preRun)for("function"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)N.unshift(l.preRun.shift());ge(N),0<q||(l.setStatus?(l.setStatus("Running..."),setTimeout((function(){setTimeout((function(){l.setStatus("")}),1),e()}),1)):e())}}if(l.___start_em_js=908408,l.___stop_em_js=908569,l.keepRuntimeAlive=V,l.wasmMemory=E,l.stackAlloc=zt,l.stackSave=kt,l.stackRestore=Dt,l.UTF8ToString=de,l.stringToUTF8=_e,l.lengthBytesUTF8=xe,l.ExitStatus=ie,l.PThread=he,X=function e(){Ot||Nt(),Ot||(X=e)},l.preInit)for("function"==typeof l.preInit&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();return Nt(),e.ready});e.exports=r},9377:(e,t,n)=>{var _scriptDir,r=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,r,a=e;a.ready=new Promise(((e,n)=>{t=e,r=n})),a.jsepInit=function(e,t,n,r,i,o,s,u){a.Sa=e,a.Ea=t,a.Ga=n,a.Ca=r,a.Fa=i,a.la=o,a.Ha=s,a.Ia=u};var i,o,s,u=Object.assign({},a),l="./this.program",c=(e,t)=>{throw t},d="object"==typeof window,p="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var g=n(1384),m=n(908);h=p?m.dirname(h)+"/":__dirname+"/",i=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),g.readFileSync(e,t?void 0:"utf8")),s=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),g.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),c=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(d||p)&&(p?h=self.location.href:"undefined"!=typeof document&&document.currentScript&&(h=document.currentScript.src),_scriptDir&&(h=_scriptDir),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},p&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,b=a.print||console.log.bind(console),v=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(l=a.thisProgram),a.quit&&(c=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var $,x,S,_,A,C,O,T,I=!1;function E(){var e=$.buffer;a.HEAP8=_=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=C=new Int32Array(e),a.HEAPU8=A=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=O=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=T=new Float64Array(e)}var P=[],M=[],R=[];function k(){var e=a.preRun.shift();P.unshift(e)}var D,z=0,j=null,B=null;function W(e){throw a.onAbort&&a.onAbort(e),v(e="Aborted("+e+")"),I=!0,S=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),r(e),e}function G(e){return e.startsWith("data:application/octet-stream;base64,")}if(!G(D="ort-wasm-simd.wasm")){var U=D;D=a.locateFile?a.locateFile(U,h):h+U}function N(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function L(e,t,n){return function(e){if(!y&&(d||p)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>N(e)));if(o)return new Promise(((t,n)=>{o(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>N(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{v("failed to asynchronously prepare wasm: "+e),W(e)}))}var H,F={894528:()=>{a.jsepRunPromise=new Promise((function(e){a.Ja=e}))},894623:e=>{a.Ja(e)},894661:e=>a.Ea(e),894694:e=>a.Ga(e),894726:(e,t,n)=>{a.Ca(e,t,n,!0)},894765:(e,t,n)=>{a.Ca(e,t,n)},894798:e=>{a.la("Abs",e,void 0)},894849:e=>{a.la("Neg",e,void 0)},894900:e=>{a.la("Floor",e,void 0)},894953:e=>{a.la("Ceil",e,void 0)},895005:e=>{a.la("Reciprocal",e,void 0)},895063:e=>{a.la("Sqrt",e,void 0)},895115:e=>{a.la("Exp",e,void 0)},895166:e=>{a.la("Erf",e,void 0)},895217:e=>{a.la("Sigmoid",e,void 0)},895272:e=>{a.la("Log",e,void 0)},895323:e=>{a.la("Sin",e,void 0)},895374:e=>{a.la("Cos",e,void 0)},895425:e=>{a.la("Tan",e,void 0)},895476:e=>{a.la("Asin",e,void 0)},895528:e=>{a.la("Acos",e,void 0)},895580:e=>{a.la("Atan",e,void 0)},895632:e=>{a.la("Sinh",e,void 0)},895684:e=>{a.la("Cosh",e,void 0)},895736:e=>{a.la("Asinh",e,void 0)},895789:e=>{a.la("Acosh",e,void 0)},895842:e=>{a.la("Atanh",e,void 0)},895895:e=>{a.la("Tanh",e,void 0)},895947:(e,t,n)=>{a.la("ClipV10",e,{min:t,max:n})},896019:e=>{a.la("Clip",e,void 0)},896071:(e,t)=>{a.la("Elu",e,{alpha:t})},896129:e=>{a.la("Relu",e,void 0)},896181:(e,t)=>{a.la("LeakyRelu",e,{alpha:t})},896245:(e,t)=>{a.la("ThresholdedRelu",e,{alpha:t})},896315:(e,t)=>{a.la("Cast",e,{to:t})},896373:e=>{a.la("Add",e,void 0)},896424:e=>{a.la("Sub",e,void 0)},896475:e=>{a.la("Mul",e,void 0)},896526:e=>{a.la("Div",e,void 0)},896577:e=>{a.la("Pow",e,void 0)},896628:(e,t,n,r,i)=>{a.la("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},896792:(e,t,n,r,i)=>{a.la("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},896955:(e,t,n,r,i)=>{a.la("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897118:(e,t,n,r,i)=>{a.la("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897282:(e,t,n,r,i)=>{a.la("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897445:(e,t,n,r,i)=>{a.la("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897607:(e,t,n,r,i)=>{a.la("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897769:(e,t,n,r,i)=>{a.la("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897935:(e,t,n,r,i)=>{a.la("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},898104:(e,t,n,r,i)=>{a.la("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},898273:(e,t,n)=>{a.la("Transpose",e,{perm:t?Array.from(C.subarray(n>>>0,n+t>>>0)):[]})},898386:(e,t,n,r,i,o,s,u,l,c)=>{a.la("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!_[c>>>0]})},898614:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g)=>{a.la("Conv",e,{format:h?"NHWC":"NCHW",auto_pad:t,dilations:[n,r],group:i,kernel_shape:[o,s],pads:[u,l,c,d],strides:[p,f],w_is_const:()=>!!_[g>>>0]})},898873:(e,t,n,r,i,o,s,u,l,c)=>{a.la("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!_[c>>>0]})},899101:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g)=>{a.la("Conv",e,{format:h?"NHWC":"NCHW",auto_pad:t,dilations:[n,r],group:i,kernel_shape:[o,s],pads:[u,l,c,d],strides:[p,f],w_is_const:()=>!!_[g>>>0]})},899360:(e,t,n,r,i,o,s,u,l,c,d,p,f,h)=>{a.la("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[c>>>0],outputPadding:d?Array.from(C.subarray(p>>>0,p+d>>>0)):[],outputShape:f?Array.from(C.subarray(h>>>0,h+f>>>0)):[]})},899740:(e,t,n,r,i,o,s,u,l,c,d,p,f)=>{a.la("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(C.subarray(n>>>0,n+2>>>0)),group:r,kernelShape:Array.from(C.subarray(i>>>0,i+2>>>0)),pads:Array.from(C.subarray(o>>>0,o+4>>>0)),strides:Array.from(C.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<c?Array.from(C.subarray(d>>>0,d+c>>>0)):[],outputShape:0<p?Array.from(C.subarray(f>>>0,f+p>>>0)):[]})},900263:(e,t,n,r,i,o,s,u,l,c,d,p,f,h)=>{a.la("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[c>>>0],outputPadding:d?Array.from(C.subarray(p>>>0,p+d>>>0)):[],outputShape:f?Array.from(C.subarray(h>>>0,h+f>>>0)):[]})},900643:(e,t,n,r,i,o,s,u,l,c,d,p,f)=>{a.la("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(C.subarray(n>>>0,n+2>>>0)),group:r,kernelShape:Array.from(C.subarray(i>>>0,i+2>>>0)),pads:Array.from(C.subarray(o>>>0,o+4>>>0)),strides:Array.from(C.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<c?Array.from(C.subarray(d>>>0,d+c>>>0)):[],outputShape:0<p?Array.from(C.subarray(f>>>0,f+p>>>0)):[]})},901166:(e,t)=>{a.la("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},901257:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},901541:(e,t)=>{a.la("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},901632:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},901916:(e,t)=>{a.la("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},902003:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},902283:(e,t)=>{a.la("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},902370:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},902650:(e,t,n,r,i)=>{a.la("Gemm",e,{alpha:t,beta:n,transA:r,transB:i})},902754:e=>{a.la("MatMul",e,void 0)},902808:(e,t,n,r)=>{a.la("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},902916:(e,t,n,r)=>{a.la("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},903024:(e,t)=>{a.la("Softmax",e,{axis:t})},903087:(e,t)=>{a.la("Concat",e,{axis:t})},903147:(e,t,n,r,i)=>{a.la("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},903292:e=>{a.la("Expand",e,void 0)},903346:(e,t)=>{a.la("Gather",e,{axis:Number(t)})},903417:(e,t,n,r,i,o,s,u,l,c,d)=>{a.la("Resize",e,{antialias:t,axes:n?Array.from(C.subarray(r>>>0,r+n>>>0)):[],coordinateTransformMode:Q(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:Q(l),mode:Q(c),nearestMode:Q(d)})},903768:(e,t,n,r,i,o,s)=>{a.la("Slice",e,{starts:t?Array.from(C.subarray(n>>>0,n+t>>>0)):[],ends:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[],axes:o?Array.from(C.subarray(s>>>0,s+o>>>0)):[]})},903999:e=>{a.la("Tile",e,void 0)},904051:(e,t,n)=>{a.la("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},904158:(e,t,n)=>{a.la("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},904272:(e,t,n)=>{a.la("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},904386:e=>{a.la("Gelu",e,void 0)},904438:(e,t)=>{a.la("SkipLayerNormalization",e,{epsilon:t})},904519:e=>{a.Ha(e)},904553:(e,t)=>a.Ia(e,t)};function V(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var K=e=>{for(;0<e.length;)e.shift()(a)};function q(e){this.za=e-24,this.Ra=function(e){O[this.za+4>>2>>>0]=e},this.Qa=function(e){O[this.za+8>>2>>>0]=e},this.Ka=function(e,t){this.Pa(),this.Ra(e),this.Qa(t)},this.Pa=function(){O[this.za+16>>2>>>0]=0}}var Y,X="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,J=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&X)return X.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},Q=(e,t)=>(e>>>=0)?J(A,e,t):"",Z=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},ee=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},te=e=>0==e%4&&(0!=e%100||0==e%400),ne=[0,31,60,91,121,152,182,213,244,274,305,335],re=[0,31,59,90,120,151,181,212,243,273,304,334],ae=e=>{var t=Z(e)+1,n=Oe(t);return n&&ee(e,A,n,t),n},ie=[],oe=(e,t)=>{var n;for(ie.length=0,t>>=2;n=A[e++>>>0];)t+=105!=n&t,ie.push(105==n?C[t>>>0]:T[t++>>>1]),++t;return ie},se={},ue=()=>{if(!Y){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"};for(e in se)void 0===se[e]?delete t[e]:t[e]=se[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Y=n}return Y},le=e=>{S=e,w||(a.onExit&&a.onExit(e),I=!0),c(e,new V(e))},ce=[null,[],[]],de=e=>(de=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(f)try{var e=n(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),pe=[31,29,31,30,31,30,31,31,30,31,30,31],fe=[31,28,31,30,31,30,31,31,30,31,30,31];function he(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return a(e,t,"0")}function o(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.va;for(e=new Date(new Date(e.wa+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?pe:fe)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=o(t,e)?0>=o(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0;var l=C[40+(r>>>=0)>>2>>>0];for(var c in r={Na:C[r>>2>>>0],Ma:C[r+4>>2>>>0],xa:C[r+8>>2>>>0],Ba:C[r+12>>2>>>0],ya:C[r+16>>2>>>0],wa:C[r+20>>2>>>0],qa:C[r+24>>2>>>0],va:C[r+28>>2>>>0],Ta:C[r+32>>2>>>0],La:C[r+36>>2>>>0],Oa:l?Q(l):""},n=Q(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(c,"g"),l[c]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(c in l={"%a":e=>d[e.qa].substring(0,3),"%A":e=>d[e.qa],"%b":e=>p[e.ya].substring(0,3),"%B":e=>p[e.ya],"%C":e=>i((e.wa+1900)/100|0,2),"%d":e=>i(e.Ba,2),"%e":e=>a(e.Ba,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>i(e.xa,2),"%I":e=>(0==(e=e.xa)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.ya-1;t+=(te(e.wa+1900)?pe:fe)[n++]);return i(e.Ba+t,3)},"%m":e=>i(e.ya+1,2),"%M":e=>i(e.Ma,2),"%n":()=>"\\n","%p":e=>0<=e.xa&&12>e.xa?"AM":"PM","%S":e=>i(e.Na,2),"%t":()=>"\\t","%u":e=>e.qa||7,"%U":e=>i(Math.floor((e.va+7-e.qa)/7),2),"%V":e=>{var t=Math.floor((e.va+7-(e.qa+6)%7)/7);if(2>=(e.qa+371-e.va-2)%7&&t++,t)53==t&&(4==(n=(e.qa+371-e.va)%7)||3==n&&te(e.wa)||(t=1));else{t=52;var n=(e.qa+7-e.va-1)%7;(4==n||5==n&&te(e.wa%400-1))&&t++}return i(t,2)},"%w":e=>e.qa,"%W":e=>i(Math.floor((e.va+7-(e.qa+6)%7)/7),2),"%y":e=>(e.wa+1900).toString().substring(2),"%Y":e=>e.wa+1900,"%z":e=>{var t=0<=(e=e.La);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.Oa,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0"),l)n.includes(c)&&(n=n.replace(new RegExp(c,"g"),l[c](r)));return c=function(e){var t=Array(Z(e)+1);return ee(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),c.length>t?0:(_.set(c,e>>>0),c.length-1)}function ge(e){try{e()}catch(e){W(e)}}var me=0,ye=null,be=0,ve=[],we={},$e={},xe=0,Se=null,_e=[];var Ae={o:function(e,t,n){return function(e){return function(e){if(!I){if(0===me){var t=!1,n=!1;e(((e=0)=>{if(!I&&(be=e,t=!0,n)){me=2,ge((()=>De(ye))),"undefined"!=typeof Browser&&Browser.Aa.Da&&Browser.Aa.resume(),e=!1;try{var r=(0,x[$e[C[ye+8>>2>>>0]]])()}catch(t){r=t,e=!0}var a=!1;if(!ye){var i=Se;i&&(Se=null,(e?i.reject:i.resolve)(r),a=!0)}if(e&&!a)throw r}})),n=!0,t||(me=1,ye=function(){var e=Oe(65548),t=e+12;O[e>>2>>>0]=t,O[e+4>>2>>>0]=t+65536,t=ve[0];var n=we[t];return void 0===n&&(n=xe++,we[t]=n,$e[n]=t),C[e+8>>2>>>0]=n,e}(),"undefined"!=typeof Browser&&Browser.Aa.Da&&Browser.Aa.pause(),ge((()=>Re(ye))))}else 2===me?(me=0,ge(ze),Te(ye),ye=null,_e.forEach((e=>{if(!I)try{if(e(),!w)try{S=e=S,le(e)}catch(e){e instanceof V||"unwind"==e||c(1,e)}}catch(e){e instanceof V||"unwind"==e||c(1,e)}}))):W(`invalid state: ${me}`);return be}}((t=>{e().then(t)}))}((async()=>{await a.Fa(e,t,n)}))},a:function(e,t,n){throw new q(e>>>=0).Ka(t>>>0,n>>>0),e},g:function(){return 0},L:function(){},C:function(){},E:function(){},N:function(){return 0},J:function(){},F:function(){},I:function(){},l:function(){},D:function(){},A:function(){},K:function(){},B:function(){},m:()=>!0,r:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),C[n>>2>>>0]=e.getUTCSeconds(),C[n+4>>2>>>0]=e.getUTCMinutes(),C[n+8>>2>>>0]=e.getUTCHours(),C[n+12>>2>>>0]=e.getUTCDate(),C[n+16>>2>>>0]=e.getUTCMonth(),C[n+20>>2>>>0]=e.getUTCFullYear()-1900,C[n+24>>2>>>0]=e.getUTCDay(),C[n+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},s:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),C[n>>2>>>0]=e.getSeconds(),C[n+4>>2>>>0]=e.getMinutes(),C[n+8>>2>>>0]=e.getHours(),C[n+12>>2>>>0]=e.getDate(),C[n+16>>2>>>0]=e.getMonth(),C[n+20>>2>>>0]=e.getFullYear()-1900,C[n+24>>2>>>0]=e.getDay(),C[n+28>>2>>>0]=(te(e.getFullYear())?ne:re)[e.getMonth()]+e.getDate()-1|0,C[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();C[n+32>>2>>>0]=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t))},t:function(e){e>>>=0;var t=new Date(C[e+20>>2>>>0]+1900,C[e+16>>2>>>0],C[e+12>>2>>>0],C[e+8>>2>>>0],C[e+4>>2>>>0],C[e>>2>>>0],0),n=C[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,a);return 0>n?C[e+32>>2>>>0]=Number(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),C[e+24>>2>>>0]=t.getDay(),C[e+28>>2>>>0]=(te(t.getFullYear())?ne:re)[t.getMonth()]+t.getDate()-1|0,C[e>>2>>>0]=t.getSeconds(),C[e+4>>2>>>0]=t.getMinutes(),C[e+8>>2>>>0]=t.getHours(),C[e+12>>2>>>0]=t.getDate(),C[e+16>>2>>>0]=t.getMonth(),C[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Ie((H=e,1<=+Math.abs(H)?0<H?+Math.floor(H/4294967296)>>>0:~~+Math.ceil((H-+(~~H>>>0))/4294967296)>>>0:0)),e>>>0},p:function(){return-52},q:function(){},x:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}n>>>=0;var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var s=o.getTimezoneOffset();O[e>>>0>>2>>>0]=60*Math.max(a,s),C[t>>>0>>2>>>0]=Number(a!=s),e=r(i),t=r(o),e=ae(e),t=ae(t),s<a?(O[n>>2>>>0]=e,O[n+4>>2>>>0]=t):(O[n>>2>>>0]=t,O[n+4>>2>>>0]=e)},e:()=>{W("")},b:function(e,t,n){return e>>>=0,t=oe(t>>>0,n>>>0),F[e].apply(null,t)},i:function(e,t,n){return e>>>=0,t=oe(t>>>0,n>>>0),F[e].apply(null,t)},h:function(){return Date.now()},z:function(){return 4294901760},d:()=>performance.now(),M:function(e,t,n){return t>>>=0,A.copyWithin(e>>>0>>>0,t>>>0,t+(n>>>0)>>>0)},w:function(e){e>>>=0;var t=A.length;if(4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r);e:{a=a.min.call(a,4294901760,r+(65536-r%65536)%65536)-$.buffer.byteLength+65535>>>16;try{$.grow(a),E();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},G:function(e,t){e>>>=0,t>>>=0;var n=0;return ue().forEach((function(r,a){var i=t+n;for(a=O[e+4*a>>2>>>0]=i,i=0;i<r.length;++i)_[a++>>0>>>0]=r.charCodeAt(i);_[a>>0>>>0]=0,n+=r.length+1})),0},H:function(e,t){e>>>=0,t>>>=0;var n=ue();O[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),O[t>>2>>>0]=r,0},n:e=>{S=e,le(e)},f:()=>52,k:function(){return 52},u:function(){return 70},j:function(e,t,n,r){t>>>=0,n>>>=0,r>>>=0;for(var a=0,i=0;i<n;i++){var o=O[t>>2>>>0],s=O[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=A[o+u>>>0],c=ce[e];0===l||10===l?((1===e?b:v)(J(c,0)),c.length=0):c.push(l)}a+=s}return O[r>>2>>>0]=a,0},v:function(e,t){return e>>>=0,de(A.subarray(e>>>0,e+(t>>>0)>>>0)),0},y:he,c:function(e,t,n,r){return he(e>>>0,t>>>0,n>>>0,r>>>0)}};!function(){function e(e){if(e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){ve.push(t);try{return r.apply(null,arguments)}finally{I||(ve.pop()===t||W(),ye&&1===me&&0===ve.length&&(me=0,ge(ke),"undefined"!=typeof Fibers&&Fibers.Ua()))}}:r}(t);return n}(e=e.exports),x=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),$=x.O,E(),M.unshift(x.P),z--,a.monitorRunDependencies&&a.monitorRunDependencies(z),0==z&&(null!==j&&(clearInterval(j),j=null),B)){var t=B;B=null,t()}return e}var t={a:Ae};if(z++,a.monitorRunDependencies&&a.monitorRunDependencies(z),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){v("Module.instantiateWasm callback failed with error: "+e),r(e)}(function(e,t){var n=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||G(n)||n.startsWith("file://")||f||"function"!=typeof fetch?L(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return v("wasm streaming compile failed: "+r),v("falling back to ArrayBuffer instantiation"),L(n,e,t)}))))})(t,(function(t){e(t.instance)})).catch(r)}(),a._OrtInit=(e,t)=>(a._OrtInit=x.Q)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=x.R)(e,t),a._OrtCreateSessionOptions=(e,t,n,r,i,o,s,u,l,c)=>(a._OrtCreateSessionOptions=x.S)(e,t,n,r,i,o,s,u,l,c),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=x.T)(e,t),a._OrtAddSessionConfigEntry=(e,t,n)=>(a._OrtAddSessionConfigEntry=x.U)(e,t,n),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=x.V)(e),a._OrtCreateSession=(e,t,n)=>(a._OrtCreateSession=x.W)(e,t,n),a._OrtReleaseSession=e=>(a._OrtReleaseSession=x.X)(e),a._OrtGetInputOutputCount=(e,t,n)=>(a._OrtGetInputOutputCount=x.Y)(e,t,n),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=x.Z)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=x._)(e,t),a._OrtFree=e=>(a._OrtFree=x.$)(e),a._OrtCreateTensor=(e,t,n,r,i)=>(a._OrtCreateTensor=x.aa)(e,t,n,r,i),a._OrtGetTensorData=(e,t,n,r,i)=>(a._OrtGetTensorData=x.ba)(e,t,n,r,i),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=x.ca)(e),a._OrtCreateRunOptions=(e,t,n,r)=>(a._OrtCreateRunOptions=x.da)(e,t,n,r),a._OrtAddRunConfigEntry=(e,t,n)=>(a._OrtAddRunConfigEntry=x.ea)(e,t,n),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=x.fa)(e),a._OrtRun=(e,t,n,r,i,o,s,u)=>(a._OrtRun=x.ga)(e,t,n,r,i,o,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=x.ha)(e),a._JsepOutput=(e,t,n)=>(a._JsepOutput=x.ia)(e,t,n);var Ce,Oe=a._malloc=e=>(Oe=a._malloc=x.ja)(e),Te=a._free=e=>(Te=a._free=x.ka)(e),Ie=e=>(Ie=x.ma)(e),Ee=()=>(Ee=x.na)(),Pe=e=>(Pe=x.oa)(e),Me=e=>(Me=x.pa)(e),Re=e=>(Re=x.ra)(e),ke=()=>(ke=x.sa)(),De=e=>(De=x.ta)(e),ze=()=>(ze=x.ua)();function je(){function e(){if(!Ce&&(Ce=!0,a.calledRun=!0,!I)){if(K(M),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();R.unshift(e)}K(R)}}if(!(0<z)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)k();K(P),0<z||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.___start_em_js=904588,a.___stop_em_js=904749,a.stackAlloc=Me,a.stackSave=Ee,a.stackRestore=Pe,a.UTF8ToString=Q,a.stringToUTF8=(e,t,n)=>ee(e,A,t,n),a.lengthBytesUTF8=Z,B=function e(){Ce||je(),Ce||(B=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return je(),e.ready});e.exports=r},4154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},6449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r].call(i.exports,i,i.exports,n),i.exports}(()=>{"use strict";const e=n(1259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(n.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in;(0,e.run)(t,r,a,i,o).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n', "Worker", void 0, void 0);
        }
      }, 6614: (e) => {
        "use strict";
        e.exports = function(e2, t, n, r) {
          var i = self || window;
          try {
            try {
              var o;
              try {
                o = new i.Blob([e2]);
              } catch (t2) {
                (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)()).append(e2), o = o.getBlob();
              }
              var a = i.URL || i.webkitURL, s = a.createObjectURL(o), u = new i[t](s, n);
              return a.revokeObjectURL(s), u;
            } catch (r2) {
              return new i[t]("data:application/javascript,".concat(encodeURIComponent(e2)), n);
            }
          } catch (e3) {
            if (!r)
              throw Error("Inline worker is not supported");
            return new i[t](r, n);
          }
        };
      }, 2446: (e, t, n) => {
        "use strict";
        var r, i, o, a = n(2100), s = a.Reader, u = a.Writer, l = a.util, c = a.roots.default || (a.roots.default = {});
        c.onnx = ((o = {}).Version = (r = {}, (i = Object.create(r))[r[0] = "_START_VERSION"] = 0, i[r[1] = "IR_VERSION_2017_10_10"] = 1, i[r[2] = "IR_VERSION_2017_10_30"] = 2, i[r[3] = "IR_VERSION_2017_11_3"] = 3, i[r[4] = "IR_VERSION_2019_1_22"] = 4, i[r[5] = "IR_VERSION_2019_3_18"] = 5, i[r[6] = "IR_VERSION_2019_9_19"] = 6, i[r[7] = "IR_VERSION_2020_5_8"] = 7, i[r[8] = "IR_VERSION_2021_7_30"] = 8, i[r[9] = "IR_VERSION"] = 9, i), o.AttributeProto = function() {
          function e2(e3) {
            if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.refAttrName = "", e2.prototype.docString = "", e2.prototype.type = 0, e2.prototype.f = 0, e2.prototype.i = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.s = l.newBuffer([]), e2.prototype.t = null, e2.prototype.g = null, e2.prototype.sparseTensor = null, e2.prototype.tp = null, e2.prototype.floats = l.emptyArray, e2.prototype.ints = l.emptyArray, e2.prototype.strings = l.emptyArray, e2.prototype.tensors = l.emptyArray, e2.prototype.graphs = l.emptyArray, e2.prototype.sparseTensors = l.emptyArray, e2.prototype.typeProtos = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.f && Object.hasOwnProperty.call(e3, "f") && t2.uint32(21).float(e3.f), null != e3.i && Object.hasOwnProperty.call(e3, "i") && t2.uint32(24).int64(e3.i), null != e3.s && Object.hasOwnProperty.call(e3, "s") && t2.uint32(34).bytes(e3.s), null != e3.t && Object.hasOwnProperty.call(e3, "t") && c.onnx.TensorProto.encode(e3.t, t2.uint32(42).fork()).ldelim(), null != e3.g && Object.hasOwnProperty.call(e3, "g") && c.onnx.GraphProto.encode(e3.g, t2.uint32(50).fork()).ldelim(), null != e3.floats && e3.floats.length) {
              t2.uint32(58).fork();
              for (var n2 = 0; n2 < e3.floats.length; ++n2)
                t2.float(e3.floats[n2]);
              t2.ldelim();
            }
            if (null != e3.ints && e3.ints.length) {
              for (t2.uint32(66).fork(), n2 = 0; n2 < e3.ints.length; ++n2)
                t2.int64(e3.ints[n2]);
              t2.ldelim();
            }
            if (null != e3.strings && e3.strings.length)
              for (n2 = 0; n2 < e3.strings.length; ++n2)
                t2.uint32(74).bytes(e3.strings[n2]);
            if (null != e3.tensors && e3.tensors.length)
              for (n2 = 0; n2 < e3.tensors.length; ++n2)
                c.onnx.TensorProto.encode(e3.tensors[n2], t2.uint32(82).fork()).ldelim();
            if (null != e3.graphs && e3.graphs.length)
              for (n2 = 0; n2 < e3.graphs.length; ++n2)
                c.onnx.GraphProto.encode(e3.graphs[n2], t2.uint32(90).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(106).string(e3.docString), null != e3.tp && Object.hasOwnProperty.call(e3, "tp") && c.onnx.TypeProto.encode(e3.tp, t2.uint32(114).fork()).ldelim(), null != e3.typeProtos && e3.typeProtos.length)
              for (n2 = 0; n2 < e3.typeProtos.length; ++n2)
                c.onnx.TypeProto.encode(e3.typeProtos[n2], t2.uint32(122).fork()).ldelim();
            if (null != e3.type && Object.hasOwnProperty.call(e3, "type") && t2.uint32(160).int32(e3.type), null != e3.refAttrName && Object.hasOwnProperty.call(e3, "refAttrName") && t2.uint32(170).string(e3.refAttrName), null != e3.sparseTensor && Object.hasOwnProperty.call(e3, "sparseTensor") && c.onnx.SparseTensorProto.encode(e3.sparseTensor, t2.uint32(178).fork()).ldelim(), null != e3.sparseTensors && e3.sparseTensors.length)
              for (n2 = 0; n2 < e3.sparseTensors.length; ++n2)
                c.onnx.SparseTensorProto.encode(e3.sparseTensors[n2], t2.uint32(186).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.AttributeProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 21:
                  r2.refAttrName = e3.string();
                  break;
                case 13:
                  r2.docString = e3.string();
                  break;
                case 20:
                  r2.type = e3.int32();
                  break;
                case 2:
                  r2.f = e3.float();
                  break;
                case 3:
                  r2.i = e3.int64();
                  break;
                case 4:
                  r2.s = e3.bytes();
                  break;
                case 5:
                  r2.t = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 6:
                  r2.g = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 22:
                  r2.sparseTensor = c.onnx.SparseTensorProto.decode(e3, e3.uint32());
                  break;
                case 14:
                  r2.tp = c.onnx.TypeProto.decode(e3, e3.uint32());
                  break;
                case 7:
                  if (r2.floats && r2.floats.length || (r2.floats = []), 2 == (7 & i2))
                    for (var o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.floats.push(e3.float());
                  else
                    r2.floats.push(e3.float());
                  break;
                case 8:
                  if (r2.ints && r2.ints.length || (r2.ints = []), 2 == (7 & i2))
                    for (o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.ints.push(e3.int64());
                  else
                    r2.ints.push(e3.int64());
                  break;
                case 9:
                  r2.strings && r2.strings.length || (r2.strings = []), r2.strings.push(e3.bytes());
                  break;
                case 10:
                  r2.tensors && r2.tensors.length || (r2.tensors = []), r2.tensors.push(c.onnx.TensorProto.decode(e3, e3.uint32()));
                  break;
                case 11:
                  r2.graphs && r2.graphs.length || (r2.graphs = []), r2.graphs.push(c.onnx.GraphProto.decode(e3, e3.uint32()));
                  break;
                case 23:
                  r2.sparseTensors && r2.sparseTensors.length || (r2.sparseTensors = []), r2.sparseTensors.push(c.onnx.SparseTensorProto.decode(e3, e3.uint32()));
                  break;
                case 15:
                  r2.typeProtos && r2.typeProtos.length || (r2.typeProtos = []), r2.typeProtos.push(c.onnx.TypeProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.refAttrName && e3.hasOwnProperty("refAttrName") && !l.isString(e3.refAttrName))
              return "refAttrName: string expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.type && e3.hasOwnProperty("type"))
              switch (e3.type) {
                default:
                  return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 11:
                case 13:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 14:
              }
            if (null != e3.f && e3.hasOwnProperty("f") && "number" != typeof e3.f)
              return "f: number expected";
            if (null != e3.i && e3.hasOwnProperty("i") && !(l.isInteger(e3.i) || e3.i && l.isInteger(e3.i.low) && l.isInteger(e3.i.high)))
              return "i: integer|Long expected";
            if (null != e3.s && e3.hasOwnProperty("s") && !(e3.s && "number" == typeof e3.s.length || l.isString(e3.s)))
              return "s: buffer expected";
            if (null != e3.t && e3.hasOwnProperty("t") && (n2 = c.onnx.TensorProto.verify(e3.t)))
              return "t." + n2;
            if (null != e3.g && e3.hasOwnProperty("g") && (n2 = c.onnx.GraphProto.verify(e3.g)))
              return "g." + n2;
            if (null != e3.sparseTensor && e3.hasOwnProperty("sparseTensor") && (n2 = c.onnx.SparseTensorProto.verify(e3.sparseTensor)))
              return "sparseTensor." + n2;
            if (null != e3.tp && e3.hasOwnProperty("tp") && (n2 = c.onnx.TypeProto.verify(e3.tp)))
              return "tp." + n2;
            if (null != e3.floats && e3.hasOwnProperty("floats")) {
              if (!Array.isArray(e3.floats))
                return "floats: array expected";
              for (var t2 = 0; t2 < e3.floats.length; ++t2)
                if ("number" != typeof e3.floats[t2])
                  return "floats: number[] expected";
            }
            if (null != e3.ints && e3.hasOwnProperty("ints")) {
              if (!Array.isArray(e3.ints))
                return "ints: array expected";
              for (t2 = 0; t2 < e3.ints.length; ++t2)
                if (!(l.isInteger(e3.ints[t2]) || e3.ints[t2] && l.isInteger(e3.ints[t2].low) && l.isInteger(e3.ints[t2].high)))
                  return "ints: integer|Long[] expected";
            }
            if (null != e3.strings && e3.hasOwnProperty("strings")) {
              if (!Array.isArray(e3.strings))
                return "strings: array expected";
              for (t2 = 0; t2 < e3.strings.length; ++t2)
                if (!(e3.strings[t2] && "number" == typeof e3.strings[t2].length || l.isString(e3.strings[t2])))
                  return "strings: buffer[] expected";
            }
            if (null != e3.tensors && e3.hasOwnProperty("tensors")) {
              if (!Array.isArray(e3.tensors))
                return "tensors: array expected";
              for (t2 = 0; t2 < e3.tensors.length; ++t2)
                if (n2 = c.onnx.TensorProto.verify(e3.tensors[t2]))
                  return "tensors." + n2;
            }
            if (null != e3.graphs && e3.hasOwnProperty("graphs")) {
              if (!Array.isArray(e3.graphs))
                return "graphs: array expected";
              for (t2 = 0; t2 < e3.graphs.length; ++t2)
                if (n2 = c.onnx.GraphProto.verify(e3.graphs[t2]))
                  return "graphs." + n2;
            }
            if (null != e3.sparseTensors && e3.hasOwnProperty("sparseTensors")) {
              if (!Array.isArray(e3.sparseTensors))
                return "sparseTensors: array expected";
              for (t2 = 0; t2 < e3.sparseTensors.length; ++t2)
                if (n2 = c.onnx.SparseTensorProto.verify(e3.sparseTensors[t2]))
                  return "sparseTensors." + n2;
            }
            if (null != e3.typeProtos && e3.hasOwnProperty("typeProtos")) {
              if (!Array.isArray(e3.typeProtos))
                return "typeProtos: array expected";
              for (t2 = 0; t2 < e3.typeProtos.length; ++t2) {
                var n2;
                if (n2 = c.onnx.TypeProto.verify(e3.typeProtos[t2]))
                  return "typeProtos." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.AttributeProto)
              return e3;
            var t2 = new c.onnx.AttributeProto();
            switch (null != e3.name && (t2.name = String(e3.name)), null != e3.refAttrName && (t2.refAttrName = String(e3.refAttrName)), null != e3.docString && (t2.docString = String(e3.docString)), e3.type) {
              default:
                if ("number" == typeof e3.type) {
                  t2.type = e3.type;
                  break;
                }
                break;
              case "UNDEFINED":
              case 0:
                t2.type = 0;
                break;
              case "FLOAT":
              case 1:
                t2.type = 1;
                break;
              case "INT":
              case 2:
                t2.type = 2;
                break;
              case "STRING":
              case 3:
                t2.type = 3;
                break;
              case "TENSOR":
              case 4:
                t2.type = 4;
                break;
              case "GRAPH":
              case 5:
                t2.type = 5;
                break;
              case "SPARSE_TENSOR":
              case 11:
                t2.type = 11;
                break;
              case "TYPE_PROTO":
              case 13:
                t2.type = 13;
                break;
              case "FLOATS":
              case 6:
                t2.type = 6;
                break;
              case "INTS":
              case 7:
                t2.type = 7;
                break;
              case "STRINGS":
              case 8:
                t2.type = 8;
                break;
              case "TENSORS":
              case 9:
                t2.type = 9;
                break;
              case "GRAPHS":
              case 10:
                t2.type = 10;
                break;
              case "SPARSE_TENSORS":
              case 12:
                t2.type = 12;
                break;
              case "TYPE_PROTOS":
              case 14:
                t2.type = 14;
            }
            if (null != e3.f && (t2.f = Number(e3.f)), null != e3.i && (l.Long ? (t2.i = l.Long.fromValue(e3.i)).unsigned = false : "string" == typeof e3.i ? t2.i = parseInt(e3.i, 10) : "number" == typeof e3.i ? t2.i = e3.i : "object" == typeof e3.i && (t2.i = new l.LongBits(e3.i.low >>> 0, e3.i.high >>> 0).toNumber())), null != e3.s && ("string" == typeof e3.s ? l.base64.decode(e3.s, t2.s = l.newBuffer(l.base64.length(e3.s)), 0) : e3.s.length >= 0 && (t2.s = e3.s)), null != e3.t) {
              if ("object" != typeof e3.t)
                throw TypeError(".onnx.AttributeProto.t: object expected");
              t2.t = c.onnx.TensorProto.fromObject(e3.t);
            }
            if (null != e3.g) {
              if ("object" != typeof e3.g)
                throw TypeError(".onnx.AttributeProto.g: object expected");
              t2.g = c.onnx.GraphProto.fromObject(e3.g);
            }
            if (null != e3.sparseTensor) {
              if ("object" != typeof e3.sparseTensor)
                throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
              t2.sparseTensor = c.onnx.SparseTensorProto.fromObject(e3.sparseTensor);
            }
            if (null != e3.tp) {
              if ("object" != typeof e3.tp)
                throw TypeError(".onnx.AttributeProto.tp: object expected");
              t2.tp = c.onnx.TypeProto.fromObject(e3.tp);
            }
            if (e3.floats) {
              if (!Array.isArray(e3.floats))
                throw TypeError(".onnx.AttributeProto.floats: array expected");
              t2.floats = [];
              for (var n2 = 0; n2 < e3.floats.length; ++n2)
                t2.floats[n2] = Number(e3.floats[n2]);
            }
            if (e3.ints) {
              if (!Array.isArray(e3.ints))
                throw TypeError(".onnx.AttributeProto.ints: array expected");
              for (t2.ints = [], n2 = 0; n2 < e3.ints.length; ++n2)
                l.Long ? (t2.ints[n2] = l.Long.fromValue(e3.ints[n2])).unsigned = false : "string" == typeof e3.ints[n2] ? t2.ints[n2] = parseInt(e3.ints[n2], 10) : "number" == typeof e3.ints[n2] ? t2.ints[n2] = e3.ints[n2] : "object" == typeof e3.ints[n2] && (t2.ints[n2] = new l.LongBits(e3.ints[n2].low >>> 0, e3.ints[n2].high >>> 0).toNumber());
            }
            if (e3.strings) {
              if (!Array.isArray(e3.strings))
                throw TypeError(".onnx.AttributeProto.strings: array expected");
              for (t2.strings = [], n2 = 0; n2 < e3.strings.length; ++n2)
                "string" == typeof e3.strings[n2] ? l.base64.decode(e3.strings[n2], t2.strings[n2] = l.newBuffer(l.base64.length(e3.strings[n2])), 0) : e3.strings[n2].length >= 0 && (t2.strings[n2] = e3.strings[n2]);
            }
            if (e3.tensors) {
              if (!Array.isArray(e3.tensors))
                throw TypeError(".onnx.AttributeProto.tensors: array expected");
              for (t2.tensors = [], n2 = 0; n2 < e3.tensors.length; ++n2) {
                if ("object" != typeof e3.tensors[n2])
                  throw TypeError(".onnx.AttributeProto.tensors: object expected");
                t2.tensors[n2] = c.onnx.TensorProto.fromObject(e3.tensors[n2]);
              }
            }
            if (e3.graphs) {
              if (!Array.isArray(e3.graphs))
                throw TypeError(".onnx.AttributeProto.graphs: array expected");
              for (t2.graphs = [], n2 = 0; n2 < e3.graphs.length; ++n2) {
                if ("object" != typeof e3.graphs[n2])
                  throw TypeError(".onnx.AttributeProto.graphs: object expected");
                t2.graphs[n2] = c.onnx.GraphProto.fromObject(e3.graphs[n2]);
              }
            }
            if (e3.sparseTensors) {
              if (!Array.isArray(e3.sparseTensors))
                throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
              for (t2.sparseTensors = [], n2 = 0; n2 < e3.sparseTensors.length; ++n2) {
                if ("object" != typeof e3.sparseTensors[n2])
                  throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
                t2.sparseTensors[n2] = c.onnx.SparseTensorProto.fromObject(e3.sparseTensors[n2]);
              }
            }
            if (e3.typeProtos) {
              if (!Array.isArray(e3.typeProtos))
                throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
              for (t2.typeProtos = [], n2 = 0; n2 < e3.typeProtos.length; ++n2) {
                if ("object" != typeof e3.typeProtos[n2])
                  throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
                t2.typeProtos[n2] = c.onnx.TypeProto.fromObject(e3.typeProtos[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.floats = [], n2.ints = [], n2.strings = [], n2.tensors = [], n2.graphs = [], n2.typeProtos = [], n2.sparseTensors = []), t2.defaults) {
              if (n2.name = "", n2.f = 0, l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.i = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.i = t2.longs === String ? "0" : 0;
              t2.bytes === String ? n2.s = "" : (n2.s = [], t2.bytes !== Array && (n2.s = l.newBuffer(n2.s))), n2.t = null, n2.g = null, n2.docString = "", n2.tp = null, n2.type = t2.enums === String ? "UNDEFINED" : 0, n2.refAttrName = "", n2.sparseTensor = null;
            }
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.f && e3.hasOwnProperty("f") && (n2.f = t2.json && !isFinite(e3.f) ? String(e3.f) : e3.f), null != e3.i && e3.hasOwnProperty("i") && ("number" == typeof e3.i ? n2.i = t2.longs === String ? String(e3.i) : e3.i : n2.i = t2.longs === String ? l.Long.prototype.toString.call(e3.i) : t2.longs === Number ? new l.LongBits(e3.i.low >>> 0, e3.i.high >>> 0).toNumber() : e3.i), null != e3.s && e3.hasOwnProperty("s") && (n2.s = t2.bytes === String ? l.base64.encode(e3.s, 0, e3.s.length) : t2.bytes === Array ? Array.prototype.slice.call(e3.s) : e3.s), null != e3.t && e3.hasOwnProperty("t") && (n2.t = c.onnx.TensorProto.toObject(e3.t, t2)), null != e3.g && e3.hasOwnProperty("g") && (n2.g = c.onnx.GraphProto.toObject(e3.g, t2)), e3.floats && e3.floats.length) {
              n2.floats = [];
              for (var i2 = 0; i2 < e3.floats.length; ++i2)
                n2.floats[i2] = t2.json && !isFinite(e3.floats[i2]) ? String(e3.floats[i2]) : e3.floats[i2];
            }
            if (e3.ints && e3.ints.length)
              for (n2.ints = [], i2 = 0; i2 < e3.ints.length; ++i2)
                "number" == typeof e3.ints[i2] ? n2.ints[i2] = t2.longs === String ? String(e3.ints[i2]) : e3.ints[i2] : n2.ints[i2] = t2.longs === String ? l.Long.prototype.toString.call(e3.ints[i2]) : t2.longs === Number ? new l.LongBits(e3.ints[i2].low >>> 0, e3.ints[i2].high >>> 0).toNumber() : e3.ints[i2];
            if (e3.strings && e3.strings.length)
              for (n2.strings = [], i2 = 0; i2 < e3.strings.length; ++i2)
                n2.strings[i2] = t2.bytes === String ? l.base64.encode(e3.strings[i2], 0, e3.strings[i2].length) : t2.bytes === Array ? Array.prototype.slice.call(e3.strings[i2]) : e3.strings[i2];
            if (e3.tensors && e3.tensors.length)
              for (n2.tensors = [], i2 = 0; i2 < e3.tensors.length; ++i2)
                n2.tensors[i2] = c.onnx.TensorProto.toObject(e3.tensors[i2], t2);
            if (e3.graphs && e3.graphs.length)
              for (n2.graphs = [], i2 = 0; i2 < e3.graphs.length; ++i2)
                n2.graphs[i2] = c.onnx.GraphProto.toObject(e3.graphs[i2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.tp && e3.hasOwnProperty("tp") && (n2.tp = c.onnx.TypeProto.toObject(e3.tp, t2)), e3.typeProtos && e3.typeProtos.length)
              for (n2.typeProtos = [], i2 = 0; i2 < e3.typeProtos.length; ++i2)
                n2.typeProtos[i2] = c.onnx.TypeProto.toObject(e3.typeProtos[i2], t2);
            if (null != e3.type && e3.hasOwnProperty("type") && (n2.type = t2.enums === String ? void 0 === c.onnx.AttributeProto.AttributeType[e3.type] ? e3.type : c.onnx.AttributeProto.AttributeType[e3.type] : e3.type), null != e3.refAttrName && e3.hasOwnProperty("refAttrName") && (n2.refAttrName = e3.refAttrName), null != e3.sparseTensor && e3.hasOwnProperty("sparseTensor") && (n2.sparseTensor = c.onnx.SparseTensorProto.toObject(e3.sparseTensor, t2)), e3.sparseTensors && e3.sparseTensors.length)
              for (n2.sparseTensors = [], i2 = 0; i2 < e3.sparseTensors.length; ++i2)
                n2.sparseTensors[i2] = c.onnx.SparseTensorProto.toObject(e3.sparseTensors[i2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.AttributeProto";
          }, e2.AttributeType = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "UNDEFINED"] = 0, t2[e3[1] = "FLOAT"] = 1, t2[e3[2] = "INT"] = 2, t2[e3[3] = "STRING"] = 3, t2[e3[4] = "TENSOR"] = 4, t2[e3[5] = "GRAPH"] = 5, t2[e3[11] = "SPARSE_TENSOR"] = 11, t2[e3[13] = "TYPE_PROTO"] = 13, t2[e3[6] = "FLOATS"] = 6, t2[e3[7] = "INTS"] = 7, t2[e3[8] = "STRINGS"] = 8, t2[e3[9] = "TENSORS"] = 9, t2[e3[10] = "GRAPHS"] = 10, t2[e3[12] = "SPARSE_TENSORS"] = 12, t2[e3[14] = "TYPE_PROTOS"] = 14, t2;
          }(), e2;
        }(), o.ValueInfoProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.type = null, e2.prototype.docString = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.type && Object.hasOwnProperty.call(e3, "type") && c.onnx.TypeProto.encode(e3.type, t2.uint32(18).fork()).ldelim(), null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(26).string(e3.docString), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.ValueInfoProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 2:
                  r2.type = c.onnx.TypeProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  r2.docString = e3.string();
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.type && e3.hasOwnProperty("type")) {
              var t2 = c.onnx.TypeProto.verify(e3.type);
              if (t2)
                return "type." + t2;
            }
            return null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString) ? "docString: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.ValueInfoProto)
              return e3;
            var t2 = new c.onnx.ValueInfoProto();
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.type) {
              if ("object" != typeof e3.type)
                throw TypeError(".onnx.ValueInfoProto.type: object expected");
              t2.type = c.onnx.TypeProto.fromObject(e3.type);
            }
            return null != e3.docString && (t2.docString = String(e3.docString)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            return t2.defaults && (n2.name = "", n2.type = null, n2.docString = ""), null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.type && e3.hasOwnProperty("type") && (n2.type = c.onnx.TypeProto.toObject(e3.type, t2)), null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.ValueInfoProto";
          }, e2;
        }(), o.NodeProto = function() {
          function e2(e3) {
            if (this.input = [], this.output = [], this.attribute = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.name = "", e2.prototype.opType = "", e2.prototype.domain = "", e2.prototype.attribute = l.emptyArray, e2.prototype.docString = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.input && e3.input.length)
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.uint32(10).string(e3.input[n2]);
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                t2.uint32(18).string(e3.output[n2]);
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(26).string(e3.name), null != e3.opType && Object.hasOwnProperty.call(e3, "opType") && t2.uint32(34).string(e3.opType), null != e3.attribute && e3.attribute.length)
              for (n2 = 0; n2 < e3.attribute.length; ++n2)
                c.onnx.AttributeProto.encode(e3.attribute[n2], t2.uint32(42).fork()).ldelim();
            return null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(50).string(e3.docString), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(58).string(e3.domain), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.NodeProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(e3.string());
                  break;
                case 2:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(e3.string());
                  break;
                case 3:
                  r2.name = e3.string();
                  break;
                case 4:
                  r2.opType = e3.string();
                  break;
                case 7:
                  r2.domain = e3.string();
                  break;
                case 5:
                  r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(c.onnx.AttributeProto.decode(e3, e3.uint32()));
                  break;
                case 6:
                  r2.docString = e3.string();
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (var t2 = 0; t2 < e3.input.length; ++t2)
                if (!l.isString(e3.input[t2]))
                  return "input: string[] expected";
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (!l.isString(e3.output[t2]))
                  return "output: string[] expected";
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.opType && e3.hasOwnProperty("opType") && !l.isString(e3.opType))
              return "opType: string expected";
            if (null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain))
              return "domain: string expected";
            if (null != e3.attribute && e3.hasOwnProperty("attribute")) {
              if (!Array.isArray(e3.attribute))
                return "attribute: array expected";
              for (t2 = 0; t2 < e3.attribute.length; ++t2) {
                var n2 = c.onnx.AttributeProto.verify(e3.attribute[t2]);
                if (n2)
                  return "attribute." + n2;
              }
            }
            return null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString) ? "docString: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.NodeProto)
              return e3;
            var t2 = new c.onnx.NodeProto();
            if (e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.NodeProto.input: array expected");
              t2.input = [];
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.input[n2] = String(e3.input[n2]);
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.NodeProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2)
                t2.output[n2] = String(e3.output[n2]);
            }
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.opType && (t2.opType = String(e3.opType)), null != e3.domain && (t2.domain = String(e3.domain)), e3.attribute) {
              if (!Array.isArray(e3.attribute))
                throw TypeError(".onnx.NodeProto.attribute: array expected");
              for (t2.attribute = [], n2 = 0; n2 < e3.attribute.length; ++n2) {
                if ("object" != typeof e3.attribute[n2])
                  throw TypeError(".onnx.NodeProto.attribute: object expected");
                t2.attribute[n2] = c.onnx.AttributeProto.fromObject(e3.attribute[n2]);
              }
            }
            return null != e3.docString && (t2.docString = String(e3.docString)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.input = [], n2.output = [], n2.attribute = []), t2.defaults && (n2.name = "", n2.opType = "", n2.docString = "", n2.domain = ""), e3.input && e3.input.length) {
              n2.input = [];
              for (var r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = e3.input[r2];
            }
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = e3.output[r2];
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.opType && e3.hasOwnProperty("opType") && (n2.opType = e3.opType), e3.attribute && e3.attribute.length)
              for (n2.attribute = [], r2 = 0; r2 < e3.attribute.length; ++r2)
                n2.attribute[r2] = c.onnx.AttributeProto.toObject(e3.attribute[r2], t2);
            return null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.NodeProto";
          }, e2;
        }(), o.TrainingInfoProto = function() {
          function e2(e3) {
            if (this.initializationBinding = [], this.updateBinding = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.initialization = null, e2.prototype.algorithm = null, e2.prototype.initializationBinding = l.emptyArray, e2.prototype.updateBinding = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.initialization && Object.hasOwnProperty.call(e3, "initialization") && c.onnx.GraphProto.encode(e3.initialization, t2.uint32(10).fork()).ldelim(), null != e3.algorithm && Object.hasOwnProperty.call(e3, "algorithm") && c.onnx.GraphProto.encode(e3.algorithm, t2.uint32(18).fork()).ldelim(), null != e3.initializationBinding && e3.initializationBinding.length)
              for (var n2 = 0; n2 < e3.initializationBinding.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.initializationBinding[n2], t2.uint32(26).fork()).ldelim();
            if (null != e3.updateBinding && e3.updateBinding.length)
              for (n2 = 0; n2 < e3.updateBinding.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.updateBinding[n2], t2.uint32(34).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TrainingInfoProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.initialization = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 2:
                  r2.algorithm = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  r2.initializationBinding && r2.initializationBinding.length || (r2.initializationBinding = []), r2.initializationBinding.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 4:
                  r2.updateBinding && r2.updateBinding.length || (r2.updateBinding = []), r2.updateBinding.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.initialization && e3.hasOwnProperty("initialization") && (n2 = c.onnx.GraphProto.verify(e3.initialization)))
              return "initialization." + n2;
            if (null != e3.algorithm && e3.hasOwnProperty("algorithm") && (n2 = c.onnx.GraphProto.verify(e3.algorithm)))
              return "algorithm." + n2;
            if (null != e3.initializationBinding && e3.hasOwnProperty("initializationBinding")) {
              if (!Array.isArray(e3.initializationBinding))
                return "initializationBinding: array expected";
              for (var t2 = 0; t2 < e3.initializationBinding.length; ++t2)
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.initializationBinding[t2]))
                  return "initializationBinding." + n2;
            }
            if (null != e3.updateBinding && e3.hasOwnProperty("updateBinding")) {
              if (!Array.isArray(e3.updateBinding))
                return "updateBinding: array expected";
              for (t2 = 0; t2 < e3.updateBinding.length; ++t2) {
                var n2;
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.updateBinding[t2]))
                  return "updateBinding." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TrainingInfoProto)
              return e3;
            var t2 = new c.onnx.TrainingInfoProto();
            if (null != e3.initialization) {
              if ("object" != typeof e3.initialization)
                throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
              t2.initialization = c.onnx.GraphProto.fromObject(e3.initialization);
            }
            if (null != e3.algorithm) {
              if ("object" != typeof e3.algorithm)
                throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
              t2.algorithm = c.onnx.GraphProto.fromObject(e3.algorithm);
            }
            if (e3.initializationBinding) {
              if (!Array.isArray(e3.initializationBinding))
                throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
              t2.initializationBinding = [];
              for (var n2 = 0; n2 < e3.initializationBinding.length; ++n2) {
                if ("object" != typeof e3.initializationBinding[n2])
                  throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
                t2.initializationBinding[n2] = c.onnx.StringStringEntryProto.fromObject(e3.initializationBinding[n2]);
              }
            }
            if (e3.updateBinding) {
              if (!Array.isArray(e3.updateBinding))
                throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
              for (t2.updateBinding = [], n2 = 0; n2 < e3.updateBinding.length; ++n2) {
                if ("object" != typeof e3.updateBinding[n2])
                  throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
                t2.updateBinding[n2] = c.onnx.StringStringEntryProto.fromObject(e3.updateBinding[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.initializationBinding = [], n2.updateBinding = []), t2.defaults && (n2.initialization = null, n2.algorithm = null), null != e3.initialization && e3.hasOwnProperty("initialization") && (n2.initialization = c.onnx.GraphProto.toObject(e3.initialization, t2)), null != e3.algorithm && e3.hasOwnProperty("algorithm") && (n2.algorithm = c.onnx.GraphProto.toObject(e3.algorithm, t2)), e3.initializationBinding && e3.initializationBinding.length) {
              n2.initializationBinding = [];
              for (var r2 = 0; r2 < e3.initializationBinding.length; ++r2)
                n2.initializationBinding[r2] = c.onnx.StringStringEntryProto.toObject(e3.initializationBinding[r2], t2);
            }
            if (e3.updateBinding && e3.updateBinding.length)
              for (n2.updateBinding = [], r2 = 0; r2 < e3.updateBinding.length; ++r2)
                n2.updateBinding[r2] = c.onnx.StringStringEntryProto.toObject(e3.updateBinding[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TrainingInfoProto";
          }, e2;
        }(), o.ModelProto = function() {
          function e2(e3) {
            if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.irVersion = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.opsetImport = l.emptyArray, e2.prototype.producerName = "", e2.prototype.producerVersion = "", e2.prototype.domain = "", e2.prototype.modelVersion = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.prototype.docString = "", e2.prototype.graph = null, e2.prototype.metadataProps = l.emptyArray, e2.prototype.trainingInfo = l.emptyArray, e2.prototype.functions = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.irVersion && Object.hasOwnProperty.call(e3, "irVersion") && t2.uint32(8).int64(e3.irVersion), null != e3.producerName && Object.hasOwnProperty.call(e3, "producerName") && t2.uint32(18).string(e3.producerName), null != e3.producerVersion && Object.hasOwnProperty.call(e3, "producerVersion") && t2.uint32(26).string(e3.producerVersion), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(34).string(e3.domain), null != e3.modelVersion && Object.hasOwnProperty.call(e3, "modelVersion") && t2.uint32(40).int64(e3.modelVersion), null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(50).string(e3.docString), null != e3.graph && Object.hasOwnProperty.call(e3, "graph") && c.onnx.GraphProto.encode(e3.graph, t2.uint32(58).fork()).ldelim(), null != e3.opsetImport && e3.opsetImport.length)
              for (var n2 = 0; n2 < e3.opsetImport.length; ++n2)
                c.onnx.OperatorSetIdProto.encode(e3.opsetImport[n2], t2.uint32(66).fork()).ldelim();
            if (null != e3.metadataProps && e3.metadataProps.length)
              for (n2 = 0; n2 < e3.metadataProps.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.metadataProps[n2], t2.uint32(114).fork()).ldelim();
            if (null != e3.trainingInfo && e3.trainingInfo.length)
              for (n2 = 0; n2 < e3.trainingInfo.length; ++n2)
                c.onnx.TrainingInfoProto.encode(e3.trainingInfo[n2], t2.uint32(162).fork()).ldelim();
            if (null != e3.functions && e3.functions.length)
              for (n2 = 0; n2 < e3.functions.length; ++n2)
                c.onnx.FunctionProto.encode(e3.functions[n2], t2.uint32(202).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.ModelProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.irVersion = e3.int64();
                  break;
                case 8:
                  r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e3, e3.uint32()));
                  break;
                case 2:
                  r2.producerName = e3.string();
                  break;
                case 3:
                  r2.producerVersion = e3.string();
                  break;
                case 4:
                  r2.domain = e3.string();
                  break;
                case 5:
                  r2.modelVersion = e3.int64();
                  break;
                case 6:
                  r2.docString = e3.string();
                  break;
                case 7:
                  r2.graph = c.onnx.GraphProto.decode(e3, e3.uint32());
                  break;
                case 14:
                  r2.metadataProps && r2.metadataProps.length || (r2.metadataProps = []), r2.metadataProps.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 20:
                  r2.trainingInfo && r2.trainingInfo.length || (r2.trainingInfo = []), r2.trainingInfo.push(c.onnx.TrainingInfoProto.decode(e3, e3.uint32()));
                  break;
                case 25:
                  r2.functions && r2.functions.length || (r2.functions = []), r2.functions.push(c.onnx.FunctionProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.irVersion && e3.hasOwnProperty("irVersion") && !(l.isInteger(e3.irVersion) || e3.irVersion && l.isInteger(e3.irVersion.low) && l.isInteger(e3.irVersion.high)))
              return "irVersion: integer|Long expected";
            if (null != e3.opsetImport && e3.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(e3.opsetImport))
                return "opsetImport: array expected";
              for (var t2 = 0; t2 < e3.opsetImport.length; ++t2)
                if (n2 = c.onnx.OperatorSetIdProto.verify(e3.opsetImport[t2]))
                  return "opsetImport." + n2;
            }
            if (null != e3.producerName && e3.hasOwnProperty("producerName") && !l.isString(e3.producerName))
              return "producerName: string expected";
            if (null != e3.producerVersion && e3.hasOwnProperty("producerVersion") && !l.isString(e3.producerVersion))
              return "producerVersion: string expected";
            if (null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain))
              return "domain: string expected";
            if (null != e3.modelVersion && e3.hasOwnProperty("modelVersion") && !(l.isInteger(e3.modelVersion) || e3.modelVersion && l.isInteger(e3.modelVersion.low) && l.isInteger(e3.modelVersion.high)))
              return "modelVersion: integer|Long expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.graph && e3.hasOwnProperty("graph") && (n2 = c.onnx.GraphProto.verify(e3.graph)))
              return "graph." + n2;
            if (null != e3.metadataProps && e3.hasOwnProperty("metadataProps")) {
              if (!Array.isArray(e3.metadataProps))
                return "metadataProps: array expected";
              for (t2 = 0; t2 < e3.metadataProps.length; ++t2)
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.metadataProps[t2]))
                  return "metadataProps." + n2;
            }
            if (null != e3.trainingInfo && e3.hasOwnProperty("trainingInfo")) {
              if (!Array.isArray(e3.trainingInfo))
                return "trainingInfo: array expected";
              for (t2 = 0; t2 < e3.trainingInfo.length; ++t2)
                if (n2 = c.onnx.TrainingInfoProto.verify(e3.trainingInfo[t2]))
                  return "trainingInfo." + n2;
            }
            if (null != e3.functions && e3.hasOwnProperty("functions")) {
              if (!Array.isArray(e3.functions))
                return "functions: array expected";
              for (t2 = 0; t2 < e3.functions.length; ++t2) {
                var n2;
                if (n2 = c.onnx.FunctionProto.verify(e3.functions[t2]))
                  return "functions." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.ModelProto)
              return e3;
            var t2 = new c.onnx.ModelProto();
            if (null != e3.irVersion && (l.Long ? (t2.irVersion = l.Long.fromValue(e3.irVersion)).unsigned = false : "string" == typeof e3.irVersion ? t2.irVersion = parseInt(e3.irVersion, 10) : "number" == typeof e3.irVersion ? t2.irVersion = e3.irVersion : "object" == typeof e3.irVersion && (t2.irVersion = new l.LongBits(e3.irVersion.low >>> 0, e3.irVersion.high >>> 0).toNumber())), e3.opsetImport) {
              if (!Array.isArray(e3.opsetImport))
                throw TypeError(".onnx.ModelProto.opsetImport: array expected");
              t2.opsetImport = [];
              for (var n2 = 0; n2 < e3.opsetImport.length; ++n2) {
                if ("object" != typeof e3.opsetImport[n2])
                  throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                t2.opsetImport[n2] = c.onnx.OperatorSetIdProto.fromObject(e3.opsetImport[n2]);
              }
            }
            if (null != e3.producerName && (t2.producerName = String(e3.producerName)), null != e3.producerVersion && (t2.producerVersion = String(e3.producerVersion)), null != e3.domain && (t2.domain = String(e3.domain)), null != e3.modelVersion && (l.Long ? (t2.modelVersion = l.Long.fromValue(e3.modelVersion)).unsigned = false : "string" == typeof e3.modelVersion ? t2.modelVersion = parseInt(e3.modelVersion, 10) : "number" == typeof e3.modelVersion ? t2.modelVersion = e3.modelVersion : "object" == typeof e3.modelVersion && (t2.modelVersion = new l.LongBits(e3.modelVersion.low >>> 0, e3.modelVersion.high >>> 0).toNumber())), null != e3.docString && (t2.docString = String(e3.docString)), null != e3.graph) {
              if ("object" != typeof e3.graph)
                throw TypeError(".onnx.ModelProto.graph: object expected");
              t2.graph = c.onnx.GraphProto.fromObject(e3.graph);
            }
            if (e3.metadataProps) {
              if (!Array.isArray(e3.metadataProps))
                throw TypeError(".onnx.ModelProto.metadataProps: array expected");
              for (t2.metadataProps = [], n2 = 0; n2 < e3.metadataProps.length; ++n2) {
                if ("object" != typeof e3.metadataProps[n2])
                  throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                t2.metadataProps[n2] = c.onnx.StringStringEntryProto.fromObject(e3.metadataProps[n2]);
              }
            }
            if (e3.trainingInfo) {
              if (!Array.isArray(e3.trainingInfo))
                throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
              for (t2.trainingInfo = [], n2 = 0; n2 < e3.trainingInfo.length; ++n2) {
                if ("object" != typeof e3.trainingInfo[n2])
                  throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
                t2.trainingInfo[n2] = c.onnx.TrainingInfoProto.fromObject(e3.trainingInfo[n2]);
              }
            }
            if (e3.functions) {
              if (!Array.isArray(e3.functions))
                throw TypeError(".onnx.ModelProto.functions: array expected");
              for (t2.functions = [], n2 = 0; n2 < e3.functions.length; ++n2) {
                if ("object" != typeof e3.functions[n2])
                  throw TypeError(".onnx.ModelProto.functions: object expected");
                t2.functions[n2] = c.onnx.FunctionProto.fromObject(e3.functions[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.opsetImport = [], n2.metadataProps = [], n2.trainingInfo = [], n2.functions = []), t2.defaults) {
              if (l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.irVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.irVersion = t2.longs === String ? "0" : 0;
              n2.producerName = "", n2.producerVersion = "", n2.domain = "", l.Long ? (r2 = new l.Long(0, 0, false), n2.modelVersion = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.modelVersion = t2.longs === String ? "0" : 0, n2.docString = "", n2.graph = null;
            }
            if (null != e3.irVersion && e3.hasOwnProperty("irVersion") && ("number" == typeof e3.irVersion ? n2.irVersion = t2.longs === String ? String(e3.irVersion) : e3.irVersion : n2.irVersion = t2.longs === String ? l.Long.prototype.toString.call(e3.irVersion) : t2.longs === Number ? new l.LongBits(e3.irVersion.low >>> 0, e3.irVersion.high >>> 0).toNumber() : e3.irVersion), null != e3.producerName && e3.hasOwnProperty("producerName") && (n2.producerName = e3.producerName), null != e3.producerVersion && e3.hasOwnProperty("producerVersion") && (n2.producerVersion = e3.producerVersion), null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), null != e3.modelVersion && e3.hasOwnProperty("modelVersion") && ("number" == typeof e3.modelVersion ? n2.modelVersion = t2.longs === String ? String(e3.modelVersion) : e3.modelVersion : n2.modelVersion = t2.longs === String ? l.Long.prototype.toString.call(e3.modelVersion) : t2.longs === Number ? new l.LongBits(e3.modelVersion.low >>> 0, e3.modelVersion.high >>> 0).toNumber() : e3.modelVersion), null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), null != e3.graph && e3.hasOwnProperty("graph") && (n2.graph = c.onnx.GraphProto.toObject(e3.graph, t2)), e3.opsetImport && e3.opsetImport.length) {
              n2.opsetImport = [];
              for (var i2 = 0; i2 < e3.opsetImport.length; ++i2)
                n2.opsetImport[i2] = c.onnx.OperatorSetIdProto.toObject(e3.opsetImport[i2], t2);
            }
            if (e3.metadataProps && e3.metadataProps.length)
              for (n2.metadataProps = [], i2 = 0; i2 < e3.metadataProps.length; ++i2)
                n2.metadataProps[i2] = c.onnx.StringStringEntryProto.toObject(e3.metadataProps[i2], t2);
            if (e3.trainingInfo && e3.trainingInfo.length)
              for (n2.trainingInfo = [], i2 = 0; i2 < e3.trainingInfo.length; ++i2)
                n2.trainingInfo[i2] = c.onnx.TrainingInfoProto.toObject(e3.trainingInfo[i2], t2);
            if (e3.functions && e3.functions.length)
              for (n2.functions = [], i2 = 0; i2 < e3.functions.length; ++i2)
                n2.functions[i2] = c.onnx.FunctionProto.toObject(e3.functions[i2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.ModelProto";
          }, e2;
        }(), o.StringStringEntryProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.key = "", e2.prototype.value = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.key && Object.hasOwnProperty.call(e3, "key") && t2.uint32(10).string(e3.key), null != e3.value && Object.hasOwnProperty.call(e3, "value") && t2.uint32(18).string(e3.value), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.StringStringEntryProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.key = e3.string();
                  break;
                case 2:
                  r2.value = e3.string();
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            return "object" != typeof e3 || null === e3 ? "object expected" : null != e3.key && e3.hasOwnProperty("key") && !l.isString(e3.key) ? "key: string expected" : null != e3.value && e3.hasOwnProperty("value") && !l.isString(e3.value) ? "value: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.StringStringEntryProto)
              return e3;
            var t2 = new c.onnx.StringStringEntryProto();
            return null != e3.key && (t2.key = String(e3.key)), null != e3.value && (t2.value = String(e3.value)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            return t2.defaults && (n2.key = "", n2.value = ""), null != e3.key && e3.hasOwnProperty("key") && (n2.key = e3.key), null != e3.value && e3.hasOwnProperty("value") && (n2.value = e3.value), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.StringStringEntryProto";
          }, e2;
        }(), o.TensorAnnotation = function() {
          function e2(e3) {
            if (this.quantParameterTensorNames = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.tensorName = "", e2.prototype.quantParameterTensorNames = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.tensorName && Object.hasOwnProperty.call(e3, "tensorName") && t2.uint32(10).string(e3.tensorName), null != e3.quantParameterTensorNames && e3.quantParameterTensorNames.length)
              for (var n2 = 0; n2 < e3.quantParameterTensorNames.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.quantParameterTensorNames[n2], t2.uint32(18).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorAnnotation(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.tensorName = e3.string();
                  break;
                case 2:
                  r2.quantParameterTensorNames && r2.quantParameterTensorNames.length || (r2.quantParameterTensorNames = []), r2.quantParameterTensorNames.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.tensorName && e3.hasOwnProperty("tensorName") && !l.isString(e3.tensorName))
              return "tensorName: string expected";
            if (null != e3.quantParameterTensorNames && e3.hasOwnProperty("quantParameterTensorNames")) {
              if (!Array.isArray(e3.quantParameterTensorNames))
                return "quantParameterTensorNames: array expected";
              for (var t2 = 0; t2 < e3.quantParameterTensorNames.length; ++t2) {
                var n2 = c.onnx.StringStringEntryProto.verify(e3.quantParameterTensorNames[t2]);
                if (n2)
                  return "quantParameterTensorNames." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorAnnotation)
              return e3;
            var t2 = new c.onnx.TensorAnnotation();
            if (null != e3.tensorName && (t2.tensorName = String(e3.tensorName)), e3.quantParameterTensorNames) {
              if (!Array.isArray(e3.quantParameterTensorNames))
                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
              t2.quantParameterTensorNames = [];
              for (var n2 = 0; n2 < e3.quantParameterTensorNames.length; ++n2) {
                if ("object" != typeof e3.quantParameterTensorNames[n2])
                  throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                t2.quantParameterTensorNames[n2] = c.onnx.StringStringEntryProto.fromObject(e3.quantParameterTensorNames[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.quantParameterTensorNames = []), t2.defaults && (n2.tensorName = ""), null != e3.tensorName && e3.hasOwnProperty("tensorName") && (n2.tensorName = e3.tensorName), e3.quantParameterTensorNames && e3.quantParameterTensorNames.length) {
              n2.quantParameterTensorNames = [];
              for (var r2 = 0; r2 < e3.quantParameterTensorNames.length; ++r2)
                n2.quantParameterTensorNames[r2] = c.onnx.StringStringEntryProto.toObject(e3.quantParameterTensorNames[r2], t2);
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorAnnotation";
          }, e2;
        }(), o.GraphProto = function() {
          function e2(e3) {
            if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.node = l.emptyArray, e2.prototype.name = "", e2.prototype.initializer = l.emptyArray, e2.prototype.sparseInitializer = l.emptyArray, e2.prototype.docString = "", e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.valueInfo = l.emptyArray, e2.prototype.quantizationAnnotation = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.node && e3.node.length)
              for (var n2 = 0; n2 < e3.node.length; ++n2)
                c.onnx.NodeProto.encode(e3.node[n2], t2.uint32(10).fork()).ldelim();
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(18).string(e3.name), null != e3.initializer && e3.initializer.length)
              for (n2 = 0; n2 < e3.initializer.length; ++n2)
                c.onnx.TensorProto.encode(e3.initializer[n2], t2.uint32(42).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(82).string(e3.docString), null != e3.input && e3.input.length)
              for (n2 = 0; n2 < e3.input.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.input[n2], t2.uint32(90).fork()).ldelim();
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.output[n2], t2.uint32(98).fork()).ldelim();
            if (null != e3.valueInfo && e3.valueInfo.length)
              for (n2 = 0; n2 < e3.valueInfo.length; ++n2)
                c.onnx.ValueInfoProto.encode(e3.valueInfo[n2], t2.uint32(106).fork()).ldelim();
            if (null != e3.quantizationAnnotation && e3.quantizationAnnotation.length)
              for (n2 = 0; n2 < e3.quantizationAnnotation.length; ++n2)
                c.onnx.TensorAnnotation.encode(e3.quantizationAnnotation[n2], t2.uint32(114).fork()).ldelim();
            if (null != e3.sparseInitializer && e3.sparseInitializer.length)
              for (n2 = 0; n2 < e3.sparseInitializer.length; ++n2)
                c.onnx.SparseTensorProto.encode(e3.sparseInitializer[n2], t2.uint32(122).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.GraphProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.node && r2.node.length || (r2.node = []), r2.node.push(c.onnx.NodeProto.decode(e3, e3.uint32()));
                  break;
                case 2:
                  r2.name = e3.string();
                  break;
                case 5:
                  r2.initializer && r2.initializer.length || (r2.initializer = []), r2.initializer.push(c.onnx.TensorProto.decode(e3, e3.uint32()));
                  break;
                case 15:
                  r2.sparseInitializer && r2.sparseInitializer.length || (r2.sparseInitializer = []), r2.sparseInitializer.push(c.onnx.SparseTensorProto.decode(e3, e3.uint32()));
                  break;
                case 10:
                  r2.docString = e3.string();
                  break;
                case 11:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 12:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 13:
                  r2.valueInfo && r2.valueInfo.length || (r2.valueInfo = []), r2.valueInfo.push(c.onnx.ValueInfoProto.decode(e3, e3.uint32()));
                  break;
                case 14:
                  r2.quantizationAnnotation && r2.quantizationAnnotation.length || (r2.quantizationAnnotation = []), r2.quantizationAnnotation.push(c.onnx.TensorAnnotation.decode(e3, e3.uint32()));
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.node && e3.hasOwnProperty("node")) {
              if (!Array.isArray(e3.node))
                return "node: array expected";
              for (var t2 = 0; t2 < e3.node.length; ++t2)
                if (n2 = c.onnx.NodeProto.verify(e3.node[t2]))
                  return "node." + n2;
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.initializer && e3.hasOwnProperty("initializer")) {
              if (!Array.isArray(e3.initializer))
                return "initializer: array expected";
              for (t2 = 0; t2 < e3.initializer.length; ++t2)
                if (n2 = c.onnx.TensorProto.verify(e3.initializer[t2]))
                  return "initializer." + n2;
            }
            if (null != e3.sparseInitializer && e3.hasOwnProperty("sparseInitializer")) {
              if (!Array.isArray(e3.sparseInitializer))
                return "sparseInitializer: array expected";
              for (t2 = 0; t2 < e3.sparseInitializer.length; ++t2)
                if (n2 = c.onnx.SparseTensorProto.verify(e3.sparseInitializer[t2]))
                  return "sparseInitializer." + n2;
            }
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (t2 = 0; t2 < e3.input.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.input[t2]))
                  return "input." + n2;
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.output[t2]))
                  return "output." + n2;
            }
            if (null != e3.valueInfo && e3.hasOwnProperty("valueInfo")) {
              if (!Array.isArray(e3.valueInfo))
                return "valueInfo: array expected";
              for (t2 = 0; t2 < e3.valueInfo.length; ++t2)
                if (n2 = c.onnx.ValueInfoProto.verify(e3.valueInfo[t2]))
                  return "valueInfo." + n2;
            }
            if (null != e3.quantizationAnnotation && e3.hasOwnProperty("quantizationAnnotation")) {
              if (!Array.isArray(e3.quantizationAnnotation))
                return "quantizationAnnotation: array expected";
              for (t2 = 0; t2 < e3.quantizationAnnotation.length; ++t2) {
                var n2;
                if (n2 = c.onnx.TensorAnnotation.verify(e3.quantizationAnnotation[t2]))
                  return "quantizationAnnotation." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.GraphProto)
              return e3;
            var t2 = new c.onnx.GraphProto();
            if (e3.node) {
              if (!Array.isArray(e3.node))
                throw TypeError(".onnx.GraphProto.node: array expected");
              t2.node = [];
              for (var n2 = 0; n2 < e3.node.length; ++n2) {
                if ("object" != typeof e3.node[n2])
                  throw TypeError(".onnx.GraphProto.node: object expected");
                t2.node[n2] = c.onnx.NodeProto.fromObject(e3.node[n2]);
              }
            }
            if (null != e3.name && (t2.name = String(e3.name)), e3.initializer) {
              if (!Array.isArray(e3.initializer))
                throw TypeError(".onnx.GraphProto.initializer: array expected");
              for (t2.initializer = [], n2 = 0; n2 < e3.initializer.length; ++n2) {
                if ("object" != typeof e3.initializer[n2])
                  throw TypeError(".onnx.GraphProto.initializer: object expected");
                t2.initializer[n2] = c.onnx.TensorProto.fromObject(e3.initializer[n2]);
              }
            }
            if (e3.sparseInitializer) {
              if (!Array.isArray(e3.sparseInitializer))
                throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
              for (t2.sparseInitializer = [], n2 = 0; n2 < e3.sparseInitializer.length; ++n2) {
                if ("object" != typeof e3.sparseInitializer[n2])
                  throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
                t2.sparseInitializer[n2] = c.onnx.SparseTensorProto.fromObject(e3.sparseInitializer[n2]);
              }
            }
            if (null != e3.docString && (t2.docString = String(e3.docString)), e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.GraphProto.input: array expected");
              for (t2.input = [], n2 = 0; n2 < e3.input.length; ++n2) {
                if ("object" != typeof e3.input[n2])
                  throw TypeError(".onnx.GraphProto.input: object expected");
                t2.input[n2] = c.onnx.ValueInfoProto.fromObject(e3.input[n2]);
              }
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.GraphProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2) {
                if ("object" != typeof e3.output[n2])
                  throw TypeError(".onnx.GraphProto.output: object expected");
                t2.output[n2] = c.onnx.ValueInfoProto.fromObject(e3.output[n2]);
              }
            }
            if (e3.valueInfo) {
              if (!Array.isArray(e3.valueInfo))
                throw TypeError(".onnx.GraphProto.valueInfo: array expected");
              for (t2.valueInfo = [], n2 = 0; n2 < e3.valueInfo.length; ++n2) {
                if ("object" != typeof e3.valueInfo[n2])
                  throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                t2.valueInfo[n2] = c.onnx.ValueInfoProto.fromObject(e3.valueInfo[n2]);
              }
            }
            if (e3.quantizationAnnotation) {
              if (!Array.isArray(e3.quantizationAnnotation))
                throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
              for (t2.quantizationAnnotation = [], n2 = 0; n2 < e3.quantizationAnnotation.length; ++n2) {
                if ("object" != typeof e3.quantizationAnnotation[n2])
                  throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                t2.quantizationAnnotation[n2] = c.onnx.TensorAnnotation.fromObject(e3.quantizationAnnotation[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.node = [], n2.initializer = [], n2.input = [], n2.output = [], n2.valueInfo = [], n2.quantizationAnnotation = [], n2.sparseInitializer = []), t2.defaults && (n2.name = "", n2.docString = ""), e3.node && e3.node.length) {
              n2.node = [];
              for (var r2 = 0; r2 < e3.node.length; ++r2)
                n2.node[r2] = c.onnx.NodeProto.toObject(e3.node[r2], t2);
            }
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), e3.initializer && e3.initializer.length)
              for (n2.initializer = [], r2 = 0; r2 < e3.initializer.length; ++r2)
                n2.initializer[r2] = c.onnx.TensorProto.toObject(e3.initializer[r2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.input && e3.input.length)
              for (n2.input = [], r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = c.onnx.ValueInfoProto.toObject(e3.input[r2], t2);
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = c.onnx.ValueInfoProto.toObject(e3.output[r2], t2);
            if (e3.valueInfo && e3.valueInfo.length)
              for (n2.valueInfo = [], r2 = 0; r2 < e3.valueInfo.length; ++r2)
                n2.valueInfo[r2] = c.onnx.ValueInfoProto.toObject(e3.valueInfo[r2], t2);
            if (e3.quantizationAnnotation && e3.quantizationAnnotation.length)
              for (n2.quantizationAnnotation = [], r2 = 0; r2 < e3.quantizationAnnotation.length; ++r2)
                n2.quantizationAnnotation[r2] = c.onnx.TensorAnnotation.toObject(e3.quantizationAnnotation[r2], t2);
            if (e3.sparseInitializer && e3.sparseInitializer.length)
              for (n2.sparseInitializer = [], r2 = 0; r2 < e3.sparseInitializer.length; ++r2)
                n2.sparseInitializer[r2] = c.onnx.SparseTensorProto.toObject(e3.sparseInitializer[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.GraphProto";
          }, e2;
        }(), o.TensorProto = function() {
          function e2(e3) {
            if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.dims = l.emptyArray, e2.prototype.dataType = 0, e2.prototype.segment = null, e2.prototype.floatData = l.emptyArray, e2.prototype.int32Data = l.emptyArray, e2.prototype.stringData = l.emptyArray, e2.prototype.int64Data = l.emptyArray, e2.prototype.name = "", e2.prototype.docString = "", e2.prototype.rawData = l.newBuffer([]), e2.prototype.externalData = l.emptyArray, e2.prototype.dataLocation = 0, e2.prototype.doubleData = l.emptyArray, e2.prototype.uint64Data = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.dims && e3.dims.length) {
              t2.uint32(10).fork();
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                t2.int64(e3.dims[n2]);
              t2.ldelim();
            }
            if (null != e3.dataType && Object.hasOwnProperty.call(e3, "dataType") && t2.uint32(16).int32(e3.dataType), null != e3.segment && Object.hasOwnProperty.call(e3, "segment") && c.onnx.TensorProto.Segment.encode(e3.segment, t2.uint32(26).fork()).ldelim(), null != e3.floatData && e3.floatData.length) {
              for (t2.uint32(34).fork(), n2 = 0; n2 < e3.floatData.length; ++n2)
                t2.float(e3.floatData[n2]);
              t2.ldelim();
            }
            if (null != e3.int32Data && e3.int32Data.length) {
              for (t2.uint32(42).fork(), n2 = 0; n2 < e3.int32Data.length; ++n2)
                t2.int32(e3.int32Data[n2]);
              t2.ldelim();
            }
            if (null != e3.stringData && e3.stringData.length)
              for (n2 = 0; n2 < e3.stringData.length; ++n2)
                t2.uint32(50).bytes(e3.stringData[n2]);
            if (null != e3.int64Data && e3.int64Data.length) {
              for (t2.uint32(58).fork(), n2 = 0; n2 < e3.int64Data.length; ++n2)
                t2.int64(e3.int64Data[n2]);
              t2.ldelim();
            }
            if (null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(66).string(e3.name), null != e3.rawData && Object.hasOwnProperty.call(e3, "rawData") && t2.uint32(74).bytes(e3.rawData), null != e3.doubleData && e3.doubleData.length) {
              for (t2.uint32(82).fork(), n2 = 0; n2 < e3.doubleData.length; ++n2)
                t2.double(e3.doubleData[n2]);
              t2.ldelim();
            }
            if (null != e3.uint64Data && e3.uint64Data.length) {
              for (t2.uint32(90).fork(), n2 = 0; n2 < e3.uint64Data.length; ++n2)
                t2.uint64(e3.uint64Data[n2]);
              t2.ldelim();
            }
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(98).string(e3.docString), null != e3.externalData && e3.externalData.length)
              for (n2 = 0; n2 < e3.externalData.length; ++n2)
                c.onnx.StringStringEntryProto.encode(e3.externalData[n2], t2.uint32(106).fork()).ldelim();
            return null != e3.dataLocation && Object.hasOwnProperty.call(e3, "dataLocation") && t2.uint32(112).int32(e3.dataLocation), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & i2))
                    for (var o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.dims.push(e3.int64());
                  else
                    r2.dims.push(e3.int64());
                  break;
                case 2:
                  r2.dataType = e3.int32();
                  break;
                case 3:
                  r2.segment = c.onnx.TensorProto.Segment.decode(e3, e3.uint32());
                  break;
                case 4:
                  if (r2.floatData && r2.floatData.length || (r2.floatData = []), 2 == (7 & i2))
                    for (o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.floatData.push(e3.float());
                  else
                    r2.floatData.push(e3.float());
                  break;
                case 5:
                  if (r2.int32Data && r2.int32Data.length || (r2.int32Data = []), 2 == (7 & i2))
                    for (o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.int32Data.push(e3.int32());
                  else
                    r2.int32Data.push(e3.int32());
                  break;
                case 6:
                  r2.stringData && r2.stringData.length || (r2.stringData = []), r2.stringData.push(e3.bytes());
                  break;
                case 7:
                  if (r2.int64Data && r2.int64Data.length || (r2.int64Data = []), 2 == (7 & i2))
                    for (o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.int64Data.push(e3.int64());
                  else
                    r2.int64Data.push(e3.int64());
                  break;
                case 8:
                  r2.name = e3.string();
                  break;
                case 12:
                  r2.docString = e3.string();
                  break;
                case 9:
                  r2.rawData = e3.bytes();
                  break;
                case 13:
                  r2.externalData && r2.externalData.length || (r2.externalData = []), r2.externalData.push(c.onnx.StringStringEntryProto.decode(e3, e3.uint32()));
                  break;
                case 14:
                  r2.dataLocation = e3.int32();
                  break;
                case 10:
                  if (r2.doubleData && r2.doubleData.length || (r2.doubleData = []), 2 == (7 & i2))
                    for (o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.doubleData.push(e3.double());
                  else
                    r2.doubleData.push(e3.double());
                  break;
                case 11:
                  if (r2.uint64Data && r2.uint64Data.length || (r2.uint64Data = []), 2 == (7 & i2))
                    for (o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.uint64Data.push(e3.uint64());
                  else
                    r2.uint64Data.push(e3.uint64());
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.dims && e3.hasOwnProperty("dims")) {
              if (!Array.isArray(e3.dims))
                return "dims: array expected";
              for (var t2 = 0; t2 < e3.dims.length; ++t2)
                if (!(l.isInteger(e3.dims[t2]) || e3.dims[t2] && l.isInteger(e3.dims[t2].low) && l.isInteger(e3.dims[t2].high)))
                  return "dims: integer|Long[] expected";
            }
            if (null != e3.dataType && e3.hasOwnProperty("dataType") && !l.isInteger(e3.dataType))
              return "dataType: integer expected";
            if (null != e3.segment && e3.hasOwnProperty("segment") && (n2 = c.onnx.TensorProto.Segment.verify(e3.segment)))
              return "segment." + n2;
            if (null != e3.floatData && e3.hasOwnProperty("floatData")) {
              if (!Array.isArray(e3.floatData))
                return "floatData: array expected";
              for (t2 = 0; t2 < e3.floatData.length; ++t2)
                if ("number" != typeof e3.floatData[t2])
                  return "floatData: number[] expected";
            }
            if (null != e3.int32Data && e3.hasOwnProperty("int32Data")) {
              if (!Array.isArray(e3.int32Data))
                return "int32Data: array expected";
              for (t2 = 0; t2 < e3.int32Data.length; ++t2)
                if (!l.isInteger(e3.int32Data[t2]))
                  return "int32Data: integer[] expected";
            }
            if (null != e3.stringData && e3.hasOwnProperty("stringData")) {
              if (!Array.isArray(e3.stringData))
                return "stringData: array expected";
              for (t2 = 0; t2 < e3.stringData.length; ++t2)
                if (!(e3.stringData[t2] && "number" == typeof e3.stringData[t2].length || l.isString(e3.stringData[t2])))
                  return "stringData: buffer[] expected";
            }
            if (null != e3.int64Data && e3.hasOwnProperty("int64Data")) {
              if (!Array.isArray(e3.int64Data))
                return "int64Data: array expected";
              for (t2 = 0; t2 < e3.int64Data.length; ++t2)
                if (!(l.isInteger(e3.int64Data[t2]) || e3.int64Data[t2] && l.isInteger(e3.int64Data[t2].low) && l.isInteger(e3.int64Data[t2].high)))
                  return "int64Data: integer|Long[] expected";
            }
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.rawData && e3.hasOwnProperty("rawData") && !(e3.rawData && "number" == typeof e3.rawData.length || l.isString(e3.rawData)))
              return "rawData: buffer expected";
            if (null != e3.externalData && e3.hasOwnProperty("externalData")) {
              if (!Array.isArray(e3.externalData))
                return "externalData: array expected";
              for (t2 = 0; t2 < e3.externalData.length; ++t2) {
                var n2;
                if (n2 = c.onnx.StringStringEntryProto.verify(e3.externalData[t2]))
                  return "externalData." + n2;
              }
            }
            if (null != e3.dataLocation && e3.hasOwnProperty("dataLocation"))
              switch (e3.dataLocation) {
                default:
                  return "dataLocation: enum value expected";
                case 0:
                case 1:
              }
            if (null != e3.doubleData && e3.hasOwnProperty("doubleData")) {
              if (!Array.isArray(e3.doubleData))
                return "doubleData: array expected";
              for (t2 = 0; t2 < e3.doubleData.length; ++t2)
                if ("number" != typeof e3.doubleData[t2])
                  return "doubleData: number[] expected";
            }
            if (null != e3.uint64Data && e3.hasOwnProperty("uint64Data")) {
              if (!Array.isArray(e3.uint64Data))
                return "uint64Data: array expected";
              for (t2 = 0; t2 < e3.uint64Data.length; ++t2)
                if (!(l.isInteger(e3.uint64Data[t2]) || e3.uint64Data[t2] && l.isInteger(e3.uint64Data[t2].low) && l.isInteger(e3.uint64Data[t2].high)))
                  return "uint64Data: integer|Long[] expected";
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorProto)
              return e3;
            var t2 = new c.onnx.TensorProto();
            if (e3.dims) {
              if (!Array.isArray(e3.dims))
                throw TypeError(".onnx.TensorProto.dims: array expected");
              t2.dims = [];
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                l.Long ? (t2.dims[n2] = l.Long.fromValue(e3.dims[n2])).unsigned = false : "string" == typeof e3.dims[n2] ? t2.dims[n2] = parseInt(e3.dims[n2], 10) : "number" == typeof e3.dims[n2] ? t2.dims[n2] = e3.dims[n2] : "object" == typeof e3.dims[n2] && (t2.dims[n2] = new l.LongBits(e3.dims[n2].low >>> 0, e3.dims[n2].high >>> 0).toNumber());
            }
            if (null != e3.dataType && (t2.dataType = 0 | e3.dataType), null != e3.segment) {
              if ("object" != typeof e3.segment)
                throw TypeError(".onnx.TensorProto.segment: object expected");
              t2.segment = c.onnx.TensorProto.Segment.fromObject(e3.segment);
            }
            if (e3.floatData) {
              if (!Array.isArray(e3.floatData))
                throw TypeError(".onnx.TensorProto.floatData: array expected");
              for (t2.floatData = [], n2 = 0; n2 < e3.floatData.length; ++n2)
                t2.floatData[n2] = Number(e3.floatData[n2]);
            }
            if (e3.int32Data) {
              if (!Array.isArray(e3.int32Data))
                throw TypeError(".onnx.TensorProto.int32Data: array expected");
              for (t2.int32Data = [], n2 = 0; n2 < e3.int32Data.length; ++n2)
                t2.int32Data[n2] = 0 | e3.int32Data[n2];
            }
            if (e3.stringData) {
              if (!Array.isArray(e3.stringData))
                throw TypeError(".onnx.TensorProto.stringData: array expected");
              for (t2.stringData = [], n2 = 0; n2 < e3.stringData.length; ++n2)
                "string" == typeof e3.stringData[n2] ? l.base64.decode(e3.stringData[n2], t2.stringData[n2] = l.newBuffer(l.base64.length(e3.stringData[n2])), 0) : e3.stringData[n2].length >= 0 && (t2.stringData[n2] = e3.stringData[n2]);
            }
            if (e3.int64Data) {
              if (!Array.isArray(e3.int64Data))
                throw TypeError(".onnx.TensorProto.int64Data: array expected");
              for (t2.int64Data = [], n2 = 0; n2 < e3.int64Data.length; ++n2)
                l.Long ? (t2.int64Data[n2] = l.Long.fromValue(e3.int64Data[n2])).unsigned = false : "string" == typeof e3.int64Data[n2] ? t2.int64Data[n2] = parseInt(e3.int64Data[n2], 10) : "number" == typeof e3.int64Data[n2] ? t2.int64Data[n2] = e3.int64Data[n2] : "object" == typeof e3.int64Data[n2] && (t2.int64Data[n2] = new l.LongBits(e3.int64Data[n2].low >>> 0, e3.int64Data[n2].high >>> 0).toNumber());
            }
            if (null != e3.name && (t2.name = String(e3.name)), null != e3.docString && (t2.docString = String(e3.docString)), null != e3.rawData && ("string" == typeof e3.rawData ? l.base64.decode(e3.rawData, t2.rawData = l.newBuffer(l.base64.length(e3.rawData)), 0) : e3.rawData.length >= 0 && (t2.rawData = e3.rawData)), e3.externalData) {
              if (!Array.isArray(e3.externalData))
                throw TypeError(".onnx.TensorProto.externalData: array expected");
              for (t2.externalData = [], n2 = 0; n2 < e3.externalData.length; ++n2) {
                if ("object" != typeof e3.externalData[n2])
                  throw TypeError(".onnx.TensorProto.externalData: object expected");
                t2.externalData[n2] = c.onnx.StringStringEntryProto.fromObject(e3.externalData[n2]);
              }
            }
            switch (e3.dataLocation) {
              default:
                if ("number" == typeof e3.dataLocation) {
                  t2.dataLocation = e3.dataLocation;
                  break;
                }
                break;
              case "DEFAULT":
              case 0:
                t2.dataLocation = 0;
                break;
              case "EXTERNAL":
              case 1:
                t2.dataLocation = 1;
            }
            if (e3.doubleData) {
              if (!Array.isArray(e3.doubleData))
                throw TypeError(".onnx.TensorProto.doubleData: array expected");
              for (t2.doubleData = [], n2 = 0; n2 < e3.doubleData.length; ++n2)
                t2.doubleData[n2] = Number(e3.doubleData[n2]);
            }
            if (e3.uint64Data) {
              if (!Array.isArray(e3.uint64Data))
                throw TypeError(".onnx.TensorProto.uint64Data: array expected");
              for (t2.uint64Data = [], n2 = 0; n2 < e3.uint64Data.length; ++n2)
                l.Long ? (t2.uint64Data[n2] = l.Long.fromValue(e3.uint64Data[n2])).unsigned = true : "string" == typeof e3.uint64Data[n2] ? t2.uint64Data[n2] = parseInt(e3.uint64Data[n2], 10) : "number" == typeof e3.uint64Data[n2] ? t2.uint64Data[n2] = e3.uint64Data[n2] : "object" == typeof e3.uint64Data[n2] && (t2.uint64Data[n2] = new l.LongBits(e3.uint64Data[n2].low >>> 0, e3.uint64Data[n2].high >>> 0).toNumber(true));
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dims = [], n2.floatData = [], n2.int32Data = [], n2.stringData = [], n2.int64Data = [], n2.doubleData = [], n2.uint64Data = [], n2.externalData = []), t2.defaults && (n2.dataType = 0, n2.segment = null, n2.name = "", t2.bytes === String ? n2.rawData = "" : (n2.rawData = [], t2.bytes !== Array && (n2.rawData = l.newBuffer(n2.rawData))), n2.docString = "", n2.dataLocation = t2.enums === String ? "DEFAULT" : 0), e3.dims && e3.dims.length) {
              n2.dims = [];
              for (var r2 = 0; r2 < e3.dims.length; ++r2)
                "number" == typeof e3.dims[r2] ? n2.dims[r2] = t2.longs === String ? String(e3.dims[r2]) : e3.dims[r2] : n2.dims[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.dims[r2]) : t2.longs === Number ? new l.LongBits(e3.dims[r2].low >>> 0, e3.dims[r2].high >>> 0).toNumber() : e3.dims[r2];
            }
            if (null != e3.dataType && e3.hasOwnProperty("dataType") && (n2.dataType = e3.dataType), null != e3.segment && e3.hasOwnProperty("segment") && (n2.segment = c.onnx.TensorProto.Segment.toObject(e3.segment, t2)), e3.floatData && e3.floatData.length)
              for (n2.floatData = [], r2 = 0; r2 < e3.floatData.length; ++r2)
                n2.floatData[r2] = t2.json && !isFinite(e3.floatData[r2]) ? String(e3.floatData[r2]) : e3.floatData[r2];
            if (e3.int32Data && e3.int32Data.length)
              for (n2.int32Data = [], r2 = 0; r2 < e3.int32Data.length; ++r2)
                n2.int32Data[r2] = e3.int32Data[r2];
            if (e3.stringData && e3.stringData.length)
              for (n2.stringData = [], r2 = 0; r2 < e3.stringData.length; ++r2)
                n2.stringData[r2] = t2.bytes === String ? l.base64.encode(e3.stringData[r2], 0, e3.stringData[r2].length) : t2.bytes === Array ? Array.prototype.slice.call(e3.stringData[r2]) : e3.stringData[r2];
            if (e3.int64Data && e3.int64Data.length)
              for (n2.int64Data = [], r2 = 0; r2 < e3.int64Data.length; ++r2)
                "number" == typeof e3.int64Data[r2] ? n2.int64Data[r2] = t2.longs === String ? String(e3.int64Data[r2]) : e3.int64Data[r2] : n2.int64Data[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.int64Data[r2]) : t2.longs === Number ? new l.LongBits(e3.int64Data[r2].low >>> 0, e3.int64Data[r2].high >>> 0).toNumber() : e3.int64Data[r2];
            if (null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), null != e3.rawData && e3.hasOwnProperty("rawData") && (n2.rawData = t2.bytes === String ? l.base64.encode(e3.rawData, 0, e3.rawData.length) : t2.bytes === Array ? Array.prototype.slice.call(e3.rawData) : e3.rawData), e3.doubleData && e3.doubleData.length)
              for (n2.doubleData = [], r2 = 0; r2 < e3.doubleData.length; ++r2)
                n2.doubleData[r2] = t2.json && !isFinite(e3.doubleData[r2]) ? String(e3.doubleData[r2]) : e3.doubleData[r2];
            if (e3.uint64Data && e3.uint64Data.length)
              for (n2.uint64Data = [], r2 = 0; r2 < e3.uint64Data.length; ++r2)
                "number" == typeof e3.uint64Data[r2] ? n2.uint64Data[r2] = t2.longs === String ? String(e3.uint64Data[r2]) : e3.uint64Data[r2] : n2.uint64Data[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.uint64Data[r2]) : t2.longs === Number ? new l.LongBits(e3.uint64Data[r2].low >>> 0, e3.uint64Data[r2].high >>> 0).toNumber(true) : e3.uint64Data[r2];
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.externalData && e3.externalData.length)
              for (n2.externalData = [], r2 = 0; r2 < e3.externalData.length; ++r2)
                n2.externalData[r2] = c.onnx.StringStringEntryProto.toObject(e3.externalData[r2], t2);
            return null != e3.dataLocation && e3.hasOwnProperty("dataLocation") && (n2.dataLocation = t2.enums === String ? void 0 === c.onnx.TensorProto.DataLocation[e3.dataLocation] ? e3.dataLocation : c.onnx.TensorProto.DataLocation[e3.dataLocation] : e3.dataLocation), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorProto";
          }, e2.DataType = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "UNDEFINED"] = 0, t2[e3[1] = "FLOAT"] = 1, t2[e3[2] = "UINT8"] = 2, t2[e3[3] = "INT8"] = 3, t2[e3[4] = "UINT16"] = 4, t2[e3[5] = "INT16"] = 5, t2[e3[6] = "INT32"] = 6, t2[e3[7] = "INT64"] = 7, t2[e3[8] = "STRING"] = 8, t2[e3[9] = "BOOL"] = 9, t2[e3[10] = "FLOAT16"] = 10, t2[e3[11] = "DOUBLE"] = 11, t2[e3[12] = "UINT32"] = 12, t2[e3[13] = "UINT64"] = 13, t2[e3[14] = "COMPLEX64"] = 14, t2[e3[15] = "COMPLEX128"] = 15, t2[e3[16] = "BFLOAT16"] = 16, t2[e3[17] = "FLOAT8E4M3FN"] = 17, t2[e3[18] = "FLOAT8E4M3FNUZ"] = 18, t2[e3[19] = "FLOAT8E5M2"] = 19, t2[e3[20] = "FLOAT8E5M2FNUZ"] = 20, t2;
          }(), e2.Segment = function() {
            function e3(e4) {
              if (e4)
                for (var t2 = Object.keys(e4), n2 = 0; n2 < t2.length; ++n2)
                  null != e4[t2[n2]] && (this[t2[n2]] = e4[t2[n2]]);
            }
            return e3.prototype.begin = l.Long ? l.Long.fromBits(0, 0, false) : 0, e3.prototype.end = l.Long ? l.Long.fromBits(0, 0, false) : 0, e3.create = function(t2) {
              return new e3(t2);
            }, e3.encode = function(e4, t2) {
              return t2 || (t2 = u.create()), null != e4.begin && Object.hasOwnProperty.call(e4, "begin") && t2.uint32(8).int64(e4.begin), null != e4.end && Object.hasOwnProperty.call(e4, "end") && t2.uint32(16).int64(e4.end), t2;
            }, e3.encodeDelimited = function(e4, t2) {
              return this.encode(e4, t2).ldelim();
            }, e3.decode = function(e4, t2) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t2 ? e4.len : e4.pos + t2, r2 = new c.onnx.TensorProto.Segment(); e4.pos < n2; ) {
                var i2 = e4.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.begin = e4.int64();
                    break;
                  case 2:
                    r2.end = e4.int64();
                    break;
                  default:
                    e4.skipType(7 & i2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              return "object" != typeof e4 || null === e4 ? "object expected" : null != e4.begin && e4.hasOwnProperty("begin") && !(l.isInteger(e4.begin) || e4.begin && l.isInteger(e4.begin.low) && l.isInteger(e4.begin.high)) ? "begin: integer|Long expected" : null != e4.end && e4.hasOwnProperty("end") && !(l.isInteger(e4.end) || e4.end && l.isInteger(e4.end.low) && l.isInteger(e4.end.high)) ? "end: integer|Long expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TensorProto.Segment)
                return e4;
              var t2 = new c.onnx.TensorProto.Segment();
              return null != e4.begin && (l.Long ? (t2.begin = l.Long.fromValue(e4.begin)).unsigned = false : "string" == typeof e4.begin ? t2.begin = parseInt(e4.begin, 10) : "number" == typeof e4.begin ? t2.begin = e4.begin : "object" == typeof e4.begin && (t2.begin = new l.LongBits(e4.begin.low >>> 0, e4.begin.high >>> 0).toNumber())), null != e4.end && (l.Long ? (t2.end = l.Long.fromValue(e4.end)).unsigned = false : "string" == typeof e4.end ? t2.end = parseInt(e4.end, 10) : "number" == typeof e4.end ? t2.end = e4.end : "object" == typeof e4.end && (t2.end = new l.LongBits(e4.end.low >>> 0, e4.end.high >>> 0).toNumber())), t2;
            }, e3.toObject = function(e4, t2) {
              t2 || (t2 = {});
              var n2 = {};
              if (t2.defaults) {
                if (l.Long) {
                  var r2 = new l.Long(0, 0, false);
                  n2.begin = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
                } else
                  n2.begin = t2.longs === String ? "0" : 0;
                l.Long ? (r2 = new l.Long(0, 0, false), n2.end = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2) : n2.end = t2.longs === String ? "0" : 0;
              }
              return null != e4.begin && e4.hasOwnProperty("begin") && ("number" == typeof e4.begin ? n2.begin = t2.longs === String ? String(e4.begin) : e4.begin : n2.begin = t2.longs === String ? l.Long.prototype.toString.call(e4.begin) : t2.longs === Number ? new l.LongBits(e4.begin.low >>> 0, e4.begin.high >>> 0).toNumber() : e4.begin), null != e4.end && e4.hasOwnProperty("end") && ("number" == typeof e4.end ? n2.end = t2.longs === String ? String(e4.end) : e4.end : n2.end = t2.longs === String ? l.Long.prototype.toString.call(e4.end) : t2.longs === Number ? new l.LongBits(e4.end.low >>> 0, e4.end.high >>> 0).toNumber() : e4.end), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorProto.Segment";
            }, e3;
          }(), e2.DataLocation = function() {
            var e3 = {}, t2 = Object.create(e3);
            return t2[e3[0] = "DEFAULT"] = 0, t2[e3[1] = "EXTERNAL"] = 1, t2;
          }(), e2;
        }(), o.SparseTensorProto = function() {
          function e2(e3) {
            if (this.dims = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.values = null, e2.prototype.indices = null, e2.prototype.dims = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.values && Object.hasOwnProperty.call(e3, "values") && c.onnx.TensorProto.encode(e3.values, t2.uint32(10).fork()).ldelim(), null != e3.indices && Object.hasOwnProperty.call(e3, "indices") && c.onnx.TensorProto.encode(e3.indices, t2.uint32(18).fork()).ldelim(), null != e3.dims && e3.dims.length) {
              t2.uint32(26).fork();
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                t2.int64(e3.dims[n2]);
              t2.ldelim();
            }
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.SparseTensorProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.values = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 2:
                  r2.indices = c.onnx.TensorProto.decode(e3, e3.uint32());
                  break;
                case 3:
                  if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & i2))
                    for (var o2 = e3.uint32() + e3.pos; e3.pos < o2; )
                      r2.dims.push(e3.int64());
                  else
                    r2.dims.push(e3.int64());
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            var t2;
            if (null != e3.values && e3.hasOwnProperty("values") && (t2 = c.onnx.TensorProto.verify(e3.values)))
              return "values." + t2;
            if (null != e3.indices && e3.hasOwnProperty("indices") && (t2 = c.onnx.TensorProto.verify(e3.indices)))
              return "indices." + t2;
            if (null != e3.dims && e3.hasOwnProperty("dims")) {
              if (!Array.isArray(e3.dims))
                return "dims: array expected";
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                if (!(l.isInteger(e3.dims[n2]) || e3.dims[n2] && l.isInteger(e3.dims[n2].low) && l.isInteger(e3.dims[n2].high)))
                  return "dims: integer|Long[] expected";
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.SparseTensorProto)
              return e3;
            var t2 = new c.onnx.SparseTensorProto();
            if (null != e3.values) {
              if ("object" != typeof e3.values)
                throw TypeError(".onnx.SparseTensorProto.values: object expected");
              t2.values = c.onnx.TensorProto.fromObject(e3.values);
            }
            if (null != e3.indices) {
              if ("object" != typeof e3.indices)
                throw TypeError(".onnx.SparseTensorProto.indices: object expected");
              t2.indices = c.onnx.TensorProto.fromObject(e3.indices);
            }
            if (e3.dims) {
              if (!Array.isArray(e3.dims))
                throw TypeError(".onnx.SparseTensorProto.dims: array expected");
              t2.dims = [];
              for (var n2 = 0; n2 < e3.dims.length; ++n2)
                l.Long ? (t2.dims[n2] = l.Long.fromValue(e3.dims[n2])).unsigned = false : "string" == typeof e3.dims[n2] ? t2.dims[n2] = parseInt(e3.dims[n2], 10) : "number" == typeof e3.dims[n2] ? t2.dims[n2] = e3.dims[n2] : "object" == typeof e3.dims[n2] && (t2.dims[n2] = new l.LongBits(e3.dims[n2].low >>> 0, e3.dims[n2].high >>> 0).toNumber());
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dims = []), t2.defaults && (n2.values = null, n2.indices = null), null != e3.values && e3.hasOwnProperty("values") && (n2.values = c.onnx.TensorProto.toObject(e3.values, t2)), null != e3.indices && e3.hasOwnProperty("indices") && (n2.indices = c.onnx.TensorProto.toObject(e3.indices, t2)), e3.dims && e3.dims.length) {
              n2.dims = [];
              for (var r2 = 0; r2 < e3.dims.length; ++r2)
                "number" == typeof e3.dims[r2] ? n2.dims[r2] = t2.longs === String ? String(e3.dims[r2]) : e3.dims[r2] : n2.dims[r2] = t2.longs === String ? l.Long.prototype.toString.call(e3.dims[r2]) : t2.longs === Number ? new l.LongBits(e3.dims[r2].low >>> 0, e3.dims[r2].high >>> 0).toNumber() : e3.dims[r2];
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.SparseTensorProto";
          }, e2;
        }(), o.TensorShapeProto = function() {
          function e2(e3) {
            if (this.dim = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.dim = l.emptyArray, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.dim && e3.dim.length)
              for (var n2 = 0; n2 < e3.dim.length; ++n2)
                c.onnx.TensorShapeProto.Dimension.encode(e3.dim[n2], t2.uint32(10).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.TensorShapeProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              i2 >>> 3 == 1 ? (r2.dim && r2.dim.length || (r2.dim = []), r2.dim.push(c.onnx.TensorShapeProto.Dimension.decode(e3, e3.uint32()))) : e3.skipType(7 & i2);
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.dim && e3.hasOwnProperty("dim")) {
              if (!Array.isArray(e3.dim))
                return "dim: array expected";
              for (var t2 = 0; t2 < e3.dim.length; ++t2) {
                var n2 = c.onnx.TensorShapeProto.Dimension.verify(e3.dim[t2]);
                if (n2)
                  return "dim." + n2;
              }
            }
            return null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TensorShapeProto)
              return e3;
            var t2 = new c.onnx.TensorShapeProto();
            if (e3.dim) {
              if (!Array.isArray(e3.dim))
                throw TypeError(".onnx.TensorShapeProto.dim: array expected");
              t2.dim = [];
              for (var n2 = 0; n2 < e3.dim.length; ++n2) {
                if ("object" != typeof e3.dim[n2])
                  throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                t2.dim[n2] = c.onnx.TensorShapeProto.Dimension.fromObject(e3.dim[n2]);
              }
            }
            return t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.dim = []), e3.dim && e3.dim.length) {
              n2.dim = [];
              for (var r2 = 0; r2 < e3.dim.length; ++r2)
                n2.dim[r2] = c.onnx.TensorShapeProto.Dimension.toObject(e3.dim[r2], t2);
            }
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TensorShapeProto";
          }, e2.Dimension = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            var t2;
            return e3.prototype.dimValue = null, e3.prototype.dimParam = null, e3.prototype.denotation = "", Object.defineProperty(e3.prototype, "value", { get: l.oneOfGetter(t2 = ["dimValue", "dimParam"]), set: l.oneOfSetter(t2) }), e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.dimValue && Object.hasOwnProperty.call(e4, "dimValue") && t3.uint32(8).int64(e4.dimValue), null != e4.dimParam && Object.hasOwnProperty.call(e4, "dimParam") && t3.uint32(18).string(e4.dimParam), null != e4.denotation && Object.hasOwnProperty.call(e4, "denotation") && t3.uint32(26).string(e4.denotation), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TensorShapeProto.Dimension(); e4.pos < n2; ) {
                var i2 = e4.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.dimValue = e4.int64();
                    break;
                  case 2:
                    r2.dimParam = e4.string();
                    break;
                  case 3:
                    r2.denotation = e4.string();
                    break;
                  default:
                    e4.skipType(7 & i2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              var t3 = {};
              if (null != e4.dimValue && e4.hasOwnProperty("dimValue") && (t3.value = 1, !(l.isInteger(e4.dimValue) || e4.dimValue && l.isInteger(e4.dimValue.low) && l.isInteger(e4.dimValue.high))))
                return "dimValue: integer|Long expected";
              if (null != e4.dimParam && e4.hasOwnProperty("dimParam")) {
                if (1 === t3.value)
                  return "value: multiple values";
                if (t3.value = 1, !l.isString(e4.dimParam))
                  return "dimParam: string expected";
              }
              return null != e4.denotation && e4.hasOwnProperty("denotation") && !l.isString(e4.denotation) ? "denotation: string expected" : null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TensorShapeProto.Dimension)
                return e4;
              var t3 = new c.onnx.TensorShapeProto.Dimension();
              return null != e4.dimValue && (l.Long ? (t3.dimValue = l.Long.fromValue(e4.dimValue)).unsigned = false : "string" == typeof e4.dimValue ? t3.dimValue = parseInt(e4.dimValue, 10) : "number" == typeof e4.dimValue ? t3.dimValue = e4.dimValue : "object" == typeof e4.dimValue && (t3.dimValue = new l.LongBits(e4.dimValue.low >>> 0, e4.dimValue.high >>> 0).toNumber())), null != e4.dimParam && (t3.dimParam = String(e4.dimParam)), null != e4.denotation && (t3.denotation = String(e4.denotation)), t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.denotation = ""), null != e4.dimValue && e4.hasOwnProperty("dimValue") && ("number" == typeof e4.dimValue ? n2.dimValue = t3.longs === String ? String(e4.dimValue) : e4.dimValue : n2.dimValue = t3.longs === String ? l.Long.prototype.toString.call(e4.dimValue) : t3.longs === Number ? new l.LongBits(e4.dimValue.low >>> 0, e4.dimValue.high >>> 0).toNumber() : e4.dimValue, t3.oneofs && (n2.value = "dimValue")), null != e4.dimParam && e4.hasOwnProperty("dimParam") && (n2.dimParam = e4.dimParam, t3.oneofs && (n2.value = "dimParam")), null != e4.denotation && e4.hasOwnProperty("denotation") && (n2.denotation = e4.denotation), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TensorShapeProto.Dimension";
            }, e3;
          }(), e2;
        }(), o.TypeProto = function() {
          function e2(e3) {
            if (e3)
              for (var t3 = Object.keys(e3), n2 = 0; n2 < t3.length; ++n2)
                null != e3[t3[n2]] && (this[t3[n2]] = e3[t3[n2]]);
          }
          var t2;
          return e2.prototype.tensorType = null, e2.prototype.sequenceType = null, e2.prototype.mapType = null, e2.prototype.optionalType = null, e2.prototype.sparseTensorType = null, e2.prototype.denotation = "", Object.defineProperty(e2.prototype, "value", { get: l.oneOfGetter(t2 = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]), set: l.oneOfSetter(t2) }), e2.create = function(t3) {
            return new e2(t3);
          }, e2.encode = function(e3, t3) {
            return t3 || (t3 = u.create()), null != e3.tensorType && Object.hasOwnProperty.call(e3, "tensorType") && c.onnx.TypeProto.Tensor.encode(e3.tensorType, t3.uint32(10).fork()).ldelim(), null != e3.sequenceType && Object.hasOwnProperty.call(e3, "sequenceType") && c.onnx.TypeProto.Sequence.encode(e3.sequenceType, t3.uint32(34).fork()).ldelim(), null != e3.mapType && Object.hasOwnProperty.call(e3, "mapType") && c.onnx.TypeProto.Map.encode(e3.mapType, t3.uint32(42).fork()).ldelim(), null != e3.denotation && Object.hasOwnProperty.call(e3, "denotation") && t3.uint32(50).string(e3.denotation), null != e3.sparseTensorType && Object.hasOwnProperty.call(e3, "sparseTensorType") && c.onnx.TypeProto.SparseTensor.encode(e3.sparseTensorType, t3.uint32(66).fork()).ldelim(), null != e3.optionalType && Object.hasOwnProperty.call(e3, "optionalType") && c.onnx.TypeProto.Optional.encode(e3.optionalType, t3.uint32(74).fork()).ldelim(), t3;
          }, e2.encodeDelimited = function(e3, t3) {
            return this.encode(e3, t3).ldelim();
          }, e2.decode = function(e3, t3) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t3 ? e3.len : e3.pos + t3, r2 = new c.onnx.TypeProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.tensorType = c.onnx.TypeProto.Tensor.decode(e3, e3.uint32());
                  break;
                case 4:
                  r2.sequenceType = c.onnx.TypeProto.Sequence.decode(e3, e3.uint32());
                  break;
                case 5:
                  r2.mapType = c.onnx.TypeProto.Map.decode(e3, e3.uint32());
                  break;
                case 9:
                  r2.optionalType = c.onnx.TypeProto.Optional.decode(e3, e3.uint32());
                  break;
                case 8:
                  r2.sparseTensorType = c.onnx.TypeProto.SparseTensor.decode(e3, e3.uint32());
                  break;
                case 6:
                  r2.denotation = e3.string();
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            var t3 = {};
            if (null != e3.tensorType && e3.hasOwnProperty("tensorType") && (t3.value = 1, n2 = c.onnx.TypeProto.Tensor.verify(e3.tensorType)))
              return "tensorType." + n2;
            if (null != e3.sequenceType && e3.hasOwnProperty("sequenceType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Sequence.verify(e3.sequenceType))
                return "sequenceType." + n2;
            }
            if (null != e3.mapType && e3.hasOwnProperty("mapType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Map.verify(e3.mapType))
                return "mapType." + n2;
            }
            if (null != e3.optionalType && e3.hasOwnProperty("optionalType")) {
              if (1 === t3.value)
                return "value: multiple values";
              if (t3.value = 1, n2 = c.onnx.TypeProto.Optional.verify(e3.optionalType))
                return "optionalType." + n2;
            }
            if (null != e3.sparseTensorType && e3.hasOwnProperty("sparseTensorType")) {
              if (1 === t3.value)
                return "value: multiple values";
              var n2;
              if (t3.value = 1, n2 = c.onnx.TypeProto.SparseTensor.verify(e3.sparseTensorType))
                return "sparseTensorType." + n2;
            }
            return null != e3.denotation && e3.hasOwnProperty("denotation") && !l.isString(e3.denotation) ? "denotation: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.TypeProto)
              return e3;
            var t3 = new c.onnx.TypeProto();
            if (null != e3.tensorType) {
              if ("object" != typeof e3.tensorType)
                throw TypeError(".onnx.TypeProto.tensorType: object expected");
              t3.tensorType = c.onnx.TypeProto.Tensor.fromObject(e3.tensorType);
            }
            if (null != e3.sequenceType) {
              if ("object" != typeof e3.sequenceType)
                throw TypeError(".onnx.TypeProto.sequenceType: object expected");
              t3.sequenceType = c.onnx.TypeProto.Sequence.fromObject(e3.sequenceType);
            }
            if (null != e3.mapType) {
              if ("object" != typeof e3.mapType)
                throw TypeError(".onnx.TypeProto.mapType: object expected");
              t3.mapType = c.onnx.TypeProto.Map.fromObject(e3.mapType);
            }
            if (null != e3.optionalType) {
              if ("object" != typeof e3.optionalType)
                throw TypeError(".onnx.TypeProto.optionalType: object expected");
              t3.optionalType = c.onnx.TypeProto.Optional.fromObject(e3.optionalType);
            }
            if (null != e3.sparseTensorType) {
              if ("object" != typeof e3.sparseTensorType)
                throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
              t3.sparseTensorType = c.onnx.TypeProto.SparseTensor.fromObject(e3.sparseTensorType);
            }
            return null != e3.denotation && (t3.denotation = String(e3.denotation)), t3;
          }, e2.toObject = function(e3, t3) {
            t3 || (t3 = {});
            var n2 = {};
            return t3.defaults && (n2.denotation = ""), null != e3.tensorType && e3.hasOwnProperty("tensorType") && (n2.tensorType = c.onnx.TypeProto.Tensor.toObject(e3.tensorType, t3), t3.oneofs && (n2.value = "tensorType")), null != e3.sequenceType && e3.hasOwnProperty("sequenceType") && (n2.sequenceType = c.onnx.TypeProto.Sequence.toObject(e3.sequenceType, t3), t3.oneofs && (n2.value = "sequenceType")), null != e3.mapType && e3.hasOwnProperty("mapType") && (n2.mapType = c.onnx.TypeProto.Map.toObject(e3.mapType, t3), t3.oneofs && (n2.value = "mapType")), null != e3.denotation && e3.hasOwnProperty("denotation") && (n2.denotation = e3.denotation), null != e3.sparseTensorType && e3.hasOwnProperty("sparseTensorType") && (n2.sparseTensorType = c.onnx.TypeProto.SparseTensor.toObject(e3.sparseTensorType, t3), t3.oneofs && (n2.value = "sparseTensorType")), null != e3.optionalType && e3.hasOwnProperty("optionalType") && (n2.optionalType = c.onnx.TypeProto.Optional.toObject(e3.optionalType, t3), t3.oneofs && (n2.value = "optionalType")), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.TypeProto";
          }, e2.Tensor = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = 0, e3.prototype.shape = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && t3.uint32(8).int32(e4.elemType), null != e4.shape && Object.hasOwnProperty.call(e4, "shape") && c.onnx.TensorShapeProto.encode(e4.shape, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Tensor(); e4.pos < n2; ) {
                var i2 = e4.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.elemType = e4.int32();
                    break;
                  case 2:
                    r2.shape = c.onnx.TensorShapeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & i2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType") && !l.isInteger(e4.elemType))
                return "elemType: integer expected";
              if (null != e4.shape && e4.hasOwnProperty("shape")) {
                var t3 = c.onnx.TensorShapeProto.verify(e4.shape);
                if (t3)
                  return "shape." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Tensor)
                return e4;
              var t3 = new c.onnx.TypeProto.Tensor();
              if (null != e4.elemType && (t3.elemType = 0 | e4.elemType), null != e4.shape) {
                if ("object" != typeof e4.shape)
                  throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                t3.shape = c.onnx.TensorShapeProto.fromObject(e4.shape);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = 0, n2.shape = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = e4.elemType), null != e4.shape && e4.hasOwnProperty("shape") && (n2.shape = c.onnx.TensorShapeProto.toObject(e4.shape, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Tensor";
            }, e3;
          }(), e2.Sequence = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && c.onnx.TypeProto.encode(e4.elemType, t3.uint32(10).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Sequence(); e4.pos < n2; ) {
                var i2 = e4.uint32();
                i2 >>> 3 == 1 ? r2.elemType = c.onnx.TypeProto.decode(e4, e4.uint32()) : e4.skipType(7 & i2);
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType")) {
                var t3 = c.onnx.TypeProto.verify(e4.elemType);
                if (t3)
                  return "elemType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Sequence)
                return e4;
              var t3 = new c.onnx.TypeProto.Sequence();
              if (null != e4.elemType) {
                if ("object" != typeof e4.elemType)
                  throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
                t3.elemType = c.onnx.TypeProto.fromObject(e4.elemType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = c.onnx.TypeProto.toObject(e4.elemType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Sequence";
            }, e3;
          }(), e2.Map = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.keyType = 0, e3.prototype.valueType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.keyType && Object.hasOwnProperty.call(e4, "keyType") && t3.uint32(8).int32(e4.keyType), null != e4.valueType && Object.hasOwnProperty.call(e4, "valueType") && c.onnx.TypeProto.encode(e4.valueType, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Map(); e4.pos < n2; ) {
                var i2 = e4.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.keyType = e4.int32();
                    break;
                  case 2:
                    r2.valueType = c.onnx.TypeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & i2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.keyType && e4.hasOwnProperty("keyType") && !l.isInteger(e4.keyType))
                return "keyType: integer expected";
              if (null != e4.valueType && e4.hasOwnProperty("valueType")) {
                var t3 = c.onnx.TypeProto.verify(e4.valueType);
                if (t3)
                  return "valueType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Map)
                return e4;
              var t3 = new c.onnx.TypeProto.Map();
              if (null != e4.keyType && (t3.keyType = 0 | e4.keyType), null != e4.valueType) {
                if ("object" != typeof e4.valueType)
                  throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
                t3.valueType = c.onnx.TypeProto.fromObject(e4.valueType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.keyType = 0, n2.valueType = null), null != e4.keyType && e4.hasOwnProperty("keyType") && (n2.keyType = e4.keyType), null != e4.valueType && e4.hasOwnProperty("valueType") && (n2.valueType = c.onnx.TypeProto.toObject(e4.valueType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Map";
            }, e3;
          }(), e2.Optional = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && c.onnx.TypeProto.encode(e4.elemType, t3.uint32(10).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.Optional(); e4.pos < n2; ) {
                var i2 = e4.uint32();
                i2 >>> 3 == 1 ? r2.elemType = c.onnx.TypeProto.decode(e4, e4.uint32()) : e4.skipType(7 & i2);
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType")) {
                var t3 = c.onnx.TypeProto.verify(e4.elemType);
                if (t3)
                  return "elemType." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.Optional)
                return e4;
              var t3 = new c.onnx.TypeProto.Optional();
              if (null != e4.elemType) {
                if ("object" != typeof e4.elemType)
                  throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
                t3.elemType = c.onnx.TypeProto.fromObject(e4.elemType);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = c.onnx.TypeProto.toObject(e4.elemType, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.Optional";
            }, e3;
          }(), e2.SparseTensor = function() {
            function e3(e4) {
              if (e4)
                for (var t3 = Object.keys(e4), n2 = 0; n2 < t3.length; ++n2)
                  null != e4[t3[n2]] && (this[t3[n2]] = e4[t3[n2]]);
            }
            return e3.prototype.elemType = 0, e3.prototype.shape = null, e3.create = function(t3) {
              return new e3(t3);
            }, e3.encode = function(e4, t3) {
              return t3 || (t3 = u.create()), null != e4.elemType && Object.hasOwnProperty.call(e4, "elemType") && t3.uint32(8).int32(e4.elemType), null != e4.shape && Object.hasOwnProperty.call(e4, "shape") && c.onnx.TensorShapeProto.encode(e4.shape, t3.uint32(18).fork()).ldelim(), t3;
            }, e3.encodeDelimited = function(e4, t3) {
              return this.encode(e4, t3).ldelim();
            }, e3.decode = function(e4, t3) {
              e4 instanceof s || (e4 = s.create(e4));
              for (var n2 = void 0 === t3 ? e4.len : e4.pos + t3, r2 = new c.onnx.TypeProto.SparseTensor(); e4.pos < n2; ) {
                var i2 = e4.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.elemType = e4.int32();
                    break;
                  case 2:
                    r2.shape = c.onnx.TensorShapeProto.decode(e4, e4.uint32());
                    break;
                  default:
                    e4.skipType(7 & i2);
                }
              }
              return r2;
            }, e3.decodeDelimited = function(e4) {
              return e4 instanceof s || (e4 = new s(e4)), this.decode(e4, e4.uint32());
            }, e3.verify = function(e4) {
              if ("object" != typeof e4 || null === e4)
                return "object expected";
              if (null != e4.elemType && e4.hasOwnProperty("elemType") && !l.isInteger(e4.elemType))
                return "elemType: integer expected";
              if (null != e4.shape && e4.hasOwnProperty("shape")) {
                var t3 = c.onnx.TensorShapeProto.verify(e4.shape);
                if (t3)
                  return "shape." + t3;
              }
              return null;
            }, e3.fromObject = function(e4) {
              if (e4 instanceof c.onnx.TypeProto.SparseTensor)
                return e4;
              var t3 = new c.onnx.TypeProto.SparseTensor();
              if (null != e4.elemType && (t3.elemType = 0 | e4.elemType), null != e4.shape) {
                if ("object" != typeof e4.shape)
                  throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
                t3.shape = c.onnx.TensorShapeProto.fromObject(e4.shape);
              }
              return t3;
            }, e3.toObject = function(e4, t3) {
              t3 || (t3 = {});
              var n2 = {};
              return t3.defaults && (n2.elemType = 0, n2.shape = null), null != e4.elemType && e4.hasOwnProperty("elemType") && (n2.elemType = e4.elemType), null != e4.shape && e4.hasOwnProperty("shape") && (n2.shape = c.onnx.TensorShapeProto.toObject(e4.shape, t3)), n2;
            }, e3.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, e3.getTypeUrl = function(e4) {
              return void 0 === e4 && (e4 = "type.googleapis.com"), e4 + "/onnx.TypeProto.SparseTensor";
            }, e3;
          }(), e2;
        }(), o.OperatorSetIdProto = function() {
          function e2(e3) {
            if (e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.domain = "", e2.prototype.version = l.Long ? l.Long.fromBits(0, 0, false) : 0, e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            return t2 || (t2 = u.create()), null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(10).string(e3.domain), null != e3.version && Object.hasOwnProperty.call(e3, "version") && t2.uint32(16).int64(e3.version), t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.OperatorSetIdProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.domain = e3.string();
                  break;
                case 2:
                  r2.version = e3.int64();
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            return "object" != typeof e3 || null === e3 ? "object expected" : null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain) ? "domain: string expected" : null != e3.version && e3.hasOwnProperty("version") && !(l.isInteger(e3.version) || e3.version && l.isInteger(e3.version.low) && l.isInteger(e3.version.high)) ? "version: integer|Long expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.OperatorSetIdProto)
              return e3;
            var t2 = new c.onnx.OperatorSetIdProto();
            return null != e3.domain && (t2.domain = String(e3.domain)), null != e3.version && (l.Long ? (t2.version = l.Long.fromValue(e3.version)).unsigned = false : "string" == typeof e3.version ? t2.version = parseInt(e3.version, 10) : "number" == typeof e3.version ? t2.version = e3.version : "object" == typeof e3.version && (t2.version = new l.LongBits(e3.version.low >>> 0, e3.version.high >>> 0).toNumber())), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if (t2.defaults)
              if (n2.domain = "", l.Long) {
                var r2 = new l.Long(0, 0, false);
                n2.version = t2.longs === String ? r2.toString() : t2.longs === Number ? r2.toNumber() : r2;
              } else
                n2.version = t2.longs === String ? "0" : 0;
            return null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), null != e3.version && e3.hasOwnProperty("version") && ("number" == typeof e3.version ? n2.version = t2.longs === String ? String(e3.version) : e3.version : n2.version = t2.longs === String ? l.Long.prototype.toString.call(e3.version) : t2.longs === Number ? new l.LongBits(e3.version.low >>> 0, e3.version.high >>> 0).toNumber() : e3.version), n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.OperatorSetIdProto";
          }, e2;
        }(), o.OperatorStatus = function() {
          var e2 = {}, t2 = Object.create(e2);
          return t2[e2[0] = "EXPERIMENTAL"] = 0, t2[e2[1] = "STABLE"] = 1, t2;
        }(), o.FunctionProto = function() {
          function e2(e3) {
            if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], e3)
              for (var t2 = Object.keys(e3), n2 = 0; n2 < t2.length; ++n2)
                null != e3[t2[n2]] && (this[t2[n2]] = e3[t2[n2]]);
          }
          return e2.prototype.name = "", e2.prototype.input = l.emptyArray, e2.prototype.output = l.emptyArray, e2.prototype.attribute = l.emptyArray, e2.prototype.attributeProto = l.emptyArray, e2.prototype.node = l.emptyArray, e2.prototype.docString = "", e2.prototype.opsetImport = l.emptyArray, e2.prototype.domain = "", e2.create = function(t2) {
            return new e2(t2);
          }, e2.encode = function(e3, t2) {
            if (t2 || (t2 = u.create()), null != e3.name && Object.hasOwnProperty.call(e3, "name") && t2.uint32(10).string(e3.name), null != e3.input && e3.input.length)
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.uint32(34).string(e3.input[n2]);
            if (null != e3.output && e3.output.length)
              for (n2 = 0; n2 < e3.output.length; ++n2)
                t2.uint32(42).string(e3.output[n2]);
            if (null != e3.attribute && e3.attribute.length)
              for (n2 = 0; n2 < e3.attribute.length; ++n2)
                t2.uint32(50).string(e3.attribute[n2]);
            if (null != e3.node && e3.node.length)
              for (n2 = 0; n2 < e3.node.length; ++n2)
                c.onnx.NodeProto.encode(e3.node[n2], t2.uint32(58).fork()).ldelim();
            if (null != e3.docString && Object.hasOwnProperty.call(e3, "docString") && t2.uint32(66).string(e3.docString), null != e3.opsetImport && e3.opsetImport.length)
              for (n2 = 0; n2 < e3.opsetImport.length; ++n2)
                c.onnx.OperatorSetIdProto.encode(e3.opsetImport[n2], t2.uint32(74).fork()).ldelim();
            if (null != e3.domain && Object.hasOwnProperty.call(e3, "domain") && t2.uint32(82).string(e3.domain), null != e3.attributeProto && e3.attributeProto.length)
              for (n2 = 0; n2 < e3.attributeProto.length; ++n2)
                c.onnx.AttributeProto.encode(e3.attributeProto[n2], t2.uint32(90).fork()).ldelim();
            return t2;
          }, e2.encodeDelimited = function(e3, t2) {
            return this.encode(e3, t2).ldelim();
          }, e2.decode = function(e3, t2) {
            e3 instanceof s || (e3 = s.create(e3));
            for (var n2 = void 0 === t2 ? e3.len : e3.pos + t2, r2 = new c.onnx.FunctionProto(); e3.pos < n2; ) {
              var i2 = e3.uint32();
              switch (i2 >>> 3) {
                case 1:
                  r2.name = e3.string();
                  break;
                case 4:
                  r2.input && r2.input.length || (r2.input = []), r2.input.push(e3.string());
                  break;
                case 5:
                  r2.output && r2.output.length || (r2.output = []), r2.output.push(e3.string());
                  break;
                case 6:
                  r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(e3.string());
                  break;
                case 11:
                  r2.attributeProto && r2.attributeProto.length || (r2.attributeProto = []), r2.attributeProto.push(c.onnx.AttributeProto.decode(e3, e3.uint32()));
                  break;
                case 7:
                  r2.node && r2.node.length || (r2.node = []), r2.node.push(c.onnx.NodeProto.decode(e3, e3.uint32()));
                  break;
                case 8:
                  r2.docString = e3.string();
                  break;
                case 9:
                  r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(c.onnx.OperatorSetIdProto.decode(e3, e3.uint32()));
                  break;
                case 10:
                  r2.domain = e3.string();
                  break;
                default:
                  e3.skipType(7 & i2);
              }
            }
            return r2;
          }, e2.decodeDelimited = function(e3) {
            return e3 instanceof s || (e3 = new s(e3)), this.decode(e3, e3.uint32());
          }, e2.verify = function(e3) {
            if ("object" != typeof e3 || null === e3)
              return "object expected";
            if (null != e3.name && e3.hasOwnProperty("name") && !l.isString(e3.name))
              return "name: string expected";
            if (null != e3.input && e3.hasOwnProperty("input")) {
              if (!Array.isArray(e3.input))
                return "input: array expected";
              for (var t2 = 0; t2 < e3.input.length; ++t2)
                if (!l.isString(e3.input[t2]))
                  return "input: string[] expected";
            }
            if (null != e3.output && e3.hasOwnProperty("output")) {
              if (!Array.isArray(e3.output))
                return "output: array expected";
              for (t2 = 0; t2 < e3.output.length; ++t2)
                if (!l.isString(e3.output[t2]))
                  return "output: string[] expected";
            }
            if (null != e3.attribute && e3.hasOwnProperty("attribute")) {
              if (!Array.isArray(e3.attribute))
                return "attribute: array expected";
              for (t2 = 0; t2 < e3.attribute.length; ++t2)
                if (!l.isString(e3.attribute[t2]))
                  return "attribute: string[] expected";
            }
            if (null != e3.attributeProto && e3.hasOwnProperty("attributeProto")) {
              if (!Array.isArray(e3.attributeProto))
                return "attributeProto: array expected";
              for (t2 = 0; t2 < e3.attributeProto.length; ++t2)
                if (n2 = c.onnx.AttributeProto.verify(e3.attributeProto[t2]))
                  return "attributeProto." + n2;
            }
            if (null != e3.node && e3.hasOwnProperty("node")) {
              if (!Array.isArray(e3.node))
                return "node: array expected";
              for (t2 = 0; t2 < e3.node.length; ++t2)
                if (n2 = c.onnx.NodeProto.verify(e3.node[t2]))
                  return "node." + n2;
            }
            if (null != e3.docString && e3.hasOwnProperty("docString") && !l.isString(e3.docString))
              return "docString: string expected";
            if (null != e3.opsetImport && e3.hasOwnProperty("opsetImport")) {
              if (!Array.isArray(e3.opsetImport))
                return "opsetImport: array expected";
              for (t2 = 0; t2 < e3.opsetImport.length; ++t2) {
                var n2;
                if (n2 = c.onnx.OperatorSetIdProto.verify(e3.opsetImport[t2]))
                  return "opsetImport." + n2;
              }
            }
            return null != e3.domain && e3.hasOwnProperty("domain") && !l.isString(e3.domain) ? "domain: string expected" : null;
          }, e2.fromObject = function(e3) {
            if (e3 instanceof c.onnx.FunctionProto)
              return e3;
            var t2 = new c.onnx.FunctionProto();
            if (null != e3.name && (t2.name = String(e3.name)), e3.input) {
              if (!Array.isArray(e3.input))
                throw TypeError(".onnx.FunctionProto.input: array expected");
              t2.input = [];
              for (var n2 = 0; n2 < e3.input.length; ++n2)
                t2.input[n2] = String(e3.input[n2]);
            }
            if (e3.output) {
              if (!Array.isArray(e3.output))
                throw TypeError(".onnx.FunctionProto.output: array expected");
              for (t2.output = [], n2 = 0; n2 < e3.output.length; ++n2)
                t2.output[n2] = String(e3.output[n2]);
            }
            if (e3.attribute) {
              if (!Array.isArray(e3.attribute))
                throw TypeError(".onnx.FunctionProto.attribute: array expected");
              for (t2.attribute = [], n2 = 0; n2 < e3.attribute.length; ++n2)
                t2.attribute[n2] = String(e3.attribute[n2]);
            }
            if (e3.attributeProto) {
              if (!Array.isArray(e3.attributeProto))
                throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
              for (t2.attributeProto = [], n2 = 0; n2 < e3.attributeProto.length; ++n2) {
                if ("object" != typeof e3.attributeProto[n2])
                  throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
                t2.attributeProto[n2] = c.onnx.AttributeProto.fromObject(e3.attributeProto[n2]);
              }
            }
            if (e3.node) {
              if (!Array.isArray(e3.node))
                throw TypeError(".onnx.FunctionProto.node: array expected");
              for (t2.node = [], n2 = 0; n2 < e3.node.length; ++n2) {
                if ("object" != typeof e3.node[n2])
                  throw TypeError(".onnx.FunctionProto.node: object expected");
                t2.node[n2] = c.onnx.NodeProto.fromObject(e3.node[n2]);
              }
            }
            if (null != e3.docString && (t2.docString = String(e3.docString)), e3.opsetImport) {
              if (!Array.isArray(e3.opsetImport))
                throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
              for (t2.opsetImport = [], n2 = 0; n2 < e3.opsetImport.length; ++n2) {
                if ("object" != typeof e3.opsetImport[n2])
                  throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
                t2.opsetImport[n2] = c.onnx.OperatorSetIdProto.fromObject(e3.opsetImport[n2]);
              }
            }
            return null != e3.domain && (t2.domain = String(e3.domain)), t2;
          }, e2.toObject = function(e3, t2) {
            t2 || (t2 = {});
            var n2 = {};
            if ((t2.arrays || t2.defaults) && (n2.input = [], n2.output = [], n2.attribute = [], n2.node = [], n2.opsetImport = [], n2.attributeProto = []), t2.defaults && (n2.name = "", n2.docString = "", n2.domain = ""), null != e3.name && e3.hasOwnProperty("name") && (n2.name = e3.name), e3.input && e3.input.length) {
              n2.input = [];
              for (var r2 = 0; r2 < e3.input.length; ++r2)
                n2.input[r2] = e3.input[r2];
            }
            if (e3.output && e3.output.length)
              for (n2.output = [], r2 = 0; r2 < e3.output.length; ++r2)
                n2.output[r2] = e3.output[r2];
            if (e3.attribute && e3.attribute.length)
              for (n2.attribute = [], r2 = 0; r2 < e3.attribute.length; ++r2)
                n2.attribute[r2] = e3.attribute[r2];
            if (e3.node && e3.node.length)
              for (n2.node = [], r2 = 0; r2 < e3.node.length; ++r2)
                n2.node[r2] = c.onnx.NodeProto.toObject(e3.node[r2], t2);
            if (null != e3.docString && e3.hasOwnProperty("docString") && (n2.docString = e3.docString), e3.opsetImport && e3.opsetImport.length)
              for (n2.opsetImport = [], r2 = 0; r2 < e3.opsetImport.length; ++r2)
                n2.opsetImport[r2] = c.onnx.OperatorSetIdProto.toObject(e3.opsetImport[r2], t2);
            if (null != e3.domain && e3.hasOwnProperty("domain") && (n2.domain = e3.domain), e3.attributeProto && e3.attributeProto.length)
              for (n2.attributeProto = [], r2 = 0; r2 < e3.attributeProto.length; ++r2)
                n2.attributeProto[r2] = c.onnx.AttributeProto.toObject(e3.attributeProto[r2], t2);
            return n2;
          }, e2.prototype.toJSON = function() {
            return this.constructor.toObject(this, a.util.toJSONOptions);
          }, e2.getTypeUrl = function(e3) {
            return void 0 === e3 && (e3 = "type.googleapis.com"), e3 + "/onnx.FunctionProto";
          }, e2;
        }(), o), e.exports = c;
      }, 5711: (e, t, n) => {
        var _scriptDir, r = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (_scriptDir = _scriptDir || __filename), function(e2 = {}) {
          function t2() {
            return E.buffer != R.buffer && B(), R;
          }
          function r2() {
            return E.buffer != R.buffer && B(), M;
          }
          function i() {
            return E.buffer != R.buffer && B(), j;
          }
          function o() {
            return E.buffer != R.buffer && B(), N3;
          }
          function a() {
            return E.buffer != R.buffer && B(), z;
          }
          var s, u, l = e2;
          l.ready = new Promise((e3, t3) => {
            s = e3, u = t3;
          }), l.jsepInit = function(e3, t3, n2, r3, i2, o2, a2, s2) {
            l.Ib = e3, l.ob = t3, l.qb = n2, l.ab = r3, l.pb = i2, l.xa = o2, l.rb = a2, l.sb = s2;
          };
          var c, p, d, f = Object.assign({}, l), h = "./this.program", g = (e3, t3) => {
            throw t3;
          }, m = "object" == typeof window, b = "function" == typeof importScripts, y = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, v = l.ENVIRONMENT_IS_PTHREAD || false, w = "";
          function x(e3) {
            return l.locateFile ? l.locateFile(e3, w) : w + e3;
          }
          if (y) {
            var _ = n(1384), T = n(908);
            let e3;
            w = b ? T.dirname(w) + "/" : __dirname + "/", c = (e4, t3) => (e4 = e4.startsWith("file://") ? new URL(e4) : T.normalize(e4), _.readFileSync(e4, t3 ? void 0 : "utf8")), d = (e4) => ((e4 = c(e4, true)).buffer || (e4 = new Uint8Array(e4)), e4), p = (e4, t3, n2, r3 = true) => {
              e4 = e4.startsWith("file://") ? new URL(e4) : T.normalize(e4), _.readFile(e4, r3 ? void 0 : "utf8", (e5, i2) => {
                e5 ? n2(e5) : t3(r3 ? i2.buffer : i2);
              });
            }, !l.thisProgram && 1 < process.argv.length && (h = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), g = (e4, t3) => {
              throw process.exitCode = e4, t3;
            }, l.inspect = () => "[Emscripten Module object]";
            try {
              e3 = n(9925);
            } catch (e4) {
              throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), e4;
            }
            global.Worker = e3.Worker;
          } else
            (m || b) && (b ? w = self.location.href : "undefined" != typeof document && document.currentScript && (w = document.currentScript.src), _scriptDir && (w = _scriptDir), w = 0 !== w.indexOf("blob:") ? w.substr(0, w.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", y || (c = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.send(null), t3.responseText;
            }, b && (d = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), p = (e3, t3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", e3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? t3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            }));
          y && "undefined" == typeof performance && (global.performance = n(6953).performance);
          var S = console.log.bind(console), $ = console.error.bind(console);
          y && (S = (...e3) => _.writeSync(1, e3.join(" ") + "\n"), $ = (...e3) => _.writeSync(2, e3.join(" ") + "\n"));
          var O, A = l.print || S, P = l.printErr || $;
          Object.assign(l, f), f = null, l.thisProgram && (h = l.thisProgram), l.quit && (g = l.quit), l.wasmBinary && (O = l.wasmBinary);
          var I = l.noExitRuntime || true;
          "object" != typeof WebAssembly && Q("no native wasm support detected");
          var E, C2, D, k, R, M, j, N3, z, L3 = false;
          function B() {
            var e3 = E.buffer;
            l.HEAP8 = R = new Int8Array(e3), l.HEAP16 = new Int16Array(e3), l.HEAP32 = j = new Int32Array(e3), l.HEAPU8 = M = new Uint8Array(e3), l.HEAPU16 = new Uint16Array(e3), l.HEAPU32 = N3 = new Uint32Array(e3), l.HEAPF32 = new Float32Array(e3), l.HEAPF64 = z = new Float64Array(e3);
          }
          var F = l.INITIAL_MEMORY || 16777216;
          if (5242880 <= F || Q("INITIAL_MEMORY should be larger than STACK_SIZE, was " + F + "! (STACK_SIZE=5242880)"), v)
            E = l.wasmMemory;
          else if (l.wasmMemory)
            E = l.wasmMemory;
          else if (!((E = new WebAssembly.Memory({ initial: F / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer))
            throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), y && P("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), Error("bad memory");
          B(), F = E.buffer.byteLength;
          var U = [], G = [], V = [], W = 0;
          function H() {
            return I || 0 < W;
          }
          var q, K = 0, X = null, Y = null;
          function J() {
            K++, l.monitorRunDependencies && l.monitorRunDependencies(K);
          }
          function Z() {
            if (K--, l.monitorRunDependencies && l.monitorRunDependencies(K), 0 == K && (null !== X && (clearInterval(X), X = null), Y)) {
              var e3 = Y;
              Y = null, e3();
            }
          }
          function Q(e3) {
            throw l.onAbort && l.onAbort(e3), P(e3 = "Aborted(" + e3 + ")"), L3 = true, k = 1, e3 = new WebAssembly.RuntimeError(e3 + ". Build with -sASSERTIONS for more info."), u(e3), e3;
          }
          function ee(e3) {
            return e3.startsWith("data:application/octet-stream;base64,");
          }
          function te(e3) {
            if (e3 == q && O)
              return new Uint8Array(O);
            if (d)
              return d(e3);
            throw "both async and sync fetching of the wasm failed";
          }
          function ne(e3, t3, n2) {
            return function(e4) {
              if (!O && (m || b)) {
                if ("function" == typeof fetch && !e4.startsWith("file://"))
                  return fetch(e4, { credentials: "same-origin" }).then((t4) => {
                    if (!t4.ok)
                      throw "failed to load wasm binary file at '" + e4 + "'";
                    return t4.arrayBuffer();
                  }).catch(() => te(e4));
                if (p)
                  return new Promise((t4, n3) => {
                    p(e4, (e5) => t4(new Uint8Array(e5)), n3);
                  });
              }
              return Promise.resolve().then(() => te(e4));
            }(e3).then((e4) => WebAssembly.instantiate(e4, t3)).then((e4) => e4).then(n2, (e4) => {
              P("failed to asynchronously prepare wasm: " + e4), Q(e4);
            });
          }
          ee(q = "ort-wasm-simd-threaded.wasm") || (q = x(q));
          var re, ie = { 898348: () => {
            l.jsepRunPromise = new Promise(function(e3) {
              l.tb = e3;
            });
          }, 898443: (e3) => {
            l.tb(e3);
          }, 898481: (e3) => l.ob(e3), 898514: (e3) => l.qb(e3), 898546: (e3, t3, n2) => {
            l.ab(e3, t3, n2, true);
          }, 898585: (e3, t3, n2) => {
            l.ab(e3, t3, n2);
          }, 898618: (e3) => {
            l.xa("Abs", e3, void 0);
          }, 898669: (e3) => {
            l.xa("Neg", e3, void 0);
          }, 898720: (e3) => {
            l.xa("Floor", e3, void 0);
          }, 898773: (e3) => {
            l.xa("Ceil", e3, void 0);
          }, 898825: (e3) => {
            l.xa("Reciprocal", e3, void 0);
          }, 898883: (e3) => {
            l.xa("Sqrt", e3, void 0);
          }, 898935: (e3) => {
            l.xa("Exp", e3, void 0);
          }, 898986: (e3) => {
            l.xa("Erf", e3, void 0);
          }, 899037: (e3) => {
            l.xa("Sigmoid", e3, void 0);
          }, 899092: (e3) => {
            l.xa("Log", e3, void 0);
          }, 899143: (e3) => {
            l.xa("Sin", e3, void 0);
          }, 899194: (e3) => {
            l.xa("Cos", e3, void 0);
          }, 899245: (e3) => {
            l.xa("Tan", e3, void 0);
          }, 899296: (e3) => {
            l.xa("Asin", e3, void 0);
          }, 899348: (e3) => {
            l.xa("Acos", e3, void 0);
          }, 899400: (e3) => {
            l.xa("Atan", e3, void 0);
          }, 899452: (e3) => {
            l.xa("Sinh", e3, void 0);
          }, 899504: (e3) => {
            l.xa("Cosh", e3, void 0);
          }, 899556: (e3) => {
            l.xa("Asinh", e3, void 0);
          }, 899609: (e3) => {
            l.xa("Acosh", e3, void 0);
          }, 899662: (e3) => {
            l.xa("Atanh", e3, void 0);
          }, 899715: (e3) => {
            l.xa("Tanh", e3, void 0);
          }, 899767: (e3, t3, n2) => {
            l.xa("ClipV10", e3, { min: t3, max: n2 });
          }, 899839: (e3) => {
            l.xa("Clip", e3, void 0);
          }, 899891: (e3, t3) => {
            l.xa("Elu", e3, { alpha: t3 });
          }, 899949: (e3) => {
            l.xa("Relu", e3, void 0);
          }, 900001: (e3, t3) => {
            l.xa("LeakyRelu", e3, { alpha: t3 });
          }, 900065: (e3, t3) => {
            l.xa("ThresholdedRelu", e3, { alpha: t3 });
          }, 900135: (e3, t3) => {
            l.xa("Cast", e3, { to: t3 });
          }, 900193: (e3) => {
            l.xa("Add", e3, void 0);
          }, 900244: (e3) => {
            l.xa("Sub", e3, void 0);
          }, 900295: (e3) => {
            l.xa("Mul", e3, void 0);
          }, 900346: (e3) => {
            l.xa("Div", e3, void 0);
          }, 900397: (e3) => {
            l.xa("Pow", e3, void 0);
          }, 900448: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceMean", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 900612: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceMax", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 900775: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceMin", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 900938: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceProd", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 901102: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceSum", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 901265: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceL1", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 901427: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceL2", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 901589: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceLogSum", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 901755: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceSumSquare", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 901924: (e3, t3, n2, r3, o2) => {
            l.xa("ReduceLogSumExp", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 902093: (e3, t3, n2) => {
            l.xa("Transpose", e3, { perm: t3 ? Array.from(i().subarray(n2 >>> 0, n2 + t3 >>> 0)) : [] });
          }, 902206: (e3, n2, r3, i2, o2, a2, s2, u2, c2, p2) => {
            l.xa("Conv", e3, { format: c2 ? "NHWC" : "NCHW", auto_pad: n2, dilations: [r3], group: i2, kernel_shape: [o2], pads: [a2, s2], strides: [u2], w_is_const: () => !!t2()[p2 >>> 0] });
          }, 902434: (e3, n2, r3, i2, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("Conv", e3, { format: g2 ? "NHWC" : "NCHW", auto_pad: n2, dilations: [r3, i2], group: o2, kernel_shape: [a2, s2], pads: [u2, c2, p2, d2], strides: [f2, h2], w_is_const: () => !!t2()[m2 >>> 0] });
          }, 902693: (e3, n2, r3, i2, o2, a2, s2, u2, c2, p2) => {
            l.xa("Conv", e3, { format: c2 ? "NHWC" : "NCHW", auto_pad: n2, dilations: [r3], group: i2, kernel_shape: [o2], pads: [a2, s2], strides: [u2], w_is_const: () => !!t2()[p2 >>> 0] });
          }, 902921: (e3, n2, r3, i2, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("Conv", e3, { format: g2 ? "NHWC" : "NCHW", auto_pad: n2, dilations: [r3, i2], group: o2, kernel_shape: [a2, s2], pads: [u2, c2, p2, d2], strides: [f2, h2], w_is_const: () => !!t2()[m2 >>> 0] });
          }, 903180: (e3, n2, r3, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("ConvTranspose", e3, { format: p2 ? "NHWC" : "NCHW", autoPad: n2, dilations: [r3], group: o2, kernel_shape: [a2], pads: [s2, u2], strides: [c2], wIsConst: () => !!t2()[d2 >>> 0], outputPadding: f2 ? Array.from(i().subarray(h2 >>> 0, h2 + f2 >>> 0)) : [], outputShape: g2 ? Array.from(i().subarray(m2 >>> 0, m2 + g2 >>> 0)) : [] });
          }, 903560: (e3, n2, r3, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2) => {
            l.xa("ConvTranspose", e3, { format: c2 ? "NHWC" : "NCHW", autoPad: n2, dilations: Array.from(i().subarray(r3 >>> 0, r3 + 2 >>> 0)), group: o2, kernelShape: Array.from(i().subarray(a2 >>> 0, a2 + 2 >>> 0)), pads: Array.from(i().subarray(s2 >>> 0, s2 + 4 >>> 0)), strides: Array.from(i().subarray(u2 >>> 0, u2 + 2 >>> 0)), wIsConst: () => !!t2()[p2 >>> 0], outputPadding: 0 < d2 ? Array.from(i().subarray(f2 >>> 0, f2 + d2 >>> 0)) : [], outputShape: 0 < h2 ? Array.from(i().subarray(g2 >>> 0, g2 + h2 >>> 0)) : [] });
          }, 904083: (e3, n2, r3, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("ConvTranspose", e3, { format: p2 ? "NHWC" : "NCHW", autoPad: n2, dilations: [r3], group: o2, kernel_shape: [a2], pads: [s2, u2], strides: [c2], wIsConst: () => !!t2()[d2 >>> 0], outputPadding: f2 ? Array.from(i().subarray(h2 >>> 0, h2 + f2 >>> 0)) : [], outputShape: g2 ? Array.from(i().subarray(m2 >>> 0, m2 + g2 >>> 0)) : [] });
          }, 904463: (e3, n2, r3, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2) => {
            l.xa("ConvTranspose", e3, { format: c2 ? "NHWC" : "NCHW", autoPad: n2, dilations: Array.from(i().subarray(r3 >>> 0, r3 + 2 >>> 0)), group: o2, kernelShape: Array.from(i().subarray(a2 >>> 0, a2 + 2 >>> 0)), pads: Array.from(i().subarray(s2 >>> 0, s2 + 4 >>> 0)), strides: Array.from(i().subarray(u2 >>> 0, u2 + 2 >>> 0)), wIsConst: () => !!t2()[p2 >>> 0], outputPadding: 0 < d2 ? Array.from(i().subarray(f2 >>> 0, f2 + d2 >>> 0)) : [], outputShape: 0 < h2 ? Array.from(i().subarray(g2 >>> 0, g2 + h2 >>> 0)) : [] });
          }, 904986: (e3, t3) => {
            l.xa("GlobalAveragePool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 905077: (e3, t3, n2, r3, i2, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("AveragePool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: i2, dilations: [o2, a2], kernel_shape: [s2, u2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 905361: (e3, t3) => {
            l.xa("GlobalAveragePool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 905452: (e3, t3, n2, r3, i2, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("AveragePool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: i2, dilations: [o2, a2], kernel_shape: [s2, u2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 905736: (e3, t3) => {
            l.xa("GlobalMaxPool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 905823: (e3, t3, n2, r3, i2, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("MaxPool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: i2, dilations: [o2, a2], kernel_shape: [s2, u2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 906103: (e3, t3) => {
            l.xa("GlobalMaxPool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 906190: (e3, t3, n2, r3, i2, o2, a2, s2, u2, c2, p2, d2, f2, h2, g2, m2) => {
            l.xa("MaxPool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: i2, dilations: [o2, a2], kernel_shape: [s2, u2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 906470: (e3, t3, n2, r3, i2) => {
            l.xa("Gemm", e3, { alpha: t3, beta: n2, transA: r3, transB: i2 });
          }, 906574: (e3) => {
            l.xa("MatMul", e3, void 0);
          }, 906628: (e3, t3, n2, r3) => {
            l.xa("ArgMax", e3, { keepDims: !!t3, selectLastIndex: !!n2, axis: r3 });
          }, 906736: (e3, t3, n2, r3) => {
            l.xa("ArgMin", e3, { keepDims: !!t3, selectLastIndex: !!n2, axis: r3 });
          }, 906844: (e3, t3) => {
            l.xa("Softmax", e3, { axis: t3 });
          }, 906907: (e3, t3) => {
            l.xa("Concat", e3, { axis: t3 });
          }, 906967: (e3, t3, n2, r3, o2) => {
            l.xa("Split", e3, { axis: t3, numOutputs: n2, splitSizes: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 907112: (e3) => {
            l.xa("Expand", e3, void 0);
          }, 907166: (e3, t3) => {
            l.xa("Gather", e3, { axis: Number(t3) });
          }, 907237: (e3, t3, n2, r3, o2, a2, s2, u2, c2, p2, d2) => {
            l.xa("Resize", e3, { antialias: t3, axes: n2 ? Array.from(i().subarray(r3 >>> 0, r3 + n2 >>> 0)) : [], coordinateTransformMode: pe(o2), cubicCoeffA: a2, excludeOutside: s2, extrapolationValue: u2, keepAspectRatioPolicy: pe(c2), mode: pe(p2), nearestMode: pe(d2) });
          }, 907588: (e3, t3, n2, r3, o2, a2, s2) => {
            l.xa("Slice", e3, { starts: t3 ? Array.from(i().subarray(n2 >>> 0, n2 + t3 >>> 0)) : [], ends: r3 ? Array.from(i().subarray(o2 >>> 0, o2 + r3 >>> 0)) : [], axes: a2 ? Array.from(i().subarray(s2 >>> 0, s2 + a2 >>> 0)) : [] });
          }, 907819: (e3) => {
            l.xa("Tile", e3, void 0);
          }, 907871: (e3, t3, n2) => {
            l.xa("LayerNormalization", e3, { axis: Number(t3), epsilon: Number(n2) });
          }, 907978: (e3, t3, n2) => {
            l.xa("InstanceNormalization", e3, { epsilon: t3, format: n2 ? "NHWC" : "NCHW" });
          }, 908092: (e3, t3, n2) => {
            l.xa("InstanceNormalization", e3, { epsilon: t3, format: n2 ? "NHWC" : "NCHW" });
          }, 908206: (e3) => {
            l.xa("Gelu", e3, void 0);
          }, 908258: (e3, t3) => {
            l.xa("SkipLayerNormalization", e3, { epsilon: t3 });
          }, 908339: (e3) => {
            l.rb(e3);
          }, 908373: (e3, t3) => l.sb(e3, t3) };
          function oe(e3) {
            this.name = "ExitStatus", this.message = `Program terminated with exit(${e3})`, this.status = e3;
          }
          function ae(e3) {
            e3.terminate(), e3.onmessage = () => {
            };
          }
          function se(e3) {
            (e3 = he.Ja[e3]) || Q(), he.xb(e3);
          }
          function ue(e3) {
            var t3 = he.lb();
            if (!t3)
              return 6;
            he.Ra.push(t3), he.Ja[e3.Qa] = t3, t3.Qa = e3.Qa;
            var n2 = { cmd: "run", start_routine: e3.yb, arg: e3.jb, pthread_ptr: e3.Qa };
            return y && t3.unref(), t3.postMessage(n2, e3.Eb), 0;
          }
          var le = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, ce = (e3, t3, n2) => {
            var r3 = (t3 >>>= 0) + n2;
            for (n2 = t3; e3[n2] && !(n2 >= r3); )
              ++n2;
            if (16 < n2 - t3 && e3.buffer && le)
              return le.decode(e3.buffer instanceof SharedArrayBuffer ? e3.slice(t3, n2) : e3.subarray(t3, n2));
            for (r3 = ""; t3 < n2; ) {
              var i2 = e3[t3++];
              if (128 & i2) {
                var o2 = 63 & e3[t3++];
                if (192 == (224 & i2))
                  r3 += String.fromCharCode((31 & i2) << 6 | o2);
                else {
                  var a2 = 63 & e3[t3++];
                  65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & e3[t3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                }
              } else
                r3 += String.fromCharCode(i2);
            }
            return r3;
          }, pe = (e3, t3) => (e3 >>>= 0) ? ce(r2(), e3, t3) : "";
          function de(e3) {
            if (v)
              return Ke(1, 1, e3);
            k = e3, H() || (he.zb(), l.onExit && l.onExit(e3), L3 = true), g(e3, new oe(e3));
          }
          var fe = (e3) => {
            if (k = e3, v)
              throw me(e3), "unwind";
            de(e3);
          }, he = { Ua: [], Ra: [], eb: [], Ja: {}, Xa: function() {
            v ? he.nb() : he.mb();
          }, mb: function() {
            U.unshift(() => {
              J(), he.ub(() => Z());
            });
          }, nb: function() {
            he.receiveObjectTransfer = he.wb, he.threadInitTLS = he.cb, he.setExitStatus = he.bb, I = false;
          }, bb: function(e3) {
            k = e3;
          }, Kb: ["$terminateWorker"], zb: function() {
            for (var e3 of he.Ra)
              ae(e3);
            for (e3 of he.Ua)
              ae(e3);
            he.Ua = [], he.Ra = [], he.Ja = [];
          }, xb: function(e3) {
            var t3 = e3.Qa;
            delete he.Ja[t3], he.Ua.push(e3), he.Ra.splice(he.Ra.indexOf(e3), 1), e3.Qa = 0, It(t3);
          }, wb: function() {
          }, cb: function() {
            he.eb.forEach((e3) => e3());
          }, vb: (e3) => new Promise((t3) => {
            e3.onmessage = (n3) => {
              var r4 = (n3 = n3.data).cmd;
              if (n3.targetThread && n3.targetThread != Tt()) {
                var i2 = he.Ja[n3.Jb];
                i2 ? i2.postMessage(n3, n3.transferList) : P('Internal error! Worker sent a message "' + r4 + '" to target pthread ' + n3.targetThread + ", but that thread no longer exists!");
              } else
                "checkMailbox" === r4 ? ze() : "spawnThread" === r4 ? ue(n3) : "cleanupThread" === r4 ? se(n3.thread) : "killThread" === r4 ? (n3 = n3.thread, r4 = he.Ja[n3], delete he.Ja[n3], ae(r4), It(n3), he.Ra.splice(he.Ra.indexOf(r4), 1), r4.Qa = 0) : "cancelThread" === r4 ? he.Ja[n3.thread].postMessage({ cmd: "cancel" }) : "loaded" === r4 ? (e3.loaded = true, t3(e3)) : "alert" === r4 ? alert("Thread " + n3.threadId + ": " + n3.text) : "setimmediate" === n3.target ? e3.postMessage(n3) : "callHandler" === r4 ? l[n3.handler](...n3.args) : r4 && P("worker sent an unknown command " + r4);
            }, e3.onerror = (e4) => {
              throw P("worker sent an error! " + e4.filename + ":" + e4.lineno + ": " + e4.message), e4;
            }, y && (e3.on("message", function(t4) {
              e3.onmessage({ data: t4 });
            }), e3.on("error", function(t4) {
              e3.onerror(t4);
            }));
            var n2, r3 = [];
            for (n2 of ["onExit", "onAbort", "print", "printErr"])
              l.hasOwnProperty(n2) && r3.push(n2);
            e3.postMessage({ cmd: "load", handlers: r3, urlOrBlob: l.mainScriptUrlOrBlob || _scriptDir, wasmMemory: E, wasmModule: D });
          }), ub: function(e3) {
            e3();
          }, ib: function() {
            var e3 = x("ort-wasm-simd-threaded.worker.js");
            e3 = new Worker(e3), he.Ua.push(e3);
          }, lb: function() {
            return 0 == he.Ua.length && (he.ib(), he.vb(he.Ua[0])), he.Ua.pop();
          } };
          l.PThread = he;
          var ge = (e3) => {
            for (; 0 < e3.length; )
              e3.shift()(l);
          };
          function me(e3) {
            if (v)
              return Ke(2, 0, e3);
            fe(e3);
          }
          function be(e3) {
            this.$a = e3 - 24, this.hb = function(e4) {
              o()[this.$a + 4 >> 2 >>> 0] = e4;
            }, this.gb = function(e4) {
              o()[this.$a + 8 >> 2 >>> 0] = e4;
            }, this.Xa = function(e4, t3) {
              this.fb(), this.hb(e4), this.gb(t3);
            }, this.fb = function() {
              o()[this.$a + 16 >> 2 >>> 0] = 0;
            };
          }
          function ye(e3, t3, n2, r3) {
            return v ? Ke(3, 1, e3, t3, n2, r3) : ve(e3, t3, n2, r3);
          }
          function ve(e3, t3, n2, r3) {
            if (e3 >>>= 0, t3 >>>= 0, n2 >>>= 0, r3 >>>= 0, "undefined" == typeof SharedArrayBuffer)
              return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
            var i2 = [];
            return v && 0 === i2.length ? ye(e3, t3, n2, r3) : (e3 = { yb: n2, Qa: e3, jb: r3, Eb: i2 }, v ? (e3.Gb = "spawnThread", postMessage(e3, i2), 0) : ue(e3));
          }
          function we(e3, t3, n2) {
            return v ? Ke(4, 1, e3, t3, n2) : 0;
          }
          function xe(e3, t3) {
            if (v)
              return Ke(5, 1, e3, t3);
          }
          l.establishStackSpace = function() {
            var e3 = Tt(), t3 = i()[e3 + 52 >> 2 >>> 0];
            e3 = i()[e3 + 56 >> 2 >>> 0], kt(t3, t3 - e3), Mt(t3);
          }, l.invokeEntryPoint = function(e3, t3) {
            e3 = Nt.apply(null, [e3, t3]), H() ? he.bb(e3) : Et(e3);
          };
          var _e = (e3) => {
            for (var t3 = 0, n2 = 0; n2 < e3.length; ++n2) {
              var r3 = e3.charCodeAt(n2);
              127 >= r3 ? t3++ : 2047 >= r3 ? t3 += 2 : 55296 <= r3 && 57343 >= r3 ? (t3 += 4, ++n2) : t3 += 3;
            }
            return t3;
          }, Te = (e3, t3, n2, r3) => {
            if (!(0 < r3))
              return 0;
            var i2 = n2 >>>= 0;
            r3 = n2 + r3 - 1;
            for (var o2 = 0; o2 < e3.length; ++o2) {
              var a2 = e3.charCodeAt(o2);
              if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++o2)), 127 >= a2) {
                if (n2 >= r3)
                  break;
                t3[n2++ >>> 0] = a2;
              } else {
                if (2047 >= a2) {
                  if (n2 + 1 >= r3)
                    break;
                  t3[n2++ >>> 0] = 192 | a2 >> 6;
                } else {
                  if (65535 >= a2) {
                    if (n2 + 2 >= r3)
                      break;
                    t3[n2++ >>> 0] = 224 | a2 >> 12;
                  } else {
                    if (n2 + 3 >= r3)
                      break;
                    t3[n2++ >>> 0] = 240 | a2 >> 18, t3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                }
                t3[n2++ >>> 0] = 128 | 63 & a2;
              }
            }
            return t3[n2 >>> 0] = 0, n2 - i2;
          }, Se = (e3, t3, n2) => Te(e3, r2(), t3, n2);
          function $e(e3, t3) {
            if (v)
              return Ke(6, 1, e3, t3);
          }
          function Oe(e3, t3, n2) {
            if (v)
              return Ke(7, 1, e3, t3, n2);
          }
          function Ae(e3, t3, n2) {
            return v ? Ke(8, 1, e3, t3, n2) : 0;
          }
          function Pe(e3, t3) {
            if (v)
              return Ke(9, 1, e3, t3);
          }
          function Ie(e3, t3, n2) {
            if (v)
              return Ke(10, 1, e3, t3, n2);
          }
          function Ee(e3, t3, n2, r3) {
            if (v)
              return Ke(11, 1, e3, t3, n2, r3);
          }
          function Ce(e3, t3, n2, r3) {
            if (v)
              return Ke(12, 1, e3, t3, n2, r3);
          }
          function De(e3, t3, n2, r3) {
            if (v)
              return Ke(13, 1, e3, t3, n2, r3);
          }
          function ke(e3) {
            if (v)
              return Ke(14, 1, e3);
          }
          function Re(e3, t3) {
            if (v)
              return Ke(15, 1, e3, t3);
          }
          function Me(e3, t3, n2) {
            if (v)
              return Ke(16, 1, e3, t3, n2);
          }
          var je = (e3) => {
            if (!L3)
              try {
                if (e3(), !H())
                  try {
                    v ? Et(k) : fe(k);
                  } catch (e4) {
                    e4 instanceof oe || "unwind" == e4 || g(1, e4);
                  }
              } catch (e4) {
                e4 instanceof oe || "unwind" == e4 || g(1, e4);
              }
          };
          function Ne(e3) {
            e3 >>>= 0, "function" == typeof Atomics.Fb && (Atomics.Fb(i(), e3 >> 2, e3).value.then(ze), e3 += 128, Atomics.store(i(), e3 >> 2, 1));
          }
          function ze() {
            var e3 = Tt();
            e3 && (Ne(e3), je(() => Ct()));
          }
          l.__emscripten_thread_mailbox_await = Ne, l.checkMailbox = ze;
          var Le = (e3) => 0 == e3 % 4 && (0 != e3 % 100 || 0 == e3 % 400), Be = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Fe = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
          function Ue(e3, t3, n2, r3, i2, o2, a2, s2) {
            return v ? Ke(17, 1, e3, t3, n2, r3, i2, o2, a2, s2) : -52;
          }
          function Ge(e3, t3, n2, r3, i2, o2, a2) {
            if (v)
              return Ke(18, 1, e3, t3, n2, r3, i2, o2, a2);
          }
          var Ve = (e3) => {
            var t3 = _e(e3) + 1, n2 = St(t3);
            return n2 && Se(e3, n2, t3), n2;
          }, We = [], He = (e3, t3) => {
            var n2;
            for (We.length = 0, t3 >>= 2; n2 = r2()[e3++ >>> 0]; )
              t3 += 105 != n2 & t3, We.push(105 == n2 ? i()[t3 >>> 0] : a()[t3++ >>> 1]), ++t3;
            return We;
          }, qe = (e3) => {
            var t3 = Rt();
            return e3 = e3(), Mt(t3), e3;
          };
          function Ke(e3, t3) {
            var n2 = arguments.length - 2, r3 = arguments;
            return qe(() => {
              for (var i2 = jt(8 * n2), o2 = i2 >> 3, s2 = 0; s2 < n2; s2++) {
                var u2 = r3[2 + s2];
                a()[o2 + s2 >>> 0] = u2;
              }
              return Pt(e3, n2, i2, t3);
            });
          }
          var Xe, Ye = [], Je = {}, Ze = () => {
            if (!Xe) {
              var e3, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: h || "./this.program" };
              for (e3 in Je)
                void 0 === Je[e3] ? delete t3[e3] : t3[e3] = Je[e3];
              var n2 = [];
              for (e3 in t3)
                n2.push(`${e3}=${t3[e3]}`);
              Xe = n2;
            }
            return Xe;
          };
          function Qe(e3, n2) {
            if (v)
              return Ke(19, 1, e3, n2);
            e3 >>>= 0, n2 >>>= 0;
            var r3 = 0;
            return Ze().forEach(function(i2, a2) {
              var s2 = n2 + r3;
              for (a2 = o()[e3 + 4 * a2 >> 2 >>> 0] = s2, s2 = 0; s2 < i2.length; ++s2)
                t2()[a2++ >> 0 >>> 0] = i2.charCodeAt(s2);
              t2()[a2 >> 0 >>> 0] = 0, r3 += i2.length + 1;
            }), 0;
          }
          function et(e3, t3) {
            if (v)
              return Ke(20, 1, e3, t3);
            e3 >>>= 0, t3 >>>= 0;
            var n2 = Ze();
            o()[e3 >> 2 >>> 0] = n2.length;
            var r3 = 0;
            return n2.forEach(function(e4) {
              r3 += e4.length + 1;
            }), o()[t3 >> 2 >>> 0] = r3, 0;
          }
          function tt(e3) {
            return v ? Ke(21, 1, e3) : 52;
          }
          function nt(e3, t3, n2, r3) {
            return v ? Ke(22, 1, e3, t3, n2, r3) : 52;
          }
          function rt(e3, t3, n2, r3, i2) {
            return v ? Ke(23, 1, e3, t3, n2, r3, i2) : 70;
          }
          var it = [null, [], []];
          function ot(e3, t3, n2, i2) {
            if (v)
              return Ke(24, 1, e3, t3, n2, i2);
            t3 >>>= 0, n2 >>>= 0, i2 >>>= 0;
            for (var a2 = 0, s2 = 0; s2 < n2; s2++) {
              var u2 = o()[t3 >> 2 >>> 0], l2 = o()[t3 + 4 >> 2 >>> 0];
              t3 += 8;
              for (var c2 = 0; c2 < l2; c2++) {
                var p2 = r2()[u2 + c2 >>> 0], d2 = it[e3];
                0 === p2 || 10 === p2 ? ((1 === e3 ? A : P)(ce(d2, 0)), d2.length = 0) : d2.push(p2);
              }
              a2 += l2;
            }
            return o()[i2 >> 2 >>> 0] = a2, 0;
          }
          var at = (e3) => (at = (() => {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
              return (e5) => (e5.set(crypto.getRandomValues(new Uint8Array(e5.byteLength))), e5);
            if (y)
              try {
                var e4 = n(760);
                if (e4.randomFillSync)
                  return (t4) => e4.randomFillSync(t4);
                var t3 = e4.randomBytes;
                return (e5) => (e5.set(t3(e5.byteLength)), e5);
              } catch (e5) {
              }
            Q("initRandomDevice");
          })())(e3), st = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ut = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], lt = (e3, n2) => {
            t2().set(e3, n2 >>> 0);
          };
          function ct(e3, t3, n2, r3) {
            function o2(e4, t4, n3) {
              for (e4 = "number" == typeof e4 ? e4.toString() : e4 || ""; e4.length < t4; )
                e4 = n3[0] + e4;
              return e4;
            }
            function a2(e4, t4) {
              return o2(e4, t4, "0");
            }
            function s2(e4, t4) {
              function n3(e5) {
                return 0 > e5 ? -1 : 0 < e5 ? 1 : 0;
              }
              var r4;
              return 0 === (r4 = n3(e4.getFullYear() - t4.getFullYear())) && 0 === (r4 = n3(e4.getMonth() - t4.getMonth())) && (r4 = n3(e4.getDate() - t4.getDate())), r4;
            }
            function u2(e4) {
              switch (e4.getDay()) {
                case 0:
                  return new Date(e4.getFullYear() - 1, 11, 29);
                case 1:
                  return e4;
                case 2:
                  return new Date(e4.getFullYear(), 0, 3);
                case 3:
                  return new Date(e4.getFullYear(), 0, 2);
                case 4:
                  return new Date(e4.getFullYear(), 0, 1);
                case 5:
                  return new Date(e4.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(e4.getFullYear() - 1, 11, 30);
              }
            }
            function l2(e4) {
              var t4 = e4.Sa;
              for (e4 = new Date(new Date(e4.Ta + 1900, 0, 1).getTime()); 0 < t4; ) {
                var n3 = e4.getMonth(), r4 = (Le(e4.getFullYear()) ? st : ut)[n3];
                if (!(t4 > r4 - e4.getDate())) {
                  e4.setDate(e4.getDate() + t4);
                  break;
                }
                t4 -= r4 - e4.getDate() + 1, e4.setDate(1), 11 > n3 ? e4.setMonth(n3 + 1) : (e4.setMonth(0), e4.setFullYear(e4.getFullYear() + 1));
              }
              return n3 = new Date(e4.getFullYear() + 1, 0, 4), t4 = u2(new Date(e4.getFullYear(), 0, 4)), n3 = u2(n3), 0 >= s2(t4, e4) ? 0 >= s2(n3, e4) ? e4.getFullYear() + 1 : e4.getFullYear() : e4.getFullYear() - 1;
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0, r3 >>>= 0;
            var c2 = i()[r3 + 40 >> 2 >>> 0];
            for (var p2 in r3 = { Cb: i()[r3 >> 2 >>> 0], Bb: i()[r3 + 4 >> 2 >>> 0], Va: i()[r3 + 8 >> 2 >>> 0], Za: i()[r3 + 12 >> 2 >>> 0], Wa: i()[r3 + 16 >> 2 >>> 0], Ta: i()[r3 + 20 >> 2 >>> 0], Pa: i()[r3 + 24 >> 2 >>> 0], Sa: i()[r3 + 28 >> 2 >>> 0], Lb: i()[r3 + 32 >> 2 >>> 0], Ab: i()[r3 + 36 >> 2 >>> 0], Db: c2 ? pe(c2) : "" }, n2 = pe(n2), c2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
              n2 = n2.replace(new RegExp(p2, "g"), c2[p2]);
            var d2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f2 = "January February March April May June July August September October November December".split(" ");
            for (p2 in c2 = { "%a": (e4) => d2[e4.Pa].substring(0, 3), "%A": (e4) => d2[e4.Pa], "%b": (e4) => f2[e4.Wa].substring(0, 3), "%B": (e4) => f2[e4.Wa], "%C": (e4) => a2((e4.Ta + 1900) / 100 | 0, 2), "%d": (e4) => a2(e4.Za, 2), "%e": (e4) => o2(e4.Za, 2, " "), "%g": (e4) => l2(e4).toString().substring(2), "%G": (e4) => l2(e4), "%H": (e4) => a2(e4.Va, 2), "%I": (e4) => (0 == (e4 = e4.Va) ? e4 = 12 : 12 < e4 && (e4 -= 12), a2(e4, 2)), "%j": (e4) => {
              for (var t4 = 0, n3 = 0; n3 <= e4.Wa - 1; t4 += (Le(e4.Ta + 1900) ? st : ut)[n3++])
                ;
              return a2(e4.Za + t4, 3);
            }, "%m": (e4) => a2(e4.Wa + 1, 2), "%M": (e4) => a2(e4.Bb, 2), "%n": () => "\n", "%p": (e4) => 0 <= e4.Va && 12 > e4.Va ? "AM" : "PM", "%S": (e4) => a2(e4.Cb, 2), "%t": () => "	", "%u": (e4) => e4.Pa || 7, "%U": (e4) => a2(Math.floor((e4.Sa + 7 - e4.Pa) / 7), 2), "%V": (e4) => {
              var t4 = Math.floor((e4.Sa + 7 - (e4.Pa + 6) % 7) / 7);
              if (2 >= (e4.Pa + 371 - e4.Sa - 2) % 7 && t4++, t4)
                53 == t4 && (4 == (n3 = (e4.Pa + 371 - e4.Sa) % 7) || 3 == n3 && Le(e4.Ta) || (t4 = 1));
              else {
                t4 = 52;
                var n3 = (e4.Pa + 7 - e4.Sa - 1) % 7;
                (4 == n3 || 5 == n3 && Le(e4.Ta % 400 - 1)) && t4++;
              }
              return a2(t4, 2);
            }, "%w": (e4) => e4.Pa, "%W": (e4) => a2(Math.floor((e4.Sa + 7 - (e4.Pa + 6) % 7) / 7), 2), "%y": (e4) => (e4.Ta + 1900).toString().substring(2), "%Y": (e4) => e4.Ta + 1900, "%z": (e4) => {
              var t4 = 0 <= (e4 = e4.Ab);
              return e4 = Math.abs(e4) / 60, (t4 ? "+" : "-") + String("0000" + (e4 / 60 * 100 + e4 % 60)).slice(-4);
            }, "%Z": (e4) => e4.Db, "%%": () => "%" }, n2 = n2.replace(/%%/g, "\0\0"), c2)
              n2.includes(p2) && (n2 = n2.replace(new RegExp(p2, "g"), c2[p2](r3)));
            return p2 = function(e4) {
              var t4 = Array(_e(e4) + 1);
              return Te(e4, t4, 0, t4.length), t4;
            }(n2 = n2.replace(/\0\0/g, "%")), p2.length > t3 ? 0 : (lt(p2, e3), p2.length - 1);
          }
          function pt(e3) {
            try {
              e3();
            } catch (e4) {
              Q(e4);
            }
          }
          var dt = 0, ft = null, ht = 0, gt = [], mt = {}, bt = {}, yt = 0, vt = null, wt = [];
          he.Xa();
          var xt = [null, de, me, ye, we, xe, $e, Oe, Ae, Pe, Ie, Ee, Ce, De, ke, Re, Me, Ue, Ge, Qe, et, tt, nt, rt, ot], _t = { r: function(e3, t3, n2) {
            return function(e4) {
              return function(e5) {
                if (!L3) {
                  if (0 === dt) {
                    var t4 = false, n3 = false;
                    e5((e6 = 0) => {
                      if (!L3 && (ht = e6, t4 = true, n3)) {
                        dt = 2, pt(() => Bt(ft)), "undefined" != typeof Browser && Browser.Ya.kb && Browser.Ya.resume(), e6 = false;
                        try {
                          var r3 = function() {
                            var e7 = i()[ft + 8 >> 2 >>> 0];
                            return e7 = C2[bt[e7]], --W, e7();
                          }();
                        } catch (t5) {
                          r3 = t5, e6 = true;
                        }
                        var o2 = false;
                        if (!ft) {
                          var a2 = vt;
                          a2 && (vt = null, (e6 ? a2.reject : a2.resolve)(r3), o2 = true);
                        }
                        if (e6 && !o2)
                          throw r3;
                      }
                    }), n3 = true, t4 || (dt = 1, ft = function() {
                      var e6 = St(65548), t5 = e6 + 12;
                      o()[e6 >> 2 >>> 0] = t5, o()[e6 + 4 >> 2 >>> 0] = t5 + 65536, t5 = gt[0];
                      var n4 = mt[t5];
                      return void 0 === n4 && (n4 = yt++, mt[t5] = n4, bt[n4] = t5), t5 = n4, i()[e6 + 8 >> 2 >>> 0] = t5, e6;
                    }(), "undefined" != typeof Browser && Browser.Ya.kb && Browser.Ya.pause(), pt(() => zt(ft)));
                  } else
                    2 === dt ? (dt = 0, pt(Ft), $t(ft), ft = null, wt.forEach((e6) => je(e6))) : Q(`invalid state: ${dt}`);
                  return ht;
                }
              }((t4) => {
                e4().then(t4);
              });
            }(async () => {
              await l.pb(e3, t3, n2);
            });
          }, b: function(e3, t3, n2) {
            throw new be(e3 >>>= 0).Xa(t3 >>> 0, n2 >>> 0), e3;
          }, O: function(e3) {
            Ot(e3 >>> 0, !b, 1, !m, 131072, false), he.cb();
          }, m: function(e3) {
            e3 >>>= 0, v ? postMessage({ cmd: "cleanupThread", thread: e3 }) : se(e3);
          }, J: ve, i: we, U: xe, G: $e, I: Oe, V: Ae, S: Pe, K: Ie, R: Ee, q: Ce, H: De, E: ke, T: Re, F: Me, Y: () => true, C: function(e3, t3) {
            (e3 >>>= 0) == t3 >>> 0 ? setTimeout(() => ze()) : v ? postMessage({ targetThread: e3, cmd: "checkMailbox" }) : (e3 = he.Ja[e3]) && e3.postMessage({ cmd: "checkMailbox" });
          }, M: function() {
            return -1;
          }, N: Ne, X: function(e3) {
            y && he.Ja[e3 >>> 0].ref();
          }, u: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), i()[n2 >> 2 >>> 0] = e3.getUTCSeconds(), i()[n2 + 4 >> 2 >>> 0] = e3.getUTCMinutes(), i()[n2 + 8 >> 2 >>> 0] = e3.getUTCHours(), i()[n2 + 12 >> 2 >>> 0] = e3.getUTCDate(), i()[n2 + 16 >> 2 >>> 0] = e3.getUTCMonth(), i()[n2 + 20 >> 2 >>> 0] = e3.getUTCFullYear() - 1900, i()[n2 + 24 >> 2 >>> 0] = e3.getUTCDay(), e3 = (e3.getTime() - Date.UTC(e3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[n2 + 28 >> 2 >>> 0] = e3;
          }, v: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), i()[n2 >> 2 >>> 0] = e3.getSeconds(), i()[n2 + 4 >> 2 >>> 0] = e3.getMinutes(), i()[n2 + 8 >> 2 >>> 0] = e3.getHours(), i()[n2 + 12 >> 2 >>> 0] = e3.getDate(), i()[n2 + 16 >> 2 >>> 0] = e3.getMonth(), i()[n2 + 20 >> 2 >>> 0] = e3.getFullYear() - 1900, i()[n2 + 24 >> 2 >>> 0] = e3.getDay(), t3 = (Le(e3.getFullYear()) ? Be : Fe)[e3.getMonth()] + e3.getDate() - 1 | 0, i()[n2 + 28 >> 2 >>> 0] = t3, i()[n2 + 36 >> 2 >>> 0] = -60 * e3.getTimezoneOffset(), t3 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset();
            var r3 = new Date(e3.getFullYear(), 0, 1).getTimezoneOffset();
            e3 = 0 | (t3 != r3 && e3.getTimezoneOffset() == Math.min(r3, t3)), i()[n2 + 32 >> 2 >>> 0] = e3;
          }, w: function(e3) {
            e3 >>>= 0;
            var t3 = new Date(i()[e3 + 20 >> 2 >>> 0] + 1900, i()[e3 + 16 >> 2 >>> 0], i()[e3 + 12 >> 2 >>> 0], i()[e3 + 8 >> 2 >>> 0], i()[e3 + 4 >> 2 >>> 0], i()[e3 >> 2 >>> 0], 0), n2 = i()[e3 + 32 >> 2 >>> 0], r3 = t3.getTimezoneOffset(), o2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), a2 = new Date(t3.getFullYear(), 0, 1).getTimezoneOffset(), s2 = Math.min(a2, o2);
            return 0 > n2 ? i()[e3 + 32 >> 2 >>> 0] = Number(o2 != a2 && s2 == r3) : 0 < n2 != (s2 == r3) && (o2 = Math.max(a2, o2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? s2 : o2) - r3))), i()[e3 + 24 >> 2 >>> 0] = t3.getDay(), n2 = (Le(t3.getFullYear()) ? Be : Fe)[t3.getMonth()] + t3.getDate() - 1 | 0, i()[e3 + 28 >> 2 >>> 0] = n2, i()[e3 >> 2 >>> 0] = t3.getSeconds(), i()[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), i()[e3 + 8 >> 2 >>> 0] = t3.getHours(), i()[e3 + 12 >> 2 >>> 0] = t3.getDate(), i()[e3 + 16 >> 2 >>> 0] = t3.getMonth(), i()[e3 + 20 >> 2 >>> 0] = t3.getYear(), e3 = t3.getTime() / 1e3, Dt((re = e3, 1 <= +Math.abs(re) ? 0 < re ? +Math.floor(re / 4294967296) >>> 0 : ~~+Math.ceil((re - +(~~re >>> 0)) / 4294967296) >>> 0 : 0)), e3 >>> 0;
          }, s: Ue, t: Ge, A: function(e3, t3, n2) {
            function r3(e4) {
              return (e4 = e4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e4[1] : "GMT";
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0;
            var a2 = (/* @__PURE__ */ new Date()).getFullYear(), s2 = new Date(a2, 0, 1), u2 = new Date(a2, 6, 1);
            a2 = s2.getTimezoneOffset();
            var l2 = u2.getTimezoneOffset(), c2 = Math.max(a2, l2);
            o()[e3 >> 2 >>> 0] = 60 * c2, i()[t3 >> 2 >>> 0] = Number(a2 != l2), e3 = r3(s2), t3 = r3(u2), e3 = Ve(e3), t3 = Ve(t3), l2 < a2 ? (o()[n2 >> 2 >>> 0] = e3, o()[n2 + 4 >> 2 >>> 0] = t3) : (o()[n2 >> 2 >>> 0] = t3, o()[n2 + 4 >> 2 >>> 0] = e3);
          }, d: () => {
            Q("");
          }, c: function(e3, t3, n2) {
            return e3 >>>= 0, t3 = He(t3 >>> 0, n2 >>> 0), ie[e3].apply(null, t3);
          }, l: function(e3, t3, n2) {
            return e3 >>>= 0, t3 = He(t3 >>> 0, n2 >>> 0), ie[e3].apply(null, t3);
          }, n: function() {
          }, j: function() {
            return Date.now();
          }, W: () => {
            throw W += 1, "unwind";
          }, D: function() {
            return 4294901760;
          }, f: () => performance.timeOrigin + performance.now(), g: function() {
            return y ? n(3993).cpus().length : navigator.hardwareConcurrency;
          }, L: function(e3, t3, n2, r3) {
            for (he.Hb = t3 >>> 0, Ye.length = n2, t3 = r3 >>> 0 >> 3, r3 = 0; r3 < n2; r3++)
              Ye[r3] = a()[t3 + r3 >>> 0];
            return (0 > e3 ? ie[-e3 - 1] : xt[e3]).apply(null, Ye);
          }, z: function(e3) {
            e3 >>>= 0;
            var t3 = r2().length;
            if (e3 <= t3 || 4294901760 < e3)
              return false;
            for (var n2 = 1; 4 >= n2; n2 *= 2) {
              var i2 = t3 * (1 + 0.2 / n2);
              i2 = Math.min(i2, e3 + 100663296);
              var o2 = Math;
              i2 = Math.max(e3, i2);
              e: {
                o2 = o2.min.call(o2, 4294901760, i2 + (65536 - i2 % 65536) % 65536) - E.buffer.byteLength + 65535 >>> 16;
                try {
                  E.grow(o2), B();
                  var a2 = 1;
                  break e;
                } catch (e4) {
                }
                a2 = void 0;
              }
              if (a2)
                return true;
            }
            return false;
          }, P: Qe, Q: et, k: fe, h: tt, p: nt, x: rt, o: ot, y: function(e3, t3) {
            return e3 >>>= 0, t3 >>>= 0, at(r2().subarray(e3 >>> 0, e3 + t3 >>> 0)), 0;
          }, a: E || l.wasmMemory, B: ct, e: function(e3, t3, n2, r3) {
            return ct(e3 >>> 0, t3 >>> 0, n2 >>> 0, r3 >>> 0);
          } };
          !function() {
            function e3(e4, t4) {
              return e4 = function(e5) {
                var t5, n2 = {};
                for (t5 in e5)
                  !function(t6) {
                    var r3 = e5[t6];
                    n2[t6] = "function" == typeof r3 ? function() {
                      gt.push(t6);
                      try {
                        return r3.apply(null, arguments);
                      } finally {
                        L3 || (gt.pop() === t6 || Q(), ft && 1 === dt && 0 === gt.length && (dt = 0, W += 1, pt(Lt), "undefined" != typeof Fibers && Fibers.Mb()));
                      }
                    } : r3;
                  }(t5);
                return n2;
              }(e4 = e4.exports), C2 = e4 = function(e5) {
                var t5 = (e6) => () => e6() >>> 0, n2 = (e6) => (t6) => e6(t6) >>> 0;
                return (e5 = Object.assign({}, e5)).__errno_location = t5(e5.__errno_location), e5.pthread_self = t5(e5.pthread_self), e5.malloc = n2(e5.malloc), e5.stackSave = t5(e5.stackSave), e5.stackAlloc = n2(e5.stackAlloc), e5;
              }(e4), he.eb.push(C2.wa), G.unshift(C2.Z), D = t4, Z(), e4;
            }
            var t3 = { a: _t };
            if (J(), l.instantiateWasm)
              try {
                return l.instantiateWasm(t3, e3);
              } catch (e4) {
                P("Module.instantiateWasm callback failed with error: " + e4), u(e4);
              }
            (function(e4, t4) {
              var n2 = q;
              return O || "function" != typeof WebAssembly.instantiateStreaming || ee(n2) || n2.startsWith("file://") || y || "function" != typeof fetch ? ne(n2, e4, t4) : fetch(n2, { credentials: "same-origin" }).then((r3) => WebAssembly.instantiateStreaming(r3, e4).then(t4, function(r4) {
                return P("wasm streaming compile failed: " + r4), P("falling back to ArrayBuffer instantiation"), ne(n2, e4, t4);
              }));
            })(t3, function(t4) {
              e3(t4.instance, t4.module);
            }).catch(u);
          }(), l._OrtInit = (e3, t3) => (l._OrtInit = C2._)(e3, t3), l._OrtGetLastError = (e3, t3) => (l._OrtGetLastError = C2.$)(e3, t3), l._OrtCreateSessionOptions = (e3, t3, n2, r3, i2, o2, a2, s2, u2, c2) => (l._OrtCreateSessionOptions = C2.aa)(e3, t3, n2, r3, i2, o2, a2, s2, u2, c2), l._OrtAppendExecutionProvider = (e3, t3) => (l._OrtAppendExecutionProvider = C2.ba)(e3, t3), l._OrtAddSessionConfigEntry = (e3, t3, n2) => (l._OrtAddSessionConfigEntry = C2.ca)(e3, t3, n2), l._OrtReleaseSessionOptions = (e3) => (l._OrtReleaseSessionOptions = C2.da)(e3), l._OrtCreateSession = (e3, t3, n2) => (l._OrtCreateSession = C2.ea)(e3, t3, n2), l._OrtReleaseSession = (e3) => (l._OrtReleaseSession = C2.fa)(e3), l._OrtGetInputOutputCount = (e3, t3, n2) => (l._OrtGetInputOutputCount = C2.ga)(e3, t3, n2), l._OrtGetInputName = (e3, t3) => (l._OrtGetInputName = C2.ha)(e3, t3), l._OrtGetOutputName = (e3, t3) => (l._OrtGetOutputName = C2.ia)(e3, t3), l._OrtFree = (e3) => (l._OrtFree = C2.ja)(e3), l._OrtCreateTensor = (e3, t3, n2, r3, i2) => (l._OrtCreateTensor = C2.ka)(e3, t3, n2, r3, i2), l._OrtGetTensorData = (e3, t3, n2, r3, i2) => (l._OrtGetTensorData = C2.la)(e3, t3, n2, r3, i2), l._OrtReleaseTensor = (e3) => (l._OrtReleaseTensor = C2.ma)(e3), l._OrtCreateRunOptions = (e3, t3, n2, r3) => (l._OrtCreateRunOptions = C2.na)(e3, t3, n2, r3), l._OrtAddRunConfigEntry = (e3, t3, n2) => (l._OrtAddRunConfigEntry = C2.oa)(e3, t3, n2), l._OrtReleaseRunOptions = (e3) => (l._OrtReleaseRunOptions = C2.pa)(e3), l._OrtRun = (e3, t3, n2, r3, i2, o2, a2, s2) => (l._OrtRun = C2.qa)(e3, t3, n2, r3, i2, o2, a2, s2), l._OrtEndProfiling = (e3) => (l._OrtEndProfiling = C2.ra)(e3), l._JsepOutput = (e3, t3, n2) => (l._JsepOutput = C2.sa)(e3, t3, n2);
          var Tt = l._pthread_self = () => (Tt = l._pthread_self = C2.ta)(), St = l._malloc = (e3) => (St = l._malloc = C2.ua)(e3), $t = l._free = (e3) => ($t = l._free = C2.va)(e3);
          l.__emscripten_tls_init = () => (l.__emscripten_tls_init = C2.wa)();
          var Ot = l.__emscripten_thread_init = (e3, t3, n2, r3, i2, o2) => (Ot = l.__emscripten_thread_init = C2.ya)(e3, t3, n2, r3, i2, o2);
          l.__emscripten_thread_crashed = () => (l.__emscripten_thread_crashed = C2.za)();
          var At, Pt = (e3, t3, n2, r3) => (Pt = C2.Aa)(e3, t3, n2, r3), It = (e3) => (It = C2.Ba)(e3), Et = l.__emscripten_thread_exit = (e3) => (Et = l.__emscripten_thread_exit = C2.Ca)(e3), Ct = l.__emscripten_check_mailbox = () => (Ct = l.__emscripten_check_mailbox = C2.Da)(), Dt = (e3) => (Dt = C2.Ea)(e3), kt = (e3, t3) => (kt = C2.Fa)(e3, t3), Rt = () => (Rt = C2.Ga)(), Mt = (e3) => (Mt = C2.Ha)(e3), jt = (e3) => (jt = C2.Ia)(e3), Nt = l.dynCall_ii = (e3, t3) => (Nt = l.dynCall_ii = C2.Ka)(e3, t3), zt = (e3) => (zt = C2.La)(e3), Lt = () => (Lt = C2.Ma)(), Bt = (e3) => (Bt = C2.Na)(e3), Ft = () => (Ft = C2.Oa)();
          function Ut() {
            function e3() {
              if (!At && (At = true, l.calledRun = true, !L3) && (v || ge(G), s(l), l.onRuntimeInitialized && l.onRuntimeInitialized(), !v)) {
                if (l.postRun)
                  for ("function" == typeof l.postRun && (l.postRun = [l.postRun]); l.postRun.length; ) {
                    var e4 = l.postRun.shift();
                    V.unshift(e4);
                  }
                ge(V);
              }
            }
            if (!(0 < K))
              if (v)
                s(l), v || ge(G), startWorker(l);
              else {
                if (l.preRun)
                  for ("function" == typeof l.preRun && (l.preRun = [l.preRun]); l.preRun.length; )
                    U.unshift(l.preRun.shift());
                ge(U), 0 < K || (l.setStatus ? (l.setStatus("Running..."), setTimeout(function() {
                  setTimeout(function() {
                    l.setStatus("");
                  }, 1), e3();
                }, 1)) : e3());
              }
          }
          if (l.___start_em_js = 908408, l.___stop_em_js = 908569, l.keepRuntimeAlive = H, l.wasmMemory = E, l.stackAlloc = jt, l.stackSave = Rt, l.stackRestore = Mt, l.UTF8ToString = pe, l.stringToUTF8 = Se, l.lengthBytesUTF8 = _e, l.ExitStatus = oe, l.PThread = he, Y = function e3() {
            At || Ut(), At || (Y = e3);
          }, l.preInit)
            for ("function" == typeof l.preInit && (l.preInit = [l.preInit]); 0 < l.preInit.length; )
              l.preInit.pop()();
          return Ut(), e2.ready;
        });
        e.exports = r;
      }, 9377: (e, t, n) => {
        var _scriptDir, r = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, "undefined" != typeof __filename && (_scriptDir = _scriptDir || __filename), function(e2 = {}) {
          var t2, r2, i = e2;
          i.ready = new Promise((e3, n2) => {
            t2 = e3, r2 = n2;
          }), i.jsepInit = function(e3, t3, n2, r3, o2, a2, s2, u2) {
            i.Sa = e3, i.Ea = t3, i.Ga = n2, i.Ca = r3, i.Fa = o2, i.la = a2, i.Ha = s2, i.Ia = u2;
          };
          var o, a, s, u = Object.assign({}, i), l = "./this.program", c = (e3, t3) => {
            throw t3;
          }, p = "object" == typeof window, d = "function" == typeof importScripts, f = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, h = "";
          if (f) {
            var g = n(1384), m = n(908);
            h = d ? m.dirname(h) + "/" : __dirname + "/", o = (e3, t3) => (e3 = e3.startsWith("file://") ? new URL(e3) : m.normalize(e3), g.readFileSync(e3, t3 ? void 0 : "utf8")), s = (e3) => ((e3 = o(e3, true)).buffer || (e3 = new Uint8Array(e3)), e3), a = (e3, t3, n2, r3 = true) => {
              e3 = e3.startsWith("file://") ? new URL(e3) : m.normalize(e3), g.readFile(e3, r3 ? void 0 : "utf8", (e4, i2) => {
                e4 ? n2(e4) : t3(r3 ? i2.buffer : i2);
              });
            }, !i.thisProgram && 1 < process.argv.length && (l = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), c = (e3, t3) => {
              throw process.exitCode = e3, t3;
            }, i.inspect = () => "[Emscripten Module object]";
          } else
            (p || d) && (d ? h = self.location.href : "undefined" != typeof document && document.currentScript && (h = document.currentScript.src), _scriptDir && (h = _scriptDir), h = 0 !== h.indexOf("blob:") ? h.substr(0, h.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", o = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.send(null), t3.responseText;
            }, d && (s = (e3) => {
              var t3 = new XMLHttpRequest();
              return t3.open("GET", e3, false), t3.responseType = "arraybuffer", t3.send(null), new Uint8Array(t3.response);
            }), a = (e3, t3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", e3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? t3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            });
          var b, y = i.print || console.log.bind(console), v = i.printErr || console.error.bind(console);
          Object.assign(i, u), u = null, i.thisProgram && (l = i.thisProgram), i.quit && (c = i.quit), i.wasmBinary && (b = i.wasmBinary);
          var w = i.noExitRuntime || true;
          "object" != typeof WebAssembly && L3("no native wasm support detected");
          var x, _, T, S, $, O, A, P, I = false;
          function E() {
            var e3 = x.buffer;
            i.HEAP8 = S = new Int8Array(e3), i.HEAP16 = new Int16Array(e3), i.HEAP32 = O = new Int32Array(e3), i.HEAPU8 = $ = new Uint8Array(e3), i.HEAPU16 = new Uint16Array(e3), i.HEAPU32 = A = new Uint32Array(e3), i.HEAPF32 = new Float32Array(e3), i.HEAPF64 = P = new Float64Array(e3);
          }
          var C2 = [], D = [], k = [];
          function R() {
            var e3 = i.preRun.shift();
            C2.unshift(e3);
          }
          var M, j = 0, N3 = null, z = null;
          function L3(e3) {
            throw i.onAbort && i.onAbort(e3), v(e3 = "Aborted(" + e3 + ")"), I = true, T = 1, e3 = new WebAssembly.RuntimeError(e3 + ". Build with -sASSERTIONS for more info."), r2(e3), e3;
          }
          function B(e3) {
            return e3.startsWith("data:application/octet-stream;base64,");
          }
          if (!B(M = "ort-wasm-simd.wasm")) {
            var F = M;
            M = i.locateFile ? i.locateFile(F, h) : h + F;
          }
          function U(e3) {
            if (e3 == M && b)
              return new Uint8Array(b);
            if (s)
              return s(e3);
            throw "both async and sync fetching of the wasm failed";
          }
          function G(e3, t3, n2) {
            return function(e4) {
              if (!b && (p || d)) {
                if ("function" == typeof fetch && !e4.startsWith("file://"))
                  return fetch(e4, { credentials: "same-origin" }).then((t4) => {
                    if (!t4.ok)
                      throw "failed to load wasm binary file at '" + e4 + "'";
                    return t4.arrayBuffer();
                  }).catch(() => U(e4));
                if (a)
                  return new Promise((t4, n3) => {
                    a(e4, (e5) => t4(new Uint8Array(e5)), n3);
                  });
              }
              return Promise.resolve().then(() => U(e4));
            }(e3).then((e4) => WebAssembly.instantiate(e4, t3)).then((e4) => e4).then(n2, (e4) => {
              v("failed to asynchronously prepare wasm: " + e4), L3(e4);
            });
          }
          var V, W = { 894528: () => {
            i.jsepRunPromise = new Promise(function(e3) {
              i.Ja = e3;
            });
          }, 894623: (e3) => {
            i.Ja(e3);
          }, 894661: (e3) => i.Ea(e3), 894694: (e3) => i.Ga(e3), 894726: (e3, t3, n2) => {
            i.Ca(e3, t3, n2, true);
          }, 894765: (e3, t3, n2) => {
            i.Ca(e3, t3, n2);
          }, 894798: (e3) => {
            i.la("Abs", e3, void 0);
          }, 894849: (e3) => {
            i.la("Neg", e3, void 0);
          }, 894900: (e3) => {
            i.la("Floor", e3, void 0);
          }, 894953: (e3) => {
            i.la("Ceil", e3, void 0);
          }, 895005: (e3) => {
            i.la("Reciprocal", e3, void 0);
          }, 895063: (e3) => {
            i.la("Sqrt", e3, void 0);
          }, 895115: (e3) => {
            i.la("Exp", e3, void 0);
          }, 895166: (e3) => {
            i.la("Erf", e3, void 0);
          }, 895217: (e3) => {
            i.la("Sigmoid", e3, void 0);
          }, 895272: (e3) => {
            i.la("Log", e3, void 0);
          }, 895323: (e3) => {
            i.la("Sin", e3, void 0);
          }, 895374: (e3) => {
            i.la("Cos", e3, void 0);
          }, 895425: (e3) => {
            i.la("Tan", e3, void 0);
          }, 895476: (e3) => {
            i.la("Asin", e3, void 0);
          }, 895528: (e3) => {
            i.la("Acos", e3, void 0);
          }, 895580: (e3) => {
            i.la("Atan", e3, void 0);
          }, 895632: (e3) => {
            i.la("Sinh", e3, void 0);
          }, 895684: (e3) => {
            i.la("Cosh", e3, void 0);
          }, 895736: (e3) => {
            i.la("Asinh", e3, void 0);
          }, 895789: (e3) => {
            i.la("Acosh", e3, void 0);
          }, 895842: (e3) => {
            i.la("Atanh", e3, void 0);
          }, 895895: (e3) => {
            i.la("Tanh", e3, void 0);
          }, 895947: (e3, t3, n2) => {
            i.la("ClipV10", e3, { min: t3, max: n2 });
          }, 896019: (e3) => {
            i.la("Clip", e3, void 0);
          }, 896071: (e3, t3) => {
            i.la("Elu", e3, { alpha: t3 });
          }, 896129: (e3) => {
            i.la("Relu", e3, void 0);
          }, 896181: (e3, t3) => {
            i.la("LeakyRelu", e3, { alpha: t3 });
          }, 896245: (e3, t3) => {
            i.la("ThresholdedRelu", e3, { alpha: t3 });
          }, 896315: (e3, t3) => {
            i.la("Cast", e3, { to: t3 });
          }, 896373: (e3) => {
            i.la("Add", e3, void 0);
          }, 896424: (e3) => {
            i.la("Sub", e3, void 0);
          }, 896475: (e3) => {
            i.la("Mul", e3, void 0);
          }, 896526: (e3) => {
            i.la("Div", e3, void 0);
          }, 896577: (e3) => {
            i.la("Pow", e3, void 0);
          }, 896628: (e3, t3, n2, r3, o2) => {
            i.la("ReduceMean", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 896792: (e3, t3, n2, r3, o2) => {
            i.la("ReduceMax", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 896955: (e3, t3, n2, r3, o2) => {
            i.la("ReduceMin", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 897118: (e3, t3, n2, r3, o2) => {
            i.la("ReduceProd", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 897282: (e3, t3, n2, r3, o2) => {
            i.la("ReduceSum", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 897445: (e3, t3, n2, r3, o2) => {
            i.la("ReduceL1", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 897607: (e3, t3, n2, r3, o2) => {
            i.la("ReduceL2", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 897769: (e3, t3, n2, r3, o2) => {
            i.la("ReduceLogSum", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 897935: (e3, t3, n2, r3, o2) => {
            i.la("ReduceSumSquare", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 898104: (e3, t3, n2, r3, o2) => {
            i.la("ReduceLogSumExp", e3, { keepDims: !!t3, noopWithEmptyAxes: !!n2, axes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 898273: (e3, t3, n2) => {
            i.la("Transpose", e3, { perm: t3 ? Array.from(O.subarray(n2 >>> 0, n2 + t3 >>> 0)) : [] });
          }, 898386: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2) => {
            i.la("Conv", e3, { format: l2 ? "NHWC" : "NCHW", auto_pad: t3, dilations: [n2], group: r3, kernel_shape: [o2], pads: [a2, s2], strides: [u2], w_is_const: () => !!S[c2 >>> 0] });
          }, 898614: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2, g2) => {
            i.la("Conv", e3, { format: h2 ? "NHWC" : "NCHW", auto_pad: t3, dilations: [n2, r3], group: o2, kernel_shape: [a2, s2], pads: [u2, l2, c2, p2], strides: [d2, f2], w_is_const: () => !!S[g2 >>> 0] });
          }, 898873: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2) => {
            i.la("Conv", e3, { format: l2 ? "NHWC" : "NCHW", auto_pad: t3, dilations: [n2], group: r3, kernel_shape: [o2], pads: [a2, s2], strides: [u2], w_is_const: () => !!S[c2 >>> 0] });
          }, 899101: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2, g2) => {
            i.la("Conv", e3, { format: h2 ? "NHWC" : "NCHW", auto_pad: t3, dilations: [n2, r3], group: o2, kernel_shape: [a2, s2], pads: [u2, l2, c2, p2], strides: [d2, f2], w_is_const: () => !!S[g2 >>> 0] });
          }, 899360: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2) => {
            i.la("ConvTranspose", e3, { format: l2 ? "NHWC" : "NCHW", autoPad: t3, dilations: [n2], group: r3, kernel_shape: [o2], pads: [a2, s2], strides: [u2], wIsConst: () => !!S[c2 >>> 0], outputPadding: p2 ? Array.from(O.subarray(d2 >>> 0, d2 + p2 >>> 0)) : [], outputShape: f2 ? Array.from(O.subarray(h2 >>> 0, h2 + f2 >>> 0)) : [] });
          }, 899740: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2) => {
            i.la("ConvTranspose", e3, { format: u2 ? "NHWC" : "NCHW", autoPad: t3, dilations: Array.from(O.subarray(n2 >>> 0, n2 + 2 >>> 0)), group: r3, kernelShape: Array.from(O.subarray(o2 >>> 0, o2 + 2 >>> 0)), pads: Array.from(O.subarray(a2 >>> 0, a2 + 4 >>> 0)), strides: Array.from(O.subarray(s2 >>> 0, s2 + 2 >>> 0)), wIsConst: () => !!S[l2 >>> 0], outputPadding: 0 < c2 ? Array.from(O.subarray(p2 >>> 0, p2 + c2 >>> 0)) : [], outputShape: 0 < d2 ? Array.from(O.subarray(f2 >>> 0, f2 + d2 >>> 0)) : [] });
          }, 900263: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2) => {
            i.la("ConvTranspose", e3, { format: l2 ? "NHWC" : "NCHW", autoPad: t3, dilations: [n2], group: r3, kernel_shape: [o2], pads: [a2, s2], strides: [u2], wIsConst: () => !!S[c2 >>> 0], outputPadding: p2 ? Array.from(O.subarray(d2 >>> 0, d2 + p2 >>> 0)) : [], outputShape: f2 ? Array.from(O.subarray(h2 >>> 0, h2 + f2 >>> 0)) : [] });
          }, 900643: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2) => {
            i.la("ConvTranspose", e3, { format: u2 ? "NHWC" : "NCHW", autoPad: t3, dilations: Array.from(O.subarray(n2 >>> 0, n2 + 2 >>> 0)), group: r3, kernelShape: Array.from(O.subarray(o2 >>> 0, o2 + 2 >>> 0)), pads: Array.from(O.subarray(a2 >>> 0, a2 + 4 >>> 0)), strides: Array.from(O.subarray(s2 >>> 0, s2 + 2 >>> 0)), wIsConst: () => !!S[l2 >>> 0], outputPadding: 0 < c2 ? Array.from(O.subarray(p2 >>> 0, p2 + c2 >>> 0)) : [], outputShape: 0 < d2 ? Array.from(O.subarray(f2 >>> 0, f2 + d2 >>> 0)) : [] });
          }, 901166: (e3, t3) => {
            i.la("GlobalAveragePool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 901257: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2, g2, m2) => {
            i.la("AveragePool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: o2, dilations: [a2, s2], kernel_shape: [u2, l2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 901541: (e3, t3) => {
            i.la("GlobalAveragePool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 901632: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2, g2, m2) => {
            i.la("AveragePool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: o2, dilations: [a2, s2], kernel_shape: [u2, l2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 901916: (e3, t3) => {
            i.la("GlobalMaxPool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 902003: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2, g2, m2) => {
            i.la("MaxPool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: o2, dilations: [a2, s2], kernel_shape: [u2, l2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 902283: (e3, t3) => {
            i.la("GlobalMaxPool", e3, { format: t3 ? "NHWC" : "NCHW" });
          }, 902370: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2, d2, f2, h2, g2, m2) => {
            i.la("MaxPool", e3, { format: m2 ? "NHWC" : "NCHW", auto_pad: t3, ceil_mode: n2, count_include_pad: r3, storage_order: o2, dilations: [a2, s2], kernel_shape: [u2, l2], pads: [c2, p2, d2, f2], strides: [h2, g2] });
          }, 902650: (e3, t3, n2, r3, o2) => {
            i.la("Gemm", e3, { alpha: t3, beta: n2, transA: r3, transB: o2 });
          }, 902754: (e3) => {
            i.la("MatMul", e3, void 0);
          }, 902808: (e3, t3, n2, r3) => {
            i.la("ArgMax", e3, { keepDims: !!t3, selectLastIndex: !!n2, axis: r3 });
          }, 902916: (e3, t3, n2, r3) => {
            i.la("ArgMin", e3, { keepDims: !!t3, selectLastIndex: !!n2, axis: r3 });
          }, 903024: (e3, t3) => {
            i.la("Softmax", e3, { axis: t3 });
          }, 903087: (e3, t3) => {
            i.la("Concat", e3, { axis: t3 });
          }, 903147: (e3, t3, n2, r3, o2) => {
            i.la("Split", e3, { axis: t3, numOutputs: n2, splitSizes: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [] });
          }, 903292: (e3) => {
            i.la("Expand", e3, void 0);
          }, 903346: (e3, t3) => {
            i.la("Gather", e3, { axis: Number(t3) });
          }, 903417: (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2, p2) => {
            i.la("Resize", e3, { antialias: t3, axes: n2 ? Array.from(O.subarray(r3 >>> 0, r3 + n2 >>> 0)) : [], coordinateTransformMode: Z(o2), cubicCoeffA: a2, excludeOutside: s2, extrapolationValue: u2, keepAspectRatioPolicy: Z(l2), mode: Z(c2), nearestMode: Z(p2) });
          }, 903768: (e3, t3, n2, r3, o2, a2, s2) => {
            i.la("Slice", e3, { starts: t3 ? Array.from(O.subarray(n2 >>> 0, n2 + t3 >>> 0)) : [], ends: r3 ? Array.from(O.subarray(o2 >>> 0, o2 + r3 >>> 0)) : [], axes: a2 ? Array.from(O.subarray(s2 >>> 0, s2 + a2 >>> 0)) : [] });
          }, 903999: (e3) => {
            i.la("Tile", e3, void 0);
          }, 904051: (e3, t3, n2) => {
            i.la("LayerNormalization", e3, { axis: Number(t3), epsilon: Number(n2) });
          }, 904158: (e3, t3, n2) => {
            i.la("InstanceNormalization", e3, { epsilon: t3, format: n2 ? "NHWC" : "NCHW" });
          }, 904272: (e3, t3, n2) => {
            i.la("InstanceNormalization", e3, { epsilon: t3, format: n2 ? "NHWC" : "NCHW" });
          }, 904386: (e3) => {
            i.la("Gelu", e3, void 0);
          }, 904438: (e3, t3) => {
            i.la("SkipLayerNormalization", e3, { epsilon: t3 });
          }, 904519: (e3) => {
            i.Ha(e3);
          }, 904553: (e3, t3) => i.Ia(e3, t3) };
          function H(e3) {
            this.name = "ExitStatus", this.message = `Program terminated with exit(${e3})`, this.status = e3;
          }
          var q = (e3) => {
            for (; 0 < e3.length; )
              e3.shift()(i);
          };
          function K(e3) {
            this.za = e3 - 24, this.Ra = function(e4) {
              A[this.za + 4 >> 2 >>> 0] = e4;
            }, this.Qa = function(e4) {
              A[this.za + 8 >> 2 >>> 0] = e4;
            }, this.Ka = function(e4, t3) {
              this.Pa(), this.Ra(e4), this.Qa(t3);
            }, this.Pa = function() {
              A[this.za + 16 >> 2 >>> 0] = 0;
            };
          }
          var X, Y = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, J = (e3, t3, n2) => {
            var r3 = (t3 >>>= 0) + n2;
            for (n2 = t3; e3[n2] && !(n2 >= r3); )
              ++n2;
            if (16 < n2 - t3 && e3.buffer && Y)
              return Y.decode(e3.subarray(t3, n2));
            for (r3 = ""; t3 < n2; ) {
              var i2 = e3[t3++];
              if (128 & i2) {
                var o2 = 63 & e3[t3++];
                if (192 == (224 & i2))
                  r3 += String.fromCharCode((31 & i2) << 6 | o2);
                else {
                  var a2 = 63 & e3[t3++];
                  65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & e3[t3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                }
              } else
                r3 += String.fromCharCode(i2);
            }
            return r3;
          }, Z = (e3, t3) => (e3 >>>= 0) ? J($, e3, t3) : "", Q = (e3) => {
            for (var t3 = 0, n2 = 0; n2 < e3.length; ++n2) {
              var r3 = e3.charCodeAt(n2);
              127 >= r3 ? t3++ : 2047 >= r3 ? t3 += 2 : 55296 <= r3 && 57343 >= r3 ? (t3 += 4, ++n2) : t3 += 3;
            }
            return t3;
          }, ee = (e3, t3, n2, r3) => {
            if (!(0 < r3))
              return 0;
            var i2 = n2 >>>= 0;
            r3 = n2 + r3 - 1;
            for (var o2 = 0; o2 < e3.length; ++o2) {
              var a2 = e3.charCodeAt(o2);
              if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++o2)), 127 >= a2) {
                if (n2 >= r3)
                  break;
                t3[n2++ >>> 0] = a2;
              } else {
                if (2047 >= a2) {
                  if (n2 + 1 >= r3)
                    break;
                  t3[n2++ >>> 0] = 192 | a2 >> 6;
                } else {
                  if (65535 >= a2) {
                    if (n2 + 2 >= r3)
                      break;
                    t3[n2++ >>> 0] = 224 | a2 >> 12;
                  } else {
                    if (n2 + 3 >= r3)
                      break;
                    t3[n2++ >>> 0] = 240 | a2 >> 18, t3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                  }
                  t3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                }
                t3[n2++ >>> 0] = 128 | 63 & a2;
              }
            }
            return t3[n2 >>> 0] = 0, n2 - i2;
          }, te = (e3) => 0 == e3 % 4 && (0 != e3 % 100 || 0 == e3 % 400), ne = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], re = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], ie = (e3) => {
            var t3 = Q(e3) + 1, n2 = Ae(t3);
            return n2 && ee(e3, $, n2, t3), n2;
          }, oe = [], ae = (e3, t3) => {
            var n2;
            for (oe.length = 0, t3 >>= 2; n2 = $[e3++ >>> 0]; )
              t3 += 105 != n2 & t3, oe.push(105 == n2 ? O[t3 >>> 0] : P[t3++ >>> 1]), ++t3;
            return oe;
          }, se = {}, ue = () => {
            if (!X) {
              var e3, t3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: l || "./this.program" };
              for (e3 in se)
                void 0 === se[e3] ? delete t3[e3] : t3[e3] = se[e3];
              var n2 = [];
              for (e3 in t3)
                n2.push(`${e3}=${t3[e3]}`);
              X = n2;
            }
            return X;
          }, le = (e3) => {
            T = e3, w || (i.onExit && i.onExit(e3), I = true), c(e3, new H(e3));
          }, ce = [null, [], []], pe = (e3) => (pe = (() => {
            if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues)
              return (e5) => crypto.getRandomValues(e5);
            if (f)
              try {
                var e4 = n(760);
                if (e4.randomFillSync)
                  return (t4) => e4.randomFillSync(t4);
                var t3 = e4.randomBytes;
                return (e5) => (e5.set(t3(e5.byteLength)), e5);
              } catch (e5) {
              }
            L3("initRandomDevice");
          })())(e3), de = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], fe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function he(e3, t3, n2, r3) {
            function i2(e4, t4, n3) {
              for (e4 = "number" == typeof e4 ? e4.toString() : e4 || ""; e4.length < t4; )
                e4 = n3[0] + e4;
              return e4;
            }
            function o2(e4, t4) {
              return i2(e4, t4, "0");
            }
            function a2(e4, t4) {
              function n3(e5) {
                return 0 > e5 ? -1 : 0 < e5 ? 1 : 0;
              }
              var r4;
              return 0 === (r4 = n3(e4.getFullYear() - t4.getFullYear())) && 0 === (r4 = n3(e4.getMonth() - t4.getMonth())) && (r4 = n3(e4.getDate() - t4.getDate())), r4;
            }
            function s2(e4) {
              switch (e4.getDay()) {
                case 0:
                  return new Date(e4.getFullYear() - 1, 11, 29);
                case 1:
                  return e4;
                case 2:
                  return new Date(e4.getFullYear(), 0, 3);
                case 3:
                  return new Date(e4.getFullYear(), 0, 2);
                case 4:
                  return new Date(e4.getFullYear(), 0, 1);
                case 5:
                  return new Date(e4.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(e4.getFullYear() - 1, 11, 30);
              }
            }
            function u2(e4) {
              var t4 = e4.va;
              for (e4 = new Date(new Date(e4.wa + 1900, 0, 1).getTime()); 0 < t4; ) {
                var n3 = e4.getMonth(), r4 = (te(e4.getFullYear()) ? de : fe)[n3];
                if (!(t4 > r4 - e4.getDate())) {
                  e4.setDate(e4.getDate() + t4);
                  break;
                }
                t4 -= r4 - e4.getDate() + 1, e4.setDate(1), 11 > n3 ? e4.setMonth(n3 + 1) : (e4.setMonth(0), e4.setFullYear(e4.getFullYear() + 1));
              }
              return n3 = new Date(e4.getFullYear() + 1, 0, 4), t4 = s2(new Date(e4.getFullYear(), 0, 4)), n3 = s2(n3), 0 >= a2(t4, e4) ? 0 >= a2(n3, e4) ? e4.getFullYear() + 1 : e4.getFullYear() : e4.getFullYear() - 1;
            }
            e3 >>>= 0, t3 >>>= 0, n2 >>>= 0;
            var l2 = O[40 + (r3 >>>= 0) >> 2 >>> 0];
            for (var c2 in r3 = { Na: O[r3 >> 2 >>> 0], Ma: O[r3 + 4 >> 2 >>> 0], xa: O[r3 + 8 >> 2 >>> 0], Ba: O[r3 + 12 >> 2 >>> 0], ya: O[r3 + 16 >> 2 >>> 0], wa: O[r3 + 20 >> 2 >>> 0], qa: O[r3 + 24 >> 2 >>> 0], va: O[r3 + 28 >> 2 >>> 0], Ta: O[r3 + 32 >> 2 >>> 0], La: O[r3 + 36 >> 2 >>> 0], Oa: l2 ? Z(l2) : "" }, n2 = Z(n2), l2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" })
              n2 = n2.replace(new RegExp(c2, "g"), l2[c2]);
            var p2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), d2 = "January February March April May June July August September October November December".split(" ");
            for (c2 in l2 = { "%a": (e4) => p2[e4.qa].substring(0, 3), "%A": (e4) => p2[e4.qa], "%b": (e4) => d2[e4.ya].substring(0, 3), "%B": (e4) => d2[e4.ya], "%C": (e4) => o2((e4.wa + 1900) / 100 | 0, 2), "%d": (e4) => o2(e4.Ba, 2), "%e": (e4) => i2(e4.Ba, 2, " "), "%g": (e4) => u2(e4).toString().substring(2), "%G": (e4) => u2(e4), "%H": (e4) => o2(e4.xa, 2), "%I": (e4) => (0 == (e4 = e4.xa) ? e4 = 12 : 12 < e4 && (e4 -= 12), o2(e4, 2)), "%j": (e4) => {
              for (var t4 = 0, n3 = 0; n3 <= e4.ya - 1; t4 += (te(e4.wa + 1900) ? de : fe)[n3++])
                ;
              return o2(e4.Ba + t4, 3);
            }, "%m": (e4) => o2(e4.ya + 1, 2), "%M": (e4) => o2(e4.Ma, 2), "%n": () => "\n", "%p": (e4) => 0 <= e4.xa && 12 > e4.xa ? "AM" : "PM", "%S": (e4) => o2(e4.Na, 2), "%t": () => "	", "%u": (e4) => e4.qa || 7, "%U": (e4) => o2(Math.floor((e4.va + 7 - e4.qa) / 7), 2), "%V": (e4) => {
              var t4 = Math.floor((e4.va + 7 - (e4.qa + 6) % 7) / 7);
              if (2 >= (e4.qa + 371 - e4.va - 2) % 7 && t4++, t4)
                53 == t4 && (4 == (n3 = (e4.qa + 371 - e4.va) % 7) || 3 == n3 && te(e4.wa) || (t4 = 1));
              else {
                t4 = 52;
                var n3 = (e4.qa + 7 - e4.va - 1) % 7;
                (4 == n3 || 5 == n3 && te(e4.wa % 400 - 1)) && t4++;
              }
              return o2(t4, 2);
            }, "%w": (e4) => e4.qa, "%W": (e4) => o2(Math.floor((e4.va + 7 - (e4.qa + 6) % 7) / 7), 2), "%y": (e4) => (e4.wa + 1900).toString().substring(2), "%Y": (e4) => e4.wa + 1900, "%z": (e4) => {
              var t4 = 0 <= (e4 = e4.La);
              return e4 = Math.abs(e4) / 60, (t4 ? "+" : "-") + String("0000" + (e4 / 60 * 100 + e4 % 60)).slice(-4);
            }, "%Z": (e4) => e4.Oa, "%%": () => "%" }, n2 = n2.replace(/%%/g, "\0\0"), l2)
              n2.includes(c2) && (n2 = n2.replace(new RegExp(c2, "g"), l2[c2](r3)));
            return c2 = function(e4) {
              var t4 = Array(Q(e4) + 1);
              return ee(e4, t4, 0, t4.length), t4;
            }(n2 = n2.replace(/\0\0/g, "%")), c2.length > t3 ? 0 : (S.set(c2, e3 >>> 0), c2.length - 1);
          }
          function ge(e3) {
            try {
              e3();
            } catch (e4) {
              L3(e4);
            }
          }
          var me = 0, be = null, ye = 0, ve = [], we = {}, xe = {}, _e = 0, Te = null, Se = [];
          var $e = { o: function(e3, t3, n2) {
            return function(e4) {
              return function(e5) {
                if (!I) {
                  if (0 === me) {
                    var t4 = false, n3 = false;
                    e5((e6 = 0) => {
                      if (!I && (ye = e6, t4 = true, n3)) {
                        me = 2, ge(() => Me(be)), "undefined" != typeof Browser && Browser.Aa.Da && Browser.Aa.resume(), e6 = false;
                        try {
                          var r3 = (0, _[xe[O[be + 8 >> 2 >>> 0]]])();
                        } catch (t5) {
                          r3 = t5, e6 = true;
                        }
                        var i2 = false;
                        if (!be) {
                          var o2 = Te;
                          o2 && (Te = null, (e6 ? o2.reject : o2.resolve)(r3), i2 = true);
                        }
                        if (e6 && !i2)
                          throw r3;
                      }
                    }), n3 = true, t4 || (me = 1, be = function() {
                      var e6 = Ae(65548), t5 = e6 + 12;
                      A[e6 >> 2 >>> 0] = t5, A[e6 + 4 >> 2 >>> 0] = t5 + 65536, t5 = ve[0];
                      var n4 = we[t5];
                      return void 0 === n4 && (n4 = _e++, we[t5] = n4, xe[n4] = t5), O[e6 + 8 >> 2 >>> 0] = n4, e6;
                    }(), "undefined" != typeof Browser && Browser.Aa.Da && Browser.Aa.pause(), ge(() => ke(be)));
                  } else
                    2 === me ? (me = 0, ge(je), Pe(be), be = null, Se.forEach((e6) => {
                      if (!I)
                        try {
                          if (e6(), !w)
                            try {
                              T = e6 = T, le(e6);
                            } catch (e7) {
                              e7 instanceof H || "unwind" == e7 || c(1, e7);
                            }
                        } catch (e7) {
                          e7 instanceof H || "unwind" == e7 || c(1, e7);
                        }
                    })) : L3(`invalid state: ${me}`);
                  return ye;
                }
              }((t4) => {
                e4().then(t4);
              });
            }(async () => {
              await i.Fa(e3, t3, n2);
            });
          }, a: function(e3, t3, n2) {
            throw new K(e3 >>>= 0).Ka(t3 >>> 0, n2 >>> 0), e3;
          }, g: function() {
            return 0;
          }, L: function() {
          }, C: function() {
          }, E: function() {
          }, N: function() {
            return 0;
          }, J: function() {
          }, F: function() {
          }, I: function() {
          }, l: function() {
          }, D: function() {
          }, A: function() {
          }, K: function() {
          }, B: function() {
          }, m: () => true, r: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), O[n2 >> 2 >>> 0] = e3.getUTCSeconds(), O[n2 + 4 >> 2 >>> 0] = e3.getUTCMinutes(), O[n2 + 8 >> 2 >>> 0] = e3.getUTCHours(), O[n2 + 12 >> 2 >>> 0] = e3.getUTCDate(), O[n2 + 16 >> 2 >>> 0] = e3.getUTCMonth(), O[n2 + 20 >> 2 >>> 0] = e3.getUTCFullYear() - 1900, O[n2 + 24 >> 2 >>> 0] = e3.getUTCDay(), O[n2 + 28 >> 2 >>> 0] = (e3.getTime() - Date.UTC(e3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
          }, s: function(e3, t3, n2) {
            e3 = t3 + 2097152 >>> 0 < 4194305 - !!e3 ? (e3 >>> 0) + 4294967296 * t3 : NaN, n2 >>>= 0, e3 = new Date(1e3 * e3), O[n2 >> 2 >>> 0] = e3.getSeconds(), O[n2 + 4 >> 2 >>> 0] = e3.getMinutes(), O[n2 + 8 >> 2 >>> 0] = e3.getHours(), O[n2 + 12 >> 2 >>> 0] = e3.getDate(), O[n2 + 16 >> 2 >>> 0] = e3.getMonth(), O[n2 + 20 >> 2 >>> 0] = e3.getFullYear() - 1900, O[n2 + 24 >> 2 >>> 0] = e3.getDay(), O[n2 + 28 >> 2 >>> 0] = (te(e3.getFullYear()) ? ne : re)[e3.getMonth()] + e3.getDate() - 1 | 0, O[n2 + 36 >> 2 >>> 0] = -60 * e3.getTimezoneOffset(), t3 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset();
            var r3 = new Date(e3.getFullYear(), 0, 1).getTimezoneOffset();
            O[n2 + 32 >> 2 >>> 0] = 0 | (t3 != r3 && e3.getTimezoneOffset() == Math.min(r3, t3));
          }, t: function(e3) {
            e3 >>>= 0;
            var t3 = new Date(O[e3 + 20 >> 2 >>> 0] + 1900, O[e3 + 16 >> 2 >>> 0], O[e3 + 12 >> 2 >>> 0], O[e3 + 8 >> 2 >>> 0], O[e3 + 4 >> 2 >>> 0], O[e3 >> 2 >>> 0], 0), n2 = O[e3 + 32 >> 2 >>> 0], r3 = t3.getTimezoneOffset(), i2 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), o2 = new Date(t3.getFullYear(), 0, 1).getTimezoneOffset(), a2 = Math.min(o2, i2);
            return 0 > n2 ? O[e3 + 32 >> 2 >>> 0] = Number(i2 != o2 && a2 == r3) : 0 < n2 != (a2 == r3) && (i2 = Math.max(o2, i2), t3.setTime(t3.getTime() + 6e4 * ((0 < n2 ? a2 : i2) - r3))), O[e3 + 24 >> 2 >>> 0] = t3.getDay(), O[e3 + 28 >> 2 >>> 0] = (te(t3.getFullYear()) ? ne : re)[t3.getMonth()] + t3.getDate() - 1 | 0, O[e3 >> 2 >>> 0] = t3.getSeconds(), O[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), O[e3 + 8 >> 2 >>> 0] = t3.getHours(), O[e3 + 12 >> 2 >>> 0] = t3.getDate(), O[e3 + 16 >> 2 >>> 0] = t3.getMonth(), O[e3 + 20 >> 2 >>> 0] = t3.getYear(), e3 = t3.getTime() / 1e3, Ie((V = e3, 1 <= +Math.abs(V) ? 0 < V ? +Math.floor(V / 4294967296) >>> 0 : ~~+Math.ceil((V - +(~~V >>> 0)) / 4294967296) >>> 0 : 0)), e3 >>> 0;
          }, p: function() {
            return -52;
          }, q: function() {
          }, x: function(e3, t3, n2) {
            function r3(e4) {
              return (e4 = e4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? e4[1] : "GMT";
            }
            n2 >>>= 0;
            var i2 = (/* @__PURE__ */ new Date()).getFullYear(), o2 = new Date(i2, 0, 1), a2 = new Date(i2, 6, 1);
            i2 = o2.getTimezoneOffset();
            var s2 = a2.getTimezoneOffset();
            A[e3 >>> 0 >> 2 >>> 0] = 60 * Math.max(i2, s2), O[t3 >>> 0 >> 2 >>> 0] = Number(i2 != s2), e3 = r3(o2), t3 = r3(a2), e3 = ie(e3), t3 = ie(t3), s2 < i2 ? (A[n2 >> 2 >>> 0] = e3, A[n2 + 4 >> 2 >>> 0] = t3) : (A[n2 >> 2 >>> 0] = t3, A[n2 + 4 >> 2 >>> 0] = e3);
          }, e: () => {
            L3("");
          }, b: function(e3, t3, n2) {
            return e3 >>>= 0, t3 = ae(t3 >>> 0, n2 >>> 0), W[e3].apply(null, t3);
          }, i: function(e3, t3, n2) {
            return e3 >>>= 0, t3 = ae(t3 >>> 0, n2 >>> 0), W[e3].apply(null, t3);
          }, h: function() {
            return Date.now();
          }, z: function() {
            return 4294901760;
          }, d: () => performance.now(), M: function(e3, t3, n2) {
            return t3 >>>= 0, $.copyWithin(e3 >>> 0 >>> 0, t3 >>> 0, t3 + (n2 >>> 0) >>> 0);
          }, w: function(e3) {
            e3 >>>= 0;
            var t3 = $.length;
            if (4294901760 < e3)
              return false;
            for (var n2 = 1; 4 >= n2; n2 *= 2) {
              var r3 = t3 * (1 + 0.2 / n2);
              r3 = Math.min(r3, e3 + 100663296);
              var i2 = Math;
              r3 = Math.max(e3, r3);
              e: {
                i2 = i2.min.call(i2, 4294901760, r3 + (65536 - r3 % 65536) % 65536) - x.buffer.byteLength + 65535 >>> 16;
                try {
                  x.grow(i2), E();
                  var o2 = 1;
                  break e;
                } catch (e4) {
                }
                o2 = void 0;
              }
              if (o2)
                return true;
            }
            return false;
          }, G: function(e3, t3) {
            e3 >>>= 0, t3 >>>= 0;
            var n2 = 0;
            return ue().forEach(function(r3, i2) {
              var o2 = t3 + n2;
              for (i2 = A[e3 + 4 * i2 >> 2 >>> 0] = o2, o2 = 0; o2 < r3.length; ++o2)
                S[i2++ >> 0 >>> 0] = r3.charCodeAt(o2);
              S[i2 >> 0 >>> 0] = 0, n2 += r3.length + 1;
            }), 0;
          }, H: function(e3, t3) {
            e3 >>>= 0, t3 >>>= 0;
            var n2 = ue();
            A[e3 >> 2 >>> 0] = n2.length;
            var r3 = 0;
            return n2.forEach(function(e4) {
              r3 += e4.length + 1;
            }), A[t3 >> 2 >>> 0] = r3, 0;
          }, n: (e3) => {
            T = e3, le(e3);
          }, f: () => 52, k: function() {
            return 52;
          }, u: function() {
            return 70;
          }, j: function(e3, t3, n2, r3) {
            t3 >>>= 0, n2 >>>= 0, r3 >>>= 0;
            for (var i2 = 0, o2 = 0; o2 < n2; o2++) {
              var a2 = A[t3 >> 2 >>> 0], s2 = A[t3 + 4 >> 2 >>> 0];
              t3 += 8;
              for (var u2 = 0; u2 < s2; u2++) {
                var l2 = $[a2 + u2 >>> 0], c2 = ce[e3];
                0 === l2 || 10 === l2 ? ((1 === e3 ? y : v)(J(c2, 0)), c2.length = 0) : c2.push(l2);
              }
              i2 += s2;
            }
            return A[r3 >> 2 >>> 0] = i2, 0;
          }, v: function(e3, t3) {
            return e3 >>>= 0, pe($.subarray(e3 >>> 0, e3 + (t3 >>> 0) >>> 0)), 0;
          }, y: he, c: function(e3, t3, n2, r3) {
            return he(e3 >>> 0, t3 >>> 0, n2 >>> 0, r3 >>> 0);
          } };
          !function() {
            function e3(e4) {
              if (e4 = function(e5) {
                var t5, n2 = {};
                for (t5 in e5)
                  !function(t6) {
                    var r3 = e5[t6];
                    n2[t6] = "function" == typeof r3 ? function() {
                      ve.push(t6);
                      try {
                        return r3.apply(null, arguments);
                      } finally {
                        I || (ve.pop() === t6 || L3(), be && 1 === me && 0 === ve.length && (me = 0, ge(Re), "undefined" != typeof Fibers && Fibers.Ua()));
                      }
                    } : r3;
                  }(t5);
                return n2;
              }(e4 = e4.exports), _ = e4 = function(e5) {
                var t5 = (e6) => () => e6() >>> 0, n2 = (e6) => (t6) => e6(t6) >>> 0;
                return (e5 = Object.assign({}, e5)).__errno_location = t5(e5.__errno_location), e5.malloc = n2(e5.malloc), e5.stackSave = t5(e5.stackSave), e5.stackAlloc = n2(e5.stackAlloc), e5;
              }(e4), x = _.O, E(), D.unshift(_.P), j--, i.monitorRunDependencies && i.monitorRunDependencies(j), 0 == j && (null !== N3 && (clearInterval(N3), N3 = null), z)) {
                var t4 = z;
                z = null, t4();
              }
              return e4;
            }
            var t3 = { a: $e };
            if (j++, i.monitorRunDependencies && i.monitorRunDependencies(j), i.instantiateWasm)
              try {
                return i.instantiateWasm(t3, e3);
              } catch (e4) {
                v("Module.instantiateWasm callback failed with error: " + e4), r2(e4);
              }
            (function(e4, t4) {
              var n2 = M;
              return b || "function" != typeof WebAssembly.instantiateStreaming || B(n2) || n2.startsWith("file://") || f || "function" != typeof fetch ? G(n2, e4, t4) : fetch(n2, { credentials: "same-origin" }).then((r3) => WebAssembly.instantiateStreaming(r3, e4).then(t4, function(r4) {
                return v("wasm streaming compile failed: " + r4), v("falling back to ArrayBuffer instantiation"), G(n2, e4, t4);
              }));
            })(t3, function(t4) {
              e3(t4.instance);
            }).catch(r2);
          }(), i._OrtInit = (e3, t3) => (i._OrtInit = _.Q)(e3, t3), i._OrtGetLastError = (e3, t3) => (i._OrtGetLastError = _.R)(e3, t3), i._OrtCreateSessionOptions = (e3, t3, n2, r3, o2, a2, s2, u2, l2, c2) => (i._OrtCreateSessionOptions = _.S)(e3, t3, n2, r3, o2, a2, s2, u2, l2, c2), i._OrtAppendExecutionProvider = (e3, t3) => (i._OrtAppendExecutionProvider = _.T)(e3, t3), i._OrtAddSessionConfigEntry = (e3, t3, n2) => (i._OrtAddSessionConfigEntry = _.U)(e3, t3, n2), i._OrtReleaseSessionOptions = (e3) => (i._OrtReleaseSessionOptions = _.V)(e3), i._OrtCreateSession = (e3, t3, n2) => (i._OrtCreateSession = _.W)(e3, t3, n2), i._OrtReleaseSession = (e3) => (i._OrtReleaseSession = _.X)(e3), i._OrtGetInputOutputCount = (e3, t3, n2) => (i._OrtGetInputOutputCount = _.Y)(e3, t3, n2), i._OrtGetInputName = (e3, t3) => (i._OrtGetInputName = _.Z)(e3, t3), i._OrtGetOutputName = (e3, t3) => (i._OrtGetOutputName = _._)(e3, t3), i._OrtFree = (e3) => (i._OrtFree = _.$)(e3), i._OrtCreateTensor = (e3, t3, n2, r3, o2) => (i._OrtCreateTensor = _.aa)(e3, t3, n2, r3, o2), i._OrtGetTensorData = (e3, t3, n2, r3, o2) => (i._OrtGetTensorData = _.ba)(e3, t3, n2, r3, o2), i._OrtReleaseTensor = (e3) => (i._OrtReleaseTensor = _.ca)(e3), i._OrtCreateRunOptions = (e3, t3, n2, r3) => (i._OrtCreateRunOptions = _.da)(e3, t3, n2, r3), i._OrtAddRunConfigEntry = (e3, t3, n2) => (i._OrtAddRunConfigEntry = _.ea)(e3, t3, n2), i._OrtReleaseRunOptions = (e3) => (i._OrtReleaseRunOptions = _.fa)(e3), i._OrtRun = (e3, t3, n2, r3, o2, a2, s2, u2) => (i._OrtRun = _.ga)(e3, t3, n2, r3, o2, a2, s2, u2), i._OrtEndProfiling = (e3) => (i._OrtEndProfiling = _.ha)(e3), i._JsepOutput = (e3, t3, n2) => (i._JsepOutput = _.ia)(e3, t3, n2);
          var Oe, Ae = i._malloc = (e3) => (Ae = i._malloc = _.ja)(e3), Pe = i._free = (e3) => (Pe = i._free = _.ka)(e3), Ie = (e3) => (Ie = _.ma)(e3), Ee = () => (Ee = _.na)(), Ce = (e3) => (Ce = _.oa)(e3), De = (e3) => (De = _.pa)(e3), ke = (e3) => (ke = _.ra)(e3), Re = () => (Re = _.sa)(), Me = (e3) => (Me = _.ta)(e3), je = () => (je = _.ua)();
          function Ne() {
            function e3() {
              if (!Oe && (Oe = true, i.calledRun = true, !I)) {
                if (q(D), t2(i), i.onRuntimeInitialized && i.onRuntimeInitialized(), i.postRun)
                  for ("function" == typeof i.postRun && (i.postRun = [i.postRun]); i.postRun.length; ) {
                    var e4 = i.postRun.shift();
                    k.unshift(e4);
                  }
                q(k);
              }
            }
            if (!(0 < j)) {
              if (i.preRun)
                for ("function" == typeof i.preRun && (i.preRun = [i.preRun]); i.preRun.length; )
                  R();
              q(C2), 0 < j || (i.setStatus ? (i.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  i.setStatus("");
                }, 1), e3();
              }, 1)) : e3());
            }
          }
          if (i.___start_em_js = 904588, i.___stop_em_js = 904749, i.stackAlloc = De, i.stackSave = Ee, i.stackRestore = Ce, i.UTF8ToString = Z, i.stringToUTF8 = (e3, t3, n2) => ee(e3, $, t3, n2), i.lengthBytesUTF8 = Q, z = function e3() {
            Oe || Ne(), Oe || (z = e3);
          }, i.preInit)
            for ("function" == typeof i.preInit && (i.preInit = [i.preInit]); 0 < i.preInit.length; )
              i.preInit.pop()();
          return Ne(), e2.ready;
        });
        e.exports = r;
      }, 4537: (e) => {
        "use strict";
        e.exports = function(e2, t) {
          for (var n = new Array(arguments.length - 1), r = 0, i = 2, o = true; i < arguments.length; )
            n[r++] = arguments[i++];
          return new Promise(function(i2, a) {
            n[r] = function(e3) {
              if (o)
                if (o = false, e3)
                  a(e3);
                else {
                  for (var t2 = new Array(arguments.length - 1), n2 = 0; n2 < t2.length; )
                    t2[n2++] = arguments[n2];
                  i2.apply(null, t2);
                }
            };
            try {
              e2.apply(t || null, n);
            } catch (e3) {
              o && (o = false, a(e3));
            }
          });
        };
      }, 7419: (e, t) => {
        "use strict";
        var n = t;
        n.length = function(e2) {
          var t2 = e2.length;
          if (!t2)
            return 0;
          for (var n2 = 0; --t2 % 4 > 1 && "=" === e2.charAt(t2); )
            ++n2;
          return Math.ceil(3 * e2.length) / 4 - n2;
        };
        for (var r = new Array(64), i = new Array(123), o = 0; o < 64; )
          i[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
        n.encode = function(e2, t2, n2) {
          for (var i2, o2 = null, a2 = [], s = 0, u = 0; t2 < n2; ) {
            var l = e2[t2++];
            switch (u) {
              case 0:
                a2[s++] = r[l >> 2], i2 = (3 & l) << 4, u = 1;
                break;
              case 1:
                a2[s++] = r[i2 | l >> 4], i2 = (15 & l) << 2, u = 2;
                break;
              case 2:
                a2[s++] = r[i2 | l >> 6], a2[s++] = r[63 & l], u = 0;
            }
            s > 8191 && ((o2 || (o2 = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
          }
          return u && (a2[s++] = r[i2], a2[s++] = 61, 1 === u && (a2[s++] = 61)), o2 ? (s && o2.push(String.fromCharCode.apply(String, a2.slice(0, s))), o2.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
        };
        var a = "invalid encoding";
        n.decode = function(e2, t2, n2) {
          for (var r2, o2 = n2, s = 0, u = 0; u < e2.length; ) {
            var l = e2.charCodeAt(u++);
            if (61 === l && s > 1)
              break;
            if (void 0 === (l = i[l]))
              throw Error(a);
            switch (s) {
              case 0:
                r2 = l, s = 1;
                break;
              case 1:
                t2[n2++] = r2 << 2 | (48 & l) >> 4, r2 = l, s = 2;
                break;
              case 2:
                t2[n2++] = (15 & r2) << 4 | (60 & l) >> 2, r2 = l, s = 3;
                break;
              case 3:
                t2[n2++] = (3 & r2) << 6 | l, s = 0;
            }
          }
          if (1 === s)
            throw Error(a);
          return n2 - o2;
        }, n.test = function(e2) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e2);
        };
      }, 9211: (e) => {
        "use strict";
        function t() {
          this._listeners = {};
        }
        e.exports = t, t.prototype.on = function(e2, t2, n) {
          return (this._listeners[e2] || (this._listeners[e2] = [])).push({ fn: t2, ctx: n || this }), this;
        }, t.prototype.off = function(e2, t2) {
          if (void 0 === e2)
            this._listeners = {};
          else if (void 0 === t2)
            this._listeners[e2] = [];
          else
            for (var n = this._listeners[e2], r = 0; r < n.length; )
              n[r].fn === t2 ? n.splice(r, 1) : ++r;
          return this;
        }, t.prototype.emit = function(e2) {
          var t2 = this._listeners[e2];
          if (t2) {
            for (var n = [], r = 1; r < arguments.length; )
              n.push(arguments[r++]);
            for (r = 0; r < t2.length; )
              t2[r].fn.apply(t2[r++].ctx, n);
          }
          return this;
        };
      }, 945: (e) => {
        "use strict";
        function t(e2) {
          return "undefined" != typeof Float32Array ? function() {
            var t2 = new Float32Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[3];
            function i2(e3, r3, i3) {
              t2[0] = e3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3];
            }
            function o2(e3, r3, i3) {
              t2[0] = e3, r3[i3] = n2[3], r3[i3 + 1] = n2[2], r3[i3 + 2] = n2[1], r3[i3 + 3] = n2[0];
            }
            function a(e3, r3) {
              return n2[0] = e3[r3], n2[1] = e3[r3 + 1], n2[2] = e3[r3 + 2], n2[3] = e3[r3 + 3], t2[0];
            }
            function s(e3, r3) {
              return n2[3] = e3[r3], n2[2] = e3[r3 + 1], n2[1] = e3[r3 + 2], n2[0] = e3[r3 + 3], t2[0];
            }
            e2.writeFloatLE = r2 ? i2 : o2, e2.writeFloatBE = r2 ? o2 : i2, e2.readFloatLE = r2 ? a : s, e2.readFloatBE = r2 ? s : a;
          }() : function() {
            function t2(e3, t3, n2, r2) {
              var i2 = t3 < 0 ? 1 : 0;
              if (i2 && (t3 = -t3), 0 === t3)
                e3(1 / t3 > 0 ? 0 : 2147483648, n2, r2);
              else if (isNaN(t3))
                e3(2143289344, n2, r2);
              else if (t3 > 34028234663852886e22)
                e3((i2 << 31 | 2139095040) >>> 0, n2, r2);
              else if (t3 < 11754943508222875e-54)
                e3((i2 << 31 | Math.round(t3 / 1401298464324817e-60)) >>> 0, n2, r2);
              else {
                var o2 = Math.floor(Math.log(t3) / Math.LN2);
                e3((i2 << 31 | o2 + 127 << 23 | 8388607 & Math.round(t3 * Math.pow(2, -o2) * 8388608)) >>> 0, n2, r2);
              }
            }
            function a(e3, t3, n2) {
              var r2 = e3(t3, n2), i2 = 2 * (r2 >> 31) + 1, o2 = r2 >>> 23 & 255, a2 = 8388607 & r2;
              return 255 === o2 ? a2 ? NaN : i2 * (1 / 0) : 0 === o2 ? 1401298464324817e-60 * i2 * a2 : i2 * Math.pow(2, o2 - 150) * (a2 + 8388608);
            }
            e2.writeFloatLE = t2.bind(null, n), e2.writeFloatBE = t2.bind(null, r), e2.readFloatLE = a.bind(null, i), e2.readFloatBE = a.bind(null, o);
          }(), "undefined" != typeof Float64Array ? function() {
            var t2 = new Float64Array([-0]), n2 = new Uint8Array(t2.buffer), r2 = 128 === n2[7];
            function i2(e3, r3, i3) {
              t2[0] = e3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3], r3[i3 + 4] = n2[4], r3[i3 + 5] = n2[5], r3[i3 + 6] = n2[6], r3[i3 + 7] = n2[7];
            }
            function o2(e3, r3, i3) {
              t2[0] = e3, r3[i3] = n2[7], r3[i3 + 1] = n2[6], r3[i3 + 2] = n2[5], r3[i3 + 3] = n2[4], r3[i3 + 4] = n2[3], r3[i3 + 5] = n2[2], r3[i3 + 6] = n2[1], r3[i3 + 7] = n2[0];
            }
            function a(e3, r3) {
              return n2[0] = e3[r3], n2[1] = e3[r3 + 1], n2[2] = e3[r3 + 2], n2[3] = e3[r3 + 3], n2[4] = e3[r3 + 4], n2[5] = e3[r3 + 5], n2[6] = e3[r3 + 6], n2[7] = e3[r3 + 7], t2[0];
            }
            function s(e3, r3) {
              return n2[7] = e3[r3], n2[6] = e3[r3 + 1], n2[5] = e3[r3 + 2], n2[4] = e3[r3 + 3], n2[3] = e3[r3 + 4], n2[2] = e3[r3 + 5], n2[1] = e3[r3 + 6], n2[0] = e3[r3 + 7], t2[0];
            }
            e2.writeDoubleLE = r2 ? i2 : o2, e2.writeDoubleBE = r2 ? o2 : i2, e2.readDoubleLE = r2 ? a : s, e2.readDoubleBE = r2 ? s : a;
          }() : function() {
            function t2(e3, t3, n2, r2, i2, o2) {
              var a2 = r2 < 0 ? 1 : 0;
              if (a2 && (r2 = -r2), 0 === r2)
                e3(0, i2, o2 + t3), e3(1 / r2 > 0 ? 0 : 2147483648, i2, o2 + n2);
              else if (isNaN(r2))
                e3(0, i2, o2 + t3), e3(2146959360, i2, o2 + n2);
              else if (r2 > 17976931348623157e292)
                e3(0, i2, o2 + t3), e3((a2 << 31 | 2146435072) >>> 0, i2, o2 + n2);
              else {
                var s;
                if (r2 < 22250738585072014e-324)
                  e3((s = r2 / 5e-324) >>> 0, i2, o2 + t3), e3((a2 << 31 | s / 4294967296) >>> 0, i2, o2 + n2);
                else {
                  var u = Math.floor(Math.log(r2) / Math.LN2);
                  1024 === u && (u = 1023), e3(4503599627370496 * (s = r2 * Math.pow(2, -u)) >>> 0, i2, o2 + t3), e3((a2 << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, i2, o2 + n2);
                }
              }
            }
            function a(e3, t3, n2, r2, i2) {
              var o2 = e3(r2, i2 + t3), a2 = e3(r2, i2 + n2), s = 2 * (a2 >> 31) + 1, u = a2 >>> 20 & 2047, l = 4294967296 * (1048575 & a2) + o2;
              return 2047 === u ? l ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * l : s * Math.pow(2, u - 1075) * (l + 4503599627370496);
            }
            e2.writeDoubleLE = t2.bind(null, n, 0, 4), e2.writeDoubleBE = t2.bind(null, r, 4, 0), e2.readDoubleLE = a.bind(null, i, 0, 4), e2.readDoubleBE = a.bind(null, o, 4, 0);
          }(), e2;
        }
        function n(e2, t2, n2) {
          t2[n2] = 255 & e2, t2[n2 + 1] = e2 >>> 8 & 255, t2[n2 + 2] = e2 >>> 16 & 255, t2[n2 + 3] = e2 >>> 24;
        }
        function r(e2, t2, n2) {
          t2[n2] = e2 >>> 24, t2[n2 + 1] = e2 >>> 16 & 255, t2[n2 + 2] = e2 >>> 8 & 255, t2[n2 + 3] = 255 & e2;
        }
        function i(e2, t2) {
          return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24) >>> 0;
        }
        function o(e2, t2) {
          return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
        }
        e.exports = t(t);
      }, 7199: (module) => {
        "use strict";
        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length))
              return mod;
          } catch (e) {
          }
          return null;
        }
        module.exports = inquire;
      }, 6662: (e) => {
        "use strict";
        e.exports = function(e2, t, n) {
          var r = n || 8192, i = r >>> 1, o = null, a = r;
          return function(n2) {
            if (n2 < 1 || n2 > i)
              return e2(n2);
            a + n2 > r && (o = e2(r), a = 0);
            var s = t.call(o, a, a += n2);
            return 7 & a && (a = 1 + (7 | a)), s;
          };
        };
      }, 4997: (e, t) => {
        "use strict";
        var n = t;
        n.length = function(e2) {
          for (var t2 = 0, n2 = 0, r = 0; r < e2.length; ++r)
            (n2 = e2.charCodeAt(r)) < 128 ? t2 += 1 : n2 < 2048 ? t2 += 2 : 55296 == (64512 & n2) && 56320 == (64512 & e2.charCodeAt(r + 1)) ? (++r, t2 += 4) : t2 += 3;
          return t2;
        }, n.read = function(e2, t2, n2) {
          if (n2 - t2 < 1)
            return "";
          for (var r, i = null, o = [], a = 0; t2 < n2; )
            (r = e2[t2++]) < 128 ? o[a++] = r : r > 191 && r < 224 ? o[a++] = (31 & r) << 6 | 63 & e2[t2++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & e2[t2++]) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++]) - 65536, o[a++] = 55296 + (r >> 10), o[a++] = 56320 + (1023 & r)) : o[a++] = (15 & r) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++], a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a = 0);
          return i ? (a && i.push(String.fromCharCode.apply(String, o.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, a));
        }, n.write = function(e2, t2, n2) {
          for (var r, i, o = n2, a = 0; a < e2.length; ++a)
            (r = e2.charCodeAt(a)) < 128 ? t2[n2++] = r : r < 2048 ? (t2[n2++] = r >> 6 | 192, t2[n2++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (i = e2.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++a, t2[n2++] = r >> 18 | 240, t2[n2++] = r >> 12 & 63 | 128, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128) : (t2[n2++] = r >> 12 | 224, t2[n2++] = r >> 6 & 63 | 128, t2[n2++] = 63 & r | 128);
          return n2 - o;
        };
      }, 3442: (e, t) => {
        "use strict";
        t.__esModule = true;
        var n = function() {
          function e2(t2) {
            if (!t2)
              throw new TypeError("Invalid argument; `value` has no value.");
            this.value = e2.EMPTY, t2 && e2.isGuid(t2) && (this.value = t2);
          }
          return e2.isGuid = function(t2) {
            var n2 = t2.toString();
            return t2 && (t2 instanceof e2 || e2.validator.test(n2));
          }, e2.create = function() {
            return new e2([e2.gen(2), e2.gen(1), e2.gen(1), e2.gen(1), e2.gen(3)].join("-"));
          }, e2.createEmpty = function() {
            return new e2("emptyguid");
          }, e2.parse = function(t2) {
            return new e2(t2);
          }, e2.raw = function() {
            return [e2.gen(2), e2.gen(1), e2.gen(1), e2.gen(1), e2.gen(3)].join("-");
          }, e2.gen = function(e3) {
            for (var t2 = "", n2 = 0; n2 < e3; n2++)
              t2 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
            return t2;
          }, e2.prototype.equals = function(t2) {
            return e2.isGuid(t2) && this.value === t2.toString();
          }, e2.prototype.isEmpty = function() {
            return this.value === e2.EMPTY;
          }, e2.prototype.toString = function() {
            return this.value;
          }, e2.prototype.toJSON = function() {
            return { value: this.value };
          }, e2.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), e2.EMPTY = "00000000-0000-0000-0000-000000000000", e2;
        }();
        t.Guid = n;
      }, 2100: (e, t, n) => {
        "use strict";
        e.exports = n(9482);
      }, 9482: (e, t, n) => {
        "use strict";
        var r = t;
        function i() {
          r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
        }
        r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = i, i();
      }, 1408: (e, t, n) => {
        "use strict";
        e.exports = u;
        var r, i = n(9693), o = i.LongBits, a = i.utf8;
        function s(e2, t2) {
          return RangeError("index out of range: " + e2.pos + " + " + (t2 || 1) + " > " + e2.len);
        }
        function u(e2) {
          this.buf = e2, this.pos = 0, this.len = e2.length;
        }
        var l, c = "undefined" != typeof Uint8Array ? function(e2) {
          if (e2 instanceof Uint8Array || Array.isArray(e2))
            return new u(e2);
          throw Error("illegal buffer");
        } : function(e2) {
          if (Array.isArray(e2))
            return new u(e2);
          throw Error("illegal buffer");
        }, p = function() {
          return i.Buffer ? function(e2) {
            return (u.create = function(e3) {
              return i.Buffer.isBuffer(e3) ? new r(e3) : c(e3);
            })(e2);
          } : c;
        };
        function d() {
          var e2 = new o(0, 0), t2 = 0;
          if (!(this.len - this.pos > 4)) {
            for (; t2 < 3; ++t2) {
              if (this.pos >= this.len)
                throw s(this);
              if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128)
                return e2;
            }
            return e2.lo = (e2.lo | (127 & this.buf[this.pos++]) << 7 * t2) >>> 0, e2;
          }
          for (; t2 < 4; ++t2)
            if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128)
              return e2;
          if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e2.hi = (e2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
            return e2;
          if (t2 = 0, this.len - this.pos > 4) {
            for (; t2 < 5; ++t2)
              if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128)
                return e2;
          } else
            for (; t2 < 5; ++t2) {
              if (this.pos >= this.len)
                throw s(this);
              if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128)
                return e2;
            }
          throw Error("invalid varint encoding");
        }
        function f(e2, t2) {
          return (e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24) >>> 0;
        }
        function h() {
          if (this.pos + 8 > this.len)
            throw s(this, 8);
          return new o(f(this.buf, this.pos += 4), f(this.buf, this.pos += 4));
        }
        u.create = p(), u.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u.prototype.uint32 = (l = 4294967295, function() {
          if (l = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if (l = (l | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
            return l;
          if ((this.pos += 5) > this.len)
            throw this.pos = this.len, s(this, 10);
          return l;
        }), u.prototype.int32 = function() {
          return 0 | this.uint32();
        }, u.prototype.sint32 = function() {
          var e2 = this.uint32();
          return e2 >>> 1 ^ -(1 & e2) | 0;
        }, u.prototype.bool = function() {
          return 0 !== this.uint32();
        }, u.prototype.fixed32 = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          return f(this.buf, this.pos += 4);
        }, u.prototype.sfixed32 = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          return 0 | f(this.buf, this.pos += 4);
        }, u.prototype.float = function() {
          if (this.pos + 4 > this.len)
            throw s(this, 4);
          var e2 = i.float.readFloatLE(this.buf, this.pos);
          return this.pos += 4, e2;
        }, u.prototype.double = function() {
          if (this.pos + 8 > this.len)
            throw s(this, 4);
          var e2 = i.float.readDoubleLE(this.buf, this.pos);
          return this.pos += 8, e2;
        }, u.prototype.bytes = function() {
          var e2 = this.uint32(), t2 = this.pos, n2 = this.pos + e2;
          if (n2 > this.len)
            throw s(this, e2);
          return this.pos += e2, Array.isArray(this.buf) ? this.buf.slice(t2, n2) : t2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, t2, n2);
        }, u.prototype.string = function() {
          var e2 = this.bytes();
          return a.read(e2, 0, e2.length);
        }, u.prototype.skip = function(e2) {
          if ("number" == typeof e2) {
            if (this.pos + e2 > this.len)
              throw s(this, e2);
            this.pos += e2;
          } else
            do {
              if (this.pos >= this.len)
                throw s(this);
            } while (128 & this.buf[this.pos++]);
          return this;
        }, u.prototype.skipType = function(e2) {
          switch (e2) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              for (; 4 != (e2 = 7 & this.uint32()); )
                this.skipType(e2);
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + e2 + " at offset " + this.pos);
          }
          return this;
        }, u._configure = function(e2) {
          r = e2, u.create = p(), r._configure();
          var t2 = i.Long ? "toLong" : "toNumber";
          i.merge(u.prototype, { int64: function() {
            return d.call(this)[t2](false);
          }, uint64: function() {
            return d.call(this)[t2](true);
          }, sint64: function() {
            return d.call(this).zzDecode()[t2](false);
          }, fixed64: function() {
            return h.call(this)[t2](true);
          }, sfixed64: function() {
            return h.call(this)[t2](false);
          } });
        };
      }, 593: (e, t, n) => {
        "use strict";
        e.exports = o;
        var r = n(1408);
        (o.prototype = Object.create(r.prototype)).constructor = o;
        var i = n(9693);
        function o(e2) {
          r.call(this, e2);
        }
        o._configure = function() {
          i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);
        }, o.prototype.string = function() {
          var e2 = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e2, this.len));
        }, o._configure();
      }, 5054: (e) => {
        "use strict";
        e.exports = {};
      }, 5994: (e, t, n) => {
        "use strict";
        t.Service = n(7948);
      }, 7948: (e, t, n) => {
        "use strict";
        e.exports = i;
        var r = n(9693);
        function i(e2, t2, n2) {
          if ("function" != typeof e2)
            throw TypeError("rpcImpl must be a function");
          r.EventEmitter.call(this), this.rpcImpl = e2, this.requestDelimited = Boolean(t2), this.responseDelimited = Boolean(n2);
        }
        (i.prototype = Object.create(r.EventEmitter.prototype)).constructor = i, i.prototype.rpcCall = function e2(t2, n2, i2, o, a) {
          if (!o)
            throw TypeError("request must be specified");
          var s = this;
          if (!a)
            return r.asPromise(e2, s, t2, n2, i2, o);
          if (s.rpcImpl)
            try {
              return s.rpcImpl(t2, n2[s.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function(e3, n3) {
                if (e3)
                  return s.emit("error", e3, t2), a(e3);
                if (null !== n3) {
                  if (!(n3 instanceof i2))
                    try {
                      n3 = i2[s.responseDelimited ? "decodeDelimited" : "decode"](n3);
                    } catch (e4) {
                      return s.emit("error", e4, t2), a(e4);
                    }
                  return s.emit("data", n3, t2), a(null, n3);
                }
                s.end(true);
              });
            } catch (e3) {
              return s.emit("error", e3, t2), void setTimeout(function() {
                a(e3);
              }, 0);
            }
          else
            setTimeout(function() {
              a(Error("already ended"));
            }, 0);
        }, i.prototype.end = function(e2) {
          return this.rpcImpl && (e2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
        };
      }, 1945: (e, t, n) => {
        "use strict";
        e.exports = i;
        var r = n(9693);
        function i(e2, t2) {
          this.lo = e2 >>> 0, this.hi = t2 >>> 0;
        }
        var o = i.zero = new i(0, 0);
        o.toNumber = function() {
          return 0;
        }, o.zzEncode = o.zzDecode = function() {
          return this;
        }, o.length = function() {
          return 1;
        };
        var a = i.zeroHash = "\0\0\0\0\0\0\0\0";
        i.fromNumber = function(e2) {
          if (0 === e2)
            return o;
          var t2 = e2 < 0;
          t2 && (e2 = -e2);
          var n2 = e2 >>> 0, r2 = (e2 - n2) / 4294967296 >>> 0;
          return t2 && (r2 = ~r2 >>> 0, n2 = ~n2 >>> 0, ++n2 > 4294967295 && (n2 = 0, ++r2 > 4294967295 && (r2 = 0))), new i(n2, r2);
        }, i.from = function(e2) {
          if ("number" == typeof e2)
            return i.fromNumber(e2);
          if (r.isString(e2)) {
            if (!r.Long)
              return i.fromNumber(parseInt(e2, 10));
            e2 = r.Long.fromString(e2);
          }
          return e2.low || e2.high ? new i(e2.low >>> 0, e2.high >>> 0) : o;
        }, i.prototype.toNumber = function(e2) {
          if (!e2 && this.hi >>> 31) {
            var t2 = 1 + ~this.lo >>> 0, n2 = ~this.hi >>> 0;
            return t2 || (n2 = n2 + 1 >>> 0), -(t2 + 4294967296 * n2);
          }
          return this.lo + 4294967296 * this.hi;
        }, i.prototype.toLong = function(e2) {
          return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(e2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e2) };
        };
        var s = String.prototype.charCodeAt;
        i.fromHash = function(e2) {
          return e2 === a ? o : new i((s.call(e2, 0) | s.call(e2, 1) << 8 | s.call(e2, 2) << 16 | s.call(e2, 3) << 24) >>> 0, (s.call(e2, 4) | s.call(e2, 5) << 8 | s.call(e2, 6) << 16 | s.call(e2, 7) << 24) >>> 0);
        }, i.prototype.toHash = function() {
          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        }, i.prototype.zzEncode = function() {
          var e2 = this.hi >> 31;
          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e2) >>> 0, this.lo = (this.lo << 1 ^ e2) >>> 0, this;
        }, i.prototype.zzDecode = function() {
          var e2 = -(1 & this.lo);
          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e2) >>> 0, this.hi = (this.hi >>> 1 ^ e2) >>> 0, this;
        }, i.prototype.length = function() {
          var e2 = this.lo, t2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
          return 0 === n2 ? 0 === t2 ? e2 < 16384 ? e2 < 128 ? 1 : 2 : e2 < 2097152 ? 3 : 4 : t2 < 16384 ? t2 < 128 ? 5 : 6 : t2 < 2097152 ? 7 : 8 : n2 < 128 ? 9 : 10;
        };
      }, 9693: function(e, t, n) {
        "use strict";
        var r = t;
        function i(e2, t2, n2) {
          for (var r2 = Object.keys(t2), i2 = 0; i2 < r2.length; ++i2)
            void 0 !== e2[r2[i2]] && n2 || (e2[r2[i2]] = t2[r2[i2]]);
          return e2;
        }
        function o(e2) {
          function t2(e3, n2) {
            if (!(this instanceof t2))
              return new t2(e3, n2);
            Object.defineProperty(this, "message", { get: function() {
              return e3;
            } }), Error.captureStackTrace ? Error.captureStackTrace(this, t2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n2 && i(this, n2);
          }
          return t2.prototype = Object.create(Error.prototype, { constructor: { value: t2, writable: true, enumerable: false, configurable: true }, name: { get: function() {
            return e2;
          }, set: void 0, enumerable: false, configurable: true }, toString: { value: function() {
            return this.name + ": " + this.message;
          }, writable: true, enumerable: false, configurable: true } }), t2;
        }
        r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean("undefined" != typeof global && global && global.process && global.process.versions && global.process.versions.node), r.global = r.isNode && global || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(e2) {
          return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
        }, r.isString = function(e2) {
          return "string" == typeof e2 || e2 instanceof String;
        }, r.isObject = function(e2) {
          return e2 && "object" == typeof e2;
        }, r.isset = r.isSet = function(e2, t2) {
          var n2 = e2[t2];
          return !(null == n2 || !e2.hasOwnProperty(t2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
        }, r.Buffer = function() {
          try {
            var e2 = r.inquire("buffer").Buffer;
            return e2.prototype.utf8Write ? e2 : null;
          } catch (e3) {
            return null;
          }
        }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(e2) {
          return "number" == typeof e2 ? r.Buffer ? r._Buffer_allocUnsafe(e2) : new r.Array(e2) : r.Buffer ? r._Buffer_from(e2) : "undefined" == typeof Uint8Array ? e2 : new Uint8Array(e2);
        }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(e2) {
          return e2 ? r.LongBits.from(e2).toHash() : r.LongBits.zeroHash;
        }, r.longFromHash = function(e2, t2) {
          var n2 = r.LongBits.fromHash(e2);
          return r.Long ? r.Long.fromBits(n2.lo, n2.hi, t2) : n2.toNumber(Boolean(t2));
        }, r.merge = i, r.lcFirst = function(e2) {
          return e2.charAt(0).toLowerCase() + e2.substring(1);
        }, r.newError = o, r.ProtocolError = o("ProtocolError"), r.oneOfGetter = function(e2) {
          for (var t2 = {}, n2 = 0; n2 < e2.length; ++n2)
            t2[e2[n2]] = 1;
          return function() {
            for (var e3 = Object.keys(this), n3 = e3.length - 1; n3 > -1; --n3)
              if (1 === t2[e3[n3]] && void 0 !== this[e3[n3]] && null !== this[e3[n3]])
                return e3[n3];
          };
        }, r.oneOfSetter = function(e2) {
          return function(t2) {
            for (var n2 = 0; n2 < e2.length; ++n2)
              e2[n2] !== t2 && delete this[e2[n2]];
          };
        }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
          var e2 = r.Buffer;
          e2 ? (r._Buffer_from = e2.from !== Uint8Array.from && e2.from || function(t2, n2) {
            return new e2(t2, n2);
          }, r._Buffer_allocUnsafe = e2.allocUnsafe || function(t2) {
            return new e2(t2);
          }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
        };
      }, 1173: (e, t, n) => {
        "use strict";
        e.exports = p;
        var r, i = n(9693), o = i.LongBits, a = i.base64, s = i.utf8;
        function u(e2, t2, n2) {
          this.fn = e2, this.len = t2, this.next = void 0, this.val = n2;
        }
        function l() {
        }
        function c(e2) {
          this.head = e2.head, this.tail = e2.tail, this.len = e2.len, this.next = e2.states;
        }
        function p() {
          this.len = 0, this.head = new u(l, 0, 0), this.tail = this.head, this.states = null;
        }
        var d = function() {
          return i.Buffer ? function() {
            return (p.create = function() {
              return new r();
            })();
          } : function() {
            return new p();
          };
        };
        function f(e2, t2, n2) {
          t2[n2] = 255 & e2;
        }
        function h(e2, t2) {
          this.len = e2, this.next = void 0, this.val = t2;
        }
        function g(e2, t2, n2) {
          for (; e2.hi; )
            t2[n2++] = 127 & e2.lo | 128, e2.lo = (e2.lo >>> 7 | e2.hi << 25) >>> 0, e2.hi >>>= 7;
          for (; e2.lo > 127; )
            t2[n2++] = 127 & e2.lo | 128, e2.lo = e2.lo >>> 7;
          t2[n2++] = e2.lo;
        }
        function m(e2, t2, n2) {
          t2[n2] = 255 & e2, t2[n2 + 1] = e2 >>> 8 & 255, t2[n2 + 2] = e2 >>> 16 & 255, t2[n2 + 3] = e2 >>> 24;
        }
        p.create = d(), p.alloc = function(e2) {
          return new i.Array(e2);
        }, i.Array !== Array && (p.alloc = i.pool(p.alloc, i.Array.prototype.subarray)), p.prototype._push = function(e2, t2, n2) {
          return this.tail = this.tail.next = new u(e2, t2, n2), this.len += t2, this;
        }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(e2, t2, n2) {
          for (; e2 > 127; )
            t2[n2++] = 127 & e2 | 128, e2 >>>= 7;
          t2[n2] = e2;
        }, p.prototype.uint32 = function(e2) {
          return this.len += (this.tail = this.tail.next = new h((e2 >>>= 0) < 128 ? 1 : e2 < 16384 ? 2 : e2 < 2097152 ? 3 : e2 < 268435456 ? 4 : 5, e2)).len, this;
        }, p.prototype.int32 = function(e2) {
          return e2 < 0 ? this._push(g, 10, o.fromNumber(e2)) : this.uint32(e2);
        }, p.prototype.sint32 = function(e2) {
          return this.uint32((e2 << 1 ^ e2 >> 31) >>> 0);
        }, p.prototype.uint64 = function(e2) {
          var t2 = o.from(e2);
          return this._push(g, t2.length(), t2);
        }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(e2) {
          var t2 = o.from(e2).zzEncode();
          return this._push(g, t2.length(), t2);
        }, p.prototype.bool = function(e2) {
          return this._push(f, 1, e2 ? 1 : 0);
        }, p.prototype.fixed32 = function(e2) {
          return this._push(m, 4, e2 >>> 0);
        }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(e2) {
          var t2 = o.from(e2);
          return this._push(m, 4, t2.lo)._push(m, 4, t2.hi);
        }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(e2) {
          return this._push(i.float.writeFloatLE, 4, e2);
        }, p.prototype.double = function(e2) {
          return this._push(i.float.writeDoubleLE, 8, e2);
        };
        var b = i.Array.prototype.set ? function(e2, t2, n2) {
          t2.set(e2, n2);
        } : function(e2, t2, n2) {
          for (var r2 = 0; r2 < e2.length; ++r2)
            t2[n2 + r2] = e2[r2];
        };
        p.prototype.bytes = function(e2) {
          var t2 = e2.length >>> 0;
          if (!t2)
            return this._push(f, 1, 0);
          if (i.isString(e2)) {
            var n2 = p.alloc(t2 = a.length(e2));
            a.decode(e2, n2, 0), e2 = n2;
          }
          return this.uint32(t2)._push(b, t2, e2);
        }, p.prototype.string = function(e2) {
          var t2 = s.length(e2);
          return t2 ? this.uint32(t2)._push(s.write, t2, e2) : this._push(f, 1, 0);
        }, p.prototype.fork = function() {
          return this.states = new c(this), this.head = this.tail = new u(l, 0, 0), this.len = 0, this;
        }, p.prototype.reset = function() {
          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(l, 0, 0), this.len = 0), this;
        }, p.prototype.ldelim = function() {
          var e2 = this.head, t2 = this.tail, n2 = this.len;
          return this.reset().uint32(n2), n2 && (this.tail.next = e2.next, this.tail = t2, this.len += n2), this;
        }, p.prototype.finish = function() {
          for (var e2 = this.head.next, t2 = this.constructor.alloc(this.len), n2 = 0; e2; )
            e2.fn(e2.val, t2, n2), n2 += e2.len, e2 = e2.next;
          return t2;
        }, p._configure = function(e2) {
          r = e2, p.create = d(), r._configure();
        };
      }, 3155: (e, t, n) => {
        "use strict";
        e.exports = o;
        var r = n(1173);
        (o.prototype = Object.create(r.prototype)).constructor = o;
        var i = n(9693);
        function o() {
          r.call(this);
        }
        function a(e2, t2, n2) {
          e2.length < 40 ? i.utf8.write(e2, t2, n2) : t2.utf8Write ? t2.utf8Write(e2, n2) : t2.write(e2, n2);
        }
        o._configure = function() {
          o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && "set" === i.Buffer.prototype.set.name ? function(e2, t2, n2) {
            t2.set(e2, n2);
          } : function(e2, t2, n2) {
            if (e2.copy)
              e2.copy(t2, n2, 0, e2.length);
            else
              for (var r2 = 0; r2 < e2.length; )
                t2[n2++] = e2[r2++];
          };
        }, o.prototype.bytes = function(e2) {
          i.isString(e2) && (e2 = i._Buffer_from(e2, "base64"));
          var t2 = e2.length >>> 0;
          return this.uint32(t2), t2 && this._push(o.writeBytesBuffer, t2, e2), this;
        }, o.prototype.string = function(e2) {
          var t2 = i.Buffer.byteLength(e2);
          return this.uint32(t2), t2 && this._push(a, t2, e2), this;
        }, o._configure();
      }, 4154: (e) => {
        "use strict";
        e.exports = '"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\n';
      }, 7067: () => {
      }, 1296: () => {
      }, 760: () => {
      }, 1384: () => {
      }, 3993: () => {
      }, 908: () => {
      }, 6953: () => {
      }, 9925: () => {
      }, 2806: () => {
      }, 6449: () => {
      }, 2850: () => {
      }, 5381: () => {
      }, 685: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveBackend = t.registerBackend = void 0;
        const n = {}, r = [];
        t.registerBackend = (e2, t2, i) => {
          if (!t2 || "function" != typeof t2.init || "function" != typeof t2.createSessionHandler)
            throw new TypeError("not a valid backend");
          {
            const o = n[e2];
            if (void 0 === o)
              n[e2] = { backend: t2, priority: i };
            else {
              if (o.priority > i)
                return;
              if (o.priority === i && o.backend !== t2)
                throw new Error(`cannot register backend "${e2}" using priority ${i}`);
            }
            if (i >= 0) {
              const t3 = r.indexOf(e2);
              -1 !== t3 && r.splice(t3, 1);
              for (let t4 = 0; t4 < r.length; t4++)
                if (n[r[t4]].priority <= i)
                  return void r.splice(t4, 0, e2);
              r.push(e2);
            }
          }
        }, t.resolveBackend = async (e2) => {
          const t2 = 0 === e2.length ? r : e2, i = [];
          for (const e3 of t2) {
            const t3 = n[e3];
            if (t3) {
              if (t3.initialized)
                return t3.backend;
              if (t3.aborted)
                continue;
              const n2 = !!t3.initPromise;
              try {
                return n2 || (t3.initPromise = t3.backend.init()), await t3.initPromise, t3.initialized = true, t3.backend;
              } catch (r2) {
                n2 || i.push({ name: e3, err: r2 }), t3.aborted = true;
              } finally {
                delete t3.initPromise;
              }
            }
          }
          throw new Error(`no available backend found. ERR: ${i.map((e3) => `[${e3.name}] ${e3.err}`).join(", ")}`);
        };
      }, 4798: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.registerBackend = void 0;
        var r = n(685);
        Object.defineProperty(t, "registerBackend", { enumerable: true, get: function() {
          return r.registerBackend;
        } });
      }, 3121: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.env = void 0;
        const r = n(9104);
        let i = "warning";
        t.env = { wasm: {}, webgl: {}, webgpu: {}, versions: { common: r.version }, set logLevel(e2) {
          if (void 0 !== e2) {
            if ("string" != typeof e2 || -1 === ["verbose", "info", "warning", "error", "fatal"].indexOf(e2))
              throw new Error(`Unsupported logging level: ${e2}`);
            i = e2;
          }
        }, get logLevel() {
          return i;
        } }, Object.defineProperty(t.env, "logLevel", { enumerable: true });
      }, 2457: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.env = void 0;
        const r = n(3121);
        t.env = r.env;
      }, 2235: function(e, t, n) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2);
          var i2 = Object.getOwnPropertyDescriptor(t2, n2);
          i2 && !("get" in i2 ? !t2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return t2[n2];
          } }), Object.defineProperty(e2, r2, i2);
        } : function(e2, t2, n2, r2) {
          void 0 === r2 && (r2 = n2), e2[r2] = t2[n2];
        }), i = this && this.__exportStar || function(e2, t2) {
          for (var n2 in e2)
            "default" === n2 || Object.prototype.hasOwnProperty.call(t2, n2) || r(t2, e2, n2);
        };
        Object.defineProperty(t, "__esModule", { value: true }), i(n(4798), t), i(n(2457), t), i(n(3974), t), i(n(963), t), i(n(7852), t);
      }, 8036: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.InferenceSession = void 0;
        const r = n(685), i = n(963);
        class o {
          constructor(e2) {
            this.handler = e2;
          }
          async run(e2, t2, n2) {
            const r2 = {};
            let o2 = {};
            if ("object" != typeof e2 || null === e2 || e2 instanceof i.Tensor || Array.isArray(e2))
              throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
            let a = true;
            if ("object" == typeof t2) {
              if (null === t2)
                throw new TypeError("Unexpected argument[1]: cannot be null.");
              if (t2 instanceof i.Tensor)
                throw new TypeError("'fetches' cannot be a Tensor");
              if (Array.isArray(t2)) {
                if (0 === t2.length)
                  throw new TypeError("'fetches' cannot be an empty array.");
                a = false;
                for (const e3 of t2) {
                  if ("string" != typeof e3)
                    throw new TypeError("'fetches' must be a string array or an object.");
                  if (-1 === this.outputNames.indexOf(e3))
                    throw new RangeError(`'fetches' contains invalid output name: ${e3}.`);
                  r2[e3] = null;
                }
                if ("object" == typeof n2 && null !== n2)
                  o2 = n2;
                else if (void 0 !== n2)
                  throw new TypeError("'options' must be an object.");
              } else {
                let e3 = false;
                const s2 = Object.getOwnPropertyNames(t2);
                for (const n3 of this.outputNames)
                  if (-1 !== s2.indexOf(n3)) {
                    const o3 = t2[n3];
                    (null === o3 || o3 instanceof i.Tensor) && (e3 = true, a = false, r2[n3] = o3);
                  }
                if (e3) {
                  if ("object" == typeof n2 && null !== n2)
                    o2 = n2;
                  else if (void 0 !== n2)
                    throw new TypeError("'options' must be an object.");
                } else
                  o2 = t2;
              }
            } else if (void 0 !== t2)
              throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
            for (const t3 of this.inputNames)
              if (void 0 === e2[t3])
                throw new Error(`input '${t3}' is missing in 'feeds'.`);
            if (a)
              for (const e3 of this.outputNames)
                r2[e3] = null;
            const s = await this.handler.run(e2, r2, o2), u = {};
            for (const e3 in s)
              Object.hasOwnProperty.call(s, e3) && (u[e3] = new i.Tensor(s[e3].type, s[e3].data, s[e3].dims));
            return u;
          }
          async release() {
            return this.handler.dispose();
          }
          static async create(e2, t2, n2, i2) {
            let a, s = {};
            if ("string" == typeof e2) {
              if (a = e2, "object" == typeof t2 && null !== t2)
                s = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else if (e2 instanceof Uint8Array) {
              if (a = e2, "object" == typeof t2 && null !== t2)
                s = t2;
              else if (void 0 !== t2)
                throw new TypeError("'options' must be an object.");
            } else {
              if (!(e2 instanceof ArrayBuffer || "undefined" != typeof SharedArrayBuffer && e2 instanceof SharedArrayBuffer))
                throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
              {
                const r2 = e2;
                let o2 = 0, u2 = e2.byteLength;
                if ("object" == typeof t2 && null !== t2)
                  s = t2;
                else if ("number" == typeof t2) {
                  if (o2 = t2, !Number.isSafeInteger(o2))
                    throw new RangeError("'byteOffset' must be an integer.");
                  if (o2 < 0 || o2 >= r2.byteLength)
                    throw new RangeError(`'byteOffset' is out of range [0, ${r2.byteLength}).`);
                  if (u2 = e2.byteLength - o2, "number" == typeof n2) {
                    if (u2 = n2, !Number.isSafeInteger(u2))
                      throw new RangeError("'byteLength' must be an integer.");
                    if (u2 <= 0 || o2 + u2 > r2.byteLength)
                      throw new RangeError(`'byteLength' is out of range (0, ${r2.byteLength - o2}].`);
                    if ("object" == typeof i2 && null !== i2)
                      s = i2;
                    else if (void 0 !== i2)
                      throw new TypeError("'options' must be an object.");
                  } else if (void 0 !== n2)
                    throw new TypeError("'byteLength' must be a number.");
                } else if (void 0 !== t2)
                  throw new TypeError("'options' must be an object.");
                a = new Uint8Array(r2, o2, u2);
              }
            }
            const u = (s.executionProviders || []).map((e3) => "string" == typeof e3 ? e3 : e3.name), l = await (0, r.resolveBackend)(u), c = await l.createSessionHandler(a, s);
            return new o(c);
          }
          startProfiling() {
            this.handler.startProfiling();
          }
          endProfiling() {
            this.handler.endProfiling();
          }
          get inputNames() {
            return this.handler.inputNames;
          }
          get outputNames() {
            return this.handler.outputNames;
          }
        }
        t.InferenceSession = o;
      }, 3974: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.InferenceSession = void 0;
        const r = n(8036);
        t.InferenceSession = r.InferenceSession;
      }, 7852: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
      }, 2350: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorToImageData = t.tensorToDataURL = void 0, t.tensorToDataURL = (e2, t2) => {
          const n = document.createElement("canvas");
          n.width = e2.dims[3], n.height = e2.dims[2];
          const r = n.getContext("2d");
          if (null != r) {
            let i, o;
            void 0 !== t2?.tensorLayout && "NHWC" === t2.tensorLayout ? (i = e2.dims[2], o = e2.dims[3]) : (i = e2.dims[3], o = e2.dims[2]);
            const a = void 0 !== t2?.format ? t2.format : "RGB", s = t2?.norm;
            let u, l;
            void 0 === s || void 0 === s.mean ? u = [255, 255, 255, 255] : "number" == typeof s.mean ? u = [s.mean, s.mean, s.mean, s.mean] : (u = [s.mean[0], s.mean[1], s.mean[2], 0], void 0 !== s.mean[3] && (u[3] = s.mean[3])), void 0 === s || void 0 === s.bias ? l = [0, 0, 0, 0] : "number" == typeof s.bias ? l = [s.bias, s.bias, s.bias, s.bias] : (l = [s.bias[0], s.bias[1], s.bias[2], 0], void 0 !== s.bias[3] && (l[3] = s.bias[3]));
            const c = o * i;
            let p = 0, d = c, f = 2 * c, h = -1;
            "RGBA" === a ? (p = 0, d = c, f = 2 * c, h = 3 * c) : "RGB" === a ? (p = 0, d = c, f = 2 * c) : "RBG" === a && (p = 0, f = c, d = 2 * c);
            for (let t3 = 0; t3 < o; t3++)
              for (let n2 = 0; n2 < i; n2++) {
                const i2 = (e2.data[p++] - l[0]) * u[0], o2 = (e2.data[d++] - l[1]) * u[1], a2 = (e2.data[f++] - l[2]) * u[2], s2 = -1 === h ? 255 : (e2.data[h++] - l[3]) * u[3];
                r.fillStyle = "rgba(" + i2 + "," + o2 + "," + a2 + "," + s2 + ")", r.fillRect(n2, t3, 1, 1);
              }
            return n.toDataURL();
          }
          throw new Error("Can not access image data");
        }, t.tensorToImageData = (e2, t2) => {
          const n = document.createElement("canvas").getContext("2d");
          let r;
          if (null == n)
            throw new Error("Can not access image data");
          {
            let i, o, a;
            void 0 !== t2?.tensorLayout && "NHWC" === t2.tensorLayout ? (i = e2.dims[2], o = e2.dims[1], a = e2.dims[3]) : (i = e2.dims[3], o = e2.dims[2], a = e2.dims[1]);
            const s = void 0 !== t2 && void 0 !== t2.format ? t2.format : "RGB", u = t2?.norm;
            let l, c;
            void 0 === u || void 0 === u.mean ? l = [255, 255, 255, 255] : "number" == typeof u.mean ? l = [u.mean, u.mean, u.mean, u.mean] : (l = [u.mean[0], u.mean[1], u.mean[2], 255], void 0 !== u.mean[3] && (l[3] = u.mean[3])), void 0 === u || void 0 === u.bias ? c = [0, 0, 0, 0] : "number" == typeof u.bias ? c = [u.bias, u.bias, u.bias, u.bias] : (c = [u.bias[0], u.bias[1], u.bias[2], 0], void 0 !== u.bias[3] && (c[3] = u.bias[3]));
            const p = o * i;
            if (void 0 !== t2 && (void 0 !== t2.format && 4 === a && "RGBA" !== t2.format || 3 === a && "RGB" !== t2.format && "BGR" !== t2.format))
              throw new Error("Tensor format doesn't match input tensor dims");
            const d = 4;
            let f = 0, h = 1, g = 2, m = 3, b = 0, y = p, v = 2 * p, w = -1;
            "RGBA" === s ? (b = 0, y = p, v = 2 * p, w = 3 * p) : "RGB" === s ? (b = 0, y = p, v = 2 * p) : "RBG" === s && (b = 0, v = p, y = 2 * p), r = n.createImageData(i, o);
            for (let t3 = 0; t3 < o * i; f += d, h += d, g += d, m += d, t3++)
              r.data[f] = (e2.data[b++] - c[0]) * l[0], r.data[h] = (e2.data[y++] - c[1]) * l[1], r.data[g] = (e2.data[v++] - c[2]) * l[2], r.data[m] = -1 === w ? 255 : (e2.data[w++] - c[3]) * l[3];
          }
          return r;
        };
      }, 4866: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorFromImage = t.bufferToTensor = void 0;
        const r = n(963);
        t.bufferToTensor = (e2, t2) => {
          if (void 0 === e2)
            throw new Error("Image buffer must be defined");
          if (void 0 === t2.height || void 0 === t2.width)
            throw new Error("Image height and width must be defined");
          if ("NHWC" === t2.tensorLayout)
            throw new Error("NHWC Tensor layout is not supported yet");
          const { height: n2, width: i } = t2, o = t2.norm ?? { mean: 255, bias: 0 };
          let a, s;
          a = "number" == typeof o.mean ? [o.mean, o.mean, o.mean, o.mean] : [o.mean[0], o.mean[1], o.mean[2], o.mean[3] ?? 255], s = "number" == typeof o.bias ? [o.bias, o.bias, o.bias, o.bias] : [o.bias[0], o.bias[1], o.bias[2], o.bias[3] ?? 0];
          const u = void 0 !== t2.format ? t2.format : "RGBA", l = void 0 !== t2.tensorFormat && void 0 !== t2.tensorFormat ? t2.tensorFormat : "RGB", c = n2 * i, p = "RGBA" === l ? new Float32Array(4 * c) : new Float32Array(3 * c);
          let d = 4, f = 0, h = 1, g = 2, m = 3, b = 0, y = c, v = 2 * c, w = -1;
          "RGB" === u && (d = 3, f = 0, h = 1, g = 2, m = -1), "RGBA" === l ? w = 3 * c : "RBG" === l ? (b = 0, v = c, y = 2 * c) : "BGR" === l && (v = 0, y = c, b = 2 * c);
          for (let t3 = 0; t3 < c; t3++, f += d, g += d, h += d, m += d)
            p[b++] = (e2[f] + s[0]) / a[0], p[y++] = (e2[h] + s[1]) / a[1], p[v++] = (e2[g] + s[2]) / a[2], -1 !== w && -1 !== m && (p[w++] = (e2[m] + s[3]) / a[3]);
          return "RGBA" === l ? new r.Tensor("float32", p, [1, 4, n2, i]) : new r.Tensor("float32", p, [1, 3, n2, i]);
        }, t.tensorFromImage = async (e2, n2) => {
          const r2 = "undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement, i = "undefined" != typeof ImageData && e2 instanceof ImageData, o = "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap, a = "string" == typeof e2;
          let s, u = n2 ?? {};
          if (r2) {
            const t2 = document.createElement("canvas");
            t2.width = e2.width, t2.height = e2.height;
            const r3 = t2.getContext("2d");
            if (null == r3)
              throw new Error("Can not access image data");
            {
              let t3 = e2.height, i2 = e2.width;
              if (void 0 !== n2 && void 0 !== n2.resizedHeight && void 0 !== n2.resizedWidth && (t3 = n2.resizedHeight, i2 = n2.resizedWidth), void 0 !== n2) {
                if (u = n2, void 0 !== n2.tensorFormat)
                  throw new Error("Image input config format must be RGBA for HTMLImageElement");
                u.tensorFormat = "RGBA", u.height = t3, u.width = i2;
              } else
                u.tensorFormat = "RGBA", u.height = t3, u.width = i2;
              r3.drawImage(e2, 0, 0), s = r3.getImageData(0, 0, i2, t3).data;
            }
          } else {
            if (!i) {
              if (o) {
                if (void 0 === n2)
                  throw new Error("Please provide image config with format for Imagebitmap");
                const r3 = document.createElement("canvas");
                r3.width = e2.width, r3.height = e2.height;
                const i2 = r3.getContext("2d");
                if (null != i2) {
                  const n3 = e2.height, r4 = e2.width;
                  return i2.drawImage(e2, 0, 0, r4, n3), s = i2.getImageData(0, 0, r4, n3).data, u.height = n3, u.width = r4, (0, t.bufferToTensor)(s, u);
                }
                throw new Error("Can not access image data");
              }
              if (a)
                return new Promise((n3, r3) => {
                  const i2 = document.createElement("canvas"), o2 = i2.getContext("2d");
                  if (!e2 || !o2)
                    return r3();
                  const a2 = new Image();
                  a2.crossOrigin = "Anonymous", a2.src = e2, a2.onload = () => {
                    i2.width = a2.width, i2.height = a2.height, o2.drawImage(a2, 0, 0, i2.width, i2.height);
                    const e3 = o2.getImageData(0, 0, i2.width, i2.height);
                    u.height = i2.height, u.width = i2.width, n3((0, t.bufferToTensor)(e3.data, u));
                  };
                });
              throw new Error("Input data provided is not supported - aborted tensor creation");
            }
            {
              let t2, r3;
              if (void 0 !== n2 && void 0 !== n2.resizedWidth && void 0 !== n2.resizedHeight ? (t2 = n2.resizedHeight, r3 = n2.resizedWidth) : (t2 = e2.height, r3 = e2.width), void 0 !== n2 && (u = n2), u.format = "RGBA", u.height = t2, u.width = r3, void 0 !== n2) {
                const n3 = document.createElement("canvas");
                n3.width = r3, n3.height = t2;
                const i2 = n3.getContext("2d");
                if (null == i2)
                  throw new Error("Can not access image data");
                i2.putImageData(e2, 0, 0), s = i2.getImageData(0, 0, r3, t2).data;
              } else
                s = e2.data;
            }
          }
          if (void 0 !== s)
            return (0, t.bufferToTensor)(s, u);
          throw new Error("Input data provided is not supported - aborted tensor creation");
        };
      }, 5957: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const r = n(2350), i = n(4866), o = n(106), a = /* @__PURE__ */ new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["float16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]]), s = /* @__PURE__ */ new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]);
        let u = false;
        t.Tensor = class {
          constructor(e2, t2, n2) {
            let r2, i2, l;
            if ((() => {
              if (!u) {
                u = true;
                const e3 = "undefined" != typeof BigInt64Array && "function" == typeof BigInt64Array.from, t3 = "undefined" != typeof BigUint64Array && "function" == typeof BigUint64Array.from;
                e3 && (a.set("int64", BigInt64Array), s.set(BigInt64Array, "int64")), t3 && (a.set("uint64", BigUint64Array), s.set(BigUint64Array, "uint64"));
              }
            })(), "string" == typeof e2)
              if (r2 = e2, l = n2, "string" === e2) {
                if (!Array.isArray(t2))
                  throw new TypeError("A string tensor's data must be a string array.");
                i2 = t2;
              } else {
                const n3 = a.get(e2);
                if (void 0 === n3)
                  throw new TypeError(`Unsupported tensor type: ${e2}.`);
                if (Array.isArray(t2)) {
                  if ("float16" === e2)
                    throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                  i2 = "uint64" === e2 || "int64" === e2 ? n3.from(t2, BigInt) : n3.from(t2);
                } else {
                  if (!(t2 instanceof n3))
                    throw new TypeError(`A ${r2} tensor's data must be type of ${n3}`);
                  i2 = t2;
                }
              }
            else if (l = t2, Array.isArray(e2)) {
              if (0 === e2.length)
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              const t3 = typeof e2[0];
              if ("string" === t3)
                r2 = "string", i2 = e2;
              else {
                if ("boolean" !== t3)
                  throw new TypeError(`Invalid element type of data array: ${t3}.`);
                r2 = "bool", i2 = Uint8Array.from(e2);
              }
            } else {
              const t3 = s.get(e2.constructor);
              if (void 0 === t3)
                throw new TypeError(`Unsupported type for tensor data: ${e2.constructor}.`);
              r2 = t3, i2 = e2;
            }
            if (void 0 === l)
              l = [i2.length];
            else if (!Array.isArray(l))
              throw new TypeError("A tensor's dims must be a number array");
            const c = (0, o.calculateSize)(l);
            if (c !== i2.length)
              throw new Error(`Tensor's size(${c}) does not match data length(${i2.length}).`);
            this.dims = l, this.type = r2, this.data = i2, this.size = c;
          }
          static async fromImage(e2, t2) {
            return (0, i.tensorFromImage)(e2, t2);
          }
          toDataURL(e2) {
            return (0, r.tensorToDataURL)(this, e2);
          }
          toImageData(e2) {
            return (0, r.tensorToImageData)(this, e2);
          }
          reshape(e2) {
            return (0, o.tensorReshape)(this, e2);
          }
        };
      }, 106: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.tensorReshape = t.calculateSize = void 0;
        const r = n(963);
        t.calculateSize = (e2) => {
          let t2 = 1;
          for (let n2 = 0; n2 < e2.length; n2++) {
            const r2 = e2[n2];
            if ("number" != typeof r2 || !Number.isSafeInteger(r2))
              throw new TypeError(`dims[${n2}] must be an integer, got: ${r2}`);
            if (r2 < 0)
              throw new RangeError(`dims[${n2}] must be a non-negative integer, got: ${r2}`);
            t2 *= r2;
          }
          return t2;
        }, t.tensorReshape = (e2, t2) => new r.Tensor(e2.type, e2.data, t2);
      }, 963: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Tensor = void 0;
        const r = n(5957);
        t.Tensor = r.Tensor;
      }, 9104: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.version = void 0, t.version = "1.16.3";
      }, 1583: (e, t) => {
        var n, r = function(e2) {
          "use strict";
          Object.defineProperty(e2, "__esModule", { value: true }), e2.default = void 0;
          var t2 = null;
          try {
            t2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
          } catch (e3) {
          }
          function n2(e3, t3, n3) {
            this.low = 0 | e3, this.high = 0 | t3, this.unsigned = !!n3;
          }
          function r2(e3) {
            return true === (e3 && e3.__isLong__);
          }
          function i(e3) {
            var t3 = Math.clz32(e3 & -e3);
            return e3 ? 31 - t3 : t3;
          }
          n2.prototype.__isLong__, Object.defineProperty(n2.prototype, "__isLong__", { value: true }), n2.isLong = r2;
          var o = {}, a = {};
          function s(e3, t3) {
            var n3, r3, i2;
            return t3 ? (i2 = 0 <= (e3 >>>= 0) && e3 < 256) && (r3 = a[e3]) ? r3 : (n3 = l(e3, 0, true), i2 && (a[e3] = n3), n3) : (i2 = -128 <= (e3 |= 0) && e3 < 128) && (r3 = o[e3]) ? r3 : (n3 = l(e3, e3 < 0 ? -1 : 0, false), i2 && (o[e3] = n3), n3);
          }
          function u(e3, t3) {
            if (isNaN(e3))
              return t3 ? y : b;
            if (t3) {
              if (e3 < 0)
                return y;
              if (e3 >= h)
                return T;
            } else {
              if (e3 <= -g)
                return S;
              if (e3 + 1 >= g)
                return _;
            }
            return e3 < 0 ? u(-e3, t3).neg() : l(e3 % f | 0, e3 / f | 0, t3);
          }
          function l(e3, t3, r3) {
            return new n2(e3, t3, r3);
          }
          n2.fromInt = s, n2.fromNumber = u, n2.fromBits = l;
          var c = Math.pow;
          function p(e3, t3, n3) {
            if (0 === e3.length)
              throw Error("empty string");
            if ("number" == typeof t3 ? (n3 = t3, t3 = false) : t3 = !!t3, "NaN" === e3 || "Infinity" === e3 || "+Infinity" === e3 || "-Infinity" === e3)
              return t3 ? y : b;
            if ((n3 = n3 || 10) < 2 || 36 < n3)
              throw RangeError("radix");
            var r3;
            if ((r3 = e3.indexOf("-")) > 0)
              throw Error("interior hyphen");
            if (0 === r3)
              return p(e3.substring(1), t3, n3).neg();
            for (var i2 = u(c(n3, 8)), o2 = b, a2 = 0; a2 < e3.length; a2 += 8) {
              var s2 = Math.min(8, e3.length - a2), l2 = parseInt(e3.substring(a2, a2 + s2), n3);
              if (s2 < 8) {
                var d2 = u(c(n3, s2));
                o2 = o2.mul(d2).add(u(l2));
              } else
                o2 = (o2 = o2.mul(i2)).add(u(l2));
            }
            return o2.unsigned = t3, o2;
          }
          function d(e3, t3) {
            return "number" == typeof e3 ? u(e3, t3) : "string" == typeof e3 ? p(e3, t3) : l(e3.low, e3.high, "boolean" == typeof t3 ? t3 : e3.unsigned);
          }
          n2.fromString = p, n2.fromValue = d;
          var f = 4294967296, h = f * f, g = h / 2, m = s(1 << 24), b = s(0);
          n2.ZERO = b;
          var y = s(0, true);
          n2.UZERO = y;
          var v = s(1);
          n2.ONE = v;
          var w = s(1, true);
          n2.UONE = w;
          var x = s(-1);
          n2.NEG_ONE = x;
          var _ = l(-1, 2147483647, false);
          n2.MAX_VALUE = _;
          var T = l(-1, -1, true);
          n2.MAX_UNSIGNED_VALUE = T;
          var S = l(0, -2147483648, false);
          n2.MIN_VALUE = S;
          var $ = n2.prototype;
          $.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }, $.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);
          }, $.toString = function(e3) {
            if ((e3 = e3 || 10) < 2 || 36 < e3)
              throw RangeError("radix");
            if (this.isZero())
              return "0";
            if (this.isNegative()) {
              if (this.eq(S)) {
                var t3 = u(e3), n3 = this.div(t3), r3 = n3.mul(t3).sub(this);
                return n3.toString(e3) + r3.toInt().toString(e3);
              }
              return "-" + this.neg().toString(e3);
            }
            for (var i2 = u(c(e3, 6), this.unsigned), o2 = this, a2 = ""; ; ) {
              var s2 = o2.div(i2), l2 = (o2.sub(s2.mul(i2)).toInt() >>> 0).toString(e3);
              if ((o2 = s2).isZero())
                return l2 + a2;
              for (; l2.length < 6; )
                l2 = "0" + l2;
              a2 = "" + l2 + a2;
            }
          }, $.getHighBits = function() {
            return this.high;
          }, $.getHighBitsUnsigned = function() {
            return this.high >>> 0;
          }, $.getLowBits = function() {
            return this.low;
          }, $.getLowBitsUnsigned = function() {
            return this.low >>> 0;
          }, $.getNumBitsAbs = function() {
            if (this.isNegative())
              return this.eq(S) ? 64 : this.neg().getNumBitsAbs();
            for (var e3 = 0 != this.high ? this.high : this.low, t3 = 31; t3 > 0 && 0 == (e3 & 1 << t3); t3--)
              ;
            return 0 != this.high ? t3 + 33 : t3 + 1;
          }, $.isZero = function() {
            return 0 === this.high && 0 === this.low;
          }, $.eqz = $.isZero, $.isNegative = function() {
            return !this.unsigned && this.high < 0;
          }, $.isPositive = function() {
            return this.unsigned || this.high >= 0;
          }, $.isOdd = function() {
            return 1 == (1 & this.low);
          }, $.isEven = function() {
            return 0 == (1 & this.low);
          }, $.equals = function(e3) {
            return r2(e3) || (e3 = d(e3)), (this.unsigned === e3.unsigned || this.high >>> 31 != 1 || e3.high >>> 31 != 1) && this.high === e3.high && this.low === e3.low;
          }, $.eq = $.equals, $.notEquals = function(e3) {
            return !this.eq(e3);
          }, $.neq = $.notEquals, $.ne = $.notEquals, $.lessThan = function(e3) {
            return this.comp(e3) < 0;
          }, $.lt = $.lessThan, $.lessThanOrEqual = function(e3) {
            return this.comp(e3) <= 0;
          }, $.lte = $.lessThanOrEqual, $.le = $.lessThanOrEqual, $.greaterThan = function(e3) {
            return this.comp(e3) > 0;
          }, $.gt = $.greaterThan, $.greaterThanOrEqual = function(e3) {
            return this.comp(e3) >= 0;
          }, $.gte = $.greaterThanOrEqual, $.ge = $.greaterThanOrEqual, $.compare = function(e3) {
            if (r2(e3) || (e3 = d(e3)), this.eq(e3))
              return 0;
            var t3 = this.isNegative(), n3 = e3.isNegative();
            return t3 && !n3 ? -1 : !t3 && n3 ? 1 : this.unsigned ? e3.high >>> 0 > this.high >>> 0 || e3.high === this.high && e3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e3).isNegative() ? -1 : 1;
          }, $.comp = $.compare, $.negate = function() {
            return !this.unsigned && this.eq(S) ? S : this.not().add(v);
          }, $.neg = $.negate, $.add = function(e3) {
            r2(e3) || (e3 = d(e3));
            var t3 = this.high >>> 16, n3 = 65535 & this.high, i2 = this.low >>> 16, o2 = 65535 & this.low, a2 = e3.high >>> 16, s2 = 65535 & e3.high, u2 = e3.low >>> 16, c2 = 0, p2 = 0, f2 = 0, h2 = 0;
            return f2 += (h2 += o2 + (65535 & e3.low)) >>> 16, p2 += (f2 += i2 + u2) >>> 16, c2 += (p2 += n3 + s2) >>> 16, c2 += t3 + a2, l((f2 &= 65535) << 16 | (h2 &= 65535), (c2 &= 65535) << 16 | (p2 &= 65535), this.unsigned);
          }, $.subtract = function(e3) {
            return r2(e3) || (e3 = d(e3)), this.add(e3.neg());
          }, $.sub = $.subtract, $.multiply = function(e3) {
            if (this.isZero())
              return this;
            if (r2(e3) || (e3 = d(e3)), t2)
              return l(t2.mul(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned);
            if (e3.isZero())
              return this.unsigned ? y : b;
            if (this.eq(S))
              return e3.isOdd() ? S : b;
            if (e3.eq(S))
              return this.isOdd() ? S : b;
            if (this.isNegative())
              return e3.isNegative() ? this.neg().mul(e3.neg()) : this.neg().mul(e3).neg();
            if (e3.isNegative())
              return this.mul(e3.neg()).neg();
            if (this.lt(m) && e3.lt(m))
              return u(this.toNumber() * e3.toNumber(), this.unsigned);
            var n3 = this.high >>> 16, i2 = 65535 & this.high, o2 = this.low >>> 16, a2 = 65535 & this.low, s2 = e3.high >>> 16, c2 = 65535 & e3.high, p2 = e3.low >>> 16, f2 = 65535 & e3.low, h2 = 0, g2 = 0, v2 = 0, w2 = 0;
            return v2 += (w2 += a2 * f2) >>> 16, g2 += (v2 += o2 * f2) >>> 16, v2 &= 65535, g2 += (v2 += a2 * p2) >>> 16, h2 += (g2 += i2 * f2) >>> 16, g2 &= 65535, h2 += (g2 += o2 * p2) >>> 16, g2 &= 65535, h2 += (g2 += a2 * c2) >>> 16, h2 += n3 * f2 + i2 * p2 + o2 * c2 + a2 * s2, l((v2 &= 65535) << 16 | (w2 &= 65535), (h2 &= 65535) << 16 | (g2 &= 65535), this.unsigned);
          }, $.mul = $.multiply, $.divide = function(e3) {
            if (r2(e3) || (e3 = d(e3)), e3.isZero())
              throw Error("division by zero");
            var n3, i2, o2;
            if (t2)
              return this.unsigned || -2147483648 !== this.high || -1 !== e3.low || -1 !== e3.high ? l((this.unsigned ? t2.div_u : t2.div_s)(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned) : this;
            if (this.isZero())
              return this.unsigned ? y : b;
            if (this.unsigned) {
              if (e3.unsigned || (e3 = e3.toUnsigned()), e3.gt(this))
                return y;
              if (e3.gt(this.shru(1)))
                return w;
              o2 = y;
            } else {
              if (this.eq(S))
                return e3.eq(v) || e3.eq(x) ? S : e3.eq(S) ? v : (n3 = this.shr(1).div(e3).shl(1)).eq(b) ? e3.isNegative() ? v : x : (i2 = this.sub(e3.mul(n3)), o2 = n3.add(i2.div(e3)));
              if (e3.eq(S))
                return this.unsigned ? y : b;
              if (this.isNegative())
                return e3.isNegative() ? this.neg().div(e3.neg()) : this.neg().div(e3).neg();
              if (e3.isNegative())
                return this.div(e3.neg()).neg();
              o2 = b;
            }
            for (i2 = this; i2.gte(e3); ) {
              n3 = Math.max(1, Math.floor(i2.toNumber() / e3.toNumber()));
              for (var a2 = Math.ceil(Math.log(n3) / Math.LN2), s2 = a2 <= 48 ? 1 : c(2, a2 - 48), p2 = u(n3), f2 = p2.mul(e3); f2.isNegative() || f2.gt(i2); )
                f2 = (p2 = u(n3 -= s2, this.unsigned)).mul(e3);
              p2.isZero() && (p2 = v), o2 = o2.add(p2), i2 = i2.sub(f2);
            }
            return o2;
          }, $.div = $.divide, $.modulo = function(e3) {
            return r2(e3) || (e3 = d(e3)), t2 ? l((this.unsigned ? t2.rem_u : t2.rem_s)(this.low, this.high, e3.low, e3.high), t2.get_high(), this.unsigned) : this.sub(this.div(e3).mul(e3));
          }, $.mod = $.modulo, $.rem = $.modulo, $.not = function() {
            return l(~this.low, ~this.high, this.unsigned);
          }, $.countLeadingZeros = function() {
            return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
          }, $.clz = $.countLeadingZeros, $.countTrailingZeros = function() {
            return this.low ? i(this.low) : i(this.high) + 32;
          }, $.ctz = $.countTrailingZeros, $.and = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low & e3.low, this.high & e3.high, this.unsigned);
          }, $.or = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low | e3.low, this.high | e3.high, this.unsigned);
          }, $.xor = function(e3) {
            return r2(e3) || (e3 = d(e3)), l(this.low ^ e3.low, this.high ^ e3.high, this.unsigned);
          }, $.shiftLeft = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low << e3, this.high << e3 | this.low >>> 32 - e3, this.unsigned) : l(0, this.low << e3 - 32, this.unsigned);
          }, $.shl = $.shiftLeft, $.shiftRight = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low >>> e3 | this.high << 32 - e3, this.high >> e3, this.unsigned) : l(this.high >> e3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }, $.shr = $.shiftRight, $.shiftRightUnsigned = function(e3) {
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? l(this.low >>> e3 | this.high << 32 - e3, this.high >>> e3, this.unsigned) : l(32 === e3 ? this.high : this.high >>> e3 - 32, 0, this.unsigned);
          }, $.shru = $.shiftRightUnsigned, $.shr_u = $.shiftRightUnsigned, $.rotateLeft = function(e3) {
            var t3;
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : 32 === e3 ? l(this.high, this.low, this.unsigned) : e3 < 32 ? (t3 = 32 - e3, l(this.low << e3 | this.high >>> t3, this.high << e3 | this.low >>> t3, this.unsigned)) : (t3 = 32 - (e3 -= 32), l(this.high << e3 | this.low >>> t3, this.low << e3 | this.high >>> t3, this.unsigned));
          }, $.rotl = $.rotateLeft, $.rotateRight = function(e3) {
            var t3;
            return r2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : 32 === e3 ? l(this.high, this.low, this.unsigned) : e3 < 32 ? (t3 = 32 - e3, l(this.high << t3 | this.low >>> e3, this.low << t3 | this.high >>> e3, this.unsigned)) : (t3 = 32 - (e3 -= 32), l(this.low << t3 | this.high >>> e3, this.high << t3 | this.low >>> e3, this.unsigned));
          }, $.rotr = $.rotateRight, $.toSigned = function() {
            return this.unsigned ? l(this.low, this.high, false) : this;
          }, $.toUnsigned = function() {
            return this.unsigned ? this : l(this.low, this.high, true);
          }, $.toBytes = function(e3) {
            return e3 ? this.toBytesLE() : this.toBytesBE();
          }, $.toBytesLE = function() {
            var e3 = this.high, t3 = this.low;
            return [255 & t3, t3 >>> 8 & 255, t3 >>> 16 & 255, t3 >>> 24, 255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24];
          }, $.toBytesBE = function() {
            var e3 = this.high, t3 = this.low;
            return [e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3, t3 >>> 24, t3 >>> 16 & 255, t3 >>> 8 & 255, 255 & t3];
          }, n2.fromBytes = function(e3, t3, r3) {
            return r3 ? n2.fromBytesLE(e3, t3) : n2.fromBytesBE(e3, t3);
          }, n2.fromBytesLE = function(e3, t3) {
            return new n2(e3[0] | e3[1] << 8 | e3[2] << 16 | e3[3] << 24, e3[4] | e3[5] << 8 | e3[6] << 16 | e3[7] << 24, t3);
          }, n2.fromBytesBE = function(e3, t3) {
            return new n2(e3[4] << 24 | e3[5] << 16 | e3[6] << 8 | e3[7], e3[0] << 24 | e3[1] << 16 | e3[2] << 8 | e3[3], t3);
          };
          var O = n2;
          return e2.default = O, "default" in e2 ? e2.default : e2;
        }({});
        void 0 === (n = function() {
          return r;
        }.apply(t, [])) || (e.exports = n);
      }, 5686: (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { flatbuffers: () => r });
        var r = {};
        r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function(e2, t2) {
          this.low = 0 | e2, this.high = 0 | t2;
        }, r.Long.create = function(e2, t2) {
          return 0 == e2 && 0 == t2 ? r.Long.ZERO : new r.Long(e2, t2);
        }, r.Long.prototype.toFloat64 = function() {
          return (this.low >>> 0) + 4294967296 * this.high;
        }, r.Long.prototype.equals = function(e2) {
          return this.low == e2.low && this.high == e2.high;
        }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(e2) {
          if (e2)
            t2 = e2;
          else
            var t2 = 1024;
          this.bb = r.ByteBuffer.allocate(t2), this.space = t2, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        }, r.Builder.prototype.clear = function() {
          this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
        }, r.Builder.prototype.forceDefaults = function(e2) {
          this.force_defaults = e2;
        }, r.Builder.prototype.dataBuffer = function() {
          return this.bb;
        }, r.Builder.prototype.asUint8Array = function() {
          return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
        }, r.Builder.prototype.prep = function(e2, t2) {
          e2 > this.minalign && (this.minalign = e2);
          for (var n2 = 1 + ~(this.bb.capacity() - this.space + t2) & e2 - 1; this.space < n2 + e2 + t2; ) {
            var i = this.bb.capacity();
            this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
          }
          this.pad(n2);
        }, r.Builder.prototype.pad = function(e2) {
          for (var t2 = 0; t2 < e2; t2++)
            this.bb.writeInt8(--this.space, 0);
        }, r.Builder.prototype.writeInt8 = function(e2) {
          this.bb.writeInt8(this.space -= 1, e2);
        }, r.Builder.prototype.writeInt16 = function(e2) {
          this.bb.writeInt16(this.space -= 2, e2);
        }, r.Builder.prototype.writeInt32 = function(e2) {
          this.bb.writeInt32(this.space -= 4, e2);
        }, r.Builder.prototype.writeInt64 = function(e2) {
          this.bb.writeInt64(this.space -= 8, e2);
        }, r.Builder.prototype.writeFloat32 = function(e2) {
          this.bb.writeFloat32(this.space -= 4, e2);
        }, r.Builder.prototype.writeFloat64 = function(e2) {
          this.bb.writeFloat64(this.space -= 8, e2);
        }, r.Builder.prototype.addInt8 = function(e2) {
          this.prep(1, 0), this.writeInt8(e2);
        }, r.Builder.prototype.addInt16 = function(e2) {
          this.prep(2, 0), this.writeInt16(e2);
        }, r.Builder.prototype.addInt32 = function(e2) {
          this.prep(4, 0), this.writeInt32(e2);
        }, r.Builder.prototype.addInt64 = function(e2) {
          this.prep(8, 0), this.writeInt64(e2);
        }, r.Builder.prototype.addFloat32 = function(e2) {
          this.prep(4, 0), this.writeFloat32(e2);
        }, r.Builder.prototype.addFloat64 = function(e2) {
          this.prep(8, 0), this.writeFloat64(e2);
        }, r.Builder.prototype.addFieldInt8 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt8(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt16 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt16(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt32 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addInt32(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldInt64 = function(e2, t2, n2) {
          !this.force_defaults && t2.equals(n2) || (this.addInt64(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldFloat32 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addFloat32(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldFloat64 = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addFloat64(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldOffset = function(e2, t2, n2) {
          (this.force_defaults || t2 != n2) && (this.addOffset(t2), this.slot(e2));
        }, r.Builder.prototype.addFieldStruct = function(e2, t2, n2) {
          t2 != n2 && (this.nested(t2), this.slot(e2));
        }, r.Builder.prototype.nested = function(e2) {
          if (e2 != this.offset())
            throw new Error("FlatBuffers: struct must be serialized inline.");
        }, r.Builder.prototype.notNested = function() {
          if (this.isNested)
            throw new Error("FlatBuffers: object serialization must not be nested.");
        }, r.Builder.prototype.slot = function(e2) {
          this.vtable[e2] = this.offset();
        }, r.Builder.prototype.offset = function() {
          return this.bb.capacity() - this.space;
        }, r.Builder.growByteBuffer = function(e2) {
          var t2 = e2.capacity();
          if (3221225472 & t2)
            throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
          var n2 = t2 << 1, i = r.ByteBuffer.allocate(n2);
          return i.setPosition(n2 - t2), i.bytes().set(e2.bytes(), n2 - t2), i;
        }, r.Builder.prototype.addOffset = function(e2) {
          this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - e2 + r.SIZEOF_INT);
        }, r.Builder.prototype.startObject = function(e2) {
          this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = e2;
          for (var t2 = 0; t2 < e2; t2++)
            this.vtable[t2] = 0;
          this.isNested = true, this.object_start = this.offset();
        }, r.Builder.prototype.endObject = function() {
          if (null == this.vtable || !this.isNested)
            throw new Error("FlatBuffers: endObject called without startObject");
          this.addInt32(0);
          for (var e2 = this.offset(), t2 = this.vtable_in_use - 1; t2 >= 0 && 0 == this.vtable[t2]; t2--)
            ;
          for (var n2 = t2 + 1; t2 >= 0; t2--)
            this.addInt16(0 != this.vtable[t2] ? e2 - this.vtable[t2] : 0);
          this.addInt16(e2 - this.object_start);
          var i = (n2 + 2) * r.SIZEOF_SHORT;
          this.addInt16(i);
          var o = 0, a = this.space;
          e:
            for (t2 = 0; t2 < this.vtables.length; t2++) {
              var s = this.bb.capacity() - this.vtables[t2];
              if (i == this.bb.readInt16(s)) {
                for (var u = r.SIZEOF_SHORT; u < i; u += r.SIZEOF_SHORT)
                  if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u))
                    continue e;
                o = this.vtables[t2];
                break;
              }
            }
          return o ? (this.space = this.bb.capacity() - e2, this.bb.writeInt32(this.space, o - e2)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e2, this.offset() - e2)), this.isNested = false, e2;
        }, r.Builder.prototype.finish = function(e2, t2, n2) {
          var i = n2 ? r.SIZE_PREFIX_LENGTH : 0;
          if (t2) {
            var o = t2;
            if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + i), o.length != r.FILE_IDENTIFIER_LENGTH)
              throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
            for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--)
              this.writeInt8(o.charCodeAt(a));
          }
          this.prep(this.minalign, r.SIZEOF_INT + i), this.addOffset(e2), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
        }, r.Builder.prototype.finishSizePrefixed = function(e2, t2) {
          this.finish(e2, t2, true);
        }, r.Builder.prototype.requiredField = function(e2, t2) {
          var n2 = this.bb.capacity() - e2, r2 = n2 - this.bb.readInt32(n2);
          if (0 == this.bb.readInt16(r2 + t2))
            throw new Error("FlatBuffers: field " + t2 + " must be set");
        }, r.Builder.prototype.startVector = function(e2, t2, n2) {
          this.notNested(), this.vector_num_elems = t2, this.prep(r.SIZEOF_INT, e2 * t2), this.prep(n2, e2 * t2);
        }, r.Builder.prototype.endVector = function() {
          return this.writeInt32(this.vector_num_elems), this.offset();
        }, r.Builder.prototype.createString = function(e2) {
          if (e2 instanceof Uint8Array)
            var t2 = e2;
          else {
            t2 = [];
            for (var n2 = 0; n2 < e2.length; ) {
              var r2, i = e2.charCodeAt(n2++);
              (r2 = i < 55296 || i >= 56320 ? i : (i << 10) + e2.charCodeAt(n2++) + -56613888) < 128 ? t2.push(r2) : (r2 < 2048 ? t2.push(r2 >> 6 & 31 | 192) : (r2 < 65536 ? t2.push(r2 >> 12 & 15 | 224) : t2.push(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128), t2.push(r2 >> 6 & 63 | 128)), t2.push(63 & r2 | 128));
            }
          }
          this.addInt8(0), this.startVector(1, t2.length, 1), this.bb.setPosition(this.space -= t2.length), n2 = 0;
          for (var o = this.space, a = this.bb.bytes(); n2 < t2.length; n2++)
            a[o++] = t2[n2];
          return this.endVector();
        }, r.Builder.prototype.createLong = function(e2, t2) {
          return r.Long.create(e2, t2);
        }, r.ByteBuffer = function(e2) {
          this.bytes_ = e2, this.position_ = 0;
        }, r.ByteBuffer.allocate = function(e2) {
          return new r.ByteBuffer(new Uint8Array(e2));
        }, r.ByteBuffer.prototype.clear = function() {
          this.position_ = 0;
        }, r.ByteBuffer.prototype.bytes = function() {
          return this.bytes_;
        }, r.ByteBuffer.prototype.position = function() {
          return this.position_;
        }, r.ByteBuffer.prototype.setPosition = function(e2) {
          this.position_ = e2;
        }, r.ByteBuffer.prototype.capacity = function() {
          return this.bytes_.length;
        }, r.ByteBuffer.prototype.readInt8 = function(e2) {
          return this.readUint8(e2) << 24 >> 24;
        }, r.ByteBuffer.prototype.readUint8 = function(e2) {
          return this.bytes_[e2];
        }, r.ByteBuffer.prototype.readInt16 = function(e2) {
          return this.readUint16(e2) << 16 >> 16;
        }, r.ByteBuffer.prototype.readUint16 = function(e2) {
          return this.bytes_[e2] | this.bytes_[e2 + 1] << 8;
        }, r.ByteBuffer.prototype.readInt32 = function(e2) {
          return this.bytes_[e2] | this.bytes_[e2 + 1] << 8 | this.bytes_[e2 + 2] << 16 | this.bytes_[e2 + 3] << 24;
        }, r.ByteBuffer.prototype.readUint32 = function(e2) {
          return this.readInt32(e2) >>> 0;
        }, r.ByteBuffer.prototype.readInt64 = function(e2) {
          return new r.Long(this.readInt32(e2), this.readInt32(e2 + 4));
        }, r.ByteBuffer.prototype.readUint64 = function(e2) {
          return new r.Long(this.readUint32(e2), this.readUint32(e2 + 4));
        }, r.ByteBuffer.prototype.readFloat32 = function(e2) {
          return r.int32[0] = this.readInt32(e2), r.float32[0];
        }, r.ByteBuffer.prototype.readFloat64 = function(e2) {
          return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(e2), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(e2 + 4), r.float64[0];
        }, r.ByteBuffer.prototype.writeInt8 = function(e2, t2) {
          this.bytes_[e2] = t2;
        }, r.ByteBuffer.prototype.writeUint8 = function(e2, t2) {
          this.bytes_[e2] = t2;
        }, r.ByteBuffer.prototype.writeInt16 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8;
        }, r.ByteBuffer.prototype.writeUint16 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8;
        }, r.ByteBuffer.prototype.writeInt32 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8, this.bytes_[e2 + 2] = t2 >> 16, this.bytes_[e2 + 3] = t2 >> 24;
        }, r.ByteBuffer.prototype.writeUint32 = function(e2, t2) {
          this.bytes_[e2] = t2, this.bytes_[e2 + 1] = t2 >> 8, this.bytes_[e2 + 2] = t2 >> 16, this.bytes_[e2 + 3] = t2 >> 24;
        }, r.ByteBuffer.prototype.writeInt64 = function(e2, t2) {
          this.writeInt32(e2, t2.low), this.writeInt32(e2 + 4, t2.high);
        }, r.ByteBuffer.prototype.writeUint64 = function(e2, t2) {
          this.writeUint32(e2, t2.low), this.writeUint32(e2 + 4, t2.high);
        }, r.ByteBuffer.prototype.writeFloat32 = function(e2, t2) {
          r.float32[0] = t2, this.writeInt32(e2, r.int32[0]);
        }, r.ByteBuffer.prototype.writeFloat64 = function(e2, t2) {
          r.float64[0] = t2, this.writeInt32(e2, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(e2 + 4, r.int32[r.isLittleEndian ? 1 : 0]);
        }, r.ByteBuffer.prototype.getBufferIdentifier = function() {
          if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
          for (var e2 = "", t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++)
            e2 += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + t2));
          return e2;
        }, r.ByteBuffer.prototype.__offset = function(e2, t2) {
          var n2 = e2 - this.readInt32(e2);
          return t2 < this.readInt16(n2) ? this.readInt16(n2 + t2) : 0;
        }, r.ByteBuffer.prototype.__union = function(e2, t2) {
          return e2.bb_pos = t2 + this.readInt32(t2), e2.bb = this, e2;
        }, r.ByteBuffer.prototype.__string = function(e2, t2) {
          e2 += this.readInt32(e2);
          var n2 = this.readInt32(e2), i = "", o = 0;
          if (e2 += r.SIZEOF_INT, t2 === r.Encoding.UTF8_BYTES)
            return this.bytes_.subarray(e2, e2 + n2);
          for (; o < n2; ) {
            var a, s = this.readUint8(e2 + o++);
            if (s < 192)
              a = s;
            else {
              var u = this.readUint8(e2 + o++);
              if (s < 224)
                a = (31 & s) << 6 | 63 & u;
              else {
                var l = this.readUint8(e2 + o++);
                a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & l : (7 & s) << 18 | (63 & u) << 12 | (63 & l) << 6 | 63 & this.readUint8(e2 + o++);
              }
            }
            a < 65536 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));
          }
          return i;
        }, r.ByteBuffer.prototype.__indirect = function(e2) {
          return e2 + this.readInt32(e2);
        }, r.ByteBuffer.prototype.__vector = function(e2) {
          return e2 + this.readInt32(e2) + r.SIZEOF_INT;
        }, r.ByteBuffer.prototype.__vector_len = function(e2) {
          return this.readInt32(e2 + this.readInt32(e2));
        }, r.ByteBuffer.prototype.__has_identifier = function(e2) {
          if (e2.length != r.FILE_IDENTIFIER_LENGTH)
            throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
          for (var t2 = 0; t2 < r.FILE_IDENTIFIER_LENGTH; t2++)
            if (e2.charCodeAt(t2) != this.readInt8(this.position_ + r.SIZEOF_INT + t2))
              return false;
          return true;
        }, r.ByteBuffer.prototype.createLong = function(e2, t2) {
          return r.Long.create(e2, t2);
        };
      } }, __webpack_module_cache__ = {};
      function __webpack_require__(e) {
        var t = __webpack_module_cache__[e];
        if (void 0 !== t)
          return t.exports;
        var n = __webpack_module_cache__[e] = { exports: {} };
        return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.exports;
      }
      __webpack_require__.n = (e) => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return __webpack_require__.d(t, { a: t }), t;
      }, __webpack_require__.d = (e, t) => {
        for (var n in t)
          __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, { enumerable: true, get: t[n] });
      }, __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), __webpack_require__.r = (e) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: true });
      };
      var __webpack_exports__ = __webpack_require__(1057);
      return __webpack_exports__;
    })());
  }
});

// src/wonnx.worker.ts
var ort = __toESM(require_ort_min(), 1);
var wgpuort = __toESM(require_ort_webgpu_min(), 1);

// src/lib/threadop.esm.js
var L = (i = () => {
}) => {
  globalThis.WORKER = {};
  let u = (r, n, l, f) => {
    if (globalThis.WORKER.SENDERS && f !== true)
      if (f !== void 0 && f !== "both")
        globalThis.WORKER.SENDERS[f] && (r?.message ? globalThis.WORKER.SENDERS[f].postMessage({ message: r.message, overridePort: r?.overridePort }, r.transfer) : globalThis.WORKER.SENDERS[f].postMessage({ message: r, overridePort: r?.overridePort }));
      else {
        for (let d in globalThis.WORKER.SENDERS) {
          if (globalThis.WORKER.BLOCKING[d]) {
            if (globalThis.WORKER.BLOCKED[d]) {
              console.error("Thread Blocked: " + d);
              continue;
            }
            globalThis.WORKER.BLOCKED[d] = true;
          }
          r?.message ? globalThis.WORKER.SENDERS[d].postMessage({ message: r.message, overridePort: r?.overridePort }, r.transfer) : globalThis.WORKER.SENDERS[d].postMessage({ message: r, overridePort: r?.overridePort });
        }
        l && postMessage(true);
      }
    (!globalThis.WORKER.SENDERS || f === true || f === "both") && (r?.message ? postMessage({ message: r.message, cb: n, overridePort: r?.overridePort }, r.transfer) : postMessage({ message: r, cb: n, overridePort: r?.overridePort }));
  }, g = (r, n) => {
    let l = i(r.data?.message);
    l?.then ? l.then((f) => {
      n && n.postMessage(true), u(f, r.data.cb, r.data.oneOff, r.data.overridePort);
    }) : (n && n.postMessage(true), u(l, r.data.cb, r.data.oneOff, r.data.overridePort));
  };
  globalThis.onmessage = (r) => {
    if (r.data?.COMMAND) {
      let n = r.data.COMMAND;
      if (typeof n.SETLOOP == "number") {
        globalThis.WORKER.LOOP && clearTimeout(globalThis.WORKER.LOOP);
        let l = () => {
          g(r), globalThis.WORKER.LOOP = setTimeout(() => {
            l();
          }, n.SETLOOP);
        };
        l();
      }
      if (n.SETANIM) {
        globalThis.WORKER.ANIM && cancelAnimationFrame(globalThis.WORKER.ANIM);
        let l = () => {
          g(r), globalThis.WORKER.ANIM = requestAnimationFrame(() => {
            l();
          });
        };
        l();
      }
      if (n.STOP && (globalThis.WORKER.LOOP && clearTimeout(globalThis.WORKER.LOOP), globalThis.WORKER.ANIM && cancelAnimationFrame(globalThis.WORKER.ANIM)), n.RECEIVER) {
        let l = n.blocking;
        globalThis.WORKER.RECEIVERS || (globalThis.WORKER.RTCR = 0, globalThis.WORKER.RECEIVERS = {});
        let f = n.id;
        globalThis.WORKER.RECEIVERS[f] = n.RECEIVER, globalThis.WORKER.RTCR++, n.RECEIVER.onmessage = (d) => {
          g(d, l ? n.RECEIVER : void 0);
        }, n.RECEIVER.onerror = (d) => {
          delete globalThis.WORKER.RECEIVERS[f];
        };
      }
      if (n.SENDER) {
        globalThis.WORKER.SENDERS || (globalThis.WORKER.PCTR = 0, globalThis.WORKER.SENDERS = {}, globalThis.WORKER.BLOCKING = {}, globalThis.WORKER.BLOCKED = {});
        let l = n.blocking, f = n.id ? n.id : globalThis.WORKER.PCTR;
        globalThis.WORKER.SENDERS[f] = n.SENDER, globalThis.WORKER.PCTR++, l && (globalThis.WORKER.BLOCKING[f] = true), n.SENDER.onmessage = (d) => {
          globalThis.WORKER.BLOCKING[f] && (globalThis.WORKER.BLOCKED[f] = false);
        }, n.SENDER.onerror = (d) => {
          delete globalThis.WORKER.SENDERS[f];
        };
      }
      n.DELETED && (delete globalThis.WORKER.RECEIVERS?.[n.DELETED], delete globalThis.WORKER.SENDERS?.[n.DELETED]);
    } else
      g(r);
  }, globalThis.onerror = (r) => {
    console.error(r);
  };
};
var N = L.toString();

// src/lib/imagemanip.js
function convertRGBAToRGBPlanarNormalized(rgbaData, outputWidth, outputHeight) {
  const numPixels = outputWidth * outputHeight;
  const rgbData = new Float32Array(numPixels * 3);
  let mean0 = 0.485, std0 = 0.229;
  let mean1 = 0.456, std1 = 0.224;
  let mean2 = 0.406, std2 = 0.225;
  const uint32View = new Uint32Array(rgbaData.buffer);
  let idxR = 0, idxG = numPixels, idxB = 2 * numPixels;
  for (let i = 0; i < numPixels; i++) {
    const rgba = uint32View[i];
    const r = (rgba & 255) / 255;
    const g = (rgba >> 8 & 255) / 255;
    const b = (rgba >> 16 & 255) / 255;
    rgbData[idxR++] = (r - mean0) / std0;
    rgbData[idxG++] = (g - mean1) / std1;
    rgbData[idxB++] = (b - mean2) / std2;
  }
  return rgbData;
}

// node_modules/threadop/dist/threadop.esm.js
var L2 = (s = () => {
}) => {
  globalThis.WORKER = {}, s = s.bind(globalThis.WORKER);
  let R = (r, n, l, f) => {
    if (globalThis.WORKER.SENDERS && f !== true)
      if (f !== void 0 && f !== "both")
        globalThis.WORKER.SENDERS[f] && (r?.message ? globalThis.WORKER.SENDERS[f].postMessage({ message: r.message, overridePort: r?.overridePort }, r.transfer) : globalThis.WORKER.SENDERS[f].postMessage({ message: r, overridePort: r?.overridePort }));
      else {
        for (let u in globalThis.WORKER.SENDERS) {
          if (globalThis.WORKER.BLOCKING[u]) {
            if (globalThis.WORKER.BLOCKED[u]) {
              console.error("Thread Blocked: " + u);
              continue;
            }
            globalThis.WORKER.BLOCKED[u] = true;
          }
          r?.message ? globalThis.WORKER.SENDERS[u].postMessage({ message: r.message, overridePort: r?.overridePort }, r.transfer) : globalThis.WORKER.SENDERS[u].postMessage({ message: r, overridePort: r?.overridePort });
        }
        l && postMessage(true);
      }
    (!globalThis.WORKER.SENDERS || f === true || f === "both") && (r?.message ? postMessage({ message: r.message, cb: n, overridePort: r?.overridePort }, r.transfer) : postMessage({ message: r, cb: n, overridePort: r?.overridePort }));
  }, g = (r, n) => {
    let l = s(r.data?.message);
    l?.then ? l.then((f) => {
      n && n.postMessage(true), R(f, r.data.cb, r.data.oneOff, r.data.overridePort);
    }) : (n && n.postMessage(true), R(l, r.data.cb, r.data.oneOff, r.data.overridePort));
  };
  globalThis.onmessage = (r) => {
    if (r.data?.COMMAND) {
      let n = r.data.COMMAND;
      if (typeof n.SETLOOP == "number") {
        globalThis.WORKER.LOOP && clearTimeout(globalThis.WORKER.LOOP);
        let l = () => {
          g(r), globalThis.WORKER.LOOP = setTimeout(() => {
            l();
          }, n.SETLOOP);
        };
        l();
      }
      if (n.SETANIM) {
        globalThis.WORKER.ANIM && cancelAnimationFrame(globalThis.WORKER.ANIM);
        let l = () => {
          g(r), globalThis.WORKER.ANIM = requestAnimationFrame(() => {
            l();
          });
        };
        l();
      }
      if (n.STOP && (globalThis.WORKER.LOOP && clearTimeout(globalThis.WORKER.LOOP), globalThis.WORKER.ANIM && cancelAnimationFrame(globalThis.WORKER.ANIM)), n.RECEIVER) {
        let l = n.blocking;
        globalThis.WORKER.RECEIVERS || (globalThis.WORKER.RTCR = 0, globalThis.WORKER.RECEIVERS = {});
        let f = n.id;
        globalThis.WORKER.RECEIVERS[f] = n.RECEIVER, globalThis.WORKER.RTCR++, n.RECEIVER.onmessage = (u) => {
          g(u, l ? n.RECEIVER : void 0);
        }, n.RECEIVER.onerror = (u) => {
          delete globalThis.WORKER.RECEIVERS[f];
        };
      }
      if (n.SENDER) {
        globalThis.WORKER.SENDERS || (globalThis.WORKER.PCTR = 0, globalThis.WORKER.SENDERS = {}, globalThis.WORKER.BLOCKING = {}, globalThis.WORKER.BLOCKED = {});
        let l = n.blocking, f = n.id ? n.id : globalThis.WORKER.PCTR;
        globalThis.WORKER.SENDERS[f] = n.SENDER, globalThis.WORKER.PCTR++, l && (globalThis.WORKER.BLOCKING[f] = true), n.SENDER.onmessage = (u) => {
          globalThis.WORKER.BLOCKING[f] && (globalThis.WORKER.BLOCKED[f] = false);
        }, n.SENDER.onerror = (u) => {
          delete globalThis.WORKER.SENDERS[f];
        };
      }
      n.DELETED && (delete globalThis.WORKER.RECEIVERS?.[n.DELETED], delete globalThis.WORKER.SENDERS?.[n.DELETED]);
    } else
      g(r);
  }, globalThis.onerror = (r) => {
    console.error(r);
  };
};
var N2 = L2.toString();

// src/wonnx.worker.ts
if (typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope) {
  const range = (start, stop, step = 1) => Array(Math.ceil((stop - start) / step)).fill(start).map((x, y) => x + y * step);
  let modelName = "inception-mnist.onnx";
  let labelsName = "mnist-labels.txt";
  let inputName = "input";
  let outputName = "output";
  let outputWidth = 224;
  let outputHeight = 224;
  let inferenceCount = 0;
  let inferenceTime = 0;
  const initClassifier = async () => {
    let session, labelsList;
    async function classifyImage(data) {
      if (data.command === "configure") {
        if (data.modelName)
          modelName = data.modelName;
        if (data.labelsName)
          labelsName = data.labelsName;
        if (data.outputName)
          outputName = data.outputName;
        if (data.inputName)
          inputName = data.inputName;
        if (data.outputWidth)
          outputWidth = data.outputWidth;
        if (data.outputHeight)
          outputHeight = data.outputHeight;
        try {
          session = await wgpuort.InferenceSession.create(location.origin + "/models/" + modelName, {
            executionProviders: ["webgpu"]
            //'wasm' 'webgl' 'webgpu'
          });
        } catch (er) {
          console.error("WebGPU ONNX Create Session error:", er);
          try {
            session = await ort.InferenceSession.create(location.origin + "/models/" + modelName, {
              executionProviders: ["webgl"]
              //'wasm' 'webgl' 'webgpu'
            });
          } catch (er2) {
            console.error("WebGL ONNX Create Session error:", er2);
            try {
              session = await ort.InferenceSession.create(location.origin + "/models/" + modelName, {
                executionProviders: ["wasm"]
                //'wasm' 'webgl' 'webgpu'
              });
            } catch (er3) {
              console.error("WASM ONNX Create Session error:", er3);
            }
          }
        }
        const labelsResult = await (data.labels ? data.labels : fetch(location.origin + "/models/" + labelsName).then((r) => r.text()));
        labelsList = labelsResult.split(/\n/g);
        return;
      }
      if (!data)
        return;
      let tensor;
      let inp;
      if (data.image && data.input === "imageflattened") {
        inp = convertRGBAToRGBPlanarNormalized(data.image, outputWidth, outputHeight);
        tensor = new ort.Tensor("float32", inp, [1, 3, outputWidth, outputHeight]);
      } else if (data.spectral && data.input === "spectral") {
        const is = data.spectral.intensities;
        inp = new Float32Array(is.length * 4);
        let startR = is.length;
        let startG = is.length * 2;
        let startB = is.length * 3;
        is.forEach((intensity, i) => {
          inp[i] = intensity.i;
          inp[i + startR] = intensity.r;
          inp[i + startB] = intensity.g;
          inp[i + startG] = intensity.b;
        });
        tensor = new ort.Tensor("float32", inp, [1, inp.length]);
      }
      const input = { [inputName]: tensor };
      const start = performance.now();
      let result;
      try {
        result = await session.run(input);
      } catch (er) {
        console.error(er);
      }
      if (!result)
        return {
          name: data.name,
          id: data.id,
          width: data.width,
          height: data.height,
          cropIndex: data.cropIndex,
          input: data.input
        };
      const duration = performance.now() - start;
      inferenceCount++;
      inferenceTime += duration;
      console.log(result);
      let key = Object.keys(result)[0];
      const probs = result[key].data;
      let maxProb = -1;
      let maxIndex = -1;
      for (let index = 0; index < probs.length; index++) {
        const p = probs[index];
        if (p > maxProb) {
          maxProb = p;
          maxIndex = index;
        }
      }
      const avgFrameTime = inferenceTime / inferenceCount;
      const avgFrameRate = inferenceCount / (inferenceTime * 1e-3);
      return {
        probs,
        maxProb,
        label: labelsList[maxIndex],
        inferenceTime: duration,
        avgFrameTime,
        avgFrameRate,
        name: data.name,
        id: data.id,
        width: data.width,
        height: data.height,
        cropIndex: data.cropIndex
      };
    }
    L2(classifyImage);
  };
  initClassifier();
}
var wonnx_worker_default = self;
export {
  wonnx_worker_default as default
};
/*! Bundled license information:

onnxruntime-web/dist/ort.min.js:
  (*!
  * ONNX Runtime Web v1.16.3
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  *)

onnxruntime-web/dist/ort.webgpu.min.js:
  (*!
  * ONNX Runtime Web v1.16.3
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  *)
*/
