var xn=Object.create;var gn=Object.defineProperty;var Tn=Object.getOwnPropertyDescriptor;var _n=Object.getOwnPropertyNames;var Sn=Object.getPrototypeOf,On=Object.prototype.hasOwnProperty;var mn=(M,c)=>()=>(c||M((c={exports:{}}).exports,c),c.exports);var An=(M,c,y,m)=>{if(c&&typeof c=="object"||typeof c=="function")for(let f of _n(c))!On.call(M,f)&&f!==y&&gn(M,f,{get:()=>c[f],enumerable:!(m=Tn(c,f))||m.enumerable});return M};var bn=(M,c,y)=>(y=M!=null?xn(Sn(M)):{},An(c||!M||!M.__esModule?gn(y,"default",{value:M,enumerable:!0}):y,M));var yn=mn((exports,module)=>{(function(M,c){typeof exports=="object"&&typeof module=="object"?module.exports=c():typeof define=="function"&&define.amd?define([],c):typeof exports=="object"?exports.ort=c():M.ort=c()})(self,()=>(()=>{var __webpack_modules__={5716:(M,c,y)=>{"use strict";c.R=void 0;let m=y(6027),f=y(1723);c.R=new class{async init(){}async createSessionHandler(h,p){let u=new m.Session(p);return await u.loadModel(h),new f.OnnxjsSessionHandler(u)}}},2818:(M,c,y)=>{"use strict";c.c8=c.rX=void 0;let m=y(2235),f=y(5381),h=y(9544),p=y(6640);c.rX=()=>{if((typeof m.env.wasm.initTimeout!="number"||m.env.wasm.initTimeout<0)&&(m.env.wasm.initTimeout=0),typeof m.env.wasm.simd!="boolean"&&(m.env.wasm.simd=!0),typeof m.env.wasm.proxy!="boolean"&&(m.env.wasm.proxy=!1),typeof m.env.wasm.numThreads!="number"||!Number.isInteger(m.env.wasm.numThreads)||m.env.wasm.numThreads<=0){let u=typeof navigator>"u"?(0,f.cpus)().length:navigator.hardwareConcurrency;m.env.wasm.numThreads=Math.min(4,Math.ceil((u||1)/2))}},c.c8=new class{async init(){(0,c.rX)(),await(0,h.initializeWebAssemblyInstance)()}async createSessionHandler(u,s){let a=new p.OnnxruntimeWebAssemblySessionHandler;return await a.loadModel(u,s),Promise.resolve(a)}}},1057:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(u,s,a,o){o===void 0&&(o=a);var n=Object.getOwnPropertyDescriptor(s,a);n&&!("get"in n?!s.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return s[a]}}),Object.defineProperty(u,o,n)}:function(u,s,a,o){o===void 0&&(o=a),u[o]=s[a]}),f=this&&this.__exportStar||function(u,s){for(var a in u)a==="default"||Object.prototype.hasOwnProperty.call(s,a)||m(s,u,a)};Object.defineProperty(c,"__esModule",{value:!0}),f(y(2235),c);let h=y(2235),p=y(8408);{let u=y(5716).R;(0,h.registerBackend)("webgl",u,-10)}{let u=y(2818).c8;(0,h.registerBackend)("cpu",u,10),(0,h.registerBackend)("wasm",u,10),(0,h.registerBackend)("xnnpack",u,9),(0,h.registerBackend)("webnn",u,9)}h.env.versions.web=p.version},4910:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createAttributeWithCacheKey=void 0;class y{constructor(f){Object.assign(this,f)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(f=>`${this[f]}`).join(";")),this._cacheKey}}c.createAttributeWithCacheKey=m=>new y(m)},6874:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Attribute=void 0;let m=y(5127),f=y(2446),h=y(9240),p=y(7273);var u=m.onnxruntime.experimental.fbs;class s{constructor(o){if(this._attributes=new Map,o!=null){for(let n of o)n instanceof f.onnx.AttributeProto?this._attributes.set(n.name,[s.getValue(n),s.getType(n)]):n instanceof u.Attribute&&this._attributes.set(n.name(),[s.getValue(n),s.getType(n)]);if(this._attributes.size<o.length)throw new Error("duplicated attribute names")}}set(o,n,e){this._attributes.set(o,[e,n])}delete(o){this._attributes.delete(o)}getFloat(o,n){return this.get(o,"float",n)}getInt(o,n){return this.get(o,"int",n)}getString(o,n){return this.get(o,"string",n)}getTensor(o,n){return this.get(o,"tensor",n)}getFloats(o,n){return this.get(o,"floats",n)}getInts(o,n){return this.get(o,"ints",n)}getStrings(o,n){return this.get(o,"strings",n)}getTensors(o,n){return this.get(o,"tensors",n)}get(o,n,e){let t=this._attributes.get(o);if(t===void 0){if(e!==void 0)return e;throw new Error(`required attribute not found: ${o}`)}if(t[1]!==n)throw new Error(`type mismatch: expected ${n} but got ${t[1]}`);return t[0]}static getType(o){let n=o instanceof f.onnx.AttributeProto?o.type:o.type();switch(n){case f.onnx.AttributeProto.AttributeType.FLOAT:return"float";case f.onnx.AttributeProto.AttributeType.INT:return"int";case f.onnx.AttributeProto.AttributeType.STRING:return"string";case f.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case f.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case f.onnx.AttributeProto.AttributeType.INTS:return"ints";case f.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case f.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${f.onnx.AttributeProto.AttributeType[n]}`)}}static getValue(o){let n=o instanceof f.onnx.AttributeProto?o.type:o.type();if(n===f.onnx.AttributeProto.AttributeType.GRAPH||n===f.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let e=this.getValueNoCheck(o);if(n===f.onnx.AttributeProto.AttributeType.INT&&p.LongUtil.isLong(e))return p.LongUtil.longToNumber(e);if(n===f.onnx.AttributeProto.AttributeType.INTS){let t=e,r=new Array(t.length);for(let i=0;i<t.length;i++){let l=t[i];r[i]=p.LongUtil.longToNumber(l)}return r}if(n===f.onnx.AttributeProto.AttributeType.TENSOR)return o instanceof f.onnx.AttributeProto?h.Tensor.fromProto(e):h.Tensor.fromOrtTensor(e);if(n===f.onnx.AttributeProto.AttributeType.TENSORS){if(o instanceof f.onnx.AttributeProto)return e.map(t=>h.Tensor.fromProto(t));if(o instanceof u.Attribute)return e.map(t=>h.Tensor.fromOrtTensor(t))}if(n===f.onnx.AttributeProto.AttributeType.STRING&&o instanceof f.onnx.AttributeProto){let t=e;return(0,p.decodeUtf8String)(t)}return n===f.onnx.AttributeProto.AttributeType.STRINGS&&o instanceof f.onnx.AttributeProto?e.map(p.decodeUtf8String):e}static getValueNoCheck(o){return o instanceof f.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(o):this.getValueNoCheckFromOrtFormat(o)}static getValueNoCheckFromOnnxFormat(o){switch(o.type){case f.onnx.AttributeProto.AttributeType.FLOAT:return o.f;case f.onnx.AttributeProto.AttributeType.INT:return o.i;case f.onnx.AttributeProto.AttributeType.STRING:return o.s;case f.onnx.AttributeProto.AttributeType.TENSOR:return o.t;case f.onnx.AttributeProto.AttributeType.GRAPH:return o.g;case f.onnx.AttributeProto.AttributeType.FLOATS:return o.floats;case f.onnx.AttributeProto.AttributeType.INTS:return o.ints;case f.onnx.AttributeProto.AttributeType.STRINGS:return o.strings;case f.onnx.AttributeProto.AttributeType.TENSORS:return o.tensors;case f.onnx.AttributeProto.AttributeType.GRAPHS:return o.graphs;default:throw new Error(`unsupported attribute type: ${f.onnx.AttributeProto.AttributeType[o.type]}`)}}static getValueNoCheckFromOrtFormat(o){switch(o.type()){case u.AttributeType.FLOAT:return o.f();case u.AttributeType.INT:return o.i();case u.AttributeType.STRING:return o.s();case u.AttributeType.TENSOR:return o.t();case u.AttributeType.GRAPH:return o.g();case u.AttributeType.FLOATS:return o.floatsArray();case u.AttributeType.INTS:{let n=[];for(let e=0;e<o.intsLength();e++)n.push(o.ints(e));return n}case u.AttributeType.STRINGS:{let n=[];for(let e=0;e<o.stringsLength();e++)n.push(o.strings(e));return n}case u.AttributeType.TENSORS:{let n=[];for(let e=0;e<o.tensorsLength();e++)n.push(o.tensors(e));return n}default:throw new Error(`unsupported attribute type: ${u.AttributeType[o.type()]}`)}}}c.Attribute=s},1975:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.resolveBackend=c.backend=void 0;let m=y(4418),f=new Map;async function h(p){let u=c.backend;if(u[p]!==void 0&&function(s){let a=s;return"initialize"in a&&typeof a.initialize=="function"&&"createSessionHandler"in a&&typeof a.createSessionHandler=="function"&&"dispose"in a&&typeof a.dispose=="function"}(u[p])){let s=u[p],a=s.initialize();if(typeof a=="object"&&"then"in a&&(a=await a),a)return f.set(p,s),s}}c.backend={webgl:new m.WebGLBackend},c.resolveBackend=async function p(u){if(!u)return p(["webgl"]);{let s=typeof u=="string"?[u]:u;for(let a of s){let o=f.get(a);if(o)return o;let n=await h(a);if(n)return n}}throw new Error("no available backend to use")}},4418:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLBackend=void 0;let m=y(2235),f=y(1315),h=y(2171),p=y(3389);c.WebGLBackend=class{get contextId(){return m.env.webgl.contextId}set contextId(u){m.env.webgl.contextId=u}get matmulMaxBatchSize(){return m.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(u){m.env.webgl.matmulMaxBatchSize=u}get textureCacheMode(){return m.env.webgl.textureCacheMode}set textureCacheMode(u){m.env.webgl.textureCacheMode=u}get pack(){return m.env.webgl.pack}set pack(u){m.env.webgl.pack=u}get async(){return m.env.webgl.async}set async(u){m.env.webgl.async=u}initialize(){try{return this.glContext=(0,p.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),f.Logger.setWithEnv(m.env),f.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(u){return f.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${u}`),!1}}createSessionHandler(u){return new h.WebGLSessionHandler(this,u)}dispose(){this.glContext.dispose()}}},6859:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.CoordsGlslLib=void 0;let m=y(7273),f=y(1997),h=y(6757),p=y(7618),u=y(432);class s extends f.GlslLib{constructor(o){super(o)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new f.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new f.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let o=this.context.outputTextureLayout;return o.isPacked?this.getPackedOutputSamplingSnippet(o):this.getUnpackedOutputSamplingSnippet(o)}getPackedOutputSamplingSnippet(o){let n=o.unpackedShape,e=[o.width,o.height],t={},r="getOutputCoords";switch(n.length){case 0:t[r]=this.getOutputScalarCoords();break;case 1:t[r]=this.getOutputPacked1DCoords(n,e);break;case 2:t[r]=this.getOutputPacked2DCoords(n,e);break;case 3:t[r]=this.getOutputPacked3DCoords(n,e);break;default:t[r]=this.getOutputPackedNDCoords(n,e)}let i=`
      void setOutput(vec4 val) {
        ${(0,h.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return t.floatTextureSetRGBA=new f.GlslLibRoutine(i),t}getUnpackedOutputSamplingSnippet(o){let n=o.unpackedShape,e=[o.width,o.height],t={},r="getOutputCoords";switch(n.length){case 0:t[r]=this.getOutputScalarCoords();break;case 1:t[r]=this.getOutputUnpacked1DCoords(n,e);break;case 2:t[r]=this.getOutputUnpacked2DCoords(n,e);break;case 3:t[r]=this.getOutputUnpacked3DCoords(n,e);break;case 4:t[r]=this.getOutputUnpacked4DCoords(n,e);break;case 5:t[r]=this.getOutputUnpacked5DCoords(n,e);break;case 6:t[r]=this.getOutputUnpacked6DCoords(n,e);break;default:throw new Error(`Unsupported output dimensionality: ${n.length}`)}let i=`
        void setOutput(float val) {
          ${(0,h.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return t.floatTextureSetR=new f.GlslLibRoutine(i),t}getOutputScalarCoords(){return new f.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(o,n){let e=n,t="";return e[0]===1?(t=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${e[1]}.0);
          }
        `,new f.GlslLibRoutine(t)):e[1]===1?(t=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${e[0]}.0);
          }
        `,new f.GlslLibRoutine(t)):(t=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${e[0]}, ${e[1]}));
          return 2 * (resTexRC.y * ${e[0]} + resTexRC.x);
        }
      `,new f.GlslLibRoutine(t))}getOutputPacked2DCoords(o,n){let e="";if(m.ArrayUtil.arraysEqual(o,n))return e=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${n[0]}, ${n[1]}));
        }
      `,new f.GlslLibRoutine(e);let t=n,r=Math.ceil(o[1]/2);return e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));

          int index = resTexRC.y * ${t[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${r}) * 2;
          int c = 2 * (index / ${r});

          return ivec2(r, c);
        }
      `,new f.GlslLibRoutine(e)}getOutputPacked3DCoords(o,n){let e=[n[0],n[1]],t=Math.ceil(o[2]/2),r=t*Math.ceil(o[1]/2),i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;

          int b = index / ${r};
          index -= b * ${r};

          // reverse r and c order for packed texture
          int r = imod(index, ${t}) * 2;
          int c = 2 * (index / ${t});

          return ivec3(b, r, c);
        }
      `;return new f.GlslLibRoutine(i)}getOutputPackedNDCoords(o,n){let e=[n[0],n[1]],t=Math.ceil(o[o.length-1]/2),r=t*Math.ceil(o[o.length-2]/2),i=r,l="",d="b, r, c";for(let b=2;b<o.length-1;b++)i*=o[o.length-b-1],l=`
      int b${b} = index / ${i};
      index -= b${b} * ${i};
    `+l,d=`b${b}, `+d;let g=`
      ivec${o.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.y * ${e[0]} + resTexRC.x;

        ${l}

        int b = index / ${r};
        index -= b * ${r};

        // reverse r and c order for packed texture
        int r = imod(index, ${t}) * 2;
        int c = 2 * (index / ${t});

        return ivec${o.length}(${d});
      }
    `;return new f.GlslLibRoutine(g)}getOutputUnpacked1DCoords(o,n){let e=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          return resTexRC.y * ${n[0]} + resTexRC.x;
        }
      `;return new f.GlslLibRoutine(e)}getOutputUnpacked2DCoords(o,n){let e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          int r = index / ${o[1]};
          int c = index - r * ${o[1]};
          return ivec2(r, c);
        }
      `;return new f.GlslLibRoutine(e)}getOutputUnpacked3DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${l}
          return ivec3(r, c, d);
        }
      `,new f.GlslLibRoutine(e)}getOutputUnpacked4DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d","d2"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${l}
          return ivec4(r, c, d, d2);
        }
      `,new f.GlslLibRoutine(e)}getOutputUnpacked5DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d","d2","d3"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${l}
          return ivec5(r, c, d, d2, d3);
        }
      `,new f.GlslLibRoutine(e)}getOutputUnpacked6DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d","d2","d3","d4"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${n[0]}, ${n[1]}));
         int index = resTexRC.y * ${n[0]} + resTexRC.x;
         ${l}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new f.GlslLibRoutine(e)}getCommonUtilFuncs(){let o={},n="uvFromFlat";o[n]=new f.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),n="packedUVfrom1D",o[n]=new f.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom2D",o[n]=new f.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom3D",o[n]=new f.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="sampleTexture";let e=(0,h.getGlsl)(this.context.glContext.version);return o[n]=new f.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${e.texture2D}(textureSampler, uv).r;
        }`),o}getInputsSamplingSnippets(){let o={},n=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((e,t)=>{let r=this.context.inputTextureLayouts[t],i=(0,u.generateShaderFuncNameFromInputSamplerName)(e);r.isPacked?o[i]=this.getPackedSamplerFromInput(i,e,r):o[i]=this.getUnpackedSamplerFromInput(i,e,r);let l=(0,u.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(e);r.unpackedShape.length<=n.unpackedShape.length&&(r.isPacked?o[l]=this.getPackedSamplerAtOutputCoords(l,r,n,e):o[l]=this.getUnpackedSamplerAtOutputCoords(l,r,n,e))}),o}getPackedSamplerAtOutputCoords(o,n,e,t){let r=n.unpackedShape,i=e.unpackedShape,l=t,d=(0,u.generateShaderFuncNameFromInputSamplerName)(l),g=r.length,b=i.length,v=m.BroadcastUtil.getBroadcastDims(r,i),w=(0,u.getCoordsDataType)(b),x=b-g,T,O=(0,u.getGlChannels)();T=g===0?"":b<2&&v.length>=1?"coords = 0;":v.map(C=>`coords.${O[C+x]} = 0;`).join(`
`);let P="";P=b<2&&g>0?"coords":r.map((C,_)=>`coords.${O[_+x]}`).join(", ");let I="return outputValue;",R=m.ShapeUtil.size(r)===1,j=m.ShapeUtil.size(i)===1;if(g!==1||R||j){if(R&&!j)I=b===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(v.length){let C=g-2,_=g-1;v.indexOf(C)>-1&&v.indexOf(_)>-1?I="return vec4(outputValue.x);":v.indexOf(C)>-1?I="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":v.indexOf(_)>-1&&(I="return vec4(outputValue.xx, outputValue.zz);")}}else I=`
        return vec4(outputValue.xy, outputValue.xy);
      `;let A=`
      vec4 ${o}() {
        ${w} coords = getOutputCoords();
        
        int lastDim = coords.${O[b-1]};
        coords.${O[b-1]} = coords.${O[b-2]};
        coords.${O[b-2]} = lastDim;
      
        ${T}
        vec4 outputValue = ${d}(${P});
        ${I}
      }
    `;return new f.GlslLibRoutine(A,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(o,n,e,t){let r=[e.width,e.height],i=[n.width,n.height],l=n.unpackedShape.length,d=e.unpackedShape.length,g=n.unpackedShape,b=e.unpackedShape,v=(0,u.generateShaderFuncNameFromInputSamplerName)(t);if(l===d&&m.ArrayUtil.arraysEqual(i,r)){let j=`
          float ${o}() {
            return sampleTexture(${t}, TexCoords);
          }
        `;return new f.GlslLibRoutine(j,["coordinates.sampleTexture"])}let w=(0,u.getCoordsDataType)(d),x=m.BroadcastUtil.getBroadcastDims(g,b),T=d-l,O,P=(0,u.getGlChannels)();O=l===0?"":d<2&&x.length>=1?"coords = 0;":x.map(j=>`coords.${P[j+T]} = 0;`).join(`
`);let I="";I=d<2&&l>0?"coords":n.unpackedShape.map((j,A)=>`coords.${P[A+T]}`).join(", ");let R=`
        float ${o}() {
          ${w} coords = getOutputCoords();
          ${O}
          return ${v}(${I});
        }
      `;return new f.GlslLibRoutine(R,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(o,n,e){switch(e.unpackedShape.length){case 0:return this.getPackedSamplerScalar(o,n);case 1:return this.getPackedSampler1D(o,n,e);case 2:return this.getPackedSampler2D(o,n,e);case 3:return this.getPackedSampler3D(o,n,e);default:return this.getPackedSamplerND(o,n,e)}}getUnpackedSamplerFromInput(o,n,e){let t=e.unpackedShape;switch(t.length){case 0:return this.getUnpackedSamplerScalar(o,n,e);case 1:return this.getUnpackedSampler1D(o,n,e);case 2:return this.getUnpackedSampler2D(o,n,e);case 3:return this.getUnpackedSampler3D(o,n,e);case 4:return this.getUnpackedSampler4D(o,n,e);case 5:return this.getUnpackedSampler5D(o,n,e);case 6:return this.getUnpackedSampler6D(o,n,e);default:throw new Error(`Unsupported dimension ${t.length}-D`)}}getPackedSamplerScalar(o,n){let e=`
          vec4 ${o}() {
            return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${n}, halfCR);
          }
        `;return new f.GlslLibRoutine(e)}getPackedSampler1D(o,n,e){let t=[e.width,e.height],r=[t[1],t[0]],i=(0,h.getGlsl)(this.context.glContext.version),l=`vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
      ${r[0]}, ${r[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }`;return new f.GlslLibRoutine(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(o,n,e){let t=e.unpackedShape,r=[e.width,e.height],i=(0,h.getGlsl)(this.context.glContext.version),l=r[0],d=r[1];if(r!=null&&m.ArrayUtil.arraysEqual(t,r)){let w=`vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${l}.0);
        return ${i.texture2D}(${n}, uv);
      }`;return new f.GlslLibRoutine(w)}let g=r,b=Math.ceil(t[1]/2),v=`vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${g[1]}, ${g[0]}, ${b}, row, col);
      return ${i.texture2D}(${n}, uv);
    }`;return new f.GlslLibRoutine(v,["coordinates.packedUVfrom2D"])}getPackedSampler3D(o,n,e){let t=e.unpackedShape,r=[e.width,e.height],i=[r[0],r[1]],l=(0,h.getGlsl)(this.context.glContext.version);if(t[0]===1){let w=t.slice(1),x=[1,2],T=(0,u.squeezeInputShape)(t,w),O=["b","row","col"],P=JSON.parse(JSON.stringify(e));P.unpackedShape=T;let I=this.getPackedSamplerFromInput(o,n,P),R=`${I.routineBody}
      vec4 ${o}(int b, int row, int col) {
        return ${o}(${(0,u.getSqueezedParams)(O,x)});
      } `;return new f.GlslLibRoutine(R,I.dependencies)}let d=i[0],g=i[1],b=Math.ceil(t[2]/2),v=`vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${g}, ${d}, ${b*Math.ceil(t[1]/2)}, ${b}, b, row, col);
      return ${l.texture2D}(${n}, uv);}`;return new f.GlslLibRoutine(v,["coordinates.packedUVfrom3D"])}getPackedSamplerND(o,n,e){let t=e.unpackedShape,r=t.length,i=[e.width,e.height],l=(0,h.getGlsl)(this.context.glContext.version),d=[i[0],i[1]],g=d[1],b=d[0],v=Math.ceil(t[r-1]/2),w=v*Math.ceil(t[r-2]/2),x="int b, int row, int col",T=`b * ${w} + (row / 2) * ${v} + (col / 2)`;for(let P=2;P<r-1;P++)x=`int b${P}, `+x,w*=t[r-P-1],T=`b${P} * ${w} + `+T;let O=`vec4 ${o}(${x}) {
      int index = ${T};
      int texR = index / ${b};
      int texC = index - texR * ${b};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${b}, ${g});
      return ${l.texture2D}(${n}, uv);
    }`;return new f.GlslLibRoutine(O)}getUnpackedSamplerScalar(o,n,e){let[t,r]=[e.width,e.height];if(t===1&&r===1){let l=`
          float ${o}() {
            return sampleTexture(${n}, halfCR);
          }
        `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}let i=`
        float ${o}() {
          int offset_${n} = coordsToOffset(TexCoords, ${t}, ${r});
          vec2 uv = uvFromFlat(${t}, ${r}, offset_${n});
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(o,n,e){let t=e.width,r=e.height;if(r===1&&t===1){let l=`
        float ${o}(int index) {
          return sampleTexture(${n}, halfCR);
        }
      `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}if(r===1){let l=`
          float ${o}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${t}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}if(t===1){let l=`
          float ${o}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${r}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}let i=`
        float ${o}(int index) {
          vec2 uv = uvFromFlat(${t}, ${r}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(o,n,e){let t=e.unpackedShape,r=[e.height,e.width];if(r!=null&&m.ArrayUtil.arraysEqual(t,r)){let w=`
          float ${o}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.sampleTexture"])}let{newShape:i,keptDims:l}=(0,p.squeezeShape)(t),d=i;if(d.length<t.length){let w=(0,u.squeezeInputShape)(t,d),x=JSON.parse(JSON.stringify(e));x.unpackedShape=w;let T=["col","row"],O=`
          ${this.getUnpackedSamplerFromInput(o,n,x).routineBody}
          float ${o}(int row, int col) {
            return ${o}(${(0,u.getSqueezedParams)(T,l)});
          }
        `;return new f.GlslLibRoutine(O,["coordinates.sampleTexture"])}let g=r[1],b=r[0];if(b===1){let w=`
          float ${o}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${g}, ${b});
            float index = dot(vec3(row, col, offset_${n}), vec3(${t[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${g}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(g===1){let w=`
          float ${o}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${g}, ${b});
            float index = dot(vec3(row, col, offset_${n}), vec3(${t[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${b}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let v=`
        float ${o}(int row, int col) {
          int index = col * ${t[1]} + row;
          vec2 uv = uvFromFlat(${g}, ${b}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(v,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(o,n,e){let t=e.unpackedShape,r=t[1]*t[2],i=t[2],{newShape:l,keptDims:d}=(0,p.squeezeShape)(t),g=l;if(g.length<t.length){let v=(0,u.squeezeInputShape)(t,g),w=["batch","col","row"],x=JSON.parse(JSON.stringify(e));x.unpackedShape=v;let T=this.getUnpackedSamplerFromInput(o,n,x),O=d.reverse(),P=`
          ${T.routineBody}
          float ${o}(int batch, int row, int col) {
            return ${o}(${(0,u.getSqueezedParams)(w,O)});
          }
        `;return new f.GlslLibRoutine(P,T.dependencies)}let b=`
          float ${o}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${r} + col * ${i} + row;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${n}, uv);
          }
      `;return new f.GlslLibRoutine(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(o,n,e){let t=e.unpackedShape,r=t[3],i=t[2]*r,l=`
        float ${o}(int row, int col, int depth, int depth2) {
          int index = row * ${t[1]*i} + col * ${i} +
              depth2 * ${r} + depth;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(l,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(o,n,e){let t=e.unpackedShape,r=t[4],i=t[3]*r,l=t[2]*i,d=t[1]*l,{newShape:g,keptDims:b}=(0,p.squeezeShape)(t);if(g.length<t.length){let w=(0,u.squeezeInputShape)(t,g),x=["row","col","depth","depth2","depth3"],T=JSON.parse(JSON.stringify(e));T.unpackedShape=w;let O=`
          ${this.getUnpackedSamplerFromInput(o,n,T).routineBody}
          float ${o}(int row, int col, int depth, int depth2, int depth3) {
            return ${o}(${(0,u.getSqueezedParams)(x,b)});
          }
        `;return new f.GlslLibRoutine(O,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let v=`
        float ${o}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${d} + col * ${l} + depth * ${i} +
          depth3 * ${r} + depth2;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(v,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(o,n,e){let t=e.unpackedShape,r=t[5],i=t[4]*r,l=t[3]*i,d=t[2]*l,g=t[1]*d,{newShape:b,keptDims:v}=(0,p.squeezeShape)(t);if(b.length<t.length){let x=(0,u.squeezeInputShape)(t,b),T=["row","col","depth","depth2","depth3","depth4"],O=JSON.parse(JSON.stringify(e));O.unpackedShape=x;let P=`
            ${this.getUnpackedSamplerFromInput(o,n,O).routineBody}
            float ${o}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${o}(${(0,u.getSqueezedParams)(T,v)});
            }
          `;return new f.GlslLibRoutine(P,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let w=`
          float ${o}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${g} + col * ${d} + depth * ${l} +
            depth2 * ${i} + depth3 * ${r} + depth4;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let o=this.context.outputTextureLayout,n=o.shape.length,e=o.strides,t=o.width,r=o.height,i=[];for(let d=0;d<n-1;++d)i.push(`
        c[${d}] = offset / ${e[d]};`),i.push(`
        offset -= c[${d}] * ${e[d]};`);i.push(`
        c[${n-1}] = offset;`);let l=`
      void toVec(vec2 texCoords, out int c[${n}]) {
        int offset = coordsToOffset(texCoords, ${t}, ${r});
        ${i.join("")}
      }
      void toVec(int offset, out int c[${n}]) {
        ${i.join("")}
      }
    `;return{toVec:new f.GlslLibRoutine(l,["coordinates.coordsToOffset"])}}valueFrom(){let o={};return this.context.programInfo.inputNames.forEach((n,e)=>{let t=this.context.inputTextureLayouts[e],r=(t.unpackedShape.length>0?t.unpackedShape:t.shape).length,i=`_${n}`;o[i]=new f.GlslLibRoutine(this.getValueFromSingle(n,r,t.width,t.height,!1),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),i+="_T",o[i]=new f.GlslLibRoutine(this.getValueFromSingle(n,r,t.width,t.height,!0),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),o}getValueFromSingle(o,n,e,t,r){let i=`_${o}`;return r&&(i+="_T"),`
        float ${i}(int m[${n}]) {
          int offset = indicesToOffset${i}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${t});
          float value = getColorAsFloat(${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords));
          return value;
        }
        `}getPackedValueFrom(o,n,e,t,r){let i=`_${o}_Pack`;return r&&(i+="_T"),`
        vec4 ${i}(int m[${n}]) {
          int offset = indicesToOffset_${o}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${t});
          return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords);
        }
        `}}c.CoordsGlslLib=s},1997:(M,c)=>{"use strict";var y;Object.defineProperty(c,"__esModule",{value:!0}),c.TopologicalSortGlslRoutines=c.GlslLibRoutineNode=c.GlslLibRoutine=c.GlslLib=c.GlslContext=c.FunctionType=void 0,(y=c.FunctionType||(c.FunctionType={}))[y.ValueBased=0]="ValueBased",y[y.Positional=1]="Positional",c.GlslContext=class{constructor(m,f,h,p){this.glContext=m,this.programInfo=f,this.inputTextureLayouts=h,this.outputTextureLayout=p}},c.GlslLib=class{constructor(m){this.context=m}},c.GlslLibRoutine=class{constructor(m,f){this.routineBody=m,this.dependencies=f}},c.GlslLibRoutineNode=class{constructor(m,f,h){this.name=m,this.dependencies=h||[],f&&(this.routineBody=f)}addDependency(m){m&&this.dependencies.push(m)}},c.TopologicalSortGlslRoutines=class{static returnOrderedNodes(m){if(!m||m.length===0)return[];if(m.length===1)return m;let f=new Set,h=new Set,p=new Array;return this.createOrderedNodes(m,f,h,p),p}static createOrderedNodes(m,f,h,p){for(let u=0;u<m.length;++u)this.dfsTraverse(m[u],f,h,p)}static dfsTraverse(m,f,h,p){if(!m||h.has(m.name))return;if(f.has(m.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");f.add(m.name);let u=m.dependencies;if(u&&u.length>0)for(let s=0;s<u.length;++s)this.dfsTraverse(u[s],f,h,p);p.push(m),h.add(m.name),f.delete(m.name)}}},1371:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.EncodingGlslLib=void 0;let m=y(1997);class f extends m.GlslLib{constructor(p){super(p)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new m.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new m.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let p=f.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new m.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${p}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let p=f.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new m.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${p}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let p=new ArrayBuffer(4),u=new Uint32Array(p),s=new Uint8Array(p);if(u[0]=3735928559,s[0]===239)return!0;if(s[0]===222)return!1;throw new Error("unknown endianness")}}c.EncodingGlslLib=f},2691:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.FragColorGlslLib=void 0;let m=y(1997),f=y(6757);class h extends m.GlslLib{constructor(u){super(u)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){let u=(0,f.getGlsl)(this.context.glContext.version);return{setFragColor:new m.GlslLibRoutine(`
        void setFragColor(float value) {
            ${u.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new m.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}c.FragColorGlslLib=h},3878:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.replaceInlines=void 0;let y=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;c.replaceInlines=function(m){let f={},h;for(;(h=y.exec(m))!==null;){let p=h[3].split(",").map(u=>{let s=u.trim().split(" ");return s&&s.length===2?{type:s[0],name:s[1]}:null}).filter(u=>u!==null);f[h[2]]={params:p,body:h[4]}}for(let p in f){let u="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",p),s=new RegExp(u,"gm");for(;(h=s.exec(m))!==null;){let a=h[1],o=h[2],n=h[3].split(","),e=a?`${a} ${o};`:"",t=f[p].body,r="";f[p].params.forEach((l,d)=>{l&&(r+=`${l.type} ${l.name} = ${n[d]};
`)}),t=`${r}
 ${t}`,t=t.replace("return",`${o} = `);let i=`
      ${e}
      {
        ${t}
      }
      `;m=m.replace(h[0],i)}}return m.replace(y,"")}},8897:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.GlslPreprocessor=void 0;let m=y(1997),f=y(3878),h=y(1248),p=y(6757);c.GlslPreprocessor=class{constructor(u,s,a,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new m.GlslContext(u,s,a,o),Object.keys(h.glslRegistry).forEach(e=>{let t=new h.glslRegistry[e](this.context);this.libs[e]=t});let n=this.glslLibRoutineDependencyGraph;for(let e in this.libs){let t=this.libs[e].getFunctions();for(let r in t){let i=e+"."+r,l;n[i]?(l=n[i],l.routineBody=t[r].routineBody):(l=new m.GlslLibRoutineNode(i,t[r].routineBody),n[i]=l);let d=t[r].dependencies;if(d)for(let g=0;g<d.length;++g)if(n[d[g]])l.addDependency(n[d[g]]);else{let b=new m.GlslLibRoutineNode(d[g]);n[d[g]]=b,l.addDependency(b)}}}}preprocess(){let u=this.context.programInfo,s=u.shaderSource;return this.context.programInfo.hasMain||(s=`${s}
      ${(0,p.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),s=(0,f.replaceInlines)(s),`${(0,p.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(u.inputNames,u.variables)}
    ${this.getImports(s)}
    ${s}`}getImports(u){let s=this.selectGlslLibRoutinesToBeIncluded(u);if(s.length===0)return"";let a="";for(let o=0;o<s.length;++o){if(!s[o].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${s[o].name}`);a+=s[o].routineBody+`
`}return a}selectGlslLibRoutinesToBeIncluded(u){let s=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(a=>{let o=a.split(".")[1];u.indexOf(o)!==-1&&s.push(this.glslLibRoutineDependencyGraph[a])}),m.TopologicalSortGlslRoutines.returnOrderedNodes(s)}getUniforms(u,s){let a=[];if(u)for(let o of u)a.push(`uniform sampler2D ${o};`);if(s)for(let o of s)a.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return a.join(`
`)}}},1248:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.glslRegistry=void 0;let m=y(6859),f=y(1371),h=y(2691),p=y(9183),u=y(9314);c.glslRegistry={encoding:f.EncodingGlslLib,fragcolor:h.FragColorGlslLib,vec:u.VecGlslLib,shapeUtils:p.ShapeUtilsGlslLib,coordinates:m.CoordsGlslLib}},9183:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ShapeUtilsGlslLib=void 0;let m=y(1997);class f extends m.GlslLib{constructor(p){super(p)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){let p=this.context.outputTextureLayout.shape.length,u={};return this.context.programInfo.inputNames.forEach((s,a)=>{let o=this.context.inputTextureLayouts[a].unpackedShape;if(o.length<=p){let n=o.length,e=p-n,t=`bcastIndices_${s}`,r="";for(let l=0;l<n;++l)r+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${e+l}]), ${o[l]}.0) );
          `;let i=`
        void ${t} (int bcastedIndices[${p}], out int realIndices[${n}]) {
          ${r}
        }
        `;u[t]=new m.GlslLibRoutine(i)}}),u}bcastMatmulIndex(){let p=this.context.outputTextureLayout.shape.length,u={};return this.context.programInfo.inputNames.forEach((s,a)=>{let o=this.context.inputTextureLayouts[a].shape;if(!(o.length<2||o.length>p)){let n=o.length,e=p-n,t=`bcastMatmulIndices_${s}`,r="";for(let l=0;l<n-2;++l)r+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${e+l}]), ${o[l]}.0) );
          `;let i=`
        void ${t}(int bcastedIndices[${p}], out int realIndices[${n}]) {
          ${r}
          realIndices[${n-1}] = bcastedIndices[${p-1}];
          realIndices[${n-2}] = bcastedIndices[${p-2}];
        }
        `;u[t]=new m.GlslLibRoutine(i)}}),u}indicesToOffset(){let p={};return this.context.programInfo.inputNames.forEach((u,s)=>{let a=this.context.inputTextureLayouts[s].shape,o=this.context.inputTextureLayouts[s].strides,n=a.length,e=`indicesToOffset_${u}`;p[e]=new m.GlslLibRoutine(f.indexToOffsetSingle(e,n,o)),e=`indicesToOffset_${u}_T`,p[e]=new m.GlslLibRoutine(f.indexToOffsetSingle(e,n,o.slice().reverse()))}),p}static indexToOffsetSingle(p,u,s){let a="";for(let o=u-1;o>=0;--o)a+=`
        offset += indices[${o}] * ${s[o]};
        `;return`
      int ${p}(int indices[${u}]) {
        int offset = 0;
        ${a}
        return offset;
      }
      `}offsetToIndices(){let p={};return this.context.programInfo.inputNames.forEach((u,s)=>{let a=this.context.inputTextureLayouts[s].shape,o=this.context.inputTextureLayouts[s].strides,n=a.length,e=`offsetToIndices_${u}`;p[e]=new m.GlslLibRoutine(f.offsetToIndicesSingle(e,n,o)),e=`offsetToIndices_${u}_T`,p[e]=new m.GlslLibRoutine(f.offsetToIndicesSingle(e,n,o.slice().reverse()))}),p}static offsetToIndicesSingle(p,u,s){let a=[];for(let o=0;o<u-1;++o)a.push(`
      indices[${o}] = offset / ${s[o]};`),a.push(`
        offset -= indices[${o}] * ${s[o]};`);return a.push(`
      indices[${u-1}] = offset;`),`
      void ${p}(int offset, out int indices[${u}]) {
        ${a.join("")}
      }
      `}incrementIndices(){let p={};return this.context.programInfo.inputNames.forEach((u,s)=>{let a=this.context.inputTextureLayouts[s].shape,o=a.length,n=`incrementIndices_${u}`,e="";for(let r=0;r<o;++r)e+=`
        shape[${r}] = ${a[r]};`;let t=`
        void ${n}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${e};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;p[n]=new m.GlslLibRoutine(t)}),p}}c.ShapeUtilsGlslLib=f},6757:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getDefaultFragShaderMain=c.getFragShaderPreamble=c.getVertexShaderSource=c.getGlsl=void 0;let y={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},m={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function f(h){return h===1?y:m}c.getGlsl=f,c.getVertexShaderSource=function(h){let p=f(h);return`${p.version}
      precision highp float;
      ${p.attribute} vec3 position;
      ${p.attribute} vec2 textureCoord;

      ${p.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},c.getFragShaderPreamble=function(h){let p=f(h);return`${p.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${p.varyingFrag} vec2 TexCoords;
    ${p.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},c.getDefaultFragShaderMain=function(h,p){return`
  void main() {
    int indices[${p}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${f(h).output} = result;
  }
  `}},9314:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.VecGlslLib=void 0;let m=y(1997);class f extends m.GlslLib{constructor(p){super(p)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){let p=this.context.outputTextureLayout.shape.length,u={add:"+=",sub:"-=",mul:"*=",div:"/="},s={};for(let a in u){let o=`${a}Vec`,n="";for(let t=0;t<p;++t)n+=`
          dest[${t}] ${u[a]} src[${t}];
          `;let e=`
        void ${o}(int src[${p}], out int dest[${p}]) {
          ${n}
        }
        `;s[o]=new m.GlslLibRoutine(e)}return s}copyVec(){let p=this.context.outputTextureLayout.shape.length,u="";for(let a=0;a<p;++a)u+=`
        dest[${a}] = src[${a}];
        `;let s=`
      void copyVec(int src[${p}], out int dest[${p}]) {
        ${u}
      }
      `;return{copyVec:new m.GlslLibRoutine(s)}}setVecItem(){let p=this.context.outputTextureLayout.shape.length,u=`
        if(index < 0)
            index =${p} + index;
        if (index == 0)
            m[0] = value;
        `;for(let a=1;a<p-1;++a)u+=`
        else if (index == ${a})
            m[${a}] = value;
            `;u+=`
        else
            m[${p-1}] = value;
        `;let s=`
      void setVecItem(out int m[${p}], int index, int value) {
        ${u}
      }
        `;return{setVecItem:new m.GlslLibRoutine(s)}}getVecItem(){let p=this.context.outputTextureLayout.shape.length,u=`
        if(index < 0)
            index = ${p} + index;
        if (index == 0)
            return m[0];
      `;for(let a=1;a<p-1;++a)u+=`
        else if (index == ${a})
            return m[${a}];
      `;u+=`
        else
            return m[${p-1}];
        `;let s=`
      int getVecItem(int m[${p}], int index) {
        ${u}
      }
    `;return{getVecItem:new m.GlslLibRoutine(s)}}}c.VecGlslLib=f},7860:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLInferenceHandler=void 0;let m=y(1315),f=y(9240),h=y(7273),p=y(9),u=y(7379),s=y(2488),a=y(540),o=y(3314),n=y(5639);c.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,t){return(0,o.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,t)}executeProgram(e,t){if(t.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let r=[];for(let v=0;v<e.inputNames.length;++v)r[v]=this.getOrCreateTextureData(t[v],e.inputTypes[v]);let i=((v,w)=>{let x=w.map(O=>`${O.unpackedShape.join(",")};${O.width}x${O.height}`).join("_"),T=v.name;return v.cacheHint&&(T+="["+v.cacheHint+"]"),T+=":"+x,T})(e,r),l=this.session.programManager.getArtifact(i),d=l?l.programInfo:typeof e.get=="function"?e.get():e,g=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,d.output.dims,d.output.textureType),b=this.createTextureData(g,d.output.type);return l||(l=this.session.programManager.build(d,r,b),this.session.programManager.setArtifact(i,l)),this.runProgram(l,r,b),b}run(e,t){return this.executeProgram(e,t).tensor}runProgram(e,t,r){for(let i=0;i<t.length;++i)if(!!t[i].isPacked!=(e.programInfo.inputTypes[i]===n.TextureType.packed))throw new Error(`input[${i}] property packed inconsistent`);if(!!r.isPacked!=(e.programInfo.output.textureType===n.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,t,r)}getOrCreateTextureData(e,t){let r=this.getTextureData(e.dataId,t===n.TextureType.packed);if(!r&&(r=this.getTextureData(e.dataId,t!==n.TextureType.packed),r))return t===n.TextureType.packed?this.pack(r):this.unpack(r);if(!r){let i=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,t);if(t===n.TextureType.packedLastDimension){let g=e.dims;if(g.length===4){let b=[g[0],Math.ceil(g[1]*g[2]*g[3]/4)],v=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,b,t),w=e.numberData;if(g[1]*g[2]*g[3]%4!=0){let x=g[0],T=g[1]*g[2]*g[3],O=Math.ceil(T*1/4)*4;w=new Float32Array(x*O);for(let P=0;P<x;++P){let I=P*T,R=P*O+P%1*T;w.set(e.numberData.subarray(I,I+T),R)}}return this.createTextureData(v,e.type,w,e,1)}}if(t===n.TextureType.packed){let l=(0,o.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),d=this.createTextureData(l,e.type,e.numberData,e,1);r=this.pack(d)}else r=this.createTextureData(i,e.type,e.numberData,e,1)}return r}createTextureDataFromLayoutBindTensor(e,t,r,i){return this.createTextureData(e,t,r,i,1)}createTextureData(e,t,r,i,l){m.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let d=this.session.textureManager.createTextureFromLayout(t,e,r,l);return this.createTextureDataFromTexture(e,t,d,i)}reshapeUnpacked(e,t){let r=this.getOrCreateTextureData(e,n.TextureType.unpacked),i={channels:r.channels,height:r.height,width:r.width,shape:t.length!==0?t:[1],strides:h.ShapeUtil.computeStrides(t),unpackedShape:t};return this.createTextureDataFromTexture(i,e.type,r.texture).tensor}reshapePacked(e,t){let r=this.getOrCreateTextureData(e,n.TextureType.packed);if((0,u.isReshapeCheap)(e.dims,t)){let b={channels:r.channels,height:r.height,width:r.width,shape:t.length!==0?t:[1],strides:h.ShapeUtil.computeStrides(t),unpackedShape:t,isPacked:!0};return this.createTextureDataFromTexture(b,e.type,r.texture).tensor}let i=(0,u.processDims3D)(e.dims),l=(0,u.processDims3D)(t),d=this.reshapePacked(e,i),g=this.run((0,u.createPackedReshape3DProgramInfoLoader)(this,d,l),[d]);return this.reshapePacked(g,t)}cast(e,t){let r=this.getOrCreateTextureData(e,n.TextureType.unpacked);return this.createTextureDataFromTexture(r,t,r.texture).tensor}createTextureDataFromTexture(e,t,r,i,l){let d=Object.assign(Object.assign({},e),{tensor:i||new f.Tensor(e.unpackedShape,t,g=>this.readTexture(d),async g=>this.readTextureAsync(d),void 0,l),texture:r});return this.setTextureData(d.tensor.dataId,d,e.isPacked),d}getTextureData(e,t=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,t):t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,r=!1){this.session.isInitializer(e)?this.session.setTextureData(e,t,r):(r?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,t)}isTextureLayoutCached(e,t=!1){return!!this.getTextureData(e.dataId,t)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,s.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,s.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,p.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,a.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},4110:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(Y,X,te,ae){ae===void 0&&(ae=te);var se=Object.getOwnPropertyDescriptor(X,te);se&&!("get"in se?!X.__esModule:se.writable||se.configurable)||(se={enumerable:!0,get:function(){return X[te]}}),Object.defineProperty(Y,ae,se)}:function(Y,X,te,ae){ae===void 0&&(ae=te),Y[ae]=X[te]}),f=this&&this.__setModuleDefault||(Object.create?function(Y,X){Object.defineProperty(Y,"default",{enumerable:!0,value:X})}:function(Y,X){Y.default=X}),h=this&&this.__importStar||function(Y){if(Y&&Y.__esModule)return Y;var X={};if(Y!=null)for(var te in Y)te!=="default"&&Object.prototype.hasOwnProperty.call(Y,te)&&m(X,Y,te);return f(X,Y),X};Object.defineProperty(c,"__esModule",{value:!0}),c.WEBGL_OP_RESOLVE_RULES=void 0;let p=y(8817),u=h(y(5194)),s=y(4752),a=y(6668),o=y(9754),n=y(5042),e=y(6742),t=y(4125),r=y(6149),i=y(5378),l=y(6981),d=y(7413),g=y(7006),b=y(8276),v=y(5565),w=y(2834),x=y(1010),T=y(8126),O=y(2801),P=y(565),I=y(2444),R=y(815),j=y(564),A=y(5416),C=y(1240),_=y(5944),S=y(5707),E=h(y(9087)),z=y(7862),L=y(3980);c.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",E.abs],["Acos","","7+",E.acos],["Add","","7+",u.add],["And","","7+",u.and],["Asin","","7+",E.asin],["Atan","","7+",E.atan],["AveragePool","","7+",w.averagePool,w.parseAveragePoolAttributes],["BatchNormalization","","7+",p.batchNormalization,p.parseBatchNormalizationAttributes],["Cast","","6+",s.cast,s.parseCastAttributes],["Ceil","","6+",E.ceil],["Clip","","6-10",E.clip,E.parseClipAttributes],["Clip","","11+",E.clipV11],["Concat","","4+",a.concat,a.parseConcatAttributes],["Conv","","1+",o.conv,o.parseConvAttributes],["ConvTranspose","","1+",n.convTranspose,n.parseConvTransposeAttributes],["Cos","","7+",E.cos],["Div","","7+",u.div],["Dropout","","7+",E.identity],["DepthToSpace","","1+",e.depthToSpace,e.parseDepthToSpaceAttributes],["Equal","","7+",u.equal],["Elu","","6+",E.elu,E.parseEluAttributes],["Exp","","6+",E.exp],["Flatten","","1+",t.flatten,t.parseFlattenAttributes],["Floor","","6+",E.floor],["FusedConv","com.microsoft","1+",o.conv,o.parseConvAttributes],["Gather","","1+",r.gather,r.parseGatherAttributes],["Gemm","","7-10",i.gemm,i.parseGemmAttributesV7],["Gemm","","11+",i.gemm,i.parseGemmAttributesV11],["GlobalAveragePool","","1+",w.globalAveragePool,w.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",w.globalMaxPool],["Greater","","7+",u.greater],["Identity","","1+",E.identity],["ImageScaler","","1+",l.imageScaler,l.parseImageScalerAttributes],["InstanceNormalization","","6+",d.instanceNormalization,d.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",E.leakyRelu,E.parseLeakyReluAttributes],["Less","","7+",u.less],["LRN","","1+",g.lrn,g.parseLrnAttributes],["Log","","6+",E.log],["MatMul","","1+",b.matMul,b.parseMatMulAttributes],["MaxPool","","1+",w.maxPool,w.parseMaxPoolAttributes],["Mul","","7+",u.mul],["Neg","","6+",E.neg],["Not","","1+",E.not],["Or","","7+",u.or],["Pad","","2-10",v.padV2,v.parsePadAttributesV2],["Pad","","11+",v.padV11,v.parsePadAttributesV11],["Pow","","7+",u.pow],["PRelu","","7+",u.pRelu],["ReduceLogSum","","1+",x.reduceLogSum,x.parseReduceAttributes],["ReduceMax","","1+",x.reduceMax,x.parseReduceAttributes],["ReduceMean","","1+",x.reduceMean,x.parseReduceAttributes],["ReduceMin","","1+",x.reduceMin,x.parseReduceAttributes],["ReduceProd","","1+",x.reduceProd,x.parseReduceAttributes],["ReduceSum","","1-12",x.reduceSum,x.parseReduceAttributes],["ReduceSumSquare","","1+",x.reduceLogSumSquare,x.parseReduceAttributes],["Relu","","6+",E.relu],["Reshape","","5+",T.reshape],["Resize","","10",O.resize,O.parseResizeAttributesV10],["Resize","","11+",O.resize,O.parseResizeAttributesV11],["Shape","","1+",P.shape],["Sigmoid","","6+",E.sigmoid],["Sin","","7+",E.sin],["Slice","","10+",I.sliceV10],["Slice","","1-9",I.slice,I.parseSliceAttributes],["Softmax","","1-12",R.softmax,R.parseSoftmaxAttributes],["Softmax","","13+",R.softmaxV13,R.parseSoftmaxAttributesV13],["Split","","2-12",j.split,j.parseSplitAttributes],["Sqrt","","6+",E.sqrt],["Squeeze","","1-12",A.squeeze,A.parseSqueezeAttributes],["Squeeze","","13+",A.squeezeV13],["Sub","","7+",u.sub],["Sum","","6+",C.sum],["Tan","","7+",E.tan],["Tanh","","6+",E.tanh],["Tile","","6+",_.tile],["Transpose","","1+",S.transpose,S.parseTransposeAttributes],["Upsample","","7-8",L.upsample,L.parseUpsampleAttributesV7],["Upsample","","9",L.upsample,L.parseUpsampleAttributesV9],["Unsqueeze","","1-12",z.unsqueeze,z.parseUnsqueezeAttributes],["Unsqueeze","","13+",z.unsqueezeV13],["Xor","","7+",u.xor]]},8817:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseBatchNormalizationAttributes=c.batchNormalization=void 0;let m=y(4910),f=y(6757),h=y(5639),p={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]};c.batchNormalization=(a,o,n)=>(s(o),[a.run(Object.assign(Object.assign({},p),{cacheHint:n.cacheKey,get:()=>u(a,o,n)}),o)]),c.parseBatchNormalizationAttributes=a=>{let o=a.attributes.getFloat("epsilon",1e-5),n=a.attributes.getFloat("momentum",.9),e=a.attributes.getInt("spatial",1);return(0,m.createAttributeWithCacheKey)({epsilon:o,momentum:n,spatial:e})};let u=(a,o,n)=>{let e=(0,f.getGlsl)(a.session.backend.glContext.version),t=o[0].dims.length,[r,i]=a.calculateTextureWidthAndHeight(o[1].dims,h.TextureType.unpacked),l=`
  float process(int[${t}] indices) {
    vec2 position = offsetToCoords(indices[1], ${r}, ${i});
    float scale = getColorAsFloat(${e.texture2D}(Scale, position));
    float mean = getColorAsFloat(${e.texture2D}(Mean, position));
    float variance = getColorAsFloat(${e.texture2D}(Variance, position));
    float b = getColorAsFloat(${e.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},p),{output:{dims:o[0].dims,type:o[0].type,textureType:h.TextureType.unpacked},shaderSource:l})},s=a=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let o=a[0],n=a[1],e=a[2],t=a[3],r=a[4];if(o.dims.length<3||n.dims.length!==1||e.dims.length!==1||t.dims.length!==1||r.dims.length!==1)throw new Error("invalid input shape.");if(n.dims[0]!==o.dims[1]||e.dims[0]!==o.dims[1]||t.dims[0]!==o.dims[1]||r.dims[0]!==o.dims[1])throw new Error("invalid input shape.");if(o.type!=="float32"&&o.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||r.type!=="float32"&&r.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.xor=c.sub=c.pRelu=c.pow=c.or=c.mul=c.less=c.greater=c.equal=c.div=c.and=c.add=c.glslPRelu=c.glslPow=c.glslXor=c.glslOr=c.glslAnd=c.glslLess=c.glslGreater=c.glslEqual=c.glslSub=c.glslMul=c.glslDiv=c.glslAdd=void 0;let m=y(7273),f=y(1997),h=y(6757),p=y(5639);function u(){let w="add_";return{body:`
  float ${w}(float a, float b) {
    return a + b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function s(){let w="div_";return{body:`
  float ${w}(float a, float b) {
    return a / b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function a(){let w="mul_";return{body:`
  float ${w}(float a, float b) {
    return a * b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function o(){let w="sub_";return{body:`
  float ${w}(float a, float b) {
    return a - b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function n(){let w="equal_";return{body:`
  float ${w}(float a, float b) {
    return float(a == b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:w,type:f.FunctionType.ValueBased}}function e(){let w="greater_";return{body:`
  float ${w}(float a, float b) {
    return float(a > b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function t(){let w="less_";return{body:`
  float ${w}(float a, float b) {
    return float(a < b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function r(){let w="and_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function i(){let w="or_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function l(){let w="xor_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function d(){return function(w){let x=`${w}_`;return{body:`
  float ${x}(float a, float b) {
    return ${w}(a, b);
  }
  vec4 ${x}(vec4 v1, vec4 v2) {
    return ${w}(v1, v2);
  }
  `,name:x,type:f.FunctionType.ValueBased}}("pow")}function g(){let w="prelu_";return{body:`
  float ${w}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:w,type:f.FunctionType.ValueBased}}c.glslAdd=u,c.glslDiv=s,c.glslMul=a,c.glslSub=o,c.glslEqual=n,c.glslGreater=e,c.glslLess=t,c.glslAnd=r,c.glslOr=i,c.glslXor=l,c.glslPow=d,c.glslPRelu=g;let b=(w,x,T,O=x[0].type,P)=>{let I=w.session.pack?p.TextureType.packed:p.TextureType.unpacked;return{name:T.name,inputNames:["A","B"],inputTypes:[I,I],cacheHint:P,get:()=>v(w,x,T,O)}},v=(w,x,T,O=x[0].type)=>{let P=w.session.pack?p.TextureType.packed:p.TextureType.unpacked,I=!m.ShapeUtil.areEqual(x[0].dims,x[1].dims),R=x[0].dims,j=w.session.pack;if(I){let _=m.BroadcastUtil.calcShape(x[0].dims,x[1].dims,!1);if(!_)throw new Error("Can't perform binary op on the given tensors");R=_;let S=R.length,E=x[0].dims.length!==0?x[0].dims.length:1,z=x[1].dims.length!==0?x[1].dims.length:1,L=x[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",Y=x[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",X=(0,h.getGlsl)(w.session.backend.glContext.version),te=j?`
      ${T.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${T.name}(a, b);
        ${X.output} = result;
      }`:`
      ${T.body}
      float process(int indices[${S}]) {
        int aindices[${E}];
        int bindices[${z}];
        ${L}
        ${Y}
        return ${T.name}(_A(aindices), _B(bindices));
      }`;return{name:T.name,inputNames:["A","B"],inputTypes:[P,P],output:{dims:R,type:O,textureType:P},shaderSource:te,hasMain:j}}let A=(0,h.getGlsl)(w.session.backend.glContext.version),C=`
    ${T.body}
    void main() {
      vec4 v1 = ${A.texture2D}(A, TexCoords);
      vec4 v2 = ${A.texture2D}(B, TexCoords);
      vec4 result = ${T.name}(v1, v2);
      ${A.output} = result;
    }
    `;return{name:T.name,inputNames:["A","B"],inputTypes:[P,P],output:{dims:x[0].dims,type:O,textureType:P},shaderSource:C,hasMain:!0}};c.add=(w,x)=>[w.run(b(w,x,u()),x)],c.and=(w,x)=>[w.run(b(w,x,r(),"bool"),x)],c.div=(w,x)=>[w.run(b(w,x,s()),x)],c.equal=(w,x)=>[w.run(b(w,x,n(),"bool"),x)],c.greater=(w,x)=>[w.run(b(w,x,e(),"bool"),x)],c.less=(w,x)=>[w.run(b(w,x,t(),"bool"),x)],c.mul=(w,x)=>[w.run(b(w,x,a()),x)],c.or=(w,x)=>[w.run(b(w,x,i(),"bool"),x)],c.pow=(w,x)=>[w.run(b(w,x,d()),x)],c.pRelu=(w,x)=>[w.run(b(w,x,g()),x)],c.sub=(w,x)=>[w.run(b(w,x,o()),x)],c.xor=(w,x)=>[w.run(b(w,x,l(),"bool"),x)]},4752:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseCastAttributes=c.cast=void 0;let m=y(7273);c.cast=(h,p,u)=>(f(p),[h.cast(p[0],u)]),c.parseCastAttributes=h=>m.ProtoUtil.tensorDataTypeFromProto(h.attributes.getInt("to"));let f=h=>{if(!h||h.length!==1)throw new Error("Cast requires 1 input.");if(h[0].type==="string")throw new Error("Invalid input type.")}},4595:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackedConcatProgramInfoLoader=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614);c.createPackedConcatProgramInfoLoader=(s,a,o)=>{let n=(e=a.length,t=o.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:e},(r,i)=>`X${i}`),inputTypes:Array(e).fill(f.TextureType.packed),cacheHint:t});var e,t;return Object.assign(Object.assign({},n),{get:()=>((r,i,l,d)=>{let g=l[0].dims.slice();if(d>=g.length||d<-1*g.length)throw new Error("axis specified for concat doesn't match input dimensionality");d<0&&(d=g.length+d);let b=g.slice(0);for(let L=1;L<l.length;L++){let Y=l[L].dims.slice();for(let X=0;X<g.length;X++)if(X===d)b[d]+=Y[X];else if(g[X]!==Y[X])throw new Error("non concat dimensions must match")}let v=b.length,w=(0,p.getChannels)("coords",v),x=(0,h.getCoordsDataType)(v),T=(0,p.unpackFromChannel)(),O=l.map(L=>L.dims),P=(0,h.getGlChannels)(v),I=new Array(O.length-1);I[0]=O[0][d];for(let L=1;L<I.length;L++)I[L]=I[L-1]+O[L][d];let R=P[d],j=P.slice(-2),A=P.join(),C=`if (${R} < ${I[0]}) {
        return getChannel(
            getX0(${A}), vec2(${j.join()}));
        }`;for(let L=1;L<I.length;L++){let Y=I[L-1];C+=`
            if (${R} < ${I[L]}  && ${R} >= ${I[L-1]}) {
              return getChannel(
                getX${L}(${u(P,R,Y)}),
                vec2(${u(j,R,Y)}));
            }`}let _=I.length,S=I[I.length-1];C+=`
            return getChannel(
              getX${_}(${u(P,R,S)}),
              vec2(${u(j,R,S)}));`;let E=(0,m.getGlsl)(r.session.backend.glContext.version),z=`
          ${T}
          float getValue(${P.map(L=>"int "+L)}) {
            ${C}
          }

          void main() {
            ${x} coords = getOutputCoords();
            int lastDim = coords.${P[v-1]};
            coords.${P[v-1]} = coords.${P[v-2]};
            coords.${P[v-2]} = lastDim;

            vec4 result = vec4(getValue(${w}), 0., 0., 0.);

            ${w[v-1]} = ${w[v-1]} + 1;
            if (${w[v-1]} < ${b[v-1]}) {
              result.g = getValue(${w});
            }

            ${w[v-2]} = ${w[v-2]} + 1;
            if (${w[v-2]} < ${b[v-2]}) {
              result.a = getValue(${w});
            }

            ${w[v-1]} = ${w[v-1]} - 1;
            if (${w[v-2]} < ${b[v-2]} &&
                ${w[v-1]} < ${b[v-1]}) {
              result.b = getValue(${w});
            }
            ${E.output} = result;
          }
        `;return Object.assign(Object.assign({},i),{output:{dims:b,type:l[0].type,textureType:f.TextureType.packed},shaderSource:z,hasMain:!0})})(s,n,a,o.axis)})};let u=(s,a,o)=>{let n=s.indexOf(a);return s.map((e,t)=>t===n?`${e} - ${o}`:e).join()}},6668:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseConcatAttributes=c.concat=void 0;let m=y(4910),f=y(5639),h=y(4595);c.concat=(e,t,r)=>(n(t),e.session.pack&&t[0].dims.length>1?[e.run((0,h.createPackedConcatProgramInfoLoader)(e,t,r),t)]:[e.run(p(e,t,r),t)]);let p=(e,t,r)=>{let i=(l=t.length,d=r.cacheKey,{name:"Concat",inputNames:Array.from({length:l},(g,b)=>`X${b}`),inputTypes:Array(l).fill(f.TextureType.unpacked),cacheHint:d});var l,d;return Object.assign(Object.assign({},i),{get:()=>((g,b,v,w)=>{let x=v[0].dims.slice();if(w>=x.length||w<-1*x.length)throw new Error("axis specified for concat doesn't match input dimensionality");w<0&&(w=x.length+w);let T=x.slice(0);for(let A=1;A<v.length;A++){let C=v[A].dims.slice();for(let _=0;_<x.length;_++)if(_===w)T[w]+=C[_];else if(x[_]!==C[_])throw new Error("non concat dimensions must match")}let O=T.length,P=new Array(v.length),I=0;for(let A=0;A<P.length;++A)I+=v[A].dims[w],P[A]=I;let R="";R=v.length<5?u(P):s(P);let j=`
        ${a(v.length,O)}
        ${o(P)}
        ${R}
        float process(int indices[${O}]) {
          int textureIndex = getTextureWhereDataResides (indices[${w}]);

          if(textureIndex != 0) {
            indices[${w}] = indices[${w}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},b),{output:{dims:T,type:v[0].type,textureType:f.TextureType.unpacked},shaderSource:j})})(0,i,t,r.axis)})},u=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((t,r)=>`if(index<${t}) {return ${r};}
`).join("")}
    }`,s=e=>u(e),a=(e,t)=>{let r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let i=0;i<e;++i)i===0?r.push(`	if (textureIndex == ${i}) { return _X${i}(indices); }`):i===e-1?r.push(`	else { return _X${i}(indices); }`):r.push(`	else if (textureIndex == ${i}) { return _X${i}(indices); }`);return r.push("	}"),r.join(`
`)},o=e=>{let t=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<e.length;++r)r===0?t.push(`	if (index == ${r}) { return ${e[r]}; }`):r===e.length-1?t.push(`	else { return ${e[r]}; }`):t.push(`	else if (index == ${r}) { return ${e[r]}; }`);return t.push("	}"),t.join(`
`)};c.parseConcatAttributes=e=>(0,m.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});let n=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].type,r=e[0].dims.length;if(t==="string")throw new Error("string tensor is not supported yet");for(let i of e){if(i.type!==t)throw new Error("input tensors should be one type");if(i.dims.length!==r)throw new Error("input tensors should have the same shape")}}},7825:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createUnpackedGroupedConvProgramInfoLoader=void 0;let m=y(1315),f=y(6757),h=y(5639),p=y(9754),u=y(2150);c.createUnpackedGroupedConvProgramInfoLoader=(s,a,o)=>{let n=(e=a.length>2,t=o.cacheKey,{name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:t});var e,t;return Object.assign(Object.assign({},n),{get:()=>((r,i,l,d)=>{let g=i.length>2?"value += getBias(output_channel);":"",b=i[0].dims.slice(),v=i[1].dims.slice(),w=v[0]/d.group;m.Logger.verbose("GroupedConv",`autpPad:${d.autoPad}, dilations:${d.dilations}, group:${d.group}, kernelShape:${d.kernelShape}, pads:${d.pads}, strides:${d.strides}`);let x=(0,p.calculateOutputShape)(b,v,d.dilations,d.pads,d.strides),T=(0,f.getGlsl)(r.session.backend.glContext.version),{activationFunction:O,applyActivation:P}=(0,u.getActivationSnippet)(d),I=`
  const ivec2 strides = ivec2(${d.strides[0]}, ${d.strides[1]});
  const ivec2 pads = ivec2(${d.pads[0]}, ${d.pads[1]});
  ${O}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${w};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${v[1]}; wInChannel++) {
      int input_channel = group_id * ${v[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${v[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${d.dilations[0]};

        if (xHeight < 0 || xHeight >= ${b[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${v[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${d.dilations[1]};
          if (xWidth < 0 || xWidth >= ${b[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${g}
    ${P}
    ${T.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},l),{output:{dims:x,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:I,hasMain:!0})})(s,a,n,o)})}},7708:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.conv2DPacked=c.conv2DPackedPointwise=void 0;let m=y(9754),f=y(5950),h=y(5632);c.conv2DPackedPointwise=(p,u,s)=>{let a=u[0].dims,o=u[1].dims,n=(0,m.calculateOutputShape)(a,o,s.dilations,s.pads,s.strides),e=p.reshapePacked(u[0],[a[1],a[2]*a[3]]),t=p.reshapePacked(u[1],[o[0],o[1]]),r=u.length>2?[t,e,u[2]]:[t,e],i=p.run((0,h.createPackedMatmulProgramInfoLoader)(p,r,s),r);return p.reshapePacked(i,n)},c.conv2DPacked=(p,u,s)=>{let a=u[0].dims,o=u[1].dims,n=(0,m.calculateOutputShape)(a,o,s.dilations,s.pads,s.strides),e=p.run((0,f.createPackedIm2ColProgramInfoLoader)(p,u[0],u[1],n,s),[u[0]]),t=p.reshapePacked(u[1],[o[0],o[1]*o[2]*o[3]]),r=u.length===3?[t,e,u[2]]:[t,e],i=p.run((0,h.createPackedMatmulProgramInfoLoader)(p,r,s),r);return p.reshapePacked(i,n)}},5042:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseConvTransposeAttributes=c.convTranspose=void 0;let m=y(4910),f=y(6757),h=y(5639),p=y(2150),u=(t,r,i,l,d,g)=>(t-1)*r+i+(l-1)*d+1-g,s=(t,r,i,l,d)=>{let g=Math.floor(t/2);r==="SAME_UPPER"?(i[l]=g,i[d]=t-g):r==="SAME_LOWER"&&(i[l]=t-g,i[d]=g)};c.convTranspose=(t,r,i)=>(e(r,i),a(t,r,i));let a=(t,r,i)=>{let l=n(i,r);return[o(t,r,l)]},o=(t,r,i)=>t.run(((l,d,g)=>{let b=(v=d.length>2,w=g.cacheKey,{name:"ConvTranspose",inputNames:v?["X","W","B"]:["X","W"],inputTypes:v?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:w});var v,w;return Object.assign(Object.assign({},b),{get:()=>((x,T,O,P)=>{let I=T.length>2?"getB(output_channel)":"0.0",R=T[0].dims,j=T[1].dims,A=j[1],C=j[0]/P.group,_=[T[0].dims[0],T[1].dims[1]*P.group,...P.outputShape],S=(0,f.getGlsl)(x.session.backend.glContext.version),{activationFunction:E,applyActivation:z}=(0,p.getActivationSnippet)(P),L=`
  const ivec2 strides = ivec2(${P.strides[0]}, ${P.strides[1]});
  const ivec2 pads = ivec2(${P.pads[0]}, ${P.pads[1]});
  ${E}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${A};
    int wOutChannel = output_channel - group_id * ${A};

    float value = ${I};
    for (int inChannelOffset = 0; inChannelOffset < ${C}; inChannelOffset++) {
      int input_channel = group_id * ${C} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${j[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${j[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${P.dilations[0]}, wHOff * ${P.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${R[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${R[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${z}
    ${S.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},O),{output:{dims:_,type:T[0].type,textureType:h.TextureType.unpacked},shaderSource:L,hasMain:!0})})(l,d,b,g)})})(t,r,i),r),n=(t,r)=>{let i=t.kernelShape.slice();if(t.kernelShape.length===0)for(let b=2;b<r[1].dims.length;++b)i.push(r[1].dims[b]);let l=t.pads.slice(),d=t.outputShape.slice();((b,v,w,x,T,O,P,I)=>{let R=b.length-2,j=I.length===0;for(let A=0;A<R;++A){let C=j?b[A+2]*O[A]:I[A],_=u(b[A+2],O[A],T[A],v[A],w[A],C);s(_,x,T,A,A+R),j&&I.push(O[A]*(b[A+2]-1)+P[A]+(v[A]-1)*w[A]+1-T[A]-T[A+R])}})(r[0].dims,i,t.dilations,t.autoPad,l,t.strides,t.outputPadding,d);let g=Object.assign({},t);return Object.assign(g,{kernelShape:i,pads:l,outputShape:d,cacheKey:t.cacheKey}),g};c.parseConvTransposeAttributes=t=>{let r=t.attributes,i=(0,p.parseInternalActivationAttributes)(r),l=r.getString("auto_pad","NOTSET"),d=r.getInts("dilations",[1,1]),g=r.getInt("group",1),b=r.getInts("kernel_shape",[]),v=r.getInts("output_padding",[0,0]),w=r.getInts("output_shape",[]),x=r.getInts("pads",[0,0,0,0]),T=r.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:l,dilations:d,group:g,kernelShape:b,outputPadding:v,outputShape:w,pads:x,strides:T},i))};let e=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4||t[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==i))throw new Error("invalid bias");let l=t[0].dims.length-2;if(r.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(r.strides.length!==l)throw new Error(`strides should be ${l}D`);if(r.pads.length!==2*l)throw new Error(`pads should be ${2*l}D`);if(r.outputPadding.length!==l)throw new Error(`output_padding should be ${l}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if(t[0].type!=="float32"||t[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(t.length===3&&t[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseConvAttributes=c.conv=c.calculateOutputShape=void 0;let m=y(4910),f=y(7273),h=y(7825),p=y(7708),u=y(3281),s=y(2150),a=y(1625),o=y(8276);c.calculateOutputShape=(l,d,g,b,v)=>{let w=l[0],x=l.slice(2),T=x.length,O=d[0],P=d.slice(2).map((R,j)=>R+(R-1)*(g[j]-1)),I=x.map((R,j)=>R+b[j]+b[j+T]).map((R,j)=>Math.floor((R-P[j]+v[j])/v[j]));return[w,O].concat(...I)},c.conv=(l,d,g)=>(i(d,g),n(l,d,g));let n=(l,d,g)=>{let b=r(g,d),v=l.session.pack,w=b.kernelShape[0]===1&&b.kernelShape[1]===1;return b.group>1?[l.run((0,h.createUnpackedGroupedConvProgramInfoLoader)(l,d,b),d)]:w&&v?[e(l,d,b)]:v&&d[0].dims.length===4&&d[0].dims[0]===1&&!w?[(0,p.conv2DPacked)(l,d,b)]:[t(l,d,b)]},e=(l,d,g)=>{let b=d[0].dims,v=d[1].dims,w=(0,c.calculateOutputShape)(b,v,g.dilations,g.pads,g.strides),x=l.reshapeUnpacked(d[0],[b[1],b[2]*b[3]]),T=l.reshapeUnpacked(d[1],[v[0],v[1]]),O=d.length>2?[T,x,d[2]]:[T,x],P=l.run((0,o.createMatmulProgramInfoLoader)(O,g),O);return l.reshapeUnpacked(P,w)},t=(l,d,g)=>{let b=d[0].dims,v=d[1].dims,w=(0,c.calculateOutputShape)(b,v,g.dilations,g.pads,g.strides),x=l.run((0,a.createIm2ColProgramInfoLoader)(l,d[0],d[1],w,g),[d[0]]),T=d.length===3?[x,d[1],d[2]]:[x,d[1]];return l.run((0,u.createDotProductProgramInfoLoader)(l,d,w,g),T)},r=(l,d)=>{let g=l.kernelShape.slice();if(l.kernelShape.length===0)for(let w=2;w<d[1].dims.length;++w)g.push(d[1].dims[w]);let b=l.pads.slice();f.PoolConvUtil.adjustPadsBasedOnAutoPad(d[0].dims,l.strides,l.dilations,g,b,l.autoPad);let v=Object.assign({},l);return Object.assign(v,{kernelShape:g,pads:b,cacheKey:l.cacheKey}),v};c.parseConvAttributes=l=>{let d=l.attributes,g=(0,s.parseInternalActivationAttributes)(d),b=d.getString("auto_pad","NOTSET"),v=d.getInts("dilations",[1,1]),w=d.getInt("group",1),x=d.getInts("kernel_shape",[]),T=d.getInts("pads",[0,0,0,0]),O=d.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:b,dilations:v,group:w,kernelShape:x,pads:T,strides:O},g))};let i=(l,d)=>{if(!l||l.length!==2&&l.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(l[0].dims.length!==4||l[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(l[0].dims[1]!==l[1].dims[1]*d.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(l.length===3&&(l[2].dims.length!==1||l[1].dims[0]!==l[2].dims[0]))throw new Error("invalid bias");let g=l[0].dims.length-2;if(d.dilations.length!==g)throw new Error(`dilations should be ${g}D`);if(d.strides.length!==g)throw new Error(`strides should be ${g}D`);if(d.pads.length!==2*g)throw new Error(`pads should be ${2*g}D`);if(d.kernelShape.length!==0&&d.kernelShape.length!==l[1].dims.length-2)throw new Error("invalid kernel shape");if(l[0].type!=="float32"||l[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(l.length===3&&l[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseDepthToSpaceAttributes=c.depthToSpace=void 0;let m=y(5707);c.depthToSpace=(h,p,u)=>{f(p);let s=u.blocksize,a=s*s,o=u.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],n=u.mode==="DCR"?[p[0].dims[0],s,s,p[0].dims[1]/a,p[0].dims[2],p[0].dims[3]]:[p[0].dims[0],p[0].dims[1]/a,s,s,p[0].dims[2],p[0].dims[3]],e=h.reshapeUnpacked(p[0],n),t={perm:o,cacheKey:`${o}`},[r]=(0,m.transpose)(h,[e],t),i=[p[0].dims[0],p[0].dims[1]/a,p[0].dims[2]*s,p[0].dims[3]*s];return[h.reshapeUnpacked(r,i)]},c.parseDepthToSpaceAttributes=h=>{let p=h.attributes.getInt("blocksize");if(p<1)throw new Error(`blocksize must be >= 1, but got : ${p} for DepthToSpace`);let u=h.attributes.getString("mode","DCR");if(u!=="DCR"&&u!=="CRD")throw new Error(`unrecognized mode: ${u} for DepthToSpace`);return{mode:u,blocksize:p}};let f=h=>{if(h.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${h.length}`);if(h[0].type==="string"||h[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createDotProductProgramInfoLoader=void 0;let m=y(7273),f=y(6757),h=y(5639),p=y(2150),u=y(1625);c.createDotProductProgramInfoLoader=(s,a,o,n)=>{let e=((t,r)=>({name:"ConvDotProduct",inputNames:t?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:t?[h.TextureType.unpacked,h.TextureType.packedLastDimension,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.packedLastDimension],cacheKey:r.activationCacheKey}))(a.length>2,n);return Object.assign(Object.assign({},e),{get:()=>((t,r,i,l,d)=>{let g=i[0].dims,b=i[1].dims,v=[b[0],Math.ceil(g[1]*b[2]*b[3]/4)],w=(0,u.calculateIm2ColDims)(g,b,l),[x,T]=t.calculateTextureWidthAndHeight(v,h.TextureType.packedLastDimension),O=m.ShapeUtil.computeStrides(w),[P,I]=t.calculateTextureWidthAndHeight(w,h.TextureType.packedLastDimension),R=l.length,j=i.length<3?"0.0":"_B(b)",A=Math.ceil(g[1]*b[2]*b[3]/4),{activationFunction:C,applyActivation:_}=(0,p.getActivationSnippet)(d),S=(0,f.getGlsl)(t.session.backend.glContext.version),E=`
${C}
float process(int indices[${R}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${O[0]} + im2col[1] * ${O[1]} + im2col[2] * ${O[2]};
  int kernelOffset = indices[1] * ${v[1]};
  float value = ${j};
  for (int i = 0; i < ${A}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${P}, ${I});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${x}, ${T});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${_}
  return value;
}`;return Object.assign(Object.assign({},r),{output:{dims:l,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:E})})(s,e,a,o,n)})}},4125:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseFlattenAttributes=c.flatten=void 0;let m=y(7273);c.flatten=(h,p,u)=>{f(p,u);let s=m.ShapeUtil.flattenShape(p[0].dims,u);return[h.reshapeUnpacked(p[0],s)]},c.parseFlattenAttributes=h=>h.attributes.getInt("axis",1);let f=(h,p)=>{if(!h||h.length!==1)throw new Error("Flatten requires 1 input.");let u=h[0].dims.length;if(u===0)throw new Error("scalar tensor is not supported.");if(p<-u||p>u)throw new Error("Invalid axis");if(h[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseInternalActivationAttributes=c.getActivationSnippet=void 0;let m=y(7273),f=y(9087);c.getActivationSnippet=function(h){let p;switch(h.activation){case"Relu":p=(0,f.glslRelu)();break;case"Sigmoid":p=(0,f.glslSigmoid)();break;case"Clip":p=(0,f.glslClip)(h.clipMin,h.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let u=p.name;return{activationFunction:p.body,applyActivation:`value = ${u}_(value);`}},c.parseInternalActivationAttributes=h=>{let p=h.getString("activation","");if(p==="Clip"){let[u,s]=h.getFloats("activation_params",[m.MIN_CLIP,m.MAX_CLIP]);return{activation:p,clipMax:s,clipMin:u,activationCacheKey:`${p}:${u},${s}`}}return{activation:p,activationCacheKey:p}}},6149:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseGatherAttributes=c.gather=void 0;let m=y(4910),f=y(6145),h=y(7273),p=y(5639);c.gather=(o,n,e)=>(a(n,e.axis),[o.run(s(o,n,e),n)]),c.parseGatherAttributes=o=>(0,m.createAttributeWithCacheKey)({axis:o.attributes.getInt("axis",0)});let u={name:"Gather",inputNames:["A","B"],inputTypes:[p.TextureType.unpacked,p.TextureType.unpacked]},s=(o,n,e)=>{let t=Object.assign(Object.assign({},u),{cacheHint:e.cacheKey});return Object.assign(Object.assign({},t),{get:()=>((r,i,l,d)=>{let g=l[0].dims.slice(),b=l[1].dims.slice(),v=new Array(g.length+b.length-1);d=h.ShapeUtil.normalizeAxis(d,g.length);let w=[];for(let T=0;T<v.length;T++)T<d?(v[T]=g[T],w.push(`inputIdx[${T}] = outputIdx[${T}];`)):T<d+b.length?(v[T]=b[T-d],w.push(`indexDataIdx[${T-d}] = outputIdx[${T}];`)):(v[T]=g[T-b.length+1],w.push(`inputIdx[${T-b.length+1}] = outputIdx[${T}];`));let x=`
      float process(int outputIdx[${v.length||1}]) {
        int inputIdx[${g.length}];
        int indexDataIdx[${b.length||1}];
        indexDataIdx[0] = 0;
        ${w.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${d}] = idx < 0 ? idx + ${g[d]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},i),{output:{dims:v,type:l[0].type,textureType:p.TextureType.unpacked},shaderSource:x})})(0,t,n,e.axis)})},a=(o,n)=>{if(!o||o.length!==2)throw new Error("Gather requires 2 inputs.");let e=o[0].dims.length;if(e<1)throw new Error("Invalid input shape.");if(n<-e||n>e-1)throw new Error("Invalid axis.");if(f.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invaid input type.");if(o[1].type!=="int32"&&o[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseGemmAttributesV11=c.parseGemmAttributesV7=c.gemm=void 0;let m=y(4910),f=y(7273),h=y(5639);c.gemm=(o,n,e)=>(a(n,e),[o.run(u(n,e),n)]);let p=(o,n)=>{let e=o.attributes.getInt("transA",0)!==0,t=o.attributes.getInt("transB",0)!==0,r=o.attributes.getFloat("alpha",1),i=o.attributes.getFloat("beta",1);return(0,m.createAttributeWithCacheKey)({transA:e,transB:t,alpha:r,beta:i,isOptionalC:n})};c.parseGemmAttributesV7=o=>p(o,!1),c.parseGemmAttributesV11=o=>p(o,!0);let u=(o,n)=>{let e={name:"Gemm",inputNames:o.length===3?["A","B","C"]:["A","B"],inputTypes:o.length===3?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],key:n.cacheKey};return Object.assign(Object.assign({},e),{get:()=>s(e,o,n)})},s=(o,n,e)=>{let t=n[0].dims.slice(),r=n[1].dims.slice(),[i,l]=f.GemmUtil.getShapeOfGemmResult(t,e.transA,r,e.transB,n.length===3?n[2].dims:void 0),d=[i,l];if(!d)throw new Error("Can't use gemm on the given tensors");let g=t[t.length-1],b="";e.transA&&(g=t[0]),e.transA&&e.transB?b="value += _A_T(a) * _B_T(b);":e.transA&&!e.transB?b="value += _A_T(a) * _B(b);":!e.transA&&e.transB?b="value += _A(a) * _B_T(b);":e.transA||e.transB||(b="value += _A(a) * _B(b);");let v=d.length,w=`
      float process(int indices[${v}]) {
          int a[${v}];
          int b[${v}];
          ${n.length===3?`int c[${n[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${n.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${g}; ++k) {
              a[${v-1}] = k;
              b[${v-2}] = k;
              ${b}
          }

          value = value * alpha;
          ${n.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},o),{output:{dims:d,type:n[0].type,textureType:h.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:e.alpha},{name:"beta",type:"float",data:e.beta}],shaderSource:w})},a=(o,n)=>{if(!o)throw new Error("Input is missing");if(n.isOptionalC&&(o.length<2||o.length>3))throw new Error("Invaid input shape.");if(!n.isOptionalC&&o.length!==3)throw new Error("Gemm requires 3 inputs");if(o.length===3&&o[2].dims.length!==1&&o[2].dims.length!==2)throw new Error("Invalid input shape of C");if(o[0].type!=="float32"&&o[0].type!=="float64"||o[1].type!=="float32"&&o[1].type!=="float64"||o.length===3&&o[2].type!=="float32"&&o[2].type!=="float64")throw new Error("Invalid input type.");if(o[0].type!==o[1].type||o.length===3&&o[0].type!==o[2].type)throw new Error("Input types are mismatched")}},5950:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackedIm2ColProgramInfoLoader=void 0;let m=y(6757),f=y(5639),h=y(5614);c.createPackedIm2ColProgramInfoLoader=(p,u,s,a,o)=>{let n=(e=o.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[f.TextureType.packed],cacheHint:e});var e;return Object.assign(Object.assign({},n),{get:()=>((t,r,i,l,d,g)=>{let b=i.dims,v=l.dims,w=d.length,x=[v[1]*v[2]*v[3],d[2]*d[3]],T=v[2]*v[3],O=(0,h.unpackFromChannel)(),P=(0,m.getGlsl)(t.session.backend.glContext.version),I="";for(let j=0;j<=1;j++)for(let A=0;A<=1;A++)I+=`
            blockIndex = rc.x + ${A};
            pos = rc.y + ${j};

            if(blockIndex < ${x[1]} && pos < ${x[0]}) {
              offsetY = int(blockIndex / (${d[w-1]})) * ${g.strides[0]} -
                ${g.pads[0]};
              d0 = offsetY + ${g.dilations[0]} * (imod(pos, ${T}) / ${v[2]});

              if(d0 < ${b[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${d[w-1]}) * ${g.strides[1]} -
                  ${g.pads[1]};
                d1 = offsetX + ${g.dilations[1]} * imod(imod(pos, ${T}), ${v[2]});

                if(d1 < ${b[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${T}.);
                    innerDims = vec2(d0, d1);
                    result[${2*j+A}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let R=`
      ${O}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${I}
          ${P.output} = result;
      }
            `;return Object.assign(Object.assign({},r),{output:{dims:x,type:i.type,textureType:f.TextureType.packed},shaderSource:R,hasMain:!0})})(p,n,u,s,a,o)})}},1625:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.calculateIm2ColDims=c.createIm2ColProgramInfoLoader=void 0;let m=y(5639);c.createIm2ColProgramInfoLoader=(f,h,p,u,s)=>{let a=(o=s.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[m.TextureType.unpacked],cacheHint:o});var o;return Object.assign(Object.assign({},a),{get:()=>((n,e,t,r,i,l)=>{let d=t.dims,g=r.dims,b=i.length,v=(0,c.calculateIm2ColDims)(d,g,i,4),w=`
        const int XC = ${d[1]};
        const int XH = ${d[2]};
        const int XW = ${d[3]};
        const int KH = ${l.kernelShape[0]};
        const int KW = ${l.kernelShape[1]};
        const int dilationH = ${l.dilations[0]};
        const int dilationW = ${l.dilations[1]};
        const int strideH = ${l.strides[0]};
        const int strideW = ${l.strides[1]};
        const int padH = ${l.pads[0]};
        const int padW = ${l.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${b}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${d.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},e),{output:{dims:v,type:t.type,textureType:m.TextureType.packedLastDimension},shaderSource:w})})(0,a,h,p,u,s)})},c.calculateIm2ColDims=(f,h,p,u=4)=>[p[0],p[2],p[3],Math.ceil(f[1]*h[2]*h[3]/u)]},6981:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseImageScalerAttributes=c.imageScaler=void 0;let m=y(4910),f=y(5639);c.imageScaler=(a,o,n)=>(s(o),[a.run(p(a,o,n),o)]),c.parseImageScalerAttributes=a=>{let o=a.attributes.getFloat("scale"),n=a.attributes.getFloats("bias");return(0,m.createAttributeWithCacheKey)({scale:o,bias:n})};let h={name:"ImageScaler",inputNames:["X"],inputTypes:[f.TextureType.unpacked]},p=(a,o,n)=>{let e=Object.assign(Object.assign({},h),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},e),{get:()=>((t,r,i,l)=>{let d=i[0].dims.slice(),g=d.length,b=`
      ${u(l.bias.length)}
      float process(int indices[${g}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},r),{output:{dims:d,type:i[0].type,textureType:f.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:l.bias.length,data:l.bias},{name:"scale",type:"float",data:l.scale}],shaderSource:b})})(0,e,o,n)})},u=a=>{let o=[`float getBias(float bias[${a}], int channel) {`];for(let n=0;n<a;++n)n===0?o.push(`	if (channel == ${n}) { return bias[${n}]; }`):n===a-1?o.push(`	else { return bias[${n}]; }`):o.push(`	else if (channel == ${n}) { return bias[${n}]; }`);return o.push("	}"),o.join(`
`)},s=a=>{if(!a||a.length!==1)throw new Error("ImageScaler requires 1 input.");if(a[0].dims.length!==4)throw new Error("Invalid input shape.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseInstanceNormalizationAttributes=c.instanceNormalization=void 0;let m=y(6757),f=y(5639);c.instanceNormalization=(o,n,e)=>{a(n);let t=o.run(p(n[0]),n);return[o.run(s(o,n[0],e,t.dims),[n[0],t,n[1],n[2]])]},c.parseInstanceNormalizationAttributes=o=>o.attributes.getFloat("epsilon",1e-5);let h={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[f.TextureType.unpacked]},p=o=>Object.assign(Object.assign({},h),{get:()=>((n,e)=>{let t=e.dims.slice(),r=t[1],i=t[2]*t[3],l=[t[0],r],d=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${t[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${t[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i});
        temp = 0.0;
        for(int a2=0; a2<${t[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${t[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i});

        return v;
      }`;return Object.assign(Object.assign({},n),{output:{dims:l,type:e.type,textureType:f.TextureType.packedLastDimension},shaderSource:d})})(h,o)}),u={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[f.TextureType.unpacked,f.TextureType.packedLastDimension,f.TextureType.unpacked,f.TextureType.unpacked]},s=(o,n,e,t)=>{let r=Object.assign(Object.assign({},u),{cacheHint:`${e}`});return Object.assign(Object.assign({},r),{get:()=>((i,l,d,g,b)=>{let v=(0,m.getGlsl)(i.session.backend.glContext.version),[w,x]=i.calculateTextureWidthAndHeight(b,f.TextureType.packedLastDimension),[T,O]=[w/4,x],P=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${T}, ${O});
        return ${v.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},l),{output:{dims:d.dims,type:d.type,textureType:f.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:g}],shaderSource:P})})(o,r,n,e,t)})},a=o=>{if(!o||o.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let n=o[0],e=o[1],t=o[2];if(n.dims.length<3||e.dims.length!==1||t.dims.length!==1)throw new Error("Invalid input shape.");if(e.dims[0]!==n.dims[1]||t.dims[0]!==n.dims[1])throw new Error("Input shapes are mismatched.");if(n.type!=="float32"&&n.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||t.type!=="float32"&&t.type!=="float64")throw new Error("Invalid input type.");if(o[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createLrnProgramInfoLoader=c.parseLrnAttributes=c.lrn=void 0;let m=y(4910),f=y(5639);c.lrn=(s,a,o)=>(u(a),[s.run(p(a,o),a)]),c.parseLrnAttributes=s=>{let a=s.attributes.getFloat("alpha",1e-4),o=s.attributes.getFloat("beta",.75),n=s.attributes.getFloat("bias",1),e=s.attributes.getInt("size");return(0,m.createAttributeWithCacheKey)({alpha:a,beta:o,bias:n,size:e})};let h={name:"LRN",inputNames:["X"],inputTypes:[f.TextureType.unpacked]};function p(s,a){return Object.assign(Object.assign({},h),{cacheHint:a.cacheKey,get:()=>function(o,n){let e=o[0].dims[1],t=o[0].dims.length,r=-Math.floor((n.size-1)/2),i=Math.ceil((n.size-1)/2),l=`float(${n.alpha}) / float(${n.size})`,d=`
    float process(int indices[${t}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${r}; i <= ${i}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${e}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${n.bias}) + ${l} * square_sum, float(${n.beta}));
    }`;return Object.assign(Object.assign({},h),{cacheHint:n.cacheKey,output:{dims:o[0].dims,type:o[0].type,textureType:f.TextureType.unpacked},shaderSource:d})}(s,a)})}c.createLrnProgramInfoLoader=p;let u=s=>{if(!s||s.length!==1)throw new Error("LRN requires 1 input.");if(s[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(s[0].type!=="float32")throw new Error("input should be float type")}},5632:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackedMatmulProgramInfoLoader=void 0;let m=y(7273),f=y(6757),h=y(5639),p=y(432),u=y(2150),s=y(8276);c.createPackedMatmulProgramInfoLoader=(a,o,n)=>{let e=(t=o.length>2,r=n.activationCacheKey,{name:"MatMul (packed)",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[h.TextureType.packed,h.TextureType.packed,h.TextureType.packed]:[h.TextureType.packed,h.TextureType.packed],cacheHint:r});var t,r;return Object.assign(Object.assign({},e),{get:()=>((i,l,d,g)=>{let b=d.length>2,v=b?"value += getBiasForMatmul();":"",w=d[0].dims,x=d[1].dims,T=m.BroadcastUtil.calcShape(w,x,!0),O=!m.ShapeUtil.areEqual(d[0].dims,d[1].dims);if(!T)throw new Error("Can't use matmul on the given tensors");let P=w[w.length-1],I=Math.ceil(P/2),R=w.length,j=x.length,A=(0,f.getGlsl)(i.session.backend.glContext.version),C=(0,p.getCoordsDataType)(T.length),_=T.length,S=(0,p.getGlChannels)(),{activationFunction:E,applyActivation:z}=(0,u.getActivationSnippet)(g),L=b?`${(0,s.getBiasForMatmul)(C,S,d[2].dims,T,!0)}`:"",Y=O?`${function(se,pe,ge,ve){let Me=[],De=[],je=ge[0].dims,_e=ge[1].dims,Be=je.length,Pe=_e.length,Re=ve.length,Ue=Re-Be,He=Re-Pe;Me=je.map((tt,Ye)=>`coords.${pe[Ye+Ue]}`),Me[Be-1]="i*2",Me.join(", "),De=_e.map((tt,Ye)=>`coords.${pe[Ye+He]}`),De[Pe-2]="i*2",De.join(", ");let Ze=m.BroadcastUtil.getBroadcastDims(je,ve),et=m.BroadcastUtil.getBroadcastDims(_e,ve),ct=Ze.map(tt=>`coords.${pe[tt+Ue]} = 0;`).join(`
`),qe=et.map(tt=>`coords.${pe[tt+He]} = 0;`).join(`
`),Qe=`int lastDim = coords.${pe[Re-1]};
  coords.${pe[Re-1]} = coords.${pe[Re-2]};
  coords.${pe[Re-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${se} coords = getOutputCoords();
  ${Qe}
  ${ct}
  vec4 outputValue = getA(${Me});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${se} coords = getOutputCoords();
  ${Qe}
  ${qe}
  vec4 outputValue = getB(${De});
  return outputValue;
}`}(C,S,d,T)}`:"",X=O?"getAAtOutCoordsMatmul(i)":`getA(${function(se,pe){let ge="";for(let ve=0;ve<pe-2;ve++)ge+=`rc.${se[ve]}, `;return ge+=`rc.${se[pe-2]}, i*2`,ge}(S,R)})`,te=O?"getBAtOutCoordsMatmul(i)":`getB(${function(se,pe){let ge="";for(let ve=0;ve<pe-2;ve++)ge+=`rc.${se[ve]}, `;return ge+=`i*2, rc.${se[pe-1]}`,ge}(S,j)})`,ae=`
            ${Y}
            ${L}
            ${E}
            void main() {
              ${O?"":`${C} rc =
          getOutputCoords(); int lastDim = rc.${S[_-1]}; rc.${S[_-1]} =
          rc.${S[_-2]}; rc.${S[_-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${I}; i++) {
                vec4 a = ${X};
                vec4 b = ${te};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${v}
              ${z}
              ${A.output} = value;
            }`;return Object.assign(Object.assign({},l),{output:{dims:T,type:d[0].type,textureType:h.TextureType.packed},shaderSource:ae,hasMain:!0})})(a,e,o,n)})}},8276:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getBiasForMatmul=c.createMatmulProgramInfoLoader=c.parseMatMulAttributes=c.matMul=void 0;let m=y(7273),f=y(5639),h=y(432),p=y(2150),u=y(5632);c.matMul=(e,t,r)=>(o(t),e.session.pack?[e.run((0,u.createPackedMatmulProgramInfoLoader)(e,t,r),t)]:[e.run(a(t,r),t)]),c.parseMatMulAttributes=e=>(0,p.parseInternalActivationAttributes)(e.attributes);let s=(e,t)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked]:[f.TextureType.unpacked,f.TextureType.unpacked],cacheHint:t});function a(e,t){let r=s(e.length>2,t.activationCacheKey);return Object.assign(Object.assign({},r),{get:()=>function(i,l,d){let g=l[0].dims,b=l[1].dims,v=m.BroadcastUtil.calcShape(g,b,!0);if(!v)throw new Error("Can't use matmul on the given tensors");let w=(0,h.getCoordsDataType)(v.length),x=(0,h.getGlChannels)(),{activationFunction:T,applyActivation:O}=(0,p.getActivationSnippet)(d),P=l.length>2,I=P?"value += getBiasForMatmul();":"",R=P?`${n(w,x,l[2].dims,v,!1)}`:"",j=v.length,A=g.length,C=b.length,_=`
    ${T}
    ${R}
    float process(int indices[${j}]) {
        int a[${A}];
        int b[${C}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${g[g.length-1]}; ++k) {
            a[${A-1}] = k;
            b[${C-2}] = k;
            value += _A(a) * _B(b);
        }
        ${I}
        ${O}
        return value;
    }`;return Object.assign(Object.assign({},i),{output:{dims:v,type:l[0].type,textureType:f.TextureType.unpacked},shaderSource:_})}(r,e,t)})}c.createMatmulProgramInfoLoader=a;let o=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function n(e,t,r,i,l){let d="",g=r.length,b=i.length,v=b-g;d=b<2&&g>0?"coords":r.map((T,O)=>`coords.${t[O+v]}`).join(", ");let w=m.BroadcastUtil.getBroadcastDims(r,i).map(T=>`coords.${t[T+v]} = 0;`).join(`
`),x="vec4(outputValue.xx, outputValue.yy)";return m.ShapeUtil.size(r)===1&&(x="vec4(outputValue.x)"),l?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${w}
  vec4 outputValue = getBias(${d});
  return ${x};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${w}
  return getBias(coords.x);
}`}c.getBiasForMatmul=n},9:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackProgramInfoLoader=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614),u={name:"pack",inputNames:["A"],inputTypes:[f.TextureType.unpackedReversed]};c.createPackProgramInfoLoader=(s,a)=>Object.assign(Object.assign({},u),{get:()=>((o,n)=>{let e=(0,m.getGlsl)(o.session.backend.glContext.version),t=n.dims,r=t.length,i=n.dims.length,l=(0,h.getCoordsDataType)(i),d=(0,p.getChannels)("rc",i),g=(b=i,v=d,w=t[t.length-2],x=t[t.length-1],b===0||b===1?"":`
    int r = ${v[b-2]};
    int c = ${v[b-1]};
    int rp1 = ${v[b-2]} + 1;
    int cp1 = ${v[b-1]} + 1;
    bool rEdge = rp1 >= ${x};
    bool cEdge = cp1 >= ${w};
    `);var b,v,w,x;let T;T=r===0?[1,1]:r===1?[t[0],1]:[t[i-1],t[i-2]];let O=function(R,j,A){if(R===0)return"false";if(R===1)return`rc > ${j[0]}`;let C="";for(let _=R-2;_<R;_++)C+=`${A[_]} >= ${j[_-R+2]}`,_<R-1&&(C+="||");return C}(i,T,d),P=function(R,j){let A=R.length;if(A===0)return"getA(), 0, 0, 0";if(A===1)return`getA(rc),
            rc + 1 >= ${R[0]} ? 0. : getA(rc + 1),
            0, 0`;let C="";if(A>2)for(let _=0;_<A-2;++_)C+=`${j[_]},`;return`getA(${C}r, c),
          rEdge ? 0. : getA(${C}rp1, c),
          cEdge ? 0. : getA(${C}r, cp1),
          rEdge || cEdge ? 0. : getA(${C}rp1, cp1)`}(t,d),I=`
        void main() {
          ${l} rc = getOutputCoords();

          if(${O}) {
            ${e.output} = vec4(0);
          } else {
            ${g}

            ${e.output} = vec4(${P});
          }
        }
      `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:n.dims,type:n.type,textureType:f.TextureType.packed},shaderSource:I})})(s,a)})},5614:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.unpackFromChannel=c.getChannels=c.getVecChannels=void 0;let m=y(432);function f(h,p){return(0,m.getGlChannels)(p).map(u=>`${h}.${u}`)}c.getVecChannels=f,c.getChannels=function(h,p){return p===1?[h]:f(h,p)},c.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parsePadAttributesV11=c.padV11=c.parsePadAttributesV2=c.padV2=void 0;let m=y(4910),f=y(7273),h=y(6757),p=y(5639),u={name:"Pad",inputNames:["A"],inputTypes:[p.TextureType.unpacked]};c.padV2=(l,d,g)=>(o(d),[l.run(Object.assign(Object.assign({},u),{cacheHint:g.cacheKey,get:()=>a(l,d[0],g)}),d)]),c.parsePadAttributesV2=l=>{let d=l.attributes.getString("mode","constant"),g=l.attributes.getFloat("value",0),b=l.attributes.getInts("pads");return(0,m.createAttributeWithCacheKey)({mode:d,value:g,pads:b})},c.padV11=(l,d,g)=>{n(d);let b=s(l,d,g);return(0,c.padV2)(l,[d[0]],b)},c.parsePadAttributesV11=l=>l.attributes.getString("mode","constant");let s=(l,d,g)=>{if(!l.session.isInitializer(d[1].dataId)||d.length>=3&&!l.session.isInitializer(d[2].dataId))throw new Error("dynamic pad attributes are not allowed");let b=Array.from(d[1].integerData),v=d.length>=3?d[2].floatData[0]:0;return(0,m.createAttributeWithCacheKey)({mode:g,pads:b,value:v})},a=(l,d,g)=>{let b=f.ShapeUtil.padShape(d.dims.slice(),g.pads),v=b.length,w=`
      ${e(l,d,g)}
      float process(int[${v}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[p.TextureType.unpacked],output:{dims:b,type:d.type,textureType:p.TextureType.unpacked},shaderSource:w}},o=l=>{if(!l||l.length!==1)throw new Error("Pad requires 1 input");if(l[0].type!=="float32"&&l[0].type!=="float64")throw new Error("Invalid input type.")},n=l=>{if(!l||l.length!==2&&l.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(l[1].type!=="int32")throw new Error("Invalid input type.");if(l.length>=3&&l[2].type==="string")throw new Error("Invalid input type.")},e=(l,d,g)=>{let b=(0,h.getGlsl)(l.session.backend.glContext.version),[v,w]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),x=f.ShapeUtil.computeStrides(d.dims);switch(g.mode){case"constant":return t(b,d.dims,x,v,w,g.pads,g.value);case"reflect":return r(b,d.dims,x,v,w,g.pads);case"edge":return i(b,d.dims,x,v,w,g.pads);default:throw new Error("Invalid mode")}},t=(l,d,g,b,v,w,x)=>{let T=d.length,O="";for(let P=T-1;P>=0;--P)O+=`
        k = m[${P}] - ${w[P]};
        if (k < 0)  return constant;
        if (k >= ${d[P]}) return constant;
        offset += k * ${g[P]};
        `;return`
      float padA(int m[${T}]) {
        const float constant = float(${x});
        int offset = 0;
        int k = 0;
        ${O}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${l.texture2D}(A, coords));
        return value;
      }
      `},r=(l,d,g,b,v,w)=>{let x=d.length,T="";for(let O=x-1;O>=0;--O)T+=`
        k = m[${O}] - ${w[O]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(d[O]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${d[O]}) { k = _2n_1 - k; }
        }
        offset += k * ${g[O]};
        `;return`
      float padA(int m[${x}]) {
        int offset = 0;
        int k = 0;
        ${T}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${l.texture2D}(A, coords));
        return value;
      }
      `},i=(l,d,g,b,v,w)=>{let x=d.length,T="";for(let O=x-1;O>=0;--O)T+=`
        k = m[${O}] - ${w[O]};
        if (k < 0)  k = 0;
        if (k >= ${d[O]}) k = ${d[O]-1};
        offset += k * ${g[O]};
      `;return`
      float padA(int m[${x}]) {
        int offset = 0;
        int k = 0;
        ${T}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${l.texture2D}(A, coords));
        return value;
      }
      `}},2834:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.globalMaxPool=c.parseMaxPoolAttributes=c.maxPool=c.parseGlobalAveragePoolAttributes=c.globalAveragePool=c.parseAveragePoolAttributes=c.averagePool=void 0;let m=y(4910),f=y(7273),h=y(5639);c.averagePool=(i,l,d)=>{n(l);let g={name:"AveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:d.cacheKey};return[i.run(Object.assign(Object.assign({},g),{get:()=>p(l,g,!1,d)}),l)]},c.parseAveragePoolAttributes=i=>{let l=i.attributes.getString("auto_pad","NOTSET"),d=i.attributes.getInt("ceil_mode",0),g=i.attributes.getInt("count_include_pad",0)!==0,b=i.attributes.getInts("kernel_shape"),v=i.attributes.getInts("strides",[]),w=i.attributes.getInts("pads",[]);if(d!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,m.createAttributeWithCacheKey)({autoPad:l,ceilMode:d,countIncludePad:g,kernelShape:b,strides:v,pads:w})};let p=(i,l,d,g)=>{let[b,v]=s(i,g,d),w=f.ShapeUtil.size(b.kernelShape),x="";b.countIncludePad?x+=`value /= float(${w});`:x+=`value /= float(${w} - pad);`;let T=`
        ${e(i[0].dims,b,"value += _X(x);",x,"0.0")}
      `;return Object.assign(Object.assign({},l),{output:{dims:v,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:T})};c.globalAveragePool=(i,l,d)=>{n(l);let g={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:`${d.countIncludePad}`};return[i.run(Object.assign(Object.assign({},g),{get:()=>p(l,g,!0,d)}),l)]},c.parseGlobalAveragePoolAttributes=i=>{let l=i.attributes.getInt("count_include_pad",0)!==0;return(0,m.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:l,kernelShape:[],strides:[],pads:[]})},c.maxPool=(i,l,d)=>{n(l);let g={name:"MaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:d.cacheKey};return[i.run(Object.assign(Object.assign({},g),{get:()=>u(l,g,!1,d)}),l)]},c.parseMaxPoolAttributes=i=>{let l=i.attributes.getString("auto_pad","NOTSET"),d=i.attributes.getInt("ceil_mode",0),g=i.attributes.getInts("kernel_shape"),b=i.attributes.getInts("strides",[]),v=i.attributes.getInts("pads",[]),w=i.attributes.getInt("storage_order",0),x=i.attributes.getInts("dilations",[]);if(w!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,m.createAttributeWithCacheKey)({autoPad:l,ceilMode:d,countIncludePad:!1,kernelShape:g,strides:b,pads:v,storageOrder:w,dilations:x})};let u=(i,l,d,g)=>{let[b,v]=s(i,g,d),w=`
      ${e(i[0].dims,b,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},l),{output:{dims:v,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:w})},s=(i,l,d)=>{let g=i[0].dims.slice(),b=Object.hasOwnProperty.call(l,"dilations"),v=l.kernelShape.slice(),w=l.strides.slice(),x=b?l.dilations.slice():[],T=l.pads.slice();f.PoolConvUtil.adjustPoolAttributes(d,g,v,w,x,T);let O=f.PoolConvUtil.computePoolOutputShape(d,g,w,x,v,T,l.autoPad),P=Object.assign({},l);return b?Object.assign(P,{kernelShape:v,strides:w,pads:T,dilations:x,cacheKey:l.cacheKey}):Object.assign(P,{kernelShape:v,strides:w,pads:T,cacheKey:l.cacheKey}),[P,O]},a={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},o={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};c.globalMaxPool=(i,l)=>(n(l),[i.run(Object.assign(Object.assign({},o),{get:()=>u(l,o,!0,a)}),l)]);let n=i=>{if(!i||i.length!==1)throw new Error("Pool ops requires 1 input.");if(i[0].type!=="float32"&&i[0].type!=="float64")throw new Error("Invalid input type.")},e=(i,l,d,g,b)=>{let v=i.length;if(l.kernelShape.length<=2){let w=l.kernelShape[l.kernelShape.length-1],x=l.strides[l.strides.length-1],T=l.pads[l.pads.length/2-1],O=l.pads[l.pads.length-1],P=i[v-1],I="",R="",j="";if(I=T+O!==0?`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${x} - ${T} + i;
            if (x[${v} - 1] < 0 || x[${v} - 1] >= ${P}) {
              pad++;
              continue;
            }
            ${d}
          }`:`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${x} - ${T} + i;
            ${d}
          }`,l.kernelShape.length===2){let A=l.kernelShape[l.kernelShape.length-2],C=l.strides[l.strides.length-2],_=l.pads[l.pads.length/2-2],S=l.pads[l.pads.length-2],E=i[v-2];R=_+S!==0?`
            for (int j = 0; j < ${A}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${C} - ${_} + j;
              if (x[${v} - 2] < 0 || x[${v} - 2] >= ${E}) {
                pad+= ${w};
                continue;
              }
          `:`
            for (int j = 0; j < ${A}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${C} - ${_} + j;
            `,j=`
          }
        `}return`
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);

          float value = ${b};
          int pad = 0;
          ${R}
          ${I}
          ${j}
          ${g}
          return value;
        }
      `}{let w=f.ShapeUtil.size(l.kernelShape),x=f.ShapeUtil.computeStrides(l.kernelShape),T=x.length,O=l.pads.length,P=r(T),I=t(i,"inputDims"),R=t(l.pads,"pads"),j=t(x,"kernelStrides"),A=t(l.strides,"strides"),C="";return C=l.pads.reduce((_,S)=>_+S)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${d}
          }`:`
          }
          ${d}
        `,`
        ${P}
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);
          int offset[${T}];
          int pads[${O}];
          int inputDims[${v}];
          int kernelStrides[${T}];
          int strides[${T}];
          ${R}
          ${I}
          ${A}
          ${j}

          float value = ${b};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${w}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${v} - ${T}; j < ${v}; j++) {
              x[j] = indices[j] * strides[j - ${v} + ${T}]
                + offset[j - ${v} + ${T}] - pads[j - 2];
              ${C}
          }
          ${g}

          return value;
        }
      `}},t=(i,l)=>{let d="";for(let g=0;g<i.length;g++)d+=`
      ${l}[${g}] = ${i[g]};
    `;return d},r=i=>`
  void offsetToIndices(int offset, int[${i}] strides, out int[${i}] indices) {
    if (${i} == 0) {
      return;
    }
    for (int i = 0; i < ${i} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${i} - 1] = offset;
  }`},1010:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.reduceLogSumSquare=c.reduceLogSum=c.reduceProd=c.reduceMin=c.reduceMax=c.reduceMean=c.reduceSum=c.parseReduceAttributes=void 0;let m=y(4910),f=y(6145),h=y(7273),p=y(5639),u=(o,n,e,t,r)=>{a(n);let i={name:t,inputNames:["A"],inputTypes:[p.TextureType.unpacked]};return[o.run(Object.assign(Object.assign({},i),{cacheHint:e.cacheKey,get:()=>s(o,n,e,t,r,i)}),n)]};c.parseReduceAttributes=o=>{let n=o.attributes.getInts("axes",[]),e=o.attributes.getInt("keepdims",1)===1;return(0,m.createAttributeWithCacheKey)({axes:n,keepDims:e})};let s=(o,n,e,t,r,i)=>{let l=[],d=n[0].dims.length||1,g=[],b=h.ShapeUtil.normalizeAxes(e.axes,n[0].dims.length),v=r(n,b),w=v[1];for(let T=0;T<n[0].dims.length;T++)b.indexOf(T)>=0||b.length===0?(e.keepDims&&l.push(1),w=`
          for(int j${T} = 0; j${T} < ${n[0].dims[T]}; j${T}++) {
            inputIdx[${T}] = j${T};
            ${w}
          }`):(g.push(`inputIdx[${T}] = outputIdx[${l.length}];`),l.push(n[0].dims[T]));let x=`
      float process(int outputIdx[${l.length||1}]) {
        float value;                 // final result
        int inputIdx[${d}];      // addressing input data
        ${g.join(`
`)}
        ${v[0]}       // init ops for reduce max/min
        ${w}
        ${v[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},i),{output:{dims:l,type:n[0].type,textureType:p.TextureType.unpacked},shaderSource:x})},a=o=>{if(!o||o.length!==1)throw new Error("Reduce op requires 1 input.");if(f.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invalid input type.")};c.reduceSum=(o,n,e)=>u(o,n,e,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),c.reduceMean=(o,n,e)=>u(o,n,e,"ReduceMean",(t,r)=>{let i=1;for(let l=0;l<t[0].dims.length;l++)(r.indexOf(l)>=0||r.length===0)&&(i*=t[0].dims[l]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${i}.;`]}),c.reduceMax=(o,n,e)=>u(o,n,e,"ReduceMax",(t,r)=>{let i=[];for(let l=0;l<t[0].dims.length;l++)(r.indexOf(l)>=0||r.length===0)&&i.push(`inputIdx[${l}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),c.reduceMin=(o,n,e)=>u(o,n,e,"ReduceMin",(t,r)=>{let i=[];for(let l=0;l<t[0].dims.length;l++)(r.indexOf(l)>=0||r.length===0)&&i.push(`inputIdx[${l}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),c.reduceProd=(o,n,e)=>u(o,n,e,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),c.reduceLogSum=(o,n,e)=>u(o,n,e,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),c.reduceLogSumSquare=(o,n,e)=>u(o,n,e,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.isReshapeCheap=c.processDims3D=c.createPackedReshape3DProgramInfoLoader=void 0;let m=y(7273),f=y(6757),h=y(5639),p=y(5614);c.createPackedReshape3DProgramInfoLoader=(u,s,a)=>{let o=(n=>({name:"Reshape (packed)",inputTypes:[h.TextureType.packed],inputNames:["A"],cacheHint:`${n}`}))(a);return Object.assign(Object.assign({},o),{get:()=>((n,e,t,r)=>{let i=e.dims,l=r,d="";for(let v=0;v<4;v++){let w="";switch(v){case 0:w="outputCoords = rc;";break;case 1:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:w="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}d+=`
        ${w}
        ${v>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${v}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${v>0?"}":""}
      `}let g=(0,f.getGlsl)(n.session.backend.glContext.version),b=`
      ${function(v){let w=m.ShapeUtil.computeStrides(v),x=["b","r","c"],T="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${w.map((O,P)=>`int ${x[P]} = ${T} / ${O}; ${P===w.length-1?`int ${x[P+1]} = ${T} - ${x[P]} * ${O}`:`index -= ${x[P]} * ${O}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(i)}
      ${function(v){let w=m.ShapeUtil.computeStrides(v);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${w[0]} + coords.z * ${w[1]} + coords.y;
  }
`}(l)}
      ${(0,p.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${l[2]};
        int cols = ${l[1]};

        ${d}
        ${g.output} = result;
      }
    `;return Object.assign(Object.assign({},t),{output:{dims:l,type:e.type,textureType:h.TextureType.packed},shaderSource:b,hasMain:!0})})(u,s,o,a)})},c.processDims3D=function(u){if(u.length===0)return[1,1,1];let s=1;for(let a=0;a<u.length-2;++a)s*=u[a];return[s,u.length>1?u[u.length-2]:1,u[u.length-1]]},c.isReshapeCheap=function(u,s){let a=!1;return a=u.length===0||s.length===0||(u.length<2||s.length<2?u[u.length-1]===s[s.length-1]:u[u.length-1]===s[s.length-1]&&u[u.length-2]===s[s.length-2]),a}},8126:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.reshape=void 0;let m=y(7273);c.reshape=(f,h)=>{let p=m.ShapeUtil.calculateReshapedDims(h[0].dims,h[1].integerData);return f.session.pack?[f.reshapePacked(h[0],p)]:[f.reshapeUnpacked(h[0],p)]}},2801:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseResizeAttributesV11=c.parseResizeAttributesV10=c.resize=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614),u=y(3980),s={name:"Resize",inputNames:["A"],inputTypes:[f.TextureType.packed]};c.resize=(t,r,i)=>((0,u.validateInputs)(r,i),[t.run(Object.assign(Object.assign({},s),{cacheHint:i.cacheKey,get:()=>a(t,r,i)}),r)]),c.parseResizeAttributesV10=t=>(0,u.parseUpsampleAttributes)(t,10),c.parseResizeAttributesV11=t=>(0,u.parseUpsampleAttributes)(t,11);let a=(t,r,i)=>{let l=(0,m.getGlsl)(t.session.backend.glContext.version),[d,g]=o(r,i);if(d.every(C=>C===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},s),{output:{dims:g,type:r[0].type,textureType:f.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${l.texture2D}(X, TexCoords);
                    ${l.output} = v;
                }`});let b=g.length;if(b<2)throw new Error(`output dimension should be at least 2, but got ${b}`);let v=g[b-2],w=g[b-1],x=r[0].dims;if(b!==x.length)throw new Error(`output dimension should match input ${x.length}, but got ${b}`);let T=x[b-2],O=x[b-1],P=d[b-2],I=d[b-1],R="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${w}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${w}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${w}.0 - 1.0, ${v}.0 - 1.0, ${w}.0 - 1.0,
                            ${v}.0 - 1.0);
                        vec4 original = vec4(${O}.0 - 1.0, ${T}.0 - 1.0, ${O}.0 - 1.0,
                            ${T}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let j=(0,h.getCoordsDataType)(b),A=`
            const vec2 inputWH = vec2(${T}.0, ${O}.0);
            const vec4 scaleWHWH = vec4(float(${P}), float(${I}), float(${P}), float(${I}));
            ${(0,p.unpackFromChannel)()}
            ${R}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${j} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${v-1};
                bool hasNextCol = rc.z < ${w-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${l.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},s),{output:{dims:g,type:r[0].type,textureType:f.TextureType.packed},hasMain:!0,shaderSource:A})},o=(t,r)=>{let i=t[0].dims,l,d=r.scales;if(d.length===0){let b=t[r.scalesInputIdx];if(b&&b.size!==0){if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");d=n(b,r.mode,r.isResize)}else{let v=t[r.sizesInputIdx];if(!v||v.size===0)throw new Error("Either scales or sizes MUST be provided as input.");l=Array.from(v.integerData),d=e(l,i,r.mode,r.isResize)}}else if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let g=l||i.map((b,v)=>Math.floor(b*d[v]));return[d,g]},n=(t,r,i)=>{let l=Array.from(t.floatData);return(0,u.scalesValidation)(l,r,i),l},e=(t,r,i,l)=>{let d=r.length,g=new Array(d);for(let b=0,v=d;b<v;b++)if(r[b]===0){if(t[b]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");g[b]=1}else g[b]=t[b]/r[b];return(0,u.scalesValidation)(g,i,l),g}},565:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.shape=void 0;let m=y(9240);c.shape=(h,p)=>(f(p),[new m.Tensor([p[0].dims.length],"int32",void 0,void 0,new Int32Array(p[0].dims))]);let f=h=>{if(!h||h.length!==1)throw new Error("Shape requires 1 input.")}},2444:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.sliceV10=c.parseSliceAttributes=c.slice=void 0;let m=y(4910),f=y(6145),h=y(7273),p=y(5639),u={name:"Slice",inputNames:["A"],inputTypes:[p.TextureType.unpacked]};c.slice=(e,t,r)=>(a(t),[e.run(Object.assign(Object.assign({},u),{cacheHint:r.cacheKey,get:()=>s(e,t[0],r)}),t)]),c.parseSliceAttributes=e=>{let t=e.attributes.getInts("starts"),r=e.attributes.getInts("ends"),i=e.attributes.getInts("axes",[]);return(0,m.createAttributeWithCacheKey)({starts:t,ends:r,axes:i})};let s=(e,t,r)=>{let i=r.axes.length===0?t.dims.slice(0).map((x,T)=>T):r.axes,l=h.ShapeUtil.normalizeAxes(i,t.dims.length),d=r.starts.map((x,T)=>x>t.dims[l[T]]-1?t.dims[l[T]]:h.ShapeUtil.normalizeAxis(x,t.dims[l[T]])),g=r.ends.map((x,T)=>x>t.dims[l[T]]-1?t.dims[l[T]]:h.ShapeUtil.normalizeAxis(x,t.dims[l[T]])),b=t.dims.slice(),v=[];for(let x=0;x<l.length;x++)b[l[x]]=g[x]-d[x],d[x]>0&&v.push(`outputIdx[${l[x]}] += ${d[x]};`);let w=`
      float process(int outputIdx[${b.length}]) {
        ${v.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},u),{output:{dims:b,type:t.type,textureType:p.TextureType.unpacked},shaderSource:w})},a=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(f.NUMBER_TYPES.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")};c.sliceV10=(e,t)=>{n(t);let r=o(e,t);return[e.run(Object.assign(Object.assign({},u),{cacheHint:r.cacheKey,get:()=>s(e,t[0],r)}),[t[0]])]};let o=(e,t)=>{if(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)||t.length>=4&&!e.session.isInitializer(t[3].dataId)||t.length>=5&&!e.session.isInitializer(t[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(t.length>=5&&t[4].integerData.some(d=>d!==1))throw new Error("currently non-1 steps is not supported for Slice");let r=Array.from(t[1].integerData),i=Array.from(t[2].integerData),l=t.length>=4?Array.from(t[3].integerData):[];return{starts:r,ends:i,axes:l,cacheKey:`${l};${r};${i}`}},n=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.softmaxV13=c.parseSoftmaxAttributesV13=c.parseSoftmaxAttributes=c.softmax=void 0;let m=y(4910),f=y(7273),h=y(6757),p=y(5639),u=y(5707),s={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[p.TextureType.unpacked]},a={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[p.TextureType.unpacked,p.TextureType.unpacked]},o={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[p.TextureType.unpacked,p.TextureType.unpacked,p.TextureType.unpacked]};c.softmax=(l,d,g)=>{i(d);let b=d[0].dims.slice(),v=f.ShapeUtil.normalizeAxis(g.axis,b.length),w=f.ShapeUtil.sizeToDimension(b,v),x=f.ShapeUtil.sizeFromDimension(b,v);return n(l,d,g,w,x)},c.parseSoftmaxAttributes=l=>(0,m.createAttributeWithCacheKey)({axis:l.attributes.getInt("axis",1)}),c.parseSoftmaxAttributesV13=l=>(0,m.createAttributeWithCacheKey)({axis:l.attributes.getInt("axis",-1)}),c.softmaxV13=(l,d,g)=>{i(d);let b=d[0].dims.slice(),v=f.ShapeUtil.normalizeAxis(g.axis,b.length),w=b.length,x=v!==w-1,T=[],O,P=[],I=[];x&&(P=Array.from({length:w}).map((C,_)=>_),P[v]=w-1,P[w-1]=v,P.map(C=>T.push(b[C])),O=(0,m.createAttributeWithCacheKey)({perm:P}),I=(0,u.transpose)(l,d,O));let R=x?f.ShapeUtil.sizeToDimension(T,w-1):f.ShapeUtil.sizeToDimension(b,w-1),j=x?f.ShapeUtil.sizeFromDimension(T,w-1):f.ShapeUtil.sizeFromDimension(b,w-1),A=n(l,x?I:d,g,R,j);return x?(0,u.transpose)(l,A,O):A};let n=(l,d,g,b,v)=>{let w=e(l,d[0],b,v,[b]),x=l.run(Object.assign(Object.assign({},s),{cacheHint:g.cacheKey,get:()=>w}),d),T=t(l,d[0],b,v,w.output.dims,[b]),O=l.run(Object.assign(Object.assign({},a),{cacheHint:g.cacheKey,get:()=>T}),[d[0],x]),P=r(l,d[0],b,v,w.output.dims,T.output.dims);return[l.run(Object.assign(Object.assign({},o),{cacheHint:g.cacheKey,get:()=>P}),[d[0],x,O])]},e=(l,d,g,b,v)=>{let[w,x]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),T=v.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1)throw new Error("Dimensionality of the output should be 1");if(v[0]!==g)throw new Error("Shape of the output should be equal to logical row count");let O=(0,h.getGlsl)(l.session.backend.glContext.version),P=`
      float process(int[${T}] indices) {
        int logical_row_start_offset = indices[0] * ${b};

        float max = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset, ${w},
        ${x} )));
        for(int i=1; i<${b}; ++i)
        {
          float current = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${w}, ${x})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},s),{output:{dims:v,type:d.type,textureType:p.TextureType.unpacked},shaderSource:P})},t=(l,d,g,b,v,w)=>{let[x,T]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),O=w.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(w.length!==1)throw new Error("Dimensionality of the output should be 1");if(w[0]!==g)throw new Error("Shape of the output should be equal to logical row count");if(v.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");let P=`
      float process(int[${O}] indices) {
        int logical_row_start_offset = indices[0] * ${b};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${b}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,h.getGlsl)(l.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${x}, ${T}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},a),{output:{dims:w,type:d.type,textureType:p.TextureType.unpacked},shaderSource:P})},r=(l,d,g,b,v,w)=>{let[x,T]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),O=d.dims.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1||w.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g||w[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");let P=`
      float process(int[${O}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${x}, ${T});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${b};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},o),{output:{dims:d.dims,type:d.type,textureType:p.TextureType.unpacked},shaderSource:P})},i=l=>{if(!l||l.length!==1)throw new Error("Softmax requires 1 input.");if(l[0].type!=="float32"&&l[0].type!=="float64")throw new Error("Invalid input type")}},564:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSplitAttributes=c.split=void 0;let m=y(4910),f=y(7273),h=y(5639),p={name:"Split",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};c.split=(o,n,e)=>{a(n);let t=f.ShapeUtil.normalizeAxis(e.axis,n[0].dims.length),r=u(o,n,t,e),i=[];for(let l=0;l<r;++l)i.push(o.run(Object.assign(Object.assign({},p),{cacheHint:`${e.cacheKey};${l}`,get:()=>s(o,n[0],e,t,l)}),n));return i},c.parseSplitAttributes=o=>{let n=o.attributes.getInt("axis",0),e=o.attributes.getInts("split",[]),t=o.outputs.length;return(0,m.createAttributeWithCacheKey)({axis:n,split:e,numOutputs:t})};let u=(o,n,e,t)=>{let[,r]=f.SplitUtil.splitShape(n[0].dims,e,t.split,t.numOutputs);return r.length},s=(o,n,e,t,r)=>{let[i,l]=f.SplitUtil.splitShape(n.dims,t,e.split,e.numOutputs),d=l[r],g=i[r],b=`
      float process(int indices[${g.length}]) {
        indices[${t}] += ${d};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},p),{cacheHint:`${e.cacheKey}:${r}`,output:{dims:g,type:n.type,textureType:h.TextureType.unpacked},shaderSource:b})},a=o=>{if(!o||o.length!==1)throw new Error("Split requires one input.");if(o[0].type!=="int8"&&o[0].type!=="uint8"&&o[0].type!=="int16"&&o[0].type!=="uint16"&&o[0].type!=="int32"&&o[0].type!=="uint32"&&o[0].type!=="float32"&&o[0].type!=="float64"&&o[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSqueezeAttributes=c.squeezeV13=c.squeeze=void 0;let m=y(7273);c.squeeze=(p,u,s)=>{f(u);let a=m.ShapeUtil.squeezeShape(u[0].dims,s);return[p.reshapeUnpacked(u[0],a)]},c.squeezeV13=(p,u)=>(h(u),(0,c.squeeze)(p,[u[0]],Array.from(u[1].integerData))),c.parseSqueezeAttributes=p=>p.attributes.getInts("axes");let f=p=>{if(!p||p.length!==1)throw new Error("Squeeze requires 1 input.");if(p[0].type==="string")throw new Error("invalid input tensor types.")},h=p=>{if(!p||p.length!==2)throw new Error("Squeeze requires 2 inputs.");if(p[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.sum=void 0;let m=y(6757),f=y(5639);c.sum=(u,s)=>{p(s);let a={name:"Sum",inputNames:s.map((o,n)=>`X${n}`),inputTypes:new Array(s.length).fill(f.TextureType.unpacked)};return[u.run(Object.assign(Object.assign({},a),{get:()=>h(u,s,a)}),s)]};let h=(u,s,a)=>{let o=(0,m.getGlsl)(u.session.backend.glContext.version),n=s[0].dims.slice(),e=`
      void main() {
        vec4 result = ${s.map((t,r)=>`${o.texture2D}(X${r},TexCoords)`).join(" + ")};
        ${o.output} = result;
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:n,type:s[0].type,textureType:f.TextureType.unpacked},hasMain:!0,shaderSource:e})},p=u=>{if(!u||u.length===0)throw new Error("Sum requires inputs.");let s=u[0].dims.length;for(let a=1;a<u.length;a++){if(s!==u[a].dims.length)throw new Error("Input shapes are mismatched.");for(let o=0;o<s;o++)if(u[0].dims[o]!==u[a].dims[o])throw new Error("Input shapes are not matched.")}if(u[0].type!=="float32"&&u[0].type!=="float64")throw new Error("Invalid input type.");for(let a=1;a<u.length;a++)if(u[0].type!==u[a].type)throw new Error("Input types are not matched.")}},5944:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tile=void 0;let m=y(6145),f=y(5639);c.tile=(u,s)=>{p(s);let a={name:"Tile",inputNames:["A"],inputTypes:[f.TextureType.unpacked]};return[u.run(Object.assign(Object.assign({},a),{get:()=>h(u,s,a)}),s)]};let h=(u,s,a)=>{let o=s[0].dims.slice(),n=new Array(o.length),e=[];for(let i=0;i<o.length;i++)n[i]=o[i]*s[1].numberData[i],e.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${o[i]}.));`);let t=n.length,r=`
      float process(int outputIdx[${t}]) {
        int inputIdx[${t}];
        ${e.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:n,type:s[0].type,textureType:f.TextureType.unpacked},shaderSource:r})},p=u=>{if(!u||u.length!==2)throw new Error("Tile requires 2 input.");if(u[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(u[1].dims[0]!==u[0].dims.length)throw new Error("Invalid input shape.");if(m.NUMBER_TYPES.indexOf(u[0].type)===-1)throw new Error("Invalid input type.");if(u[1].type!=="int32"&&u[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseTransposeAttributes=c.transpose=void 0;let m=y(4910),f=y(7273),h=y(5639),p={name:"Transpose",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};c.transpose=(e,t,r)=>(n(t),[e.run(Object.assign(Object.assign({},p),{cacheHint:r.cacheKey,get:()=>u(e,t[0],r.perm)}),t)]),c.parseTransposeAttributes=e=>(0,m.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});let u=(e,t,r)=>{let i=t.dims;r=s(i,r);let l=a(i,r),d=i.length,g=`
      ${o("perm",r,d)}
      float process(int indices[${d}]) {
        int a[${d}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},p),{output:{dims:l,type:t.type,textureType:h.TextureType.unpacked},shaderSource:g})},s=(e,t)=>(t&&t.length!==e.length&&(t=[...e.keys()].reverse()),t),a=(e,t)=>(t=s(e,t),f.ShapeUtil.sortBasedOnPerm(e,t)),o=(e,t,r)=>{let i=[];i.push(`void ${e}(out int a[${r}], int src[${r}]) {`);for(let l=0;l<r;++l)i.push(`	a[${t[l]}]=src[${l}];`);return i.push("	}"),i.join(`
`)},n=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.encodeAsUint8=void 0;let m=y(6757),f=y(5639);c.encodeAsUint8=(h,p)=>{let u=p.shape,s=(0,m.getGlsl)(h.session.backend.glContext.version),a=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${s.texture2D}(X,TexCoords).r;
      ${s.output} = encodeAsUint8(value);
    }`,o={name:"Uint8Encode",inputTypes:[f.TextureType.unpacked],inputNames:["X"],output:{dims:u,type:p.tensor.type,textureType:f.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return h.executeProgram(o,[p.tensor])}},9087:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tanh=c.tan=c.sqrt=c.sin=c.sigmoid=c.relu=c.not=c.neg=c.log=c.parseLeakyReluAttributes=c.leakyRelu=c.identity=c.floor=c.exp=c.parseEluAttributes=c.elu=c.cos=c.ceil=c.clipV11=c.parseClipAttributes=c.clip=c.atan=c.asin=c.acos=c.abs=c.glslTanh=c.glslTan=c.glslSqrt=c.glslSigmoid=c.glslRelu=c.glslSin=c.glslNot=c.glslNeg=c.glslLog=c.glslLeakyRelu=c.glslIdentity=c.glslClip=c.glslFloor=c.glslExp=c.glslElu=c.glslCos=c.glslCeil=c.glslAtan=c.glslAsin=c.glslAcos=c.glslAbs=void 0;let m=y(4910),f=y(7273),h=y(1997),p=y(6757),u=y(5639);function s(){return A("abs")}function a(){return A("acos")}function o(){return A("asin")}function n(){return A("atan")}function e(){return A("ceil")}function t(){return A("cos")}function r(S){let E="elu";return{body:`
  const float alpha = float(${S});

  float ${E}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${E}_(vec4 v) {
    return vec4(${E}_(v.x), ${E}_(v.y), ${E}_(v.z), ${E}_(v.w));
  }
  `,name:E,type:h.FunctionType.ValueBased}}function i(){return A("exp")}function l(){return A("floor")}function d(S,E){let z="clip";return{body:`
  const float min = float(${S});
  const float max = float(${E});

  float ${z}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${z}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:z,type:h.FunctionType.ValueBased}}function g(){let S="indentity";return{body:`
  float ${S}_(float a) {
    return a;
  }
  vec4 ${S}_(vec4 v) {
    return v;
  }
  `,name:S,type:h.FunctionType.ValueBased}}function b(S){let E="leakyRelu";return{body:`
  const float alpha = float(${S});

  float ${E}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${E}_(vec4 v) {
    return vec4(${E}_(v.x), ${E}_(v.y), ${E}_(v.z), ${E}_(v.w));
  }
  `,name:E,type:h.FunctionType.ValueBased}}function v(){return A("log")}function w(){let S="neg";return{body:`
  float ${S}_(float a) {
    return -a;
  }
  vec4 ${S}_(vec4 v) {
    return -v;
  }
  `,name:S,type:h.FunctionType.ValueBased}}function x(){let S="not";return{body:`
  float ${S}_(float a) {
    return float( ! bool(a) );
  }
  bool ${S}_(bool a) {
    return !a;
  }
  vec4 ${S}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${S}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:S,type:h.FunctionType.ValueBased}}function T(){return A("sin")}function O(){let S="relu";return{body:`
  float ${S}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${S}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:S,type:h.FunctionType.ValueBased}}function P(){let S="sigmoid";return{body:`
  float ${S}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${S}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:S,type:h.FunctionType.ValueBased}}function I(){return A("sqrt")}function R(){return A("tan")}function j(){let S="tanh";return{body:`
  float ${S}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${S}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:S,type:h.FunctionType.ValueBased}}function A(S){return{body:`
  float ${S}_(float a) {
    return ${S}(a);
  }
  vec4 ${S}_(vec4 v) {
    return ${S}(v);
  }
  `,name:S,type:h.FunctionType.ValueBased}}c.glslAbs=s,c.glslAcos=a,c.glslAsin=o,c.glslAtan=n,c.glslCeil=e,c.glslCos=t,c.glslElu=r,c.glslExp=i,c.glslFloor=l,c.glslClip=d,c.glslIdentity=g,c.glslLeakyRelu=b,c.glslLog=v,c.glslNeg=w,c.glslNot=x,c.glslSin=T,c.glslRelu=O,c.glslSigmoid=P,c.glslSqrt=I,c.glslTan=R,c.glslTanh=j;let C=(S,E,z,L)=>{let Y=S.session.pack?u.TextureType.packed:u.TextureType.unpacked,X={name:z.name,inputTypes:[Y],inputNames:["A"],cacheHint:L};return Object.assign(Object.assign({},X),{get:()=>((te,ae,se,pe)=>{let ge=te.session.pack?u.TextureType.packed:u.TextureType.unpacked,ve=(0,p.getGlsl)(te.session.backend.glContext.version);return Object.assign(Object.assign({},ae),{output:{dims:se.dims,type:se.type,textureType:ge},shaderSource:`
     ${pe.body}
     void main() {
       vec4 v = ${ve.texture2D}(A, TexCoords);
       v = ${pe.name}_(v);
       ${ve.output} = v;
     }
     `,hasMain:!0})})(S,X,E,z)})};c.abs=(S,E)=>[S.run(C(S,E[0],s()),E)],c.acos=(S,E)=>[S.run(C(S,E[0],a()),E)],c.asin=(S,E)=>[S.run(C(S,E[0],o()),E)],c.atan=(S,E)=>[S.run(C(S,E[0],n()),E)],c.clip=(S,E,z)=>[S.run(C(S,E[0],d(z.min,z.max),z.cacheKey),E)],c.parseClipAttributes=S=>(0,m.createAttributeWithCacheKey)({min:S.attributes.getFloat("min",f.MIN_CLIP),max:S.attributes.getFloat("max",f.MAX_CLIP)}),c.clipV11=(S,E)=>{let z=_(S,E);return(0,c.clip)(S,[E[0]],z)};let _=(S,E)=>{if(E.length>=3&&(!S.session.isInitializer(E[1].dataId)||!S.session.isInitializer(E[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let z=E.length>=3?E[1].numberData[0]:f.MIN_CLIP,L=E.length>=3?E[2].numberData[0]:f.MAX_CLIP;return(0,m.createAttributeWithCacheKey)({min:z,max:L})};c.ceil=(S,E)=>[S.run(C(S,E[0],e()),E)],c.cos=(S,E)=>[S.run(C(S,E[0],t()),E)],c.elu=(S,E,z)=>[S.run(C(S,E[0],r(z.alpha),z.cacheKey),E)],c.parseEluAttributes=S=>(0,m.createAttributeWithCacheKey)({alpha:S.attributes.getFloat("alpha",1)}),c.exp=(S,E)=>[S.run(C(S,E[0],i()),E)],c.floor=(S,E)=>[S.run(C(S,E[0],l()),E)],c.identity=(S,E)=>[S.run(C(S,E[0],g()),E)],c.leakyRelu=(S,E,z)=>[S.run(C(S,E[0],b(z.alpha),z.cacheKey),E)],c.parseLeakyReluAttributes=S=>(0,m.createAttributeWithCacheKey)({alpha:S.attributes.getFloat("alpha",.01)}),c.log=(S,E)=>[S.run(C(S,E[0],v()),E)],c.neg=(S,E)=>[S.run(C(S,E[0],w()),E)],c.not=(S,E)=>[S.run(C(S,E[0],x()),E)],c.relu=(S,E)=>[S.run(C(S,E[0],O()),E)],c.sigmoid=(S,E)=>[S.run(C(S,E[0],P()),E)],c.sin=(S,E)=>[S.run(C(S,E[0],T()),E)],c.sqrt=(S,E)=>[S.run(C(S,E[0],I()),E)],c.tan=(S,E)=>[S.run(C(S,E[0],R()),E)],c.tanh=(S,E)=>[S.run(C(S,E[0],j()),E)]},540:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createUnpackProgramInfoLoader=c.createUnpackProgramInfo=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614),u={name:"unpack",inputNames:["A"],inputTypes:[f.TextureType.packed]};c.createUnpackProgramInfo=(s,a)=>{let o=a.dims.length,n=(0,p.getChannels)("rc",o),e=n.slice(-2),t=(0,h.getCoordsDataType)(o),r=(0,p.unpackFromChannel)(),i=a.dims.length===0?"":function(g,b){if(g===1)return"rc";let v="";for(let w=0;w<g;w++)v+=b[w],w<g-1&&(v+=",");return v}(o,n),l=o<=1?"rc":`vec2(${e.join(",")})`,d=`
    ${r}
    void main() {
      ${t} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${i});

       ${(0,m.getGlsl)(s.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:a.dims,type:a.type,textureType:f.TextureType.unpacked},shaderSource:d})},c.createUnpackProgramInfoLoader=(s,a)=>Object.assign(Object.assign({},u),{get:()=>(0,c.createUnpackProgramInfo)(s,a)})},7862:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseUnsqueezeAttributes=c.unsqueezeV13=c.unsqueeze=void 0;let m=y(7273);c.unsqueeze=(p,u,s)=>{f(u);let a=m.ShapeUtil.unsqueezeShape(u[0].dims,s);return[p.reshapeUnpacked(u[0],a)]},c.unsqueezeV13=(p,u)=>(h(u),(0,c.unsqueeze)(p,[u[0]],Array.from(u[1].integerData))),c.parseUnsqueezeAttributes=p=>p.attributes.getInts("axes");let f=p=>{if(!p||p.length!==1)throw new Error("Unsqueeze requires 1 input.");if(p[0].type==="string")throw new Error("invalid input tensor types.")},h=p=>{if(!p||p.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(p[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.scalesValidation=c.validateInputs=c.parseUpsampleAttributes=c.parseUpsampleAttributesV9=c.parseUpsampleAttributesV7=c.upsample=void 0;let m=y(4910),f=y(6757),h=y(5639),p={name:"Upsample",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};c.upsample=(s,a,o)=>((0,c.validateInputs)(a,o),[s.run(Object.assign(Object.assign({},p),{cacheHint:o.cacheKey,get:()=>u(s,a,o)}),a)]),c.parseUpsampleAttributesV7=s=>(0,c.parseUpsampleAttributes)(s,7),c.parseUpsampleAttributesV9=s=>(0,c.parseUpsampleAttributes)(s,9),c.parseUpsampleAttributes=(s,a)=>{let o=a>=10,n=s.attributes.getString("mode","nearest");if(n!=="nearest"&&n!=="linear"&&(a<11||n!=="cubic"))throw new Error(`unrecognized mode: ${n}`);let e=[];a<9&&(e=s.attributes.getFloats("scales"),(0,c.scalesValidation)(e,n,o));let t=s.attributes.getFloat("extrapolation_value",0),r=a>10?s.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(r)===-1)throw new Error(`coordinate_transform_mode '${r}' is not supported`);let i=r==="tf_crop_and_resize",l=i,d=n==="nearest"&&a>=11?s.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(d)===-1)throw new Error(`nearest_mode '${d}' is not supported`);let g=s.attributes.getFloat("cubic_coeff_a",-.75),b=s.attributes.getInt("exclude_outside",0)!==0;if(b&&n!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let v=a<11||n==="nearest"&&r==="asymmetric"&&d==="floor",w=0,x=0,T=0;return a>10?s.inputs.length>2?(w=1,x=2,T=3):(x=1,T=2):a===9&&(x=1),(0,m.createAttributeWithCacheKey)({opset:a,isResize:o,mode:n,scales:e,extrapolationValue:t,coordinateTransformMode:r,useExtrapolation:l,needRoiInput:i,nearestMode:d,cubicCoefficientA:g,excludeOutside:b,useNearest2xOptimization:v,roiInputIdx:w,scalesInputIdx:x,sizesInputIdx:T})};let u=(s,a,o)=>{let n=(0,f.getGlsl)(s.session.backend.glContext.version),[e,t]=s.calculateTextureWidthAndHeight(a[0].dims,h.TextureType.unpacked),r=a[0].dims.map((T,O)=>Math.floor(T*o.scales[O])),[i,l]=s.calculateTextureWidthAndHeight(r,h.TextureType.unpacked),d=r.length,g=new Array(d),b=new Array(d),v=`
      int output_pitches[${d}];
      int input_pitches[${d}];
      `;for(let T=d-1;T>=0;T--)g[T]=T===d-1?1:g[T+1]*r[T+1],b[T]=T===d-1?1:b[T+1]*a[0].dims[T+1],v+=`
        output_pitches[${T}] = ${g[T]};
        input_pitches[${T}] = ${b[T]};
        `;let w=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${e}, ${t});
        float value = getColorAsFloat(${n.texture2D}(X, coords));
        return value;
      }
      `,x=o.mode==="nearest"?`
    ${w}
    float process(int indices[${d}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${l});

      ${v}

      int d, m;
      for (int dim = 0; dim < ${d}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:d===4?`
    ${w}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${l});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${a[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${w}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${l});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${a[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},p),{output:{dims:r,type:a[0].type,textureType:h.TextureType.unpacked},shaderSource:x,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(T=>Math.ceil(T))}]})};c.validateInputs=(s,a)=>{if(!s||a.opset<9&&s.length!==1||a.opset>=9&&a.opset<11&&s.length!==2||a.opset>=11&&s.length<2)throw new Error("invalid inputs.");if(a.scales.length>0&&s[0].dims.length!==a.scales.length)throw new Error("Invalid input shape.");if(s[0].type==="string")throw new Error("Invalid input tensor types.")},c.scalesValidation=(s,a,o)=>{if(o){for(let n of s)if(n<=0)throw new Error("Scale value should be greater than 0.")}else for(let n of s)if(n<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(a!=="linear"&&a!=="cubic"||s.length===2||s.length===4&&s[0]===1&&s[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}},2757:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ProgramManager=void 0;let m=y(2235),f=y(1315),h=y(8897),p=y(6757);c.ProgramManager=class{constructor(u,s,a){this.profiler=u,this.glContext=s,this.textureLayoutStrategy=a,this.repo=new Map,this.attributesBound=!1}getArtifact(u){return this.repo.get(u)}setArtifact(u,s){this.repo.set(u,s)}run(u,s,a){var o;this.profiler.event("op",`ProgramManager.run ${(o=u.programInfo.name)!==null&&o!==void 0?o:"unknown kernel"}`,()=>{var n;let e=this.glContext.gl,t=u.program;e.useProgram(t);try{this.bindOutput(a),this.attributesBound||this.bindAttributes(u.attribLocations),this.bindUniforms(u.uniformLocations,(n=u.programInfo.variables)!==null&&n!==void 0?n:[],s)}catch(r){throw f.Logger.error("ProgramManager",u.programInfo.shaderSource),r}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(u=>this.glContext.deleteProgram(u.program))}build(u,s,a){return this.profiler.event("backend","ProgramManager.build",()=>{let o=new h.GlslPreprocessor(this.glContext,u,s,a),n=o.preprocess(),e=this.compile(n);return{programInfo:u,program:e,uniformLocations:this.getUniformLocations(e,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(e)}})}compile(u){if(!this.vertexShader){f.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let o=(0,p.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}m.env.debug&&f.Logger.verbose("ProrgramManager",`FragShader:
${u}
`);let s=this.glContext.compileShader(u,this.glContext.gl.FRAGMENT_SHADER),a=this.glContext.createProgram(this.vertexShader,s);return this.glContext.deleteShader(s),a}bindOutput(u){let s=u.width,a=u.height;f.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${s}/${a}, shape=${u.shape}, type=${u.tensor.type}`),this.glContext.attachFramebuffer(u.texture,s,a)}bindAttributes(u){let s=u.position,a=u.textureCoord;this.glContext.setVertexAttributes(s,a),this.attributesBound=!0}bindUniforms(u,s,a){var o;let n=this.glContext.gl,e=0;for(let{name:t,type:r,location:i,arrayLength:l}of u){let d=(o=s.find(g=>g.name===t))===null||o===void 0?void 0:o.data;if(r!=="sampler2D"&&!d)throw new Error(`variable '${t}' does not have data defined in program info`);switch(r){case"sampler2D":this.bindTexture(a[e],i,e),e++;break;case"float":l?n.uniform1fv(i,d):n.uniform1f(i,d);break;case"int":l?n.uniform1iv(i,d):n.uniform1i(i,d);break;default:throw new Error(`Uniform not implemented: ${r}`)}}}bindTexture(u,s,a){this.glContext.bindTextureToUniform(u.texture,a,s)}getAttribLocations(u){return{position:this.getAttribLocation(u,"position"),textureCoord:this.getAttribLocation(u,"textureCoord")}}getUniformLocations(u,s,a){let o=[];if(s)for(let n of s)o.push({name:n,type:"sampler2D",location:this.getUniformLocation(u,n)});if(a)for(let n of a)o.push(Object.assign(Object.assign({},n),{location:this.getUniformLocation(u,n.name)}));return o}getUniformLocation(u,s){let a=this.glContext.gl.getUniformLocation(u,s);if(a===null)throw new Error(`Uniform ${s} not found.`);return a}getAttribLocation(u,s){return this.glContext.gl.getAttribLocation(u,s)}}},2171:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLSessionHandler=void 0;let m=y(1315),f=y(5881),h=y(7860),p=y(4110),u=y(2757),s=y(7618),a=y(5243);c.WebGLSessionHandler=class{constructor(o,n){this.backend=o,this.context=n,this.layoutStrategy=new s.PreferLogicalStrategy(o.glContext.maxTextureSize),this.programManager=new u.ProgramManager(this.context.profiler,o.glContext,this.layoutStrategy),this.textureManager=new a.TextureManager(o.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:o.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=o.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new h.WebGLInferenceHandler(this)}onGraphInitialized(o){let n=o.getValues().filter(e=>e.from===-1&&e.tensor).map(e=>e.tensor.dataId);this.initializers=new Set(n)}isInitializer(o){return!!this.initializers&&this.initializers.has(o)}addInitializer(o){this.initializers.add(o)}getTextureData(o,n){return n?this.packedTextureDataCache.get(o):this.unpackedTextureDataCache.get(o)}setTextureData(o,n,e=!1){m.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),e?this.packedTextureDataCache.set(o,n):this.unpackedTextureDataCache.set(o,n)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.unpackedTextureDataCache=new Map}resolve(o,n,e){let t=(0,f.resolveOperator)(o,n,p.WEBGL_OP_RESOLVE_RULES);return{impl:t.opImpl,context:t.opInit?t.opInit(o,e):o}}}},9622:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Uint8DataEncoder=c.RGBAFloatDataEncoder=c.RedFloat32DataEncoder=void 0;let m=y(1315);c.RedFloat32DataEncoder=class{constructor(f,h=1){if(h===1)this.internalFormat=f.R32F,this.format=f.RED,this.textureType=f.FLOAT,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=f.RGBA32F,this.format=f.RGBA,this.textureType=f.FLOAT,this.channelSize=h}}encode(f,h){let p,u;return f.constructor!==Float32Array&&(m.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),u=new Float32Array(f)),h*this.channelSize>f.length?(m.Logger.warning("Encoder","Source data too small. Allocating larger array"),u=f,p=this.allocate(h*this.channelSize),u.forEach((s,a)=>p[a]=s)):(u=f,p=u),p}allocate(f){return new Float32Array(4*f)}decode(f,h){return this.channelSize===1?f.filter((p,u)=>u%4==0).subarray(0,h):f.subarray(0,h)}},c.RGBAFloatDataEncoder=class{constructor(f,h=1,p){if(h!==1&&h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=f.RGBA,this.format=f.RGBA,this.channelSize=h,this.textureType=p||f.FLOAT}encode(f,h){let p=f;return this.channelSize===1&&(m.Logger.verbose("Encoder","Exploding into a larger array"),p=this.allocate(h),f.forEach((u,s)=>p[4*s]=u)),p}allocate(f){return new Float32Array(4*f)}decode(f,h){return this.channelSize===1?f.filter((p,u)=>u%4==0).subarray(0,h):f.subarray(0,h)}},c.Uint8DataEncoder=class{constructor(f,h=1){if(this.channelSize=4,h===1)this.internalFormat=f.ALPHA,this.format=f.ALPHA,this.textureType=f.UNSIGNED_BYTE,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=f.RGBA,this.format=f.RGBA,this.textureType=f.UNSIGNED_BYTE,this.channelSize=h}}encode(f,h){return new Uint8Array(f.buffer,f.byteOffset,f.byteLength)}allocate(f){return new Uint8Array(f*this.channelSize)}decode(f,h){if(f instanceof Uint8Array)return f.subarray(0,h);throw new Error(`Invalid array type: ${f.constructor}`)}}},7618:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getBatchDim=c.sizeToSquarishShape=c.getRowsCols=c.sizeFromShape=c.isInt=c.parseAxisParam=c.squeezeShape=c.PreferLogicalStrategy=c.AlwaysKeepOriginalSizeStrategy=void 0;let m=y(1315),f=y(7273);function h(o,n){let e=[],t=[],r=n!=null&&Array.isArray(n)&&n.length===0,i=n==null||r?null:p(n,o).sort(),l=0;for(let d=0;d<o.length;++d){if(i!=null){if(i[l]===d&&o[d]!==1)throw new Error(`Can't squeeze axis ${d} since its dim '${o[d]}' is not 1`);(i[l]==null||i[l]>d)&&o[d]===1&&(e.push(o[d]),t.push(d)),i[l]<=d&&l++}o[d]!==1&&(e.push(o[d]),t.push(d))}return{newShape:e,keptDims:t}}function p(o,n){let e=n.length;return o=o==null?n.map((t,r)=>r):[].concat(o),(0,f.assert)(o.every(t=>t>=-e&&t<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${o}`),(0,f.assert)(o.every(u),()=>`All values in axis param must be integers but got axis ${o}`),o.map(t=>t<0?e+t:t)}function u(o){return o%1==0}function s(o){if(o.length===0)return 1;let n=o[0];for(let e=1;e<o.length;e++)n*=o[e];return n}function a(o){let n=Math.ceil(Math.sqrt(o));return[n,Math.ceil(o/n)]}c.AlwaysKeepOriginalSizeStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,n){if(o.length===0)return[1,1];let e=this.maxTextureSize;if(n&&n.breakAxis!==void 0){let i=n.breakAxis>=o.length?1:o.slice(n.breakAxis).reduce((d,g)=>d*g),l=n.breakAxis<=0?1:o.slice(0,n.breakAxis).reduce((d,g)=>d*g);if(!(i>e||l>e))return[i,l];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${n.breakAxis}`)}let t=o.reduce((i,l)=>i*l),r=Math.floor(Math.sqrt(t));for(;r<e&&r<t&&t%r!=0;r++);if(r>=e||t%r!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${o}`);return[r,t/r]}},c.PreferLogicalStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,n){let e=this.computeTexture(o,n);return n&&n.isPacked&&(e[0]/=2,e[1]/=2),n&&n.reverseWH?[e[1],e[0]]:e}computeTexture(o,n){let e=n&&n.isPacked;if(o.length===0)return e?[2,2]:[1,1];let t=this.maxTextureSize;if(n&&n.breakAxis!==void 0){let l=n.breakAxis>=o.length?1:o.slice(n.breakAxis).reduce((g,b)=>g*b),d=n.breakAxis<=0?1:o.slice(0,n.breakAxis).reduce((g,b)=>g*b);if(!(l>t||d>t))return[l,d];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${n.breakAxis}`)}let r=o.slice(0);e&&(t*=2,r=r.map((l,d)=>d>=r.length-2?r[d]%2==0?r[d]:r[d]+1:r[d]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=h(r).newShape);let i=s(r);return r.length<=1&&i<=t?[1,i]:r.length===2&&r[0]<=t&&r[1]<=t?r:r.length===3&&r[0]*r[1]<=t&&r[2]<=t?[r[0]*r[1],r[2]]:r.length===3&&r[0]<=t&&r[1]*r[2]<=t?[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t?[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t?[r[0],r[1]*r[2]*r[3]]:e?a(i/4).map(l=>2*l):a(i)}},c.squeezeShape=h,c.parseAxisParam=p,c.isInt=u,c.sizeFromShape=s,c.getRowsCols=function(o){if(o.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[o.length>1?o[o.length-2]:1,o[o.length-1]]},c.sizeToSquarishShape=a,c.getBatchDim=function(o,n=2){return s(o.slice(0,o.length-n))}},3314:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createTextureLayoutFromShape=c.calculateTextureWidthAndHeight=c.createTextureLayoutFromTextureType=void 0;let m=y(7273),f=y(5639);c.createTextureLayoutFromTextureType=(h,p,u)=>{let s=u===f.TextureType.unpacked||u===f.TextureType.unpackedReversed?1:4,a=u===f.TextureType.packed,o=u===f.TextureType.unpackedReversed||u===f.TextureType.packed,n=u===f.TextureType.packedLastDimension?p.length-1:void 0,e=u===f.TextureType.packedLastDimension?p.map((t,r)=>r===p.length-1?4*t:t):void 0;return(0,c.createTextureLayoutFromShape)(h,p,s,e,{isPacked:a,reverseWH:o,breakAxis:n})},c.calculateTextureWidthAndHeight=(h,p,u)=>{let s=(0,c.createTextureLayoutFromTextureType)(h,p,u);return[s.width,s.height]},c.createTextureLayoutFromShape=(h,p,u=1,s,a)=>{let o=!(!a||!a.isPacked),[n,e]=h.computeTextureWH(o&&s||p,a),t=p.length,r=p.slice(0);if(t===0&&(r=[1]),u===1)s=p;else if(o){if(u!==4)throw new Error("a packed texture must be 4-channel");s=p,t>0&&(r[t-1]=Math.ceil(r[t-1]/2)),t>1&&(r[t-2]=Math.ceil(r[t-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:n,height:e,channels:u,isPacked:o,shape:r,strides:m.ShapeUtil.computeStrides(r),unpackedShape:s,reversedWH:a&&a.reverseWH}}},5243:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.TextureManager=void 0;let m=y(1315);c.TextureManager=class{constructor(f,h,p,u){this.glContext=f,this.layoutStrategy=h,this.profiler=p,this.config=u,this.pendingRead=new Map,u.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(f,h,p,u){let s=this.toEncoderType(f),a=this.glContext.getEncoder(s,h.channels||1,u);if(h.isPacked&&u===1)throw new Error("not implemented");let o=h.width,n=h.height,e,t;if(this.config.reuseTextures){e=`${o}x${n}_${a.format}_${a.internalFormat}_${a.textureType}`,t=this.inUseTextures.get(e),t||(t=[],this.inUseTextures.set(e,t));let i=this.idleTextures.get(e);if(i&&i.length>0){let l=i.pop();return t.push(l),u===1&&this.glContext.updateTexture(l,o,n,a,this.toTextureData(f,p)),l}}m.Logger.verbose("TextureManager",`Creating new texture of size ${h.width}x${h.height}`);let r=this.glContext.allocateTexture(o,n,a,this.toTextureData(f,p));return this.config.reuseTextures&&(t.push(r),this.textureLookup.set(r,e)),r}readTexture(f,h,p){return p||(p=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let u=f.shape.reduce((a,o)=>a*o)*p,s=this.glContext.readTexture(f.texture,f.width,f.height,u,this.toEncoderType(h),p);return this.toTensorData(h,s)})}async readTextureAsync(f,h,p){let u=f.tensor.dataId;if(p||(p=1),this.pendingRead.has(u)){let s=this.pendingRead.get(u);return new Promise(a=>s?.push(a))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(u,[]);let s=f.shape.reduce((e,t)=>e*t)*p;await this.glContext.createAndWaitForFence();let a=this.glContext.readTexture(f.texture,f.width,f.height,s,this.toEncoderType(h),p),o=this.toTensorData(h,a),n=this.pendingRead.get(u);return this.pendingRead.delete(u),n?.forEach(e=>e(o)),o})}readUint8TextureAsFloat(f){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let h=f.shape.reduce((u,s)=>u*s),p=this.glContext.readTexture(f.texture,f.width,f.height,4*h,"byte",4);return new Float32Array(p.buffer,p.byteOffset,h)})}releaseTexture(f,h){let p;if(this.config.reuseTextures&&(p=this.textureLookup.get(f.texture),p)){h&&this.textureLookup.delete(p);let u=this.inUseTextures.get(p);if(u){let s=u.indexOf(f.texture);if(s!==-1){u.splice(s,1);let a=this.idleTextures.get(p);a||(a=[],this.idleTextures.set(p,a)),a.push(f.texture)}}}p&&!h||(m.Logger.verbose("TextureManager",`Deleting texture of size ${f.width}x${f.height}`),this.glContext.deleteTexture(f.texture))}toTensorData(f,h){switch(f){case"int16":return h instanceof Int16Array?h:Int16Array.from(h);case"int32":return h instanceof Int32Array?h:Int32Array.from(h);case"int8":return h instanceof Int8Array?h:Int8Array.from(h);case"uint16":return h instanceof Uint16Array?h:Uint16Array.from(h);case"uint32":return h instanceof Uint32Array?h:Uint32Array.from(h);case"uint8":case"bool":return h instanceof Uint8Array?h:Uint8Array.from(h);case"float32":return h instanceof Float32Array?h:Float32Array.from(h);case"float64":return h instanceof Float64Array?h:Float64Array.from(h);default:throw new Error(`TensorData type ${f} is not supported`)}}toTextureData(f,h){if(h)return h instanceof Float32Array?h:new Float32Array(h)}toEncoderType(f){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(M,c)=>{"use strict";var y;Object.defineProperty(c,"__esModule",{value:!0}),c.TextureType=void 0,(y=c.TextureType||(c.TextureType={}))[y.unpacked=0]="unpacked",y[y.unpackedReversed=1]="unpackedReversed",y[y.packed=2]="packed",y[y.downloadUint8AsFloat=3]="downloadUint8AsFloat",y[y.packedLastDimension=4]="packedLastDimension"},432:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getGlChannels=c.getCoordsDataType=c.getSqueezedParams=c.squeezeInputShape=c.generateShaderFuncNameFromInputSamplerNameAtOutCoords=c.generateShaderFuncNameFromInputSamplerName=c.repeatedTry=c.getPackedShape=void 0;let m=y(7273);c.getPackedShape=function(f){let h=f.length;return f.slice(0,h-1).concat(f[h-1]/4)},c.repeatedTry=async function(f,h=u=>0,p){return new Promise((u,s)=>{let a=0,o=()=>{if(f())return void u();a++;let n=h(a);p!=null&&a>=p?s():setTimeout(o,n)};o()})},c.generateShaderFuncNameFromInputSamplerName=function(f){return(0,m.assert)(f!==void 0&&f.length!==0,()=>"empty string found for sampler name"),"get"+f.charAt(0).toUpperCase()+f.slice(1)},c.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(f){return(0,m.assert)(f!==void 0&&f.length!==0,()=>"empty string found for sampler name"),"get"+f.charAt(0).toUpperCase()+f.slice(1)+"AtOutCoords"},c.squeezeInputShape=function(f,h){let p=JSON.parse(JSON.stringify(f));return p=h,p},c.getSqueezedParams=function(f,h){return h.map(p=>f[p]).join(", ")},c.getCoordsDataType=function(f){if(f<=1)return"int";if(f===2)return"ivec2";if(f===3)return"ivec3";if(f===4)return"ivec4";if(f===5)return"ivec5";if(f===6)return"ivec6";throw Error(`GPU for rank ${f} is not yet supported`)},c.getGlChannels=function(f=6){return["x","y","z","w","u","v"].slice(0,f)}},3389:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createNewWebGLContext=c.createWebGLContext=void 0;let m=y(1315),f=y(3524),h={};function p(u,s){let a,o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!s||s==="webgl2")&&(a=u.getContext("webgl2",o),a))try{return new f.WebGLContext(a,2)}catch(n){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!s||s==="webgl")&&(a=u.getContext("webgl",o)||u.getContext("experimental-webgl",o),a))try{return new f.WebGLContext(a,1)}catch(n){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error("WebGL is not supported")}c.createWebGLContext=function u(s){let a;if(s&&s!=="webgl2"||!("webgl2"in h)?s&&s!=="webgl"||!("webgl"in h)||(a=h.webgl):a=h.webgl2,!a)try{a=p(function(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}(),s)}catch{a=p(function(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let e=document.createElement("canvas");return e.width=1,e.height=1,e}(),s)}s=s||a.version===1?"webgl":"webgl2";let o=a.gl;return h[s]=a,o.isContextLost()?(delete h[s],u(s)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),a)},c.createNewWebGLContext=p},3524:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(o,n,e,t){t===void 0&&(t=e);var r=Object.getOwnPropertyDescriptor(n,e);r&&!("get"in r?!n.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return n[e]}}),Object.defineProperty(o,t,r)}:function(o,n,e,t){t===void 0&&(t=e),o[t]=n[e]}),f=this&&this.__setModuleDefault||(Object.create?function(o,n){Object.defineProperty(o,"default",{enumerable:!0,value:n})}:function(o,n){o.default=n}),h=this&&this.__importStar||function(o){if(o&&o.__esModule)return o;var n={};if(o!=null)for(var e in o)e!=="default"&&Object.prototype.hasOwnProperty.call(o,e)&&m(n,o,e);return f(n,o),n};Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLContext=c.linearSearchLastTrue=void 0;let p=y(2235),u=h(y(9622)),s=y(432);function a(o){let n=0;for(;n<o.length&&o[n]();++n);return n-1}c.linearSearchLastTrue=a,c.WebGLContext=class{constructor(o,n){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=o,this.version=n,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(o,n,e,t){let r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE);let l=t?e.encode(t,o*n):null;return r.texImage2D(r.TEXTURE_2D,0,e.internalFormat,o,n,0,e.format,e.textureType,l),this.checkError(),i}updateTexture(o,n,e,t,r){let i=this.gl;i.bindTexture(i.TEXTURE_2D,o);let l=t.encode(r,n*e);i.texSubImage2D(i.TEXTURE_2D,0,0,0,n,e,t.format,t.textureType,l),this.checkError()}attachFramebuffer(o,n,e){let t=this.gl;t.bindTexture(t.TEXTURE_2D,o),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),this.checkError(),t.viewport(0,0,n,e),t.scissor(0,0,n,e)}readTexture(o,n,e,t,r,i){let l=this.gl;i||(i=1),this.frameBufferBound||this.attachFramebuffer(o,n,e);let d=this.getEncoder(r,i),g=d.allocate(n*e);return l.bindTexture(l.TEXTURE_2D,o),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,o,0),l.readPixels(0,0,n,e,l.RGBA,d.textureType,g),this.checkError(),d.decode(g,t)}isFramebufferReady(){return!0}getActiveTexture(){let o=this.gl;return"TEXTURE"+(o.getParameter(this.gl.ACTIVE_TEXTURE)-o.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(o,n){let e=this.gl;e.vertexAttribPointer(o,3,e.FLOAT,!1,20,0),e.enableVertexAttribArray(o),n!==-1&&(e.vertexAttribPointer(n,2,e.FLOAT,!1,20,12),e.enableVertexAttribArray(n)),this.checkError()}createProgram(o,n){let e=this.gl,t=e.createProgram();return e.attachShader(t,o),e.attachShader(t,n),e.linkProgram(t),t}compileShader(o,n){let e=this.gl,t=e.createShader(n);if(!t)throw new Error(`createShader() returned null with type ${n}`);if(e.shaderSource(t,o),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${e.getShaderInfoLog(t)}
Shader source:
${o}`);return t}deleteShader(o){this.gl.deleteShader(o)}bindTextureToUniform(o,n,e){let t=this.gl;t.activeTexture(t.TEXTURE0+n),this.checkError(),t.bindTexture(t.TEXTURE_2D,o),this.checkError(),t.uniform1i(e,n),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(p.env.debug){let o=this.gl,n=o.getError(),e="";switch(n){case o.NO_ERROR:return;case o.INVALID_ENUM:e="INVALID_ENUM";break;case o.INVALID_VALUE:e="INVALID_VALUE";break;case o.INVALID_OPERATION:e="INVALID_OPERATION";break;case o.INVALID_FRAMEBUFFER_OPERATION:e="INVALID_FRAMEBUFFER_OPERATION";break;case o.OUT_OF_MEMORY:e="OUT_OF_MEMORY";break;case o.CONTEXT_LOST_WEBGL:e="CONTEXT_LOST_WEBGL";break;default:e=`Unknown WebGL Error: ${n.toString(16)}`}throw new Error(e)}}deleteTexture(o){this.gl.deleteTexture(o)}deleteProgram(o){this.gl.deleteProgram(o)}getEncoder(o,n,e=0){if(this.version===2)return new u.RedFloat32DataEncoder(this.gl,n);switch(o){case"float":return e===1||this.isRenderFloat32Supported?new u.RGBAFloatDataEncoder(this.gl,n):new u.RGBAFloatDataEncoder(this.gl,n,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new u.Uint8DataEncoder(this.gl,n);default:throw new Error(`Invalid dataType: ${o}`)}}clearActiveTextures(){let o=this.gl;for(let n=0;n<this.maxTextureImageUnits;++n)o.activeTexture(o.TEXTURE0+n),o.bindTexture(o.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let o=this.gl;o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(this.framebuffer),o.bindBuffer(o.ARRAY_BUFFER,null),o.deleteBuffer(this.vertexbuffer),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null),o.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let o=this.gl,n=o.createBuffer();if(!n)throw new Error("createBuffer() returned null");let e=this.createDefaultGeometry();return o.bindBuffer(o.ARRAY_BUFFER,n),o.bufferData(o.ARRAY_BUFFER,e,o.STATIC_DRAW),this.checkError(),n}createFramebuffer(){let o=this.gl.createFramebuffer();if(!o)throw new Error("createFramebuffer returned null");return o}queryVitalParameters(){let o=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=o.getParameter(o.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=o.getParameter(o.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let o=this.gl,n=o.createTexture();o.bindTexture(o.TEXTURE_2D,n);let e=this.version===2?o.RGBA32F:o.RGBA;o.texImage2D(o.TEXTURE_2D,0,e,1,1,0,o.RGBA,o.FLOAT,null);let t=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,t),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,n,0);let r=o.checkFramebufferStatus(o.FRAMEBUFFER)===o.FRAMEBUFFER_COMPLETE;return o.bindTexture(o.TEXTURE_2D,null),o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteTexture(n),o.deleteFramebuffer(t),r}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let o=this.gl,n,e,t,r,i;try{n=o.createTexture(),e=o.createFramebuffer(),o.bindTexture(o.TEXTURE_2D,n);let l=this.version===2?o.RGBA32F:o.RGBA;return o.texImage2D(o.TEXTURE_2D,0,l,1,1,0,o.RGBA,o.FLOAT,null),o.bindFramebuffer(o.FRAMEBUFFER,e),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,n,0),o.enable(o.BLEND),t=o.createShader(o.VERTEX_SHADER),!!t&&(o.shaderSource(t,"void main(){}"),o.compileShader(t),r=o.createShader(o.FRAGMENT_SHADER),!!r&&(o.shaderSource(r,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),o.compileShader(r),i=o.createProgram(),!!i&&(o.attachShader(i,t),o.attachShader(i,r),o.linkProgram(i),o.useProgram(i),o.drawArrays(o.POINTS,0,1),o.getError()===o.NO_ERROR)))}finally{o.disable(o.BLEND),i&&o.deleteProgram(i),t&&o.deleteShader(t),r&&o.deleteShader(r),e&&(o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(e)),n&&(o.bindTexture(o.TEXTURE_2D,null),o.deleteTexture(n))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let o=this.gl,n=this.disjointTimerQueryWebgl2Extension,e=o.createQuery();return o.beginQuery(n.TIME_ELAPSED_EXT,e),e}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{let o=this.gl,n=this.disjointTimerQueryWebgl2Extension;o.endQuery(n.TIME_ELAPSED_EXT)}}isTimerResultAvailable(o){let n=!1,e=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{let t=this.gl,r=this.disjointTimerQueryWebgl2Extension;n=t.getQueryParameter(o,t.QUERY_RESULT_AVAILABLE),e=t.getParameter(r.GPU_DISJOINT_EXT)}return n&&!e}getTimerResult(o){let n=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{let e=this.gl;n=e.getQueryParameter(o,e.QUERY_RESULT),e.deleteQuery(o)}return n/1e6}async waitForQueryAndGetTime(o){return await(0,s.repeatedTry)(()=>this.isTimerResultAvailable(o)),this.getTimerResult(o)}async createAndWaitForFence(){let o=this.createFence(this.gl);return this.pollFence(o)}createFence(o){let n,e=o,t=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return o.flush(),n=t===null?()=>!0:()=>{let r=e.clientWaitSync(t,0,0);return r===e.ALREADY_SIGNALED||r===e.CONDITION_SATISFIED},{query:t,isFencePassed:n}}async pollFence(o){return new Promise(n=>{this.addItemToPoll(()=>o.isFencePassed(),()=>n())})}pollItems(){let o=a(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=o;++n){let{resolveFn:e}=this.itemsToPoll[n];e()}this.itemsToPoll=this.itemsToPoll.slice(o+1)}async addItemToPoll(o,n){this.itemsToPoll.push({isDoneFn:o,resolveFn:n}),this.itemsToPoll.length>1||await(0,s.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ExecutionPlan=void 0;let m=y(1315);class f{constructor(p,u){this.op=p,this.node=u}}c.ExecutionPlan=class{constructor(h,p,u){this.graph=h,this.profiler=u,this.initialize(p)}initialize(h){this.profiler.event("session","ExecutionPlan.initialize",()=>{let p=this.graph.getNodes();if(p.length!==h.length)throw new Error("The size of nodes and OPs do not match.");this._ops=h.map((u,s)=>new f(u,p[s])),this.reset(),this._starter=[],this._ops.forEach((u,s)=>{let a=!0;for(let o of u.node.inputs)if(!this._values[o]&&this.graph.getInputIndices().indexOf(o)===-1){a=!1;break}a&&this._starter.push(s)})})}reset(){this._values=this.graph.getValues().map(h=>h.tensor)}async execute(h,p){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let u=h.createInferenceHandler(),s=this.graph.getInputIndices();if(p.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${p.length} expected: ${s.length}`);p.forEach((r,i)=>{let l=s[i];this._values[l]=r});let a=this._starter.slice(0),o=this.graph.getValues(),n=this.graph.getNodes(),e=0;for(;e<a.length;){let r=a[e++],i=this._ops[r],l=i.node.inputs.map(v=>this._values[v]);if(l.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${i.node}`);let d=l;m.Logger.verbose("ExecPlan",`Runing op:${i.node.name} (${d.map((v,w)=>`'${i.node.inputs[w]}': ${v.type}[${v.dims.join(",")}]`).join(", ")})`);let g=await this.profiler.event("node",i.node.name,async()=>i.op.impl(u,d,i.op.context));if(g.length!==i.node.outputs.length)throw new Error("the size of output does not match model definition.");g.forEach((v,w)=>{let x=i.node.outputs[w];if(this._values[x])throw new Error(`output [${x}] already has value: op:${i.node.name}`);this._values[x]=v});let b=new Set;g.forEach((v,w)=>{let x=i.node.outputs[w];for(let T of o[x].to){let O=n[T],P=!0;for(let I of O.inputs)if(!this._values[I]){P=!1;break}P&&b.add(T)}}),a.push(...b)}let t=[];for(let r=0;r<this.graph.getOutputIndices().length;r++){let i=this.graph.getOutputIndices()[r],l=this._values[i];if(l===void 0)throw new Error(`required output [${i}] does not have value`);i===0?await l.getData():l.data,t.push(l)}return m.Logger.verbose("ExecPlan","disposing of inferenceHandler"),u.dispose(),t})}}},4662:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Graph=void 0;let m=y(6874),f=y(5127),h=y(2446),p=y(9240),u=y(7273);var s=f.onnxruntime.experimental.fbs;c.Graph={from:(e,t)=>new n(e,t)};class a{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=u.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}}class o{constructor(t,r){t instanceof h.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new m.Attribute(t.attribute)):t instanceof s.Node&&(this.name=r??t.name(),this.opType=t.opType(),this.attributes=new m.Attribute(u.ProtoUtil.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class n{constructor(t,r){if(!t)throw new TypeError("graph is empty");this.buildGraph(t),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof h.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else{if(!(t instanceof s.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(t)}}buildGraphFromOnnxFormat(t){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!t.input)throw new Error("missing information in graph: input");let l=[];for(let d of t.input){if(r.has(d.name))throw new Error(`duplicated input name: ${d.name}`);let g=this._allData.push(new a(d))-1;r.set(d.name,g),l.push(d.name)}if(!t.initializer)throw new Error("missing information in graph: initializer");for(let d of t.initializer){let g=r.get(d.name);if(g===void 0){let b=new a;b.type={shape:{dims:u.ProtoUtil.tensorDimsFromProto(d.dims)},tensorType:u.ProtoUtil.tensorDataTypeFromProto(d.dataType)},g=this._allData.push(b)-1,r.set(d.name,g)}this._allData[g]._from=-1,this._allData[g].tensor=p.Tensor.fromProto(d)}for(let d=0;d<this._allData.length;d++)this._allData[d].tensor||(this._allInputIndices.push(d),this._allInputNames.push(l[d]));if(!t.output)throw new Error("missing information in graph: output");for(let d of t.output){if(r.has(d.name))throw new Error(`duplicated output name: ${d.name}`);let g=this._allData.push(new a(d))-1;r.set(d.name,g),this._allOutputIndices.push(g),this._allOutputNames.push(d.name)}if(!t.node)throw new Error("missing information in graph: node");for(let d of t.node){if(!d.name)for(let b=0;;b++){let v=`unnamed_${d.opType}_${b}`;if(!i.has(v)){d.name=v;break}}if(i.has(d.name))throw new Error(`duplicated node name: ${d.name}`);let g=this._nodes.push(new o(d))-1;i.set(d.name,g)}for(let d=0;d<this._nodes.length;d++){let g=this._nodes[d],b=t.node[d];if(!b.output)throw new Error(`missing output for node: ${b.name}`);for(let v of b.output){let w=r.get(v);if(w===void 0&&(w=this._allData.push(new a)-1,r.set(v,w)),g.outputs.push(w),this._allData[w]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${w}`);if(this._allData[w]._from=d,b.opType==="Constant"){if(!b.attribute||b.attribute.length!==1||!b.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!b.output||b.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");g.outputs.pop(),g.executeNode=!1,this._allData[w]._from=-1,this._allData[w].tensor=p.Tensor.fromProto(b.attribute[0].t)}}}for(let d=0;d<this._nodes.length;d++){let g=this._nodes[d],b=t.node[d];if(!b.input)throw new Error(`missing input for node: ${b.name}`);for(let v of b.input){let w=r.get(v);if(w===void 0){if(v===""&&(b.input.length===3||b.input.length===4)&&b.opType==="Resize")continue;throw new Error(`unrecognized input '${v}' for node: ${b.name}`)}g.inputs.push(w),this._allData[w]._to.push(d)}}return!0}buildGraphFromOrtFormat(t){var r,i,l;let d=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let g=new Map,b=[];for(let v=0;v<t.inputsLength();v++){let w=t.inputs(v);if(d.has(w))throw new Error(`duplicated input name: ${w}`);for(let x=0;x<t.nodeArgsLength();x++)if(((r=t.nodeArgs(x))===null||r===void 0?void 0:r.name())===w){let T=new a;if(((l=(i=t.nodeArgs(x))===null||i===void 0?void 0:i.type())===null||l===void 0?void 0:l.valueType())!==s.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let O=t.nodeArgs(x).type().value(new s.TensorTypeAndShape),P=u.ProtoUtil.tensorDataTypeFromProto(O.elemType()),I=O.shape(),R=[];for(let A=0;A<I.dimLength();A++)R.push(u.LongUtil.longToNumber(I.dim(A).value().dimValue()));T.type={shape:{dims:R},tensorType:P};let j=this._allData.push(T)-1;d.set(w,j),b.push(w)}}for(let v=0;v<t.initializersLength();v++){let w=t.initializers(v),x=d.get(w.name());if(x===void 0){let T=new a,O=u.ProtoUtil.tensorDimsFromORTFormat(w),P=u.ProtoUtil.tensorDataTypeFromProto(w.dataType());T.type={shape:{dims:O},tensorType:P},x=this._allData.push(T)-1,d.set(w.name(),x)}this._allData[x]._from=-1,this._allData[x].tensor=p.Tensor.fromOrtTensor(w)}for(let v=0;v<this._allData.length;v++)this._allData[v].tensor||(this._allInputIndices.push(v),this._allInputNames.push(b[v]));for(let v=0;v<t.outputsLength();v++){let w=t.outputs(v);if(d.has(w))throw new Error(`duplicated output name: ${w}`);let x=this._allData.push(new a)-1;d.set(w,x),this._allOutputIndices.push(x),this._allOutputNames.push(w)}if(!t.nodes)throw new Error("missing information in graph: node");for(let v=0;v<t.nodesLength();v++){let w=t.nodes(v),x=w.name();if(!x)for(let O=0;x=`unnamed_${w.opType()}_${O}`,g.has(x);O++);if(g.has(x))throw new Error(`duplicated node name: ${x}`);let T=this._nodes.push(new o(w,x))-1;g.set(x,T)}for(let v=0;v<this._nodes.length;v++){let w=this._nodes[v],x=t.nodes(v);if(x==null)throw new Error(`No node exists at index ${v}`);if(x?.outputsLength()===0)throw new Error(`missing output for node: ${x.name}`);for(let T=0;T<x?.outputsLength();T++){let O=x?.outputs(T),P=d.get(O);if(P===void 0&&(P=this._allData.push(new a)-1,d.set(O,P)),w.outputs.push(P),this._allData[P]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${P}`);if(this._allData[P]._from=v,x.opType()==="Constant"){if(x.attributesLength()!==1||!x.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(x.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");w.outputs.pop(),w.executeNode=!1,this._allData[P]._from=-1,this._allData[P].tensor=p.Tensor.fromOrtTensor(x.attributes(0).t())}}}for(let v=0;v<this._nodes.length;v++){let w=this._nodes[v],x=t.nodes(v);if(x.inputsLength()===0)throw new Error(`missing input for node: ${x.name}`);for(let T=0;T<x.inputsLength();T++){let O=x.inputs(T),P=d.get(O);if(P===void 0)throw new Error(`unrecognized input '${O}' for node: ${x.name()}`);w.inputs.push(P),this._allData[P]._to.push(v)}}}checkIsAcyclic(){let t=new Set;this._allInputIndices.forEach(l=>{this._allData[l]._to.forEach(d=>{t.add(d)})});let r=Array.from(t),i=new Array(this._nodes.length).fill("white");for(;r.length>0;){let l=r.pop();i[l]==="gray"?i[l]="black":(r.push(l),i[l]="gray",this._nodes[l].outputs.forEach(d=>{let g=this._allData[d];if(g.tensor!==void 0)throw new Error("node outputs should not be initialized");if(g._from!==l)throw new Error("from property of the Value object doesn't match index of Node being processed");g._to.forEach(b=>{if(i[b]==="gray")throw new Error("model graph is cyclic");i[b]==="white"&&r.push(b)})}))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0,r=new Array(this._nodes.length,0),i=0;for(let l=0;l<this._nodes.length;l++)r[l]=i,this._nodes[l].executeNode?(i!==l&&(this._nodes[i]=this._nodes[l]),i++):this._nodes[l].outputs.forEach(d=>{this._allData[d]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let l=0;l<this._allData.length;l++){let d=this._allData[l];d._from!==void 0&&d._from!==-1&&d._from!==-2&&(d._from=r[d._from]);for(let g=0;g<d._to.length;g++){if(!(d._to[g]>=0))throw new Error("Trying to update a removed node");d._to[g]=r[d._to[g]]}}t=0;for(let l=0;l<this._allData.length;l++)if(this._allData[l].from!==-2||this._allOutputIndices.indexOf(l+t)!==-1){if(t>0){let d=-1;this._allData[l].from!==void 0&&this._allData[l].from!==-1?(d=this._nodes[this._allData[l].from].outputs.indexOf(l+t),d!==-1&&(this._nodes[this._allData[l].from].outputs[d]=l)):(d=this._allInputIndices.indexOf(l+t),d!==-1&&(this._allInputIndices[d]=l)),this._allData[l].to.forEach(g=>{d=this._nodes[g].inputs.indexOf(l+t),d!==-1&&(this._nodes[g].inputs[d]=l)}),this._allData[l].to.length===0&&(d=this._allOutputIndices.indexOf(l+t),d!==-1&&(this._allOutputIndices[d]=l))}}else t++,this._allData.splice(l,1),l--}deleteNode(t){let r=this._nodes[t];if(r.outputs.length>1){for(let b=1;b<r.outputs.length;b++)if(this._allData[r.outputs[b]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let i=r.inputs[0],l=r.outputs[0],d=this._allData[l].to;for(let b=0;b<r.inputs.length;b++){let v=this._allData[r.inputs[b]].to.indexOf(t);if(v===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[b]].to.splice(v,1)}this._allData[l]._to=[];let g=this._allOutputIndices.indexOf(l);if(g!==-1&&(this._allOutputIndices[g]=i),d&&d.length>0)for(let b of d){let v=this._nodes[b].inputs.indexOf(l);if(v===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[b].inputs[v]=i,this._allData[i].to.push(b)}}removeAllDropoutNodes(){let t=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let t of this._nodes)if(t.opType==="Conv"){let r=this._allData[t.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let i=this._nodes[r[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{t.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{t.attributes.set("activation_params","floats",[u.MIN_CLIP,u.MAX_CLIP])}else{if(!(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0))continue;t.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]])}t.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}},1315:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.now=c.Profiler=c.Logger=void 0;let y={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},m={none:new class{log(o,n,e){}},console:new class{log(o,n,e){console.log(`${this.color(o)} ${e?"\x1B[35m"+e+"\x1B[0m ":""}${n}`)}color(o){switch(o){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${o}`)}}}},f={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},h={"":f};function p(o,n,e,t){if(n===void 0)return r=o,{verbose:p.verbose.bind(null,r),info:p.info.bind(null,r),warning:p.warning.bind(null,r),error:p.error.bind(null,r),fatal:p.fatal.bind(null,r)};if(e===void 0)u(o,n);else if(typeof e=="number"&&t===void 0)u(o,n);else if(typeof e=="string"&&t===void 0)u(o,e,0,n);else{if(typeof e!="string"||typeof t!="number")throw new TypeError("input is valid");u(o,e,0,n)}var r}function u(o,n,e,t){let r=h[t||""]||h[""];y[o]<y[r.minimalSeverity]||(r.logDateTime&&(n=`${new Date().toISOString()}|${n}`),r.logSourceLocation,m[r.provider].log(o,n,t))}(function(o){function n(t){h={},e("",t||{})}function e(t,r){if(t==="*")n(r);else{let i=h[t]||f;h[t]={provider:r.provider||i.provider,minimalSeverity:r.minimalSeverity||i.minimalSeverity,logDateTime:r.logDateTime===void 0?i.logDateTime:r.logDateTime,logSourceLocation:r.logSourceLocation===void 0?i.logSourceLocation:r.logSourceLocation}}}o.verbose=function(t,r){o("verbose",t,r)},o.info=function(t,r){o("info",t,r)},o.warning=function(t,r){o("warning",t,r)},o.error=function(t,r){o("error",t,r)},o.fatal=function(t,r){o("fatal",t,r)},o.reset=n,o.set=e,o.setWithEnv=function(t){let r={};t.logLevel&&(r.minimalSeverity=t.logLevel),e("",r)}})(p||(p={})),c.Logger=p;class s{constructor(n,e,t,r,i,l){this.category=n,this.name=e,this.startTime=t,this.endCallback=r,this.timer=i,this.ctx=l}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class a{constructor(n,e,t,r){this.category=n,this.name=e,this.startTime=t,this.endTime=r}}c.Profiler=class{static create(o){return o===void 0?new this:new this(o.maxNumberEvents,o.flushBatchSize,o.flushIntervalInMilliseconds)}constructor(o,n,e){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=o===void 0?1e4:o,this._flushBatchSize=n===void 0?10:n,this._flushIntervalInMilliseconds=e===void 0?5e3:e}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,c.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(o,n,e,t){let r=this._started?this.begin(o,n,t):void 0,i=!1,l=e();if(l&&typeof l.then=="function")return i=!0,new Promise((d,g)=>{l.then(async b=>{r&&await r.end(),d(b)},async b=>{r&&await r.end(),g(b)})});if(!i&&r){let d=r.end();if(d&&typeof d.then=="function")return new Promise((g,b)=>{d.then(()=>{g(l)},v=>{b(v)})})}return l}begin(o,n,e){if(!this._started)throw new Error("profiler is not started yet");if(e===void 0){let t=(0,c.now)();return this.flush(t),new s(o,n,t,r=>this.endSync(r))}{let t=e.beginTimer();return new s(o,n,0,async r=>this.end(r),t,e)}}async end(o){let n=await o.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,n)),this.flush(n))}endSync(o){let n=(0,c.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,n)),this.flush(n))}logOneEvent(o){c.Logger.verbose(`Profiler.${o.category}`,`${(o.endTime-o.startTime).toFixed(2)}ms on event '${o.name}' at ${o.endTime.toFixed(2)}`)}flush(o){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||o-this._flushTime>=this._flushIntervalInMilliseconds){for(let n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,c.now)()}}get started(){return this._started}},c.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Model=void 0;let m=y(5686),f=y(4662),h=y(5127),p=y(2446),u=y(7273);var s=h.onnxruntime.experimental.fbs;c.Model=class{constructor(){}load(a,o,n){if(!n)try{return void this.loadFromOnnxFormat(a,o)}catch(e){if(n!==void 0)throw e}this.loadFromOrtFormat(a,o)}loadFromOnnxFormat(a,o){let n=p.onnx.ModelProto.decode(a);if(u.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map(e=>({domain:e.domain,version:u.LongUtil.longToNumber(e.version)})),this._graph=f.Graph.from(n.graph,o)}loadFromOrtFormat(a,o){let n=new m.flatbuffers.ByteBuffer(a),e=s.InferenceSession.getRootAsInferenceSession(n).model();if(u.LongUtil.longToNumber(e.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let t=0;t<e.opsetImportLength();t++){let r=e.opsetImport(t);this._opsets.push({domain:r?.domain(),version:u.LongUtil.longToNumber(r.version())})}this._graph=f.Graph.from(e.graph(),o)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.FLOAT_TYPES=c.INT_TYPES=c.NUMBER_TYPES=void 0,c.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],c.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],c.FLOAT_TYPES=["float32","float64"]},5881:(M,c)=>{"use strict";function y(m,f){if(f.endsWith("+")){let h=Number.parseInt(f.substring(0,f.length-1),10);return!isNaN(h)&&h<=m}if(f.split("-").length===2){let h=f.split("-"),p=Number.parseInt(h[0],10),u=Number.parseInt(h[1],10);return!isNaN(p)&&!isNaN(u)&&p<=m&&m<=u}return Number.parseInt(f,10)===m}Object.defineProperty(c,"__esModule",{value:!0}),c.resolveOperator=void 0,c.resolveOperator=function(m,f,h){for(let p of h){let u=p[0],s=p[1],a=p[2],o=p[3],n=p[4];if(m.opType===u){for(let e of f)if((e.domain===s||e.domain==="ai.onnx"&&s==="")&&y(e.version,a))return{opImpl:o,opInit:n}}}throw new TypeError(`cannot resolve operator '${m.opType}' with opsets: ${f.map(p=>`${p.domain||"ai.onnx"} v${p.version}`).join(", ")}`)}},5127:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.onnxruntime=void 0;let m=y(5686);var f,h;f=c.onnxruntime||(c.onnxruntime={}),function(p){let u;(function(s){s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.INT=2]="INT",s[s.STRING=3]="STRING",s[s.TENSOR=4]="TENSOR",s[s.GRAPH=5]="GRAPH",s[s.FLOATS=6]="FLOATS",s[s.INTS=7]="INTS",s[s.STRINGS=8]="STRINGS",s[s.TENSORS=9]="TENSORS",s[s.GRAPHS=10]="GRAPHS",s[s.SPARSE_TENSOR=11]="SPARSE_TENSOR",s[s.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(u=p.AttributeType||(p.AttributeType={}))}((h=f.experimental||(f.experimental={})).fbs||(h.fbs={})),function(p){(function(u){(function(s){let a;(function(o){o[o.UNKNOWN=0]="UNKNOWN",o[o.VALUE=1]="VALUE",o[o.PARAM=2]="PARAM"})(a=s.DimensionValueType||(s.DimensionValueType={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){let a;(function(o){o[o.UNDEFINED=0]="UNDEFINED",o[o.FLOAT=1]="FLOAT",o[o.UINT8=2]="UINT8",o[o.INT8=3]="INT8",o[o.UINT16=4]="UINT16",o[o.INT16=5]="INT16",o[o.INT32=6]="INT32",o[o.INT64=7]="INT64",o[o.STRING=8]="STRING",o[o.BOOL=9]="BOOL",o[o.FLOAT16=10]="FLOAT16",o[o.DOUBLE=11]="DOUBLE",o[o.UINT32=12]="UINT32",o[o.UINT64=13]="UINT64",o[o.COMPLEX64=14]="COMPLEX64",o[o.COMPLEX128=15]="COMPLEX128",o[o.BFLOAT16=16]="BFLOAT16",o[o.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",o[o.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",o[o.FLOAT8E5M2=19]="FLOAT8E5M2",o[o.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"})(a=s.TensorDataType||(s.TensorDataType={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){let a;(function(o){o[o.Primitive=0]="Primitive",o[o.Fused=1]="Fused"})(a=s.NodeType||(s.NodeType={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){let a;(function(o){o[o.NONE=0]="NONE",o[o.tensor_type=1]="tensor_type",o[o.sequence_type=2]="sequence_type",o[o.map_type=3]="map_type"})(a=s.TypeInfoValue||(s.TypeInfoValue={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsShape(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}dim(n,e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new p.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,e){n.addFieldOffset(0,e,0)}static createDimVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startDimVector(n,e){n.startVector(4,e,4)}static endShape(n){return n.endObject()}static createShape(n,e){return a.startShape(n),a.addDim(n,e),a.endShape(n)}}s.Shape=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsDimension(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}value(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}denotation(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}static startDimension(n){n.startObject(2)}static addValue(n,e){n.addFieldOffset(0,e,0)}static addDenotation(n,e){n.addFieldOffset(1,e,0)}static endDimension(n){return n.endObject()}static createDimension(n,e,t){return a.startDimension(n),a.addValue(n,e),a.addDenotation(n,t),a.endDimension(n)}}s.Dimension=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsDimensionValue(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):p.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,e){n.addFieldInt8(0,e,p.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(n,e){n.addFieldInt64(1,e,n.createLong(0,0))}static addDimParam(n,e){n.addFieldOffset(2,e,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,e,t,r){return a.startDimensionValue(n),a.addDimType(n,e),a.addDimValue(n,t),a.addDimParam(n,r),a.endDimensionValue(n)}}s.DimensionValue=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTensorTypeAndShape(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.TensorDataType.UNDEFINED}shape(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,e){n.addFieldInt32(0,e,p.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(n,e){n.addFieldOffset(1,e,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,e,t){return a.startTensorTypeAndShape(n),a.addElemType(n,e),a.addShape(n,t),a.endTensorTypeAndShape(n)}}s.TensorTypeAndShape=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsMapType(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.TensorDataType.UNDEFINED}valueType(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,e){n.addFieldInt32(0,e,p.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(n,e){n.addFieldOffset(1,e,0)}static endMapType(n){return n.endObject()}static createMapType(n,e,t){return a.startMapType(n),a.addKeyType(n,e),a.addValueType(n,t),a.endMapType(n)}}s.MapType=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSequenceType(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,e){n.addFieldOffset(0,e,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,e){return a.startSequenceType(n),a.addElemType(n,e),a.endSequenceType(n)}}s.SequenceType=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(u.fbs||(u.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(s,a){return this.bb_pos=s,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(s,a,o,n){return s.prep(4,12),s.writeInt32(n),s.writeInt32(o),s.writeInt32(a),s.offset()}}})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsNodeEdge(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+t)+12*n,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,e){let t=this.bb.__offset(this.bb_pos,8);return t?(e||new p.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+t)+12*n,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,e){n.addFieldInt32(0,e,0)}static addInputEdges(n,e){n.addFieldOffset(1,e,0)}static startInputEdgesVector(n,e){n.startVector(12,e,4)}static addOutputEdges(n,e){n.addFieldOffset(2,e,0)}static startOutputEdgesVector(n,e){n.startVector(12,e,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,e,t,r){return a.startNodeEdge(n),a.addNodeIndex(n,e),a.addInputEdges(n,t),a.addOutputEdges(n,r),a.endNodeEdge(n)}}s.NodeEdge=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsNode(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}domain(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.NodeType.Primitive}executionProviderType(n){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,n):null}inputs(n,e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,e){let t=this.bb.__offset(this.bb_pos,24);return t?(e||new p.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*n):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,e){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addDomain(n,e){n.addFieldOffset(2,e,0)}static addSinceVersion(n,e){n.addFieldInt32(3,e,0)}static addIndex(n,e){n.addFieldInt32(4,e,0)}static addOpType(n,e){n.addFieldOffset(5,e,0)}static addType(n,e){n.addFieldInt32(6,e,p.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(n,e){n.addFieldOffset(7,e,0)}static addInputs(n,e){n.addFieldOffset(8,e,0)}static createInputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startInputsVector(n,e){n.startVector(4,e,4)}static addOutputs(n,e){n.addFieldOffset(9,e,0)}static createOutputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startOutputsVector(n,e){n.startVector(4,e,4)}static addAttributes(n,e){n.addFieldOffset(10,e,0)}static createAttributesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startAttributesVector(n,e){n.startVector(4,e,4)}static addInputArgCounts(n,e){n.addFieldOffset(11,e,0)}static createInputArgCountsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addInt32(e[t]);return n.endVector()}static startInputArgCountsVector(n,e){n.startVector(4,e,4)}static addImplicitInputs(n,e){n.addFieldOffset(12,e,0)}static createImplicitInputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startImplicitInputsVector(n,e){n.startVector(4,e,4)}static endNode(n){return n.endObject()}static createNode(n,e,t,r,i,l,d,g,b,v,w,x,T,O){return a.startNode(n),a.addName(n,e),a.addDocString(n,t),a.addDomain(n,r),a.addSinceVersion(n,i),a.addIndex(n,l),a.addOpType(n,d),a.addType(n,g),a.addExecutionProviderType(n,b),a.addInputs(n,v),a.addOutputs(n,w),a.addAttributes(n,x),a.addInputArgCounts(n,T),a.addImplicitInputs(n,O),a.endNode(n)}}s.Node=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsValueInfo(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}type(n){let e=this.bb.__offset(this.bb_pos,8);return e?(n||new p.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addType(n,e){n.addFieldOffset(2,e,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,e,t,r){return a.startValueInfo(n),a.addName(n,e),a.addDocString(n,t),a.addType(n,r),a.endValueInfo(n)}}s.ValueInfo=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTypeInfo(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):p.experimental.fbs.TypeInfoValue.NONE}value(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(n,this.bb_pos+e):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,e){n.addFieldOffset(0,e,0)}static addValueType(n,e){n.addFieldInt8(1,e,p.experimental.fbs.TypeInfoValue.NONE)}static addValue(n,e){n.addFieldOffset(2,e,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,e,t,r){return a.startTypeInfo(n),a.addDenotation(n,e),a.addValueType(n,t),a.addValue(n,r),a.endTypeInfo(n)}}s.TypeInfo=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsOperatorSetId(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,e){n.addFieldOffset(0,e,0)}static addVersion(n,e){n.addFieldInt64(1,e,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,e,t){return a.startOperatorSetId(n),a.addDomain(n,e),a.addVersion(n,t),a.endOperatorSetId(n)}}s.OperatorSetId=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTensor(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}dims(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.TensorDataType.UNDEFINED}rawData(n){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addDims(n,e){n.addFieldOffset(2,e,0)}static createDimsVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startDimsVector(n,e){n.startVector(8,e,8)}static addDataType(n,e){n.addFieldInt32(3,e,p.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(n,e){n.addFieldOffset(4,e,0)}static createRawDataVector(n,e){n.startVector(1,e.length,1);for(let t=e.length-1;t>=0;t--)n.addInt8(e[t]);return n.endVector()}static startRawDataVector(n,e){n.startVector(1,e,1)}static addStringData(n,e){n.addFieldOffset(5,e,0)}static createStringDataVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startStringDataVector(n,e){n.startVector(4,e,4)}static endTensor(n){return n.endObject()}static createTensor(n,e,t,r,i,l,d){return a.startTensor(n),a.addName(n,e),a.addDocString(n,t),a.addDims(n,r),a.addDataType(n,i),a.addRawData(n,l),a.addStringData(n,d),a.endTensor(n)}}s.Tensor=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSparseTensor(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}values(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}indices(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}dims(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,e){n.addFieldOffset(0,e,0)}static addIndices(n,e){n.addFieldOffset(1,e,0)}static addDims(n,e){n.addFieldOffset(2,e,0)}static createDimsVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startDimsVector(n,e){n.startVector(8,e,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,e,t,r){return a.startSparseTensor(n),a.addValues(n,e),a.addIndices(n,t),a.addDims(n,r),a.endSparseTensor(n)}}s.SparseTensor=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsAttribute(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.AttributeType.UNDEFINED}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,n):null}t(n){let e=this.bb.__offset(this.bb_pos,16);return e?(n||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}g(n){let e=this.bb.__offset(this.bb_pos,18);return e?(n||new p.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}floats(n){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*n):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,e){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,e){let t=this.bb.__offset(this.bb_pos,26);return t?(e||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,e){let t=this.bb.__offset(this.bb_pos,28);return t?(e||new p.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addType(n,e){n.addFieldInt32(2,e,p.experimental.fbs.AttributeType.UNDEFINED)}static addF(n,e){n.addFieldFloat32(3,e,0)}static addI(n,e){n.addFieldInt64(4,e,n.createLong(0,0))}static addS(n,e){n.addFieldOffset(5,e,0)}static addT(n,e){n.addFieldOffset(6,e,0)}static addG(n,e){n.addFieldOffset(7,e,0)}static addFloats(n,e){n.addFieldOffset(8,e,0)}static createFloatsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addFloat32(e[t]);return n.endVector()}static startFloatsVector(n,e){n.startVector(4,e,4)}static addInts(n,e){n.addFieldOffset(9,e,0)}static createIntsVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startIntsVector(n,e){n.startVector(8,e,8)}static addStrings(n,e){n.addFieldOffset(10,e,0)}static createStringsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startStringsVector(n,e){n.startVector(4,e,4)}static addTensors(n,e){n.addFieldOffset(11,e,0)}static createTensorsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startTensorsVector(n,e){n.startVector(4,e,4)}static addGraphs(n,e){n.addFieldOffset(12,e,0)}static createGraphsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startGraphsVector(n,e){n.startVector(4,e,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,e,t,r,i,l,d,g,b,v,w,x,T,O){return a.startAttribute(n),a.addName(n,e),a.addDocString(n,t),a.addType(n,r),a.addF(n,i),a.addI(n,l),a.addS(n,d),a.addT(n,g),a.addG(n,b),a.addFloats(n,v),a.addInts(n,w),a.addStrings(n,x),a.addTensors(n,T),a.addGraphs(n,O),a.endAttribute(n)}}s.Attribute=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsGraph(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,e){let t=this.bb.__offset(this.bb_pos,8);return t?(e||new p.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,e){let t=this.bb.__offset(this.bb_pos,12);return t?(e||new p.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,e){let t=this.bb.__offset(this.bb_pos,18);return t?(e||new p.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,e){n.addFieldOffset(0,e,0)}static createInitializersVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startInitializersVector(n,e){n.startVector(4,e,4)}static addNodeArgs(n,e){n.addFieldOffset(1,e,0)}static createNodeArgsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startNodeArgsVector(n,e){n.startVector(4,e,4)}static addNodes(n,e){n.addFieldOffset(2,e,0)}static createNodesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startNodesVector(n,e){n.startVector(4,e,4)}static addMaxNodeIndex(n,e){n.addFieldInt32(3,e,0)}static addNodeEdges(n,e){n.addFieldOffset(4,e,0)}static createNodeEdgesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startNodeEdgesVector(n,e){n.startVector(4,e,4)}static addInputs(n,e){n.addFieldOffset(5,e,0)}static createInputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startInputsVector(n,e){n.startVector(4,e,4)}static addOutputs(n,e){n.addFieldOffset(6,e,0)}static createOutputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startOutputsVector(n,e){n.startVector(4,e,4)}static addSparseInitializers(n,e){n.addFieldOffset(7,e,0)}static createSparseInitializersVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startSparseInitializersVector(n,e){n.startVector(4,e,4)}static endGraph(n){return n.endObject()}static createGraph(n,e,t,r,i,l,d,g,b){return a.startGraph(n),a.addInitializers(n,e),a.addNodeArgs(n,t),a.addNodes(n,r),a.addMaxNodeIndex(n,i),a.addNodeEdges(n,l),a.addInputs(n,d),a.addOutputs(n,g),a.addSparseInitializers(n,b),a.endGraph(n)}}s.Graph=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsModel(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}producerVersion(n){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,n):null}domain(n){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,n):null}graph(n){let e=this.bb.__offset(this.bb_pos,18);return e?(n||new p.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}graphDocString(n){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,e){n.addFieldInt64(0,e,n.createLong(0,0))}static addOpsetImport(n,e){n.addFieldOffset(1,e,0)}static createOpsetImportVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startOpsetImportVector(n,e){n.startVector(4,e,4)}static addProducerName(n,e){n.addFieldOffset(2,e,0)}static addProducerVersion(n,e){n.addFieldOffset(3,e,0)}static addDomain(n,e){n.addFieldOffset(4,e,0)}static addModelVersion(n,e){n.addFieldInt64(5,e,n.createLong(0,0))}static addDocString(n,e){n.addFieldOffset(6,e,0)}static addGraph(n,e){n.addFieldOffset(7,e,0)}static addGraphDocString(n,e){n.addFieldOffset(8,e,0)}static endModel(n){return n.endObject()}static createModel(n,e,t,r,i,l,d,g,b,v){return a.startModel(n),a.addIrVersion(n,e),a.addOpsetImport(n,t),a.addProducerName(n,r),a.addProducerVersion(n,i),a.addDomain(n,l),a.addModelVersion(n,d),a.addDocString(n,g),a.addGraph(n,b),a.addGraphDocString(n,v),a.endModel(n)}}s.Model=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsKernelCreateInfos(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*n):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,e){n.addFieldOffset(0,e,0)}static createNodeIndicesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addInt32(e[t]);return n.endVector()}static startNodeIndicesVector(n,e){n.startVector(4,e,4)}static addKernelDefHashes(n,e){n.addFieldOffset(1,e,0)}static createKernelDefHashesVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startKernelDefHashesVector(n,e){n.startVector(8,e,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,e,t){return a.startKernelCreateInfos(n),a.addNodeIndices(n,e),a.addKernelDefHashes(n,t),a.endKernelCreateInfos(n)}}s.KernelCreateInfos=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSubGraphSessionState(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}sessionState(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,e){n.addFieldOffset(0,e,0)}static addSessionState(n,e){n.addFieldOffset(1,e,0)}static endSubGraphSessionState(n){let e=n.endObject();return n.requiredField(e,4),e}static createSubGraphSessionState(n,e,t){return a.startSubGraphSessionState(n),a.addGraphId(n,e),a.addSessionState(n,t),a.endSubGraphSessionState(n)}}s.SubGraphSessionState=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSessionState(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}subGraphSessionStates(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,e){n.addFieldOffset(0,e,0)}static addSubGraphSessionStates(n,e){n.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startSubGraphSessionStatesVector(n,e){n.startVector(4,e,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,e,t){return a.startSessionState(n),a.addKernels(n,e),a.addSubGraphSessionStates(n,t),a.endSessionState(n)}}s.SessionState=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsInferenceSession(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}model(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}sessionState(n){let e=this.bb.__offset(this.bb_pos,8);return e?(n||new p.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,e){n.addFieldOffset(0,e,0)}static addModel(n,e){n.addFieldOffset(1,e,0)}static addSessionState(n,e){n.addFieldOffset(2,e,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,e){n.finish(e,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,e){n.finish(e,"ORTM",!0)}static createInferenceSession(n,e,t,r){return a.startInferenceSession(n),a.addOrtVersion(n,e),a.addModel(n,t),a.addSessionState(n,r),a.endInferenceSession(n)}}s.InferenceSession=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={}))},1723:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.OnnxjsSessionHandler=void 0;let m=y(2235),f=y(9240);c.OnnxjsSessionHandler=class{constructor(h){this.session=h,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(h,p,u){let s=new Map;for(let n in h)if(Object.hasOwnProperty.call(h,n)){let e=h[n];s.set(n,new f.Tensor(e.dims,e.type,void 0,void 0,e.data))}let a=await this.session.run(s),o={};return a.forEach((n,e)=>{o[e]=new m.Tensor(n.type,n.data,n.dims)}),o}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Session=void 0;let m=y(7067),f=y(1296),h=y(1975),p=y(6496),u=y(1315),s=y(1745);c.Session=class{constructor(a={}){this._initialized=!1,this.backendHint=a.backendHint,this.profiler=u.Profiler.create(a.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(a,o,n){await this.profiler.event("session","Session.loadModel",async()=>{let e=await(0,h.resolveBackend)(this.backendHint);if(this.sessionHandler=e.createSessionHandler(this.context),this._model=new s.Model,typeof a=="string"){let t=a.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let r=await(0,f.promisify)(m.readFile)(a);this.initialize(r,t)}else{let r=await fetch(a),i=await r.arrayBuffer();this.initialize(new Uint8Array(i),t)}}else if(ArrayBuffer.isView(a))this.initialize(a);else{let t=new Uint8Array(a,o||0,n||a.byteLength);this.initialize(t)}})}initialize(a,o){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(a,n,o),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new p.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(a){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let o=this.normalizeAndValidateInputs(a),n=await this._executionPlan.execute(this.sessionHandler,o);return this.createOutput(n)})}normalizeAndValidateInputs(a){let o=this._model.graph.getInputNames();if(Array.isArray(a)){if(a.length!==o.length)throw new Error(`incorrect input array length: expected ${o.length} but got ${a.length}`)}else{if(a.size!==o.length)throw new Error(`incorrect input map size: expected ${o.length} but got ${a.size}`);let n=new Array(a.size),e=0;for(let t=0;t<o.length;++t){let r=a.get(o[t]);if(!r)throw new Error(`missing input tensor for: '${name}'`);n[e++]=r}a=n}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,a,!1);else{let n=this._model.graph.getInputIndices(),e=this._model.graph.getValues(),t=new Array(n.length);for(let r=0;r<n.length;++r){let i=e[n[r]];t[r]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(a[r].dims)}this.validateInputTensorDims(t,a,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,a),a}validateInputTensorTypes(a,o){for(let n=0;n<o.length;n++){let e=a[n],t=o[n].type;if(e!==t)throw new Error(`input tensor[${n}] check failed: expected type '${e}' but got ${t}`)}}validateInputTensorDims(a,o,n){for(let e=0;e<o.length;e++){let t=a[e],r=o[e].dims;if(!this.compareTensorDims(t,r,n))throw new Error(`input tensor[${e}] check failed: expected shape '[${t.join(",")}]' but got [${r.join(",")}]`)}}compareTensorDims(a,o,n){if(a.length!==o.length)return!1;for(let e=0;e<a.length;++e)if(a[e]!==o[e]&&(!n||a[e]!==0))return!1;return!0}createOutput(a){let o=this._model.graph.getOutputNames();if(a.length!==o.length)throw new Error("expected number of outputs do not match number of generated outputs");let n=new Map;for(let e=0;e<o.length;++e)n.set(o[e],a[e]);return n}initializeOps(a){let o=a.getNodes();this._ops=new Array(o.length);for(let n=0;n<o.length;n++)this._ops[n]=this.sessionHandler.resolve(o[n],this._model.opsets,a)}}},9240:function(M,c,y){"use strict";var m=this&&this.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(c,"__esModule",{value:!0}),c.Tensor=void 0;let f=y(3442),h=m(y(1583)),p=y(5127),u=y(2446),s=y(7273);var a=p.onnxruntime.experimental.fbs;class o{get data(){if(this.cache===void 0){let l=this.dataProvider(this.dataId);if(l.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=l}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(l){return this.data[s.ShapeUtil.indicesToOffset(l,this.strides)]}set(l,d){this.data[s.ShapeUtil.indicesToOffset(l,this.strides)]=d}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=s.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(l,d,g,b,v,w=f.Guid.create()){this.dims=l,this.type=d,this.dataProvider=g,this.asyncDataProvider=b,this.cache=v,this.dataId=w,this.size=s.ShapeUtil.validateDimsAndCalcSize(l);let x=this.size,T=g===void 0&&b===void 0&&v===void 0;if(v!==void 0&&v.length!==x)throw new RangeError("Input dims doesn't match data length.");if(d==="string"){if(!(v===void 0||Array.isArray(v)&&v.every(O=>typeof O=="string")))throw new TypeError("cache should be a string array");T&&(this.cache=new Array(x))}else{if(v!==void 0){let O=e(d);if(!(v instanceof O))throw new TypeError(`cache should be type ${O.name}`)}if(T){let O=new ArrayBuffer(x*function(P){switch(P){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${P}`)}}(d));this.cache=function(P,I){return new(e(I))(P)}(O,d)}}}static fromProto(l){if(!l)throw new Error("cannot construct Value from an empty tensor");let d=s.ProtoUtil.tensorDataTypeFromProto(l.dataType),g=s.ProtoUtil.tensorDimsFromProto(l.dims),b=new o(g,d);if(d==="string")l.stringData.forEach((v,w)=>{b.data[w]=(0,s.decodeUtf8String)(v)});else if(l.rawData&&typeof l.rawData.byteLength=="number"&&l.rawData.byteLength>0){let v=b.data,w=new DataView(l.rawData.buffer,l.rawData.byteOffset,l.rawData.byteLength),x=n(l.dataType),T=l.rawData.byteLength/x;if(l.rawData.byteLength%x!=0)throw new Error("invalid buffer length");if(v.length!==T)throw new Error("buffer length mismatch");for(let O=0;O<T;O++){let P=r(w,l.dataType,O*x);v[O]=P}}else{let v;switch(l.dataType){case u.onnx.TensorProto.DataType.FLOAT:v=l.floatData;break;case u.onnx.TensorProto.DataType.INT32:case u.onnx.TensorProto.DataType.INT16:case u.onnx.TensorProto.DataType.UINT16:case u.onnx.TensorProto.DataType.INT8:case u.onnx.TensorProto.DataType.UINT8:case u.onnx.TensorProto.DataType.BOOL:v=l.int32Data;break;case u.onnx.TensorProto.DataType.INT64:v=l.int64Data;break;case u.onnx.TensorProto.DataType.DOUBLE:v=l.doubleData;break;case u.onnx.TensorProto.DataType.UINT32:case u.onnx.TensorProto.DataType.UINT64:v=l.uint64Data;break;default:throw new Error("unspecific error")}if(v==null)throw new Error("failed to populate data from a tensorproto value");let w=b.data;if(w.length!==v.length)throw new Error("array length mismatch");for(let x=0;x<v.length;x++){let T=v[x];h.default.isLong(T)?w[x]=t(T,l.dataType):w[x]=T}}return b}static fromData(l,d,g){return new o(d,g,void 0,void 0,l)}static fromOrtTensor(l){if(!l)throw new Error("cannot construct Value from an empty tensor");let d=s.ProtoUtil.tensorDimsFromORTFormat(l),g=s.ProtoUtil.tensorDataTypeFromProto(l.dataType()),b=new o(d,g);if(g==="string")for(let v=0;v<l.stringDataLength();v++)b.data[v]=l.stringData(v);else if(l.rawDataArray()&&typeof l.rawDataLength()=="number"&&l.rawDataLength()>0){let v=b.data,w=new DataView(l.rawDataArray().buffer,l.rawDataArray().byteOffset,l.rawDataLength()),x=n(l.dataType()),T=l.rawDataLength()/x;if(l.rawDataLength()%x!=0)throw new Error("invalid buffer length");if(v.length!==T)throw new Error("buffer length mismatch");for(let O=0;O<T;O++){let P=r(w,l.dataType(),O*x);v[O]=P}}return b}}function n(i){switch(i){case u.onnx.TensorProto.DataType.UINT8:case u.onnx.TensorProto.DataType.INT8:case u.onnx.TensorProto.DataType.BOOL:return 1;case u.onnx.TensorProto.DataType.UINT16:case u.onnx.TensorProto.DataType.INT16:return 2;case u.onnx.TensorProto.DataType.FLOAT:case u.onnx.TensorProto.DataType.INT32:case u.onnx.TensorProto.DataType.UINT32:return 4;case u.onnx.TensorProto.DataType.INT64:case u.onnx.TensorProto.DataType.DOUBLE:case u.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${u.onnx.TensorProto.DataType[i]}`)}}function e(i){switch(i){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function t(i,l){if(l===u.onnx.TensorProto.DataType.INT64||l===a.TensorDataType.INT64){if(i.greaterThanOrEqual(2147483648)||i.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(l!==u.onnx.TensorProto.DataType.UINT32&&l!==a.TensorDataType.UINT32&&l!==u.onnx.TensorProto.DataType.UINT64&&l!==a.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${u.onnx.TensorProto.DataType[l]}`);if(i.greaterThanOrEqual(4294967296)||i.lessThan(0))throw new TypeError("uint64 is not supported")}return i.toNumber()}function r(i,l,d){switch(l){case u.onnx.TensorProto.DataType.BOOL:case u.onnx.TensorProto.DataType.UINT8:return i.getUint8(d);case u.onnx.TensorProto.DataType.INT8:return i.getInt8(d);case u.onnx.TensorProto.DataType.UINT16:return i.getUint16(d,!0);case u.onnx.TensorProto.DataType.INT16:return i.getInt16(d,!0);case u.onnx.TensorProto.DataType.FLOAT:return i.getFloat32(d,!0);case u.onnx.TensorProto.DataType.INT32:return i.getInt32(d,!0);case u.onnx.TensorProto.DataType.UINT32:return i.getUint32(d,!0);case u.onnx.TensorProto.DataType.INT64:return t(h.default.fromBits(i.getUint32(d,!0),i.getUint32(d+4,!0),!1),l);case u.onnx.TensorProto.DataType.DOUBLE:return i.getFloat64(d,!0);case u.onnx.TensorProto.DataType.UINT64:return t(h.default.fromBits(i.getUint32(d,!0),i.getUint32(d+4,!0),!0),l);default:throw new Error(`cannot read from DataView for type ${u.onnx.TensorProto.DataType[l]}`)}}c.Tensor=o},7273:function(M,c,y){"use strict";var m=this&&this.__importDefault||function(l){return l&&l.__esModule?l:{default:l}};Object.defineProperty(c,"__esModule",{value:!0}),c.decodeUtf8String=c.MAX_CLIP=c.MIN_CLIP=c.PoolConvUtil=c.ReduceUtil=c.SplitUtil=c.MathUtil=c.ShapeUtil=c.LongUtil=c.ProtoUtil=c.GemmUtil=c.arrayCopyHelper=c.BroadcastUtil=c.MatMulUtil=c.ArrayUtil=c.assert=c.checkInputsShape=void 0;let f=y(5686),h=m(y(1583)),p=y(2446),u=y(9240);c.checkInputsShape=function(l,...d){if(!l||l.length!==d.length)return!1;for(let g=0;g<l.length;g++)if(!l[g].dims||l[g].dims.length!==d[g])return!1;return!0},c.assert=function(l,d){if(!l)throw new Error(typeof d=="string"?d:d())},c.ArrayUtil=class{static arraysEqual(l,d){if(l.length!==d.length)return!1;for(let g=0;g<l.length;g++)if(l[g]!==d[g])return!1;return!0}};class s{static preprocessInputShapes(d,g){return[d.length===1?[1,d[0]]:d,g.length===1?[g[0],1]:g]}static postprocessOutputShape(d,g,b){g===1&&d.splice(d.length-2,1),b===1&&d.pop()}static calcMatMulShape(d,g){return d[1]!==g[0]?void 0:[d[0],g[1]]}}c.MatMulUtil=s;class a{static calcShape(d,g,b=!1){let v=d.length,w=g.length;if(v===0)return g;if(w===0)return d;let x=Math.max(d.length,g.length),T=new Array(x);if(b){if(v<2||w<2)return;let O=s.calcMatMulShape([d[v-2],d[v-1]],[g[w-2],g[w-1]]);if(O===void 0)return;[T[x-2],T[x-1]]=O}for(let O=b?3:1;O<=x;O++){let P=v-O<0?1:d[v-O],I=w-O<0?1:g[w-O];if(P!==I&&P>1&&I>1)return;T[x-O]=Math.max(P,I)}return T}static index(d,g){let b=new Array(g.length);return a.fillIndex(d,g,b),b}static fillIndex(d,g,b){let v=d.length-g.length;for(let w=0;w<g.length;w++)b[w]=d[v+w]%g[w]}static calc(d,g,b,v,w){let x=a.calcShape(d.dims,g.dims);if(x){if(v&&!e.areEqual(x,d.dims))return;let T=e.size(x),O=v?d:new u.Tensor(x,w||d.type);if(x.length===0)O.set([],b(d.get([]),g.get([])));else{let P=new Array(x.length),I=new Array(d.dims.length),R=new Array(g.dims.length),j,A=0,C=0,_=!1,S=!1;d.dims.length===0&&(A=d.get([]),_=!0),g.dims.length===0&&(C=g.get([]),S=!0);for(let E=0;E<T;E++){j=E;for(let z=x.length-1;z>=0;z--)P[z]=j%x[z],j=Math.floor(j/x[z]);_||(a.fillIndex(P,d.dims,I),A=d.get(I)),S||(a.fillIndex(P,g.dims,R),C=g.get(R)),O.set(P,b(A,C))}}return O}}static isValidBroadcast(d,g){let b=d.length,v=g.length;if(b>v)return!1;for(let w=1;w<=b;w++)if(d[b-w]!==1&&d[b-w]!==g[v-w])return!1;return!0}static getBroadcastDims(d,g){let b=d.length,v=[];for(let w=0;w<b;w++){let x=b-1-w,T=d[x]||1;(g[g.length-1-w]||1)>1&&T===1&&v.unshift(x)}return v}}c.BroadcastUtil=a,c.arrayCopyHelper=function(l,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)l[g+w]=d[b+w]},c.GemmUtil=class{static getShapeOfGemmResult(l,d,g,b,v){if(l.length!==2||g.length!==2)throw new Error("shape need to be of size 2");let w,x,T;d?(w=l[1],x=l[0]):(w=l[0],x=l[1]);let O=-1;if(b?(T=g[0],O=1):(T=g[1],O=0),g[O]!==x)throw new Error("dimension mismatch");if(w<=0||T<=0||x<=0)throw new Error("invalid shape specified");if(v&&!a.isValidBroadcast(v,[w,T]))throw new Error("gemm: invalid bias shape for broadcast");return[w,T,x]}};class o{static tensorDataTypeFromProto(d){switch(d){case p.onnx.TensorProto.DataType.INT8:return"int8";case p.onnx.TensorProto.DataType.UINT8:return"uint8";case p.onnx.TensorProto.DataType.BOOL:return"bool";case p.onnx.TensorProto.DataType.INT16:return"int16";case p.onnx.TensorProto.DataType.UINT16:return"uint16";case p.onnx.TensorProto.DataType.INT32:return"int32";case p.onnx.TensorProto.DataType.UINT32:return"uint32";case p.onnx.TensorProto.DataType.FLOAT:return"float32";case p.onnx.TensorProto.DataType.DOUBLE:return"float64";case p.onnx.TensorProto.DataType.STRING:return"string";case p.onnx.TensorProto.DataType.INT64:return"int32";case p.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${p.onnx.TensorProto.DataType[d]}`)}}static tensorDataTypeStringToEnum(d){switch(d){case"int8":return p.onnx.TensorProto.DataType.INT8;case"uint8":return p.onnx.TensorProto.DataType.UINT8;case"bool":return p.onnx.TensorProto.DataType.BOOL;case"int16":return p.onnx.TensorProto.DataType.INT16;case"uint16":return p.onnx.TensorProto.DataType.UINT16;case"int32":return p.onnx.TensorProto.DataType.INT32;case"uint32":return p.onnx.TensorProto.DataType.UINT32;case"float32":return p.onnx.TensorProto.DataType.FLOAT;case"float64":return p.onnx.TensorProto.DataType.DOUBLE;case"string":return p.onnx.TensorProto.DataType.STRING;case"int64":return p.onnx.TensorProto.DataType.INT64;case"uint64":return p.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${d}`)}}static tensorDimsFromProto(d){return d.map(g=>h.default.isLong(g)?g.toNumber():g)}static tensorValueTypeFromProto(d){return{tensorType:o.tensorDataTypeFromProto(d.elemType),shape:{dims:o.tensorDimsFromProto(d.shape.dim.map(g=>g.dimValue))}}}static tensorDimsFromORTFormat(d){let g=[];for(let b=0;b<d.dimsLength();b++)g.push(n.longToNumber(d.dims(b)));return g}static tensorAttributesFromORTFormat(d){let g=[];for(let b=0;b<d.attributesLength();b++)g.push(d.attributes(b));return g}}c.ProtoUtil=o;class n{static longToNumber(d,g){return h.default.isLong(d)?d.toNumber():d instanceof f.flatbuffers.Long?h.default.fromValue({low:d.low,high:d.high,unsigned:g!=null&&g}).toNumber():d}static isLong(d){return h.default.isLong(d)||d instanceof f.flatbuffers.Long}}c.LongUtil=n;class e{static size(d){return e.getSizeFromDimensionRange(d,0,d.length)}static sizeFromDimension(d,g){if(g<0||g>d.length)throw new Error(`invalid dimension of ${g} for sizeFromDimension as Tensor has ${d.length} dimensions.`);return e.getSizeFromDimensionRange(d,g,d.length)}static sizeToDimension(d,g){if(g<0||g>d.length)throw new Error(`invalid dimension of ${g} for sizeToDimension as Tensor has ${d.length} dimensions.`);return e.getSizeFromDimensionRange(d,0,g)}static getSizeFromDimensionRange(d,g,b){let v=1;for(let w=g;w<b;w++){if(d[w]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");v*=d[w]}return v}static computeStrides(d){let g=d.length;if(g===0)return[];if(g===1)return[1];let b=new Array(g);b[g-1]=1,b[g-2]=d[g-1];for(let v=g-3;v>=0;--v)b[v]=b[v+1]*d[v+1];return b}static transpose(d){return d.slice().reverse()}static indicesToOffset(d,g,b){b===void 0&&(b=d.length);let v=0;for(let w=0;w<b;++w)v+=g[w]*d[w];return v}static offsetToIndices(d,g){let b=g.length;if(b===0)return[];if(b===1)return[d*g[0]];let v=new Array(g.length);for(let w=0;w<v.length-1;++w)v[w]=Math.floor(d/g[w]),d-=v[w]*g[w];return v[v.length-1]=d,v}static normalizeAxis(d,g){if(d<-g&&d>=g)throw new Error("unsupported axis for this operation.");return d<0?d+g:d}static normalizeAxes(d,g){return d.map(b=>this.normalizeAxis(b,g))}static incrementIndex(d,g,b){if(g.length===0||d.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(b===void 0)b=g.length;else if(b<=0||b>g.length)throw new Error("Incorrect axis to increment on");for(let v=b-1;v>=0&&(d[v]++,!(d[v]<g[v]));--v)d[v]=0}static calculateReshapedDims(d,g){if(g.length===0){if(d.length===0||e.size(d)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let b=g.length,v=new Array(b),w=-1,x=1;for(let O=0;O<b;O++){if(g[O]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(g[O]===-1){if(w!==-1)throw new Error("at most one dimension in shape hints can be -1");w=O}else{if(g[O]===0){if(O>=d.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");v[O]=d[O]}else v[O]=g[O];x*=v[O]}}let T=e.size(d);if(w!==-1){if(T%x!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${d}] Output shape: [${g}]`);v[w]=T/x}else if(x!==T)throw new Error("reshapedDims and originalDims don't have matching sizes");return v}static sortBasedOnPerm(d,g){return g?g.map(b=>d[b]):d.slice().reverse()}static padShape(d,g){let b=d.length;return d.map((v,w)=>v+g[w]+g[w+b])}static areEqual(d,g){return d.length===g.length&&d.every((b,v)=>b===g[v])}static validateDimsAndCalcSize(d){if(d.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let g=1;for(let b of d){if(!Number.isInteger(b))throw new TypeError(`Invalid shape: ${b} is not an integer`);if(b<0||b>2147483647)throw new TypeError(`Invalid shape: length ${b} is not allowed`);g*=b}return g}static flattenShape(d,g){g<0&&(g+=d.length);let b=d.reduce((w,x)=>w*x,1),v=d.slice(g).reduce((w,x)=>w*x,1);return[b/v,v]}static squeezeShape(d,g){let b=new Array;g=e.normalizeAxes(g,d.length);for(let v=0;v<d.length;v++){let w=g.indexOf(v)>=0;if(w&&d[v]!==1)throw new Error("squeeze an axis of size different than 1");(g.length===0&&d[v]>1||g.length>0&&!w)&&b.push(d[v])}return b}static unsqueezeShape(d,g){let b=new Array(d.length+g.length);b.fill(0);for(let w=0;w<g.length;w++){let x=e.normalizeAxis(g[w],b.length);if(x>=b.length)throw new Error("'axes' has an out of range axis");if(b[x]!==0)throw new Error("'axes' has a duplicate axis");b[x]=1}let v=0;for(let w=0;w<b.length;w++)b[w]===0&&(b[w]=d[v++]);if(v!==d.length)throw new Error("the unsqueezed dimension could not be established");return b}}c.ShapeUtil=e,c.MathUtil=class{static sqr(l,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)l[g+w]+=Math.pow(d[b+w],2)}static axpy(l,d,g,b,v,w){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let x=0;x<v;x++)l[g+x]+=w*d[b+x]}static powx(l,d,g,b,v,w){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let x=0;x<v;x++)l[g+x]=Math.pow(d[b+x],w)}static mul(l,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)l[g+w]=d[b+w]*l[g+w]}};class t{static splitShape(d,g,b,v){if(b.length===0){if(!v)throw new Error("need to know number of outputs when the 'split' attribute is not specified");t.determineSplit(d[g],v,b)}let w=[],x=[0];for(let T=0;T<b.length;++T){T!==0&&x.push(x[T-1]+b[T-1]);let O=d.slice();O[g]=b[T],w.push(O)}return[w,x]}static determineSplit(d,g,b){if(d%g!=0)throw new Error("cannot split tensor to equal sized parts");for(let v=0;v<g;++v)b.push(d/g)}}c.SplitUtil=t;class r{static calcReduce(d,g,b,v,w){let x=d.dims.slice(0);g.length===0&&x.forEach((A,C)=>g.push(C));let T=r.calcReduceShape(x,g,!0),O=e.size(T),P=new u.Tensor(T,d.type),I=e.computeStrides(T),R=e.computeStrides(x),j=new Array(x.length);for(let A=0;A<O;A++){let C=e.offsetToIndices(A,I);a.fillIndex(C,x,j),P.set(C,r.calcReduceByAxis(d.numberData,g,x,0,e.indicesToOffset(j,R),v,w))}return b?P:new u.Tensor(r.calcReduceShape(x,g,b),P.type,void 0,void 0,P.data,P.dataId)}static calcReduceByAxis(d,g,b,v,w,x,T){let O=0;if(v>=g.length)return x(d[w]);let P=g[v],I=P>=b.length?1:e.size(b.slice(P+1));for(let R=0;R<b[P];R++)O=R===0?r.calcReduceByAxis(d,g,b,v+1,w,x,T):T(O,r.calcReduceByAxis(d,g,b,v+1,w,x,T)),w+=I;return O}static calcReduceShape(d,g,b){let v=d.slice();for(let w=0;w<g.length;w++)v[g[w]]=b?1:0;return v.filter(w=>w!==0)}}c.ReduceUtil=r;class i{static adjustPoolAttributes(d,g,b,v,w,x){if(!d&&b.length!==g.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(d)for(let T=0;T<g.length-2;T++)T>=b.length?b.push(g[T+2]):b[T]=g[T+2];for(let T=0;T<b.length;T++)if(T<v.length){if(v[T]<0)throw new Error("strides should be greater than or equal to 1")}else v.push(1);for(let T=0;T<b.length;T++)if(T<w.length){if(w[T]<0)throw new Error("dilations should be greater than or equal to 1")}else w.push(1);for(let T=0;T<2*b.length;T++)if(T<x.length){if(x[T]<0)throw new Error("pad should be greater than or equal to 1")}else x.push(0);for(let T=0;T<b.length;T++){if(b[T]<=0)throw new Error("kernel shapes need to be greater than 0");if(x[T]>=b[T]||x[T+b.length]>=b[T])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(d,g,b,v,w,x){if(x){if(w.length!==2*(d.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(g.length!==d.length-2)throw new Error("length of strides should be the length of data dimensions");if(v.length!==d.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let T=0;T<d.length-2;T++)i.adjustPadAndReturnShape(d[T+2],g[T],b[T],v[T],w,T,T+d.length-2,x)}}static computePoolOutputShape(d,g,b,v,w,x,T){if(g.length<=0)throw new Error("input shape must be of size greater than 0");let O=[g[0],g[1]];return i.computeShapeHelper(d,g,O,b,v,w,x,T),O}static computeConvOutputShape(d,g,b,v,w,x,T){if(d.length<=0||g.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let O=[d[0],g[0]];return i.computeShapeHelper(!1,d,O,b,v,w,x,T),O}static computeShapeHelper(d,g,b,v,w,x,T,O){if(d)for(let P=0;P<g.length-2;P++)b.push(1);else for(let P=0;P<g.length-2;P++)b.push(i.adjustPadAndReturnShape(g[P+2],v[P],w[P],x[P],T,P,P+g.length-2,O))}static adjustPadAndReturnShape(d,g,b,v,w,x,T,O){let P=b*(v-1)+1;if(!O||O==="NOTSET")return Math.floor((d+w[x]+w[T]-P)/g+1);switch(O){case"VALID":return w[x]=0,w[T]=0,Math.floor((d-P)/g+1);case"SAME_LOWER":case"SAME_UPPER":if(b!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let I=((d+g-1)/g-1)*g+v-d;return w[x]=Math.floor(O==="SAME_LOWER"?(I+1)/2:I/2),w[T]=I-w[x],Math.floor((d+I-v)/g+1)}default:throw new Error("Unsupported AutoPad type")}}}c.PoolConvUtil=i,c.MIN_CLIP=-34028234663852886e22,c.MAX_CLIP=34028234663852886e22,c.decodeUtf8String=function(l){return new TextDecoder().decode(l)}},8408:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.version=void 0,c.version="1.16.3"},9544:function(M,c,y){"use strict";var m,f=this&&this.__createBinding||(Object.create?function(I,R,j,A){A===void 0&&(A=j);var C=Object.getOwnPropertyDescriptor(R,j);C&&!("get"in C?!R.__esModule:C.writable||C.configurable)||(C={enumerable:!0,get:function(){return R[j]}}),Object.defineProperty(I,A,C)}:function(I,R,j,A){A===void 0&&(A=j),I[A]=R[j]}),h=this&&this.__setModuleDefault||(Object.create?function(I,R){Object.defineProperty(I,"default",{enumerable:!0,value:R})}:function(I,R){I.default=R}),p=this&&this.__importStar||function(I){if(I&&I.__esModule)return I;var R={};if(I!=null)for(var j in I)j!=="default"&&Object.prototype.hasOwnProperty.call(I,j)&&f(R,I,j);return h(R,I),R};Object.defineProperty(c,"__esModule",{value:!0}),c.endProfiling=c.run=c.releaseSession=c.createSession=c.createSessionFinalize=c.createSessionAllocate=c.initializeRuntime=c.initializeWebAssemblyInstance=void 0;let u=y(2235),s=p(y(1259)),a=y(263),o=()=>!!u.env.wasm.proxy&&typeof document<"u",n,e,t,r=!1,i=!1,l=!1,d=[],g=[],b=[],v=[],w=[],x=[],T=()=>{if(r||!i||l||!n)throw new Error("worker not ready")},O=I=>{switch(I.data.type){case"init-wasm":r=!1,I.data.err?(l=!0,e[1](I.data.err)):(i=!0,e[0]());break;case"init-ort":I.data.err?t[1](I.data.err):t[0]();break;case"create_allocate":I.data.err?d.shift()[1](I.data.err):d.shift()[0](I.data.out);break;case"create_finalize":I.data.err?g.shift()[1](I.data.err):g.shift()[0](I.data.out);break;case"create":I.data.err?b.shift()[1](I.data.err):b.shift()[0](I.data.out);break;case"release":I.data.err?v.shift()[1](I.data.err):v.shift()[0]();break;case"run":I.data.err?w.shift()[1](I.data.err):w.shift()[0](I.data.out);break;case"end-profiling":I.data.err?x.shift()[1](I.data.err):x.shift()[0]()}},P=typeof document<"u"?(m=document?.currentScript)===null||m===void 0?void 0:m.src:void 0;c.initializeWebAssemblyInstance=async()=>{if(o()){if(i)return;if(r)throw new Error("multiple calls to 'initWasm()' detected.");if(l)throw new Error("previous call to 'initWasm()' failed.");return r=!0,u.env.wasm.wasmPaths===void 0&&P&&P.indexOf("blob:")!==0&&(u.env.wasm.wasmPaths=P.substr(0,+P.lastIndexOf("/")+1)),new Promise((I,R)=>{n?.terminate(),n=y(8050).Z(),n.onmessage=O,e=[I,R];let j={type:"init-wasm",in:u.env.wasm};n.postMessage(j)})}return(0,a.initializeWebAssembly)(u.env.wasm)},c.initializeRuntime=async I=>{if(o())return T(),new Promise((R,j)=>{t=[R,j];let A={type:"init-ort",in:I};n.postMessage(A)});await s.initRuntime(I)},c.createSessionAllocate=async I=>o()?(T(),new Promise((R,j)=>{d.push([R,j]);let A={type:"create_allocate",in:{model:I}};n.postMessage(A,[I.buffer])})):s.createSessionAllocate(I),c.createSessionFinalize=async(I,R)=>o()?(T(),new Promise((j,A)=>{g.push([j,A]);let C={type:"create_finalize",in:{modeldata:I,options:R}};n.postMessage(C)})):s.createSessionFinalize(I,R),c.createSession=async(I,R)=>o()?(T(),new Promise((j,A)=>{b.push([j,A]);let C={type:"create",in:{model:I,options:R}};n.postMessage(C,[I.buffer])})):s.createSession(I,R),c.releaseSession=async I=>{if(o())return T(),new Promise((R,j)=>{v.push([R,j]);let A={type:"release",in:I};n.postMessage(A)});s.releaseSession(I)},c.run=async(I,R,j,A,C)=>o()?(T(),new Promise((_,S)=>{w.push([_,S]);let E={type:"run",in:{sessionId:I,inputIndices:R,inputs:j,outputIndices:A,options:C}};n.postMessage(E,s.extractTransferableBuffers(j))})):s.run(I,R,j,A,C),c.endProfiling=async I=>{if(o())return T(),new Promise((R,j)=>{x.push([R,j]);let A={type:"end-profiling",in:I};n.postMessage(A)});s.endProfiling(I)}},7918:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.setRunOptions=void 0;let m=y(263),f=y(1497);c.setRunOptions=h=>{let p=(0,m.getInstance)(),u=0,s=[],a=h||{};try{if(h?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof h.logSeverityLevel!="number"||!Number.isInteger(h.logSeverityLevel)||h.logSeverityLevel<0||h.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${h.logSeverityLevel}`);if(h?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof h.logVerbosityLevel!="number"||!Number.isInteger(h.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${h.logVerbosityLevel}`);h?.terminate===void 0&&(a.terminate=!1);let o=0;return h?.tag!==void 0&&(o=(0,f.allocWasmString)(h.tag,s)),u=p._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,o),u===0&&(0,f.checkLastError)("Can't create run options."),h?.extra!==void 0&&(0,f.iterateExtraOptions)(h.extra,"",new WeakSet,(n,e)=>{let t=(0,f.allocWasmString)(n,s),r=(0,f.allocWasmString)(e,s);p._OrtAddRunConfigEntry(u,t,r)!==0&&(0,f.checkLastError)(`Can't set a run config entry: ${n} - ${e}.`)}),[u,s]}catch(o){throw u!==0&&p._OrtReleaseRunOptions(u),s.forEach(n=>p._free(n)),o}}},6640:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.OnnxruntimeWebAssemblySessionHandler=void 0;let m=y(2806),f=y(2235),h=y(2850),p=y(9544),u;c.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(s){let a=await fetch(s);if(a.status!==200)throw new Error(`failed to load model: ${s}`);let o=await a.arrayBuffer();return(0,p.createSessionAllocate)(new Uint8Array(o))}async loadModel(s,a){if(u||(await(0,p.initializeRuntime)(f.env),u=!0),typeof s=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let o=await(0,h.promisify)(m.readFile)(s);[this.sessionId,this.inputNames,this.outputNames]=await(0,p.createSession)(o,a)}else{let o=await this.createSessionAllocate(s);[this.sessionId,this.inputNames,this.outputNames]=await(0,p.createSessionFinalize)(o,a)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,p.createSession)(s,a)}async dispose(){return(0,p.releaseSession)(this.sessionId)}async run(s,a,o){let n=[],e=[];Object.entries(s).forEach(l=>{let d=l[0],g=l[1],b=this.inputNames.indexOf(d);if(b===-1)throw new Error(`invalid input '${d}'`);n.push(g),e.push(b)});let t=[];Object.entries(a).forEach(l=>{let d=l[0],g=this.outputNames.indexOf(d);if(g===-1)throw new Error(`invalid output '${d}'`);t.push(g)});let r=await(0,p.run)(this.sessionId,e,n.map(l=>[l.type,l.dims,l.data]),t,o),i={};for(let l=0;l<r.length;l++)i[this.outputNames[t[l]]]=new f.Tensor(r[l][0],r[l][2],r[l][1]);return i}startProfiling(){}endProfiling(){(0,p.endProfiling)(this.sessionId)}}},7622:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.setSessionOptions=void 0;let m=y(263),f=y(1497);c.setSessionOptions=h=>{var p,u,s,a;let o=(0,m.getInstance)(),n=0,e=[],t=h||{};(r=>{r.extra||(r.extra={}),r.extra.session||(r.extra.session={});let i=r.extra.session;i.use_ort_model_bytes_directly||(i.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(l=>(typeof l=="string"?l:l.name)==="webgpu")&&(r.enableMemPattern=!1)})(t);try{let r=(v=>{switch(v){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${v}`)}})((p=t.graphOptimizationLevel)!==null&&p!==void 0?p:"all"),i=(v=>{switch(v){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${v}`)}})((u=t.executionMode)!==null&&u!==void 0?u:"sequential"),l=typeof t.logId=="string"?(0,f.allocWasmString)(t.logId,e):0,d=(s=t.logSeverityLevel)!==null&&s!==void 0?s:2;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log serverity level is not valid: ${d}`);let g=(a=t.logVerbosityLevel)!==null&&a!==void 0?a:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);let b=typeof t.optimizedModelFilePath=="string"?(0,f.allocWasmString)(t.optimizedModelFilePath,e):0;return n=o._OrtCreateSessionOptions(r,!!t.enableCpuMemArena,!!t.enableMemPattern,i,!!t.enableProfiling,0,l,d,g,b),n===0&&(0,f.checkLastError)("Can't create session options."),t.executionProviders&&((v,w,x)=>{for(let T of w){let O=typeof T=="string"?T:T.name;switch(O){case"xnnpack":O="XNNPACK";break;case"webnn":if(O="WEBNN",typeof T!="string"){let I=T;if(I?.deviceType){let R=(0,f.allocWasmString)("deviceType",x),j=(0,f.allocWasmString)(I.deviceType,x);(0,m.getInstance)()._OrtAddSessionConfigEntry(v,R,j)!==0&&(0,f.checkLastError)(`Can't set a session config entry: 'deviceType' - ${I.deviceType}.`)}if(I?.powerPreference){let R=(0,f.allocWasmString)("powerPreference",x),j=(0,f.allocWasmString)(I.powerPreference,x);(0,m.getInstance)()._OrtAddSessionConfigEntry(v,R,j)!==0&&(0,f.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${I.powerPreference}.`)}}break;case"webgpu":O="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${O}`)}let P=(0,f.allocWasmString)(O,x);(0,m.getInstance)()._OrtAppendExecutionProvider(v,P)!==0&&(0,f.checkLastError)(`Can't append execution provider: ${O}.`)}})(n,t.executionProviders,e),t.extra!==void 0&&(0,f.iterateExtraOptions)(t.extra,"",new WeakSet,(v,w)=>{let x=(0,f.allocWasmString)(v,e),T=(0,f.allocWasmString)(w,e);o._OrtAddSessionConfigEntry(n,x,T)!==0&&(0,f.checkLastError)(`Can't set a session config entry: ${v} - ${w}.`)}),[n,e]}catch(r){throw n!==0&&o._OrtReleaseSessionOptions(n),e.forEach(i=>o._free(i)),r}}},7917:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.logLevelStringToEnum=c.tensorTypeToTypedArrayConstructor=c.getTensorElementSize=c.tensorDataTypeEnumToString=c.tensorDataTypeStringToEnum=void 0,c.tensorDataTypeStringToEnum=y=>{switch(y){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${y}`)}},c.tensorDataTypeEnumToString=y=>{switch(y){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${y}`)}},c.getTensorElementSize=y=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][y],c.tensorTypeToTypedArrayConstructor=y=>{switch(y){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${y}`)}},c.logLevelStringToEnum=y=>{switch(y){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${y}`)}}},1259:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.extractTransferableBuffers=c.endProfiling=c.run=c.releaseSession=c.createSession=c.createSessionFinalize=c.createSessionAllocate=c.initRuntime=void 0;let m=y(7918),f=y(7622),h=y(7917),p=y(263),u=y(1497);c.initRuntime=async a=>{var o,n;o=a.wasm.numThreads,n=(0,h.logLevelStringToEnum)(a.logLevel),(0,p.getInstance)()._OrtInit(o,n)!==0&&(0,u.checkLastError)("Can't initialize onnxruntime.")};let s=new Map;c.createSessionAllocate=a=>{let o=(0,p.getInstance)(),n=o._malloc(a.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${a.byteLength}.`);return o.HEAPU8.set(a,n),[n,a.byteLength]},c.createSessionFinalize=(a,o)=>{let n=(0,p.getInstance)(),e=0,t=0,r=[],i=[],l=[];try{[t,r]=(0,f.setSessionOptions)(o),e=n._OrtCreateSession(a[0],a[1],t),e===0&&(0,u.checkLastError)("Can't create a session.");let[d,g]=(w=>{let x=(0,p.getInstance)(),T=x.stackSave();try{let O=x.stackAlloc(8);return x._OrtGetInputOutputCount(w,O,O+4)!==0&&(0,u.checkLastError)("Can't get session input/output count."),[x.HEAP32[O/4],x.HEAP32[O/4+1]]}finally{x.stackRestore(T)}})(e),b=[],v=[];for(let w=0;w<d;w++){let x=n._OrtGetInputName(e,w);x===0&&(0,u.checkLastError)("Can't get an input name."),i.push(x),b.push(n.UTF8ToString(x))}for(let w=0;w<g;w++){let x=n._OrtGetOutputName(e,w);x===0&&(0,u.checkLastError)("Can't get an output name."),l.push(x),v.push(n.UTF8ToString(x))}return s.set(e,[e,i,l]),[e,b,v]}catch(d){throw i.forEach(g=>n._OrtFree(g)),l.forEach(g=>n._OrtFree(g)),e!==0&&n._OrtReleaseSession(e),d}finally{n._free(a[0]),t!==0&&n._OrtReleaseSessionOptions(t),r.forEach(d=>n._free(d))}},c.createSession=(a,o)=>{let n=(0,c.createSessionAllocate)(a);return(0,c.createSessionFinalize)(n,o)},c.releaseSession=a=>{let o=(0,p.getInstance)(),n=s.get(a);if(!n)throw new Error(`cannot release session. invalid session id: ${a}`);let[e,t,r]=n;t.forEach(i=>o._OrtFree(i)),r.forEach(i=>o._OrtFree(i)),o._OrtReleaseSession(e),s.delete(a)},c.run=async(a,o,n,e,t)=>{let r=(0,p.getInstance)(),i=s.get(a);if(!i)throw new Error(`cannot run inference. invalid session id: ${a}`);let[l,d,g]=i,b=o.length,v=e.length,w=0,x=[],T=[],O=[];try{[w,x]=(0,m.setRunOptions)(t);for(let C=0;C<b;C++){let _=n[C][0],S=n[C][1],E=n[C][2],z,L;if(Array.isArray(E)){L=4*E.length,z=r._malloc(L),O.push(z);let te=z/4;for(let ae=0;ae<E.length;ae++){if(typeof E[ae]!="string")throw new TypeError(`tensor data at index ${ae} is not a string`);r.HEAPU32[te++]=(0,u.allocWasmString)(E[ae],O)}}else L=E.byteLength,z=r._malloc(L),O.push(z),r.HEAPU8.set(new Uint8Array(E.buffer,E.byteOffset,L),z);let Y=r.stackSave(),X=r.stackAlloc(4*S.length);try{let te=X/4;S.forEach(se=>r.HEAP32[te++]=se);let ae=r._OrtCreateTensor((0,h.tensorDataTypeStringToEnum)(_),z,L,X,S.length);ae===0&&(0,u.checkLastError)(`Can't create tensor for input[${C}].`),T.push(ae)}finally{r.stackRestore(Y)}}let P=r.stackSave(),I=r.stackAlloc(4*b),R=r.stackAlloc(4*b),j=r.stackAlloc(4*v),A=r.stackAlloc(4*v);try{let C=I/4,_=R/4,S=j/4,E=A/4;for(let X=0;X<b;X++)r.HEAPU32[C++]=T[X],r.HEAPU32[_++]=d[o[X]];for(let X=0;X<v;X++)r.HEAPU32[S++]=0,r.HEAPU32[E++]=g[e[X]];let z=r._OrtRun(l,R,I,b,A,v,j,w),L=r.jsepRunPromise;L&&L.then!==void 0&&(z=await L);let Y=[];z!==0&&(0,u.checkLastError)("failed to call OrtRun().");for(let X=0;X<v;X++){let te=r.HEAPU32[j/4+X],ae=r.stackSave(),se=r.stackAlloc(16),pe,ge=0;try{z=r._OrtGetTensorData(te,se,se+4,se+8,se+12),z!==0&&(0,u.checkLastError)(`Can't access output tensor data on index ${X}.`);let ve=se/4,Me=r.HEAPU32[ve++];ge=r.HEAPU32[ve++];let De=r.HEAPU32[ve++],je=r.HEAPU32[ve++],_e=[];for(let Pe=0;Pe<je;Pe++)_e.push(r.HEAPU32[De/4+Pe]);r._OrtFree(De);let Be=_e.length===0?1:_e.reduce((Pe,Re)=>Pe*Re);if(pe=(0,h.tensorDataTypeEnumToString)(Me),pe==="string"){let Pe=[],Re=ge/4;for(let Ue=0;Ue<Be;Ue++){let He=r.HEAPU32[Re++],Ze=Ue===Be-1?void 0:r.HEAPU32[Re]-He;Pe.push(r.UTF8ToString(He,Ze))}Y.push([pe,_e,Pe])}else{let Pe=new((0,h.tensorTypeToTypedArrayConstructor)(pe))(Be);new Uint8Array(Pe.buffer,Pe.byteOffset,Pe.byteLength).set(r.HEAPU8.subarray(ge,ge+Pe.byteLength)),Y.push([pe,_e,Pe])}}finally{r.stackRestore(ae),pe==="string"&&ge&&r._free(ge),r._OrtReleaseTensor(te)}}return Y}finally{r.stackRestore(P)}}finally{T.forEach(P=>r._OrtReleaseTensor(P)),O.forEach(P=>r._free(P)),w!==0&&r._OrtReleaseRunOptions(w),x.forEach(P=>r._free(P))}},c.endProfiling=a=>{let o=(0,p.getInstance)(),n=s.get(a);if(!n)throw new Error("invalid session id");let e=n[0],t=o._OrtEndProfiling(e);t===0&&(0,u.checkLastError)("Can't get an profile file name."),o._OrtFree(t)},c.extractTransferableBuffers=a=>{let o=[];for(let n of a){let e=n[2];!Array.isArray(e)&&e.buffer&&o.push(e.buffer)}return o}},263:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(t,r,i,l){l===void 0&&(l=i);var d=Object.getOwnPropertyDescriptor(r,i);d&&!("get"in d?!r.__esModule:d.writable||d.configurable)||(d={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(t,l,d)}:function(t,r,i,l){l===void 0&&(l=i),t[l]=r[i]}),f=this&&this.__setModuleDefault||(Object.create?function(t,r){Object.defineProperty(t,"default",{enumerable:!0,value:r})}:function(t,r){t.default=r}),h=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var r={};if(t!=null)for(var i in t)i!=="default"&&Object.prototype.hasOwnProperty.call(t,i)&&m(r,t,i);return f(r,t),r};Object.defineProperty(c,"__esModule",{value:!0}),c.dispose=c.getInstance=c.initializeWebAssembly=void 0;let p=h(y(6449)),u=y(932),s=y(3474),a,o=!1,n=!1,e=!1;c.initializeWebAssembly=async t=>{if(o)return Promise.resolve();if(n)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(e)throw new Error("previous call to 'initializeWebAssembly()' failed.");n=!0;let r=t.initTimeout,i=t.numThreads,l=t.simd,d=i>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),g=l&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),b=t.wasmPaths,v=typeof b=="string"?b:void 0,w=((P,I)=>I?P?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":P?"ort-wasm-simd.wasm":"ort-wasm.wasm")(g,d),x=typeof b=="object"?b[w]:void 0,T=!1,O=[];if(r>0&&O.push(new Promise(P=>{setTimeout(()=>{T=!0,P()},r)})),O.push(new Promise((P,I)=>{let R=d?s:u,j={locateFile:(A,C)=>d&&A.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([y(4154)],{type:"text/javascript"})):A.endsWith(".wasm")?x||(v??C)+w:C+A};if(d)if(typeof Blob>"u")j.mainScriptUrlOrBlob=p.join(__dirname,"ort-wasm-threaded.js");else{let A=`var ortWasmThreaded=(function(){var _scriptDir;return ${R.toString()}})();`;j.mainScriptUrlOrBlob=new Blob([A],{type:"text/javascript"})}R(j).then(A=>{n=!1,o=!0,a=A,P()},A=>{n=!1,e=!0,I(A)})})),await Promise.race(O),T)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},c.getInstance=()=>{if(o&&a)return a;throw new Error("WebAssembly is not initialized yet.")},c.dispose=()=>{var t;!o||n||e||(n=!0,(t=a.PThread)===null||t===void 0||t.terminateAllThreads(),a=void 0,n=!1,o=!1,e=!0)}},1497:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.checkLastError=c.iterateExtraOptions=c.allocWasmString=void 0;let m=y(263);c.allocWasmString=(f,h)=>{let p=(0,m.getInstance)(),u=p.lengthBytesUTF8(f)+1,s=p._malloc(u);return p.stringToUTF8(f,s,u),h.push(s),s},c.iterateExtraOptions=(f,h,p,u)=>{if(typeof f=="object"&&f!==null){if(p.has(f))throw new Error("Circular reference in options");p.add(f)}Object.entries(f).forEach(([s,a])=>{let o=h?h+s:s;if(typeof a=="object")(0,c.iterateExtraOptions)(a,o+".",p,u);else if(typeof a=="string"||typeof a=="number")u(o,a.toString());else{if(typeof a!="boolean")throw new Error("Can't handle extra config type: "+typeof a);u(o,a?"1":"0")}})},c.checkLastError=f=>{let h=(0,m.getInstance)(),p=h.stackSave();try{let u=h.stackAlloc(8);h._OrtGetLastError(u,u+4);let s=h.HEAP32[u/4],a=h.HEAPU32[u/4+1],o=a?h.UTF8ToString(a):"";throw new Error(`${f} ERROR_CODE: ${s}, ERROR_MESSAGE: ${o}`)}finally{h.stackRestore(p)}}},8050:(M,c,y)=>{"use strict";y.d(c,{Z:()=>h});var m=y(6614),f=y.n(m);function h(){return f()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={918:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],i=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))i.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))i.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(i.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(i.logSeverityLevel,i.logVerbosityLevel,!!i.terminate,n),0===r&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const i=(0,a.allocWasmString)(e,o),s=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,i,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,i;const s=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:"all"),f=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:"sequential"),d="string"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(i=l.logVerbosityLevel)&&void 0!==i?i:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=s._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)("Can\'t create session options."),l.executionProviders&&((e,t,r)=>{for(const o of t){let t="string"==typeof o?o:o.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)("deviceType",r),i=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)("powerPreference",r),i=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,i)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const i=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,i)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,"",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==s._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),c.forEach((e=>s._free(e))),e}}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),i=r(263),s=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,i.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,s.checkLastError)("Can\'t create a session.");const[d,p]=(e=>{const t=(0,i.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,i.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,u;if(Array.isArray(a)){u=4*a.length,i=l._malloc(u),w.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,i=l._malloc(u),w.push(i),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),i);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),i,u,f,n.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),i=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=i/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,i,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,i=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];i=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=i/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(i,i+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),"string"===a&&i&&l._free(i),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=u.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(r(449)),s=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(d)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h="string"==typeof g?g:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(p,o),y="object"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=h?h:t)+m:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=x.buffer&&Y(),x}function n(){return k.buffer!=x.buffer&&Y(),I}function a(){return k.buffer!=x.buffer&&Y(),U}function o(){return k.buffer!=x.buffer&&Y(),L}function i(){return k.buffer!=x.buffer&&Y(),W}var s,u,c=e;c.ready=new Promise(((e,t)=>{s=e,u=t}));var l,f,d,p=Object.assign({},c),g="./this.program",h=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(384),S=r(908);let t;w=y?S.dirname(w)+"/":__dirname+"/",l=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:"utf8")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>"[Emscripten Module object]";try{t=r(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&"undefined"==typeof performance&&(global.performance=r(953).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>O.writeSync(2,e.join(" ")+"\\n"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&te("no native wasm support detected");var k,C,P,D,x,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=x=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te("INITIAL_MEMORY should be larger than STACK_SIZE, was "+j+"! (STACK_SIZE=5242880)"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e="Aborted("+e+")"),H=!0,D=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function re(e){return e.startsWith("data:application/octet-stream;base64,")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw"both async and sync fetching of the wasm failed"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R("failed to asynchronously prepare wasm: "+e),te(e)}))}function oe(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function ie(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:"run",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V="ort-wasm-threaded.wasm")||(V=_(V));var ce="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):"";function de(e){if(b)return qe(1,1,e);D=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(D=e,b)throw me(e),"unwind";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){D=e},rb:["$terminateWorker"],hb:function(){for(var e of ge.Ia)ie(e);for(e of ge.La)ie(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\'Internal error! Worker sent a message "\'+n+\'" to target pthread \'+r.targetThread+", but that thread no longer exists!")}else"checkMailbox"===n?He():"spawnThread"===n?ue(r):"cleanupThread"===n?se(r.thread):"killThread"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],ie(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):"cancelThread"===n?ge.Fa[r.thread].postMessage({cmd:"cancel"}):"loaded"===n?(e.loaded=!0,t(e)):"alert"===n?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"callHandler"===n?c[r.handler](...r.args):n&&R("worker sent an unknown command "+n)},e.onerror=e=>{throw R("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var r,n=[];for(r of["onExit","onAbort","print","printErr"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:"load",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:P})})),bb:function(e){e()},Xa:function(){var e=_("ort-wasm-threaded.worker.js");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,"undefined"==typeof SharedArrayBuffer)return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob="spawnThread",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function De(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function xe(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(D):pe(D)}catch(e){e instanceof oe||"unwind"==e||h(1,e)}}catch(e){e instanceof oe||"unwind"==e||h(1,e)}};function We(e){e>>>=0,"function"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,i,s){return b?qe(17,1,e,t,r,n,a,o,i,s):-52}function Ne(e,t,r,n,a,o,i){if(b)return qe(18,1,e,t,r,n,a,o,i)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,s=0;s<r;s++){var u=n[2+s];i()[o+s>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,i){var s=r+n;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var i=0,s=0;s<r;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}i+=c}return o()[a>>2>>>0]=i,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te("initRandomDevice")})())(e),it=[31,29,31,30,31,30,31,31,30,31,30,31],st=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function i(e,t){return o(e,t,"0")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?it:st)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):""},r=fe(r),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(f,"g"),l[f]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(f in l={"%a":e=>d[e.Ga].substring(0,3),"%A":e=>d[e.Ga],"%b":e=>p[e.Na].substring(0,3),"%B":e=>p[e.Na],"%C":e=>i((e.Ka+1900)/100|0,2),"%d":e=>i(e.Qa,2),"%e":e=>o(e.Qa,2," "),"%g":e=>c(e).toString().substring(2),"%G":e=>c(e),"%H":e=>i(e.Ma,2),"%I":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?it:st)[r++]);return i(e.Qa+t,3)},"%m":e=>i(e.Na+1,2),"%M":e=>i(e.jb,2),"%n":()=>"\\n","%p":e=>0<=e.Ma&&12>e.Ma?"AM":"PM","%S":e=>i(e.kb,2),"%t":()=>"\\t","%u":e=>e.Ga||7,"%U":e=>i(Math.floor((e.Ja+7-e.Ga)/7),2),"%V":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return i(t,2)},"%w":e=>e.Ga,"%W":e=>i(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),"%y":e=>(e.Ka+1900).toString().substring(2),"%Y":e=>e.Ka+1900,"%z":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.lb,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),l)r.includes(f)&&(r=r.replace(new RegExp(f,"g"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,Pe,De,xe,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:"cleanupThread",thread:e}):se(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:Pe,F:De,C:xe,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=ge.Fa[e])&&e.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(i,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,r>>>=0;var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=n(s),t=n(u),e=Be(e),t=Be(t),c<i?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te("")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(993).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=i()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),P=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var r=V;return T||"function"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith("file://")||v||"function"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R("wasm streaming compile failed: "+n),R("falling back to ArrayBuffer instantiation"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,i,s,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,i,s,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,i,s)=>(c._OrtRun=C.na)(e,t,r,n,a,o,i,s),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),s(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)s(c),b||he(N),startWorker(c);else{if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,i,s,u=Object.assign({},a),c="./this.program",l=(e,t)=>{throw t},f="object"==typeof window,d="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,g="";if(p){var h=r(384),m=r(908);g=d?m.dirname(g)+"/":__dirname+"/",o=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:"utf8")),s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,r,n=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:"utf8",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(f||d)&&(d?g=self.location.href:"undefined"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf("blob:")?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},d&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function P(){var e=a.preRun.shift();F.unshift(e)}var D,x,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e="Aborted("+e+")"),M=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function H(e){return e.startsWith("data:application/octet-stream;base64,")}if(!H(D="ort-wasm.wasm")){var Y=D;D=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function z(e,t,r){return function(e){if(!y&&(f||d)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>j(e)));if(i)return new Promise(((t,r)=>{i(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b("failed to asynchronously prepare wasm: "+e),W(e)}))}function G(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):"",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),ie=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?ie:se)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):""},r=J(r),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(l in c={"%a":e=>f[e.ha].substring(0,3),"%A":e=>f[e.ha],"%b":e=>d[e.pa].substring(0,3),"%B":e=>d[e.pa],"%C":e=>o((e.na+1900)/100|0,2),"%d":e=>o(e.ra,2),"%e":e=>a(e.ra,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>o(e.oa,2),"%I":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?ie:se)[r++]);return o(e.ra+t,3)},"%m":e=>o(e.pa+1,2),"%M":e=>o(e.xa,2),"%n":()=>"\\n","%p":e=>0<=e.oa&&12>e.oa?"AM":"PM","%S":e=>o(e.ya,2),"%t":()=>"\\t","%u":e=>e.ha||7,"%U":e=>o(Math.floor((e.ma+7-e.ha)/7),2),"%V":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},"%w":e=>e.ha,"%W":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),"%y":e=>(e.na+1900).toString().substring(2),"%Y":e=>e.na+1900,"%z":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.za,"%%":()=>"%"},r=r.replace(/%%/g,"\\0\\0"),c)r.includes(l)&&(r=r.replace(new RegExp(l,"g"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((x=e,1<=+Math.abs(x)?0<x?+Math.floor(x/4294967296)>>>0:~~+Math.ceil((x-+(~~x>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,s),A[t>>>0>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=te(e),t=te(t),s<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=T[t>>2>>>0],s=T[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=E[i+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=s}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b("Module.instantiateWasm callback failed with error: "+e),n(e)}(function(e,t){var r=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith("file://")||p||"function"!=typeof fetch?z(r,e,t):fetch(r,{credentials:"same-origin"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b("wasm streaming compile failed: "+n),b("falling back to ArrayBuffer instantiation"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,i,s,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,i,s,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,i,s,u)=>(a._OrtRun=O.da)(e,t,r,n,o,i,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)P();N(F),0<I||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{"use strict";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:n})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:i}=r.data.in;(0,e.run)(t,n,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:M=>{"use strict";M.exports=function(c,y,m,f){var h=self||window;try{try{var p;try{p=new h.Blob([c])}catch{(p=new(h.BlobBuilder||h.WebKitBlobBuilder||h.MozBlobBuilder||h.MSBlobBuilder)).append(c),p=p.getBlob()}var u=h.URL||h.webkitURL,s=u.createObjectURL(p),a=new h[y](s,m);return u.revokeObjectURL(s),a}catch{return new h[y]("data:application/javascript,".concat(encodeURIComponent(c)),m)}}catch{if(!f)throw Error("Inline worker is not supported");return new h[y](f,m)}}},2446:(M,c,y)=>{"use strict";var m,f,h,p=y(2100),u=p.Reader,s=p.Writer,a=p.util,o=p.roots.default||(p.roots.default={});o.onnx=((h={}).Version=(m={},(f=Object.create(m))[m[0]="_START_VERSION"]=0,f[m[1]="IR_VERSION_2017_10_10"]=1,f[m[2]="IR_VERSION_2017_10_30"]=2,f[m[3]="IR_VERSION_2017_11_3"]=3,f[m[4]="IR_VERSION_2019_1_22"]=4,f[m[5]="IR_VERSION_2019_3_18"]=5,f[m[6]="IR_VERSION_2019_9_19"]=6,f[m[7]="IR_VERSION_2020_5_8"]=7,f[m[8]="IR_VERSION_2021_7_30"]=8,f[m[9]="IR_VERSION"]=9,f),h.AttributeProto=function(){function n(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.name="",n.prototype.refAttrName="",n.prototype.docString="",n.prototype.type=0,n.prototype.f=0,n.prototype.i=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.s=a.newBuffer([]),n.prototype.t=null,n.prototype.g=null,n.prototype.sparseTensor=null,n.prototype.tp=null,n.prototype.floats=a.emptyArray,n.prototype.ints=a.emptyArray,n.prototype.strings=a.emptyArray,n.prototype.tensors=a.emptyArray,n.prototype.graphs=a.emptyArray,n.prototype.sparseTensors=a.emptyArray,n.prototype.typeProtos=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(10).string(e.name),e.f!=null&&Object.hasOwnProperty.call(e,"f")&&t.uint32(21).float(e.f),e.i!=null&&Object.hasOwnProperty.call(e,"i")&&t.uint32(24).int64(e.i),e.s!=null&&Object.hasOwnProperty.call(e,"s")&&t.uint32(34).bytes(e.s),e.t!=null&&Object.hasOwnProperty.call(e,"t")&&o.onnx.TensorProto.encode(e.t,t.uint32(42).fork()).ldelim(),e.g!=null&&Object.hasOwnProperty.call(e,"g")&&o.onnx.GraphProto.encode(e.g,t.uint32(50).fork()).ldelim(),e.floats!=null&&e.floats.length){t.uint32(58).fork();for(var r=0;r<e.floats.length;++r)t.float(e.floats[r]);t.ldelim()}if(e.ints!=null&&e.ints.length){for(t.uint32(66).fork(),r=0;r<e.ints.length;++r)t.int64(e.ints[r]);t.ldelim()}if(e.strings!=null&&e.strings.length)for(r=0;r<e.strings.length;++r)t.uint32(74).bytes(e.strings[r]);if(e.tensors!=null&&e.tensors.length)for(r=0;r<e.tensors.length;++r)o.onnx.TensorProto.encode(e.tensors[r],t.uint32(82).fork()).ldelim();if(e.graphs!=null&&e.graphs.length)for(r=0;r<e.graphs.length;++r)o.onnx.GraphProto.encode(e.graphs[r],t.uint32(90).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(106).string(e.docString),e.tp!=null&&Object.hasOwnProperty.call(e,"tp")&&o.onnx.TypeProto.encode(e.tp,t.uint32(114).fork()).ldelim(),e.typeProtos!=null&&e.typeProtos.length)for(r=0;r<e.typeProtos.length;++r)o.onnx.TypeProto.encode(e.typeProtos[r],t.uint32(122).fork()).ldelim();if(e.type!=null&&Object.hasOwnProperty.call(e,"type")&&t.uint32(160).int32(e.type),e.refAttrName!=null&&Object.hasOwnProperty.call(e,"refAttrName")&&t.uint32(170).string(e.refAttrName),e.sparseTensor!=null&&Object.hasOwnProperty.call(e,"sparseTensor")&&o.onnx.SparseTensorProto.encode(e.sparseTensor,t.uint32(178).fork()).ldelim(),e.sparseTensors!=null&&e.sparseTensors.length)for(r=0;r<e.sparseTensors.length;++r)o.onnx.SparseTensorProto.encode(e.sparseTensors[r],t.uint32(186).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.AttributeProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.name=e.string();break;case 21:i.refAttrName=e.string();break;case 13:i.docString=e.string();break;case 20:i.type=e.int32();break;case 2:i.f=e.float();break;case 3:i.i=e.int64();break;case 4:i.s=e.bytes();break;case 5:i.t=o.onnx.TensorProto.decode(e,e.uint32());break;case 6:i.g=o.onnx.GraphProto.decode(e,e.uint32());break;case 22:i.sparseTensor=o.onnx.SparseTensorProto.decode(e,e.uint32());break;case 14:i.tp=o.onnx.TypeProto.decode(e,e.uint32());break;case 7:if(i.floats&&i.floats.length||(i.floats=[]),(7&l)==2)for(var d=e.uint32()+e.pos;e.pos<d;)i.floats.push(e.float());else i.floats.push(e.float());break;case 8:if(i.ints&&i.ints.length||(i.ints=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.ints.push(e.int64());else i.ints.push(e.int64());break;case 9:i.strings&&i.strings.length||(i.strings=[]),i.strings.push(e.bytes());break;case 10:i.tensors&&i.tensors.length||(i.tensors=[]),i.tensors.push(o.onnx.TensorProto.decode(e,e.uint32()));break;case 11:i.graphs&&i.graphs.length||(i.graphs=[]),i.graphs.push(o.onnx.GraphProto.decode(e,e.uint32()));break;case 23:i.sparseTensors&&i.sparseTensors.length||(i.sparseTensors=[]),i.sparseTensors.push(o.onnx.SparseTensorProto.decode(e,e.uint32()));break;case 15:i.typeProtos&&i.typeProtos.length||(i.typeProtos=[]),i.typeProtos.push(o.onnx.TypeProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&!a.isString(e.refAttrName))return"refAttrName: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.type!=null&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:}if(e.f!=null&&e.hasOwnProperty("f")&&typeof e.f!="number")return"f: number expected";if(e.i!=null&&e.hasOwnProperty("i")&&!(a.isInteger(e.i)||e.i&&a.isInteger(e.i.low)&&a.isInteger(e.i.high)))return"i: integer|Long expected";if(e.s!=null&&e.hasOwnProperty("s")&&!(e.s&&typeof e.s.length=="number"||a.isString(e.s)))return"s: buffer expected";if(e.t!=null&&e.hasOwnProperty("t")&&(r=o.onnx.TensorProto.verify(e.t)))return"t."+r;if(e.g!=null&&e.hasOwnProperty("g")&&(r=o.onnx.GraphProto.verify(e.g)))return"g."+r;if(e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")&&(r=o.onnx.SparseTensorProto.verify(e.sparseTensor)))return"sparseTensor."+r;if(e.tp!=null&&e.hasOwnProperty("tp")&&(r=o.onnx.TypeProto.verify(e.tp)))return"tp."+r;if(e.floats!=null&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var t=0;t<e.floats.length;++t)if(typeof e.floats[t]!="number")return"floats: number[] expected"}if(e.ints!=null&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(t=0;t<e.ints.length;++t)if(!(a.isInteger(e.ints[t])||e.ints[t]&&a.isInteger(e.ints[t].low)&&a.isInteger(e.ints[t].high)))return"ints: integer|Long[] expected"}if(e.strings!=null&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(t=0;t<e.strings.length;++t)if(!(e.strings[t]&&typeof e.strings[t].length=="number"||a.isString(e.strings[t])))return"strings: buffer[] expected"}if(e.tensors!=null&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(t=0;t<e.tensors.length;++t)if(r=o.onnx.TensorProto.verify(e.tensors[t]))return"tensors."+r}if(e.graphs!=null&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(t=0;t<e.graphs.length;++t)if(r=o.onnx.GraphProto.verify(e.graphs[t]))return"graphs."+r}if(e.sparseTensors!=null&&e.hasOwnProperty("sparseTensors")){if(!Array.isArray(e.sparseTensors))return"sparseTensors: array expected";for(t=0;t<e.sparseTensors.length;++t)if(r=o.onnx.SparseTensorProto.verify(e.sparseTensors[t]))return"sparseTensors."+r}if(e.typeProtos!=null&&e.hasOwnProperty("typeProtos")){if(!Array.isArray(e.typeProtos))return"typeProtos: array expected";for(t=0;t<e.typeProtos.length;++t){var r;if(r=o.onnx.TypeProto.verify(e.typeProtos[t]))return"typeProtos."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.AttributeProto)return e;var t=new o.onnx.AttributeProto;switch(e.name!=null&&(t.name=String(e.name)),e.refAttrName!=null&&(t.refAttrName=String(e.refAttrName)),e.docString!=null&&(t.docString=String(e.docString)),e.type){default:if(typeof e.type=="number"){t.type=e.type;break}break;case"UNDEFINED":case 0:t.type=0;break;case"FLOAT":case 1:t.type=1;break;case"INT":case 2:t.type=2;break;case"STRING":case 3:t.type=3;break;case"TENSOR":case 4:t.type=4;break;case"GRAPH":case 5:t.type=5;break;case"SPARSE_TENSOR":case 11:t.type=11;break;case"TYPE_PROTO":case 13:t.type=13;break;case"FLOATS":case 6:t.type=6;break;case"INTS":case 7:t.type=7;break;case"STRINGS":case 8:t.type=8;break;case"TENSORS":case 9:t.type=9;break;case"GRAPHS":case 10:t.type=10;break;case"SPARSE_TENSORS":case 12:t.type=12;break;case"TYPE_PROTOS":case 14:t.type=14}if(e.f!=null&&(t.f=Number(e.f)),e.i!=null&&(a.Long?(t.i=a.Long.fromValue(e.i)).unsigned=!1:typeof e.i=="string"?t.i=parseInt(e.i,10):typeof e.i=="number"?t.i=e.i:typeof e.i=="object"&&(t.i=new a.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),e.s!=null&&(typeof e.s=="string"?a.base64.decode(e.s,t.s=a.newBuffer(a.base64.length(e.s)),0):e.s.length>=0&&(t.s=e.s)),e.t!=null){if(typeof e.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");t.t=o.onnx.TensorProto.fromObject(e.t)}if(e.g!=null){if(typeof e.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");t.g=o.onnx.GraphProto.fromObject(e.g)}if(e.sparseTensor!=null){if(typeof e.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");t.sparseTensor=o.onnx.SparseTensorProto.fromObject(e.sparseTensor)}if(e.tp!=null){if(typeof e.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");t.tp=o.onnx.TypeProto.fromObject(e.tp)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");t.floats=[];for(var r=0;r<e.floats.length;++r)t.floats[r]=Number(e.floats[r])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(t.ints=[],r=0;r<e.ints.length;++r)a.Long?(t.ints[r]=a.Long.fromValue(e.ints[r])).unsigned=!1:typeof e.ints[r]=="string"?t.ints[r]=parseInt(e.ints[r],10):typeof e.ints[r]=="number"?t.ints[r]=e.ints[r]:typeof e.ints[r]=="object"&&(t.ints[r]=new a.LongBits(e.ints[r].low>>>0,e.ints[r].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(t.strings=[],r=0;r<e.strings.length;++r)typeof e.strings[r]=="string"?a.base64.decode(e.strings[r],t.strings[r]=a.newBuffer(a.base64.length(e.strings[r])),0):e.strings[r].length>=0&&(t.strings[r]=e.strings[r])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(t.tensors=[],r=0;r<e.tensors.length;++r){if(typeof e.tensors[r]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");t.tensors[r]=o.onnx.TensorProto.fromObject(e.tensors[r])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(t.graphs=[],r=0;r<e.graphs.length;++r){if(typeof e.graphs[r]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");t.graphs[r]=o.onnx.GraphProto.fromObject(e.graphs[r])}}if(e.sparseTensors){if(!Array.isArray(e.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");for(t.sparseTensors=[],r=0;r<e.sparseTensors.length;++r){if(typeof e.sparseTensors[r]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");t.sparseTensors[r]=o.onnx.SparseTensorProto.fromObject(e.sparseTensors[r])}}if(e.typeProtos){if(!Array.isArray(e.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");for(t.typeProtos=[],r=0;r<e.typeProtos.length;++r){if(typeof e.typeProtos[r]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");t.typeProtos[r]=o.onnx.TypeProto.fromObject(e.typeProtos[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.floats=[],r.ints=[],r.strings=[],r.tensors=[],r.graphs=[],r.typeProtos=[],r.sparseTensors=[]),t.defaults){if(r.name="",r.f=0,a.Long){var i=new a.Long(0,0,!1);r.i=t.longs===String?i.toString():t.longs===Number?i.toNumber():i}else r.i=t.longs===String?"0":0;t.bytes===String?r.s="":(r.s=[],t.bytes!==Array&&(r.s=a.newBuffer(r.s))),r.t=null,r.g=null,r.docString="",r.tp=null,r.type=t.enums===String?"UNDEFINED":0,r.refAttrName="",r.sparseTensor=null}if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.f!=null&&e.hasOwnProperty("f")&&(r.f=t.json&&!isFinite(e.f)?String(e.f):e.f),e.i!=null&&e.hasOwnProperty("i")&&(typeof e.i=="number"?r.i=t.longs===String?String(e.i):e.i:r.i=t.longs===String?a.Long.prototype.toString.call(e.i):t.longs===Number?new a.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),e.s!=null&&e.hasOwnProperty("s")&&(r.s=t.bytes===String?a.base64.encode(e.s,0,e.s.length):t.bytes===Array?Array.prototype.slice.call(e.s):e.s),e.t!=null&&e.hasOwnProperty("t")&&(r.t=o.onnx.TensorProto.toObject(e.t,t)),e.g!=null&&e.hasOwnProperty("g")&&(r.g=o.onnx.GraphProto.toObject(e.g,t)),e.floats&&e.floats.length){r.floats=[];for(var l=0;l<e.floats.length;++l)r.floats[l]=t.json&&!isFinite(e.floats[l])?String(e.floats[l]):e.floats[l]}if(e.ints&&e.ints.length)for(r.ints=[],l=0;l<e.ints.length;++l)typeof e.ints[l]=="number"?r.ints[l]=t.longs===String?String(e.ints[l]):e.ints[l]:r.ints[l]=t.longs===String?a.Long.prototype.toString.call(e.ints[l]):t.longs===Number?new a.LongBits(e.ints[l].low>>>0,e.ints[l].high>>>0).toNumber():e.ints[l];if(e.strings&&e.strings.length)for(r.strings=[],l=0;l<e.strings.length;++l)r.strings[l]=t.bytes===String?a.base64.encode(e.strings[l],0,e.strings[l].length):t.bytes===Array?Array.prototype.slice.call(e.strings[l]):e.strings[l];if(e.tensors&&e.tensors.length)for(r.tensors=[],l=0;l<e.tensors.length;++l)r.tensors[l]=o.onnx.TensorProto.toObject(e.tensors[l],t);if(e.graphs&&e.graphs.length)for(r.graphs=[],l=0;l<e.graphs.length;++l)r.graphs[l]=o.onnx.GraphProto.toObject(e.graphs[l],t);if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.tp!=null&&e.hasOwnProperty("tp")&&(r.tp=o.onnx.TypeProto.toObject(e.tp,t)),e.typeProtos&&e.typeProtos.length)for(r.typeProtos=[],l=0;l<e.typeProtos.length;++l)r.typeProtos[l]=o.onnx.TypeProto.toObject(e.typeProtos[l],t);if(e.type!=null&&e.hasOwnProperty("type")&&(r.type=t.enums===String?o.onnx.AttributeProto.AttributeType[e.type]===void 0?e.type:o.onnx.AttributeProto.AttributeType[e.type]:e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&(r.refAttrName=e.refAttrName),e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")&&(r.sparseTensor=o.onnx.SparseTensorProto.toObject(e.sparseTensor,t)),e.sparseTensors&&e.sparseTensors.length)for(r.sparseTensors=[],l=0;l<e.sparseTensors.length;++l)r.sparseTensors[l]=o.onnx.SparseTensorProto.toObject(e.sparseTensors[l],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.AttributeProto"},n.AttributeType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="INT"]=2,t[e[3]="STRING"]=3,t[e[4]="TENSOR"]=4,t[e[5]="GRAPH"]=5,t[e[11]="SPARSE_TENSOR"]=11,t[e[13]="TYPE_PROTO"]=13,t[e[6]="FLOATS"]=6,t[e[7]="INTS"]=7,t[e[8]="STRINGS"]=8,t[e[9]="TENSORS"]=9,t[e[10]="GRAPHS"]=10,t[e[12]="SPARSE_TENSORS"]=12,t[e[14]="TYPE_PROTOS"]=14,t}(),n}(),h.ValueInfoProto=function(){function n(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.name="",n.prototype.type=null,n.prototype.docString="",n.create=function(e){return new n(e)},n.encode=function(e,t){return t||(t=s.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(10).string(e.name),e.type!=null&&Object.hasOwnProperty.call(e,"type")&&o.onnx.TypeProto.encode(e.type,t.uint32(18).fork()).ldelim(),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(26).string(e.docString),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.ValueInfoProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.name=e.string();break;case 2:i.type=o.onnx.TypeProto.decode(e,e.uint32());break;case 3:i.docString=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.type!=null&&e.hasOwnProperty("type")){var t=o.onnx.TypeProto.verify(e.type);if(t)return"type."+t}return e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString)?"docString: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.ValueInfoProto)return e;var t=new o.onnx.ValueInfoProto;if(e.name!=null&&(t.name=String(e.name)),e.type!=null){if(typeof e.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");t.type=o.onnx.TypeProto.fromObject(e.type)}return e.docString!=null&&(t.docString=String(e.docString)),t},n.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.name="",r.type=null,r.docString=""),e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.type!=null&&e.hasOwnProperty("type")&&(r.type=o.onnx.TypeProto.toObject(e.type,t)),e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ValueInfoProto"},n}(),h.NodeProto=function(){function n(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.name="",n.prototype.opType="",n.prototype.domain="",n.prototype.attribute=a.emptyArray,n.prototype.docString="",n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.input!=null&&e.input.length)for(var r=0;r<e.input.length;++r)t.uint32(10).string(e.input[r]);if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)t.uint32(18).string(e.output[r]);if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(26).string(e.name),e.opType!=null&&Object.hasOwnProperty.call(e,"opType")&&t.uint32(34).string(e.opType),e.attribute!=null&&e.attribute.length)for(r=0;r<e.attribute.length;++r)o.onnx.AttributeProto.encode(e.attribute[r],t.uint32(42).fork()).ldelim();return e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(50).string(e.docString),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(58).string(e.domain),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.NodeProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.input&&i.input.length||(i.input=[]),i.input.push(e.string());break;case 2:i.output&&i.output.length||(i.output=[]),i.output.push(e.string());break;case 3:i.name=e.string();break;case 4:i.opType=e.string();break;case 7:i.domain=e.string();break;case 5:i.attribute&&i.attribute.length||(i.attribute=[]),i.attribute.push(o.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:i.docString=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!a.isString(e.input[t]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!a.isString(e.output[t]))return"output: string[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.opType!=null&&e.hasOwnProperty("opType")&&!a.isString(e.opType))return"opType: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain))return"domain: string expected";if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t){var r=o.onnx.AttributeProto.verify(e.attribute[t]);if(r)return"attribute."+r}}return e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString)?"docString: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.NodeProto)return e;var t=new o.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");t.input=[];for(var r=0;r<e.input.length;++r)t.input[r]=String(e.input[r])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r)t.output[r]=String(e.output[r])}if(e.name!=null&&(t.name=String(e.name)),e.opType!=null&&(t.opType=String(e.opType)),e.domain!=null&&(t.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(t.attribute=[],r=0;r<e.attribute.length;++r){if(typeof e.attribute[r]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");t.attribute[r]=o.onnx.AttributeProto.fromObject(e.attribute[r])}}return e.docString!=null&&(t.docString=String(e.docString)),t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.input=[],r.output=[],r.attribute=[]),t.defaults&&(r.name="",r.opType="",r.docString="",r.domain=""),e.input&&e.input.length){r.input=[];for(var i=0;i<e.input.length;++i)r.input[i]=e.input[i]}if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=e.output[i];if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.opType!=null&&e.hasOwnProperty("opType")&&(r.opType=e.opType),e.attribute&&e.attribute.length)for(r.attribute=[],i=0;i<e.attribute.length;++i)r.attribute[i]=o.onnx.AttributeProto.toObject(e.attribute[i],t);return e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.NodeProto"},n}(),h.TrainingInfoProto=function(){function n(e){if(this.initializationBinding=[],this.updateBinding=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.initialization=null,n.prototype.algorithm=null,n.prototype.initializationBinding=a.emptyArray,n.prototype.updateBinding=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.initialization!=null&&Object.hasOwnProperty.call(e,"initialization")&&o.onnx.GraphProto.encode(e.initialization,t.uint32(10).fork()).ldelim(),e.algorithm!=null&&Object.hasOwnProperty.call(e,"algorithm")&&o.onnx.GraphProto.encode(e.algorithm,t.uint32(18).fork()).ldelim(),e.initializationBinding!=null&&e.initializationBinding.length)for(var r=0;r<e.initializationBinding.length;++r)o.onnx.StringStringEntryProto.encode(e.initializationBinding[r],t.uint32(26).fork()).ldelim();if(e.updateBinding!=null&&e.updateBinding.length)for(r=0;r<e.updateBinding.length;++r)o.onnx.StringStringEntryProto.encode(e.updateBinding[r],t.uint32(34).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TrainingInfoProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.initialization=o.onnx.GraphProto.decode(e,e.uint32());break;case 2:i.algorithm=o.onnx.GraphProto.decode(e,e.uint32());break;case 3:i.initializationBinding&&i.initializationBinding.length||(i.initializationBinding=[]),i.initializationBinding.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 4:i.updateBinding&&i.updateBinding.length||(i.updateBinding=[]),i.updateBinding.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.initialization!=null&&e.hasOwnProperty("initialization")&&(r=o.onnx.GraphProto.verify(e.initialization)))return"initialization."+r;if(e.algorithm!=null&&e.hasOwnProperty("algorithm")&&(r=o.onnx.GraphProto.verify(e.algorithm)))return"algorithm."+r;if(e.initializationBinding!=null&&e.hasOwnProperty("initializationBinding")){if(!Array.isArray(e.initializationBinding))return"initializationBinding: array expected";for(var t=0;t<e.initializationBinding.length;++t)if(r=o.onnx.StringStringEntryProto.verify(e.initializationBinding[t]))return"initializationBinding."+r}if(e.updateBinding!=null&&e.hasOwnProperty("updateBinding")){if(!Array.isArray(e.updateBinding))return"updateBinding: array expected";for(t=0;t<e.updateBinding.length;++t){var r;if(r=o.onnx.StringStringEntryProto.verify(e.updateBinding[t]))return"updateBinding."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.TrainingInfoProto)return e;var t=new o.onnx.TrainingInfoProto;if(e.initialization!=null){if(typeof e.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");t.initialization=o.onnx.GraphProto.fromObject(e.initialization)}if(e.algorithm!=null){if(typeof e.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");t.algorithm=o.onnx.GraphProto.fromObject(e.algorithm)}if(e.initializationBinding){if(!Array.isArray(e.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");t.initializationBinding=[];for(var r=0;r<e.initializationBinding.length;++r){if(typeof e.initializationBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");t.initializationBinding[r]=o.onnx.StringStringEntryProto.fromObject(e.initializationBinding[r])}}if(e.updateBinding){if(!Array.isArray(e.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");for(t.updateBinding=[],r=0;r<e.updateBinding.length;++r){if(typeof e.updateBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");t.updateBinding[r]=o.onnx.StringStringEntryProto.fromObject(e.updateBinding[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.initializationBinding=[],r.updateBinding=[]),t.defaults&&(r.initialization=null,r.algorithm=null),e.initialization!=null&&e.hasOwnProperty("initialization")&&(r.initialization=o.onnx.GraphProto.toObject(e.initialization,t)),e.algorithm!=null&&e.hasOwnProperty("algorithm")&&(r.algorithm=o.onnx.GraphProto.toObject(e.algorithm,t)),e.initializationBinding&&e.initializationBinding.length){r.initializationBinding=[];for(var i=0;i<e.initializationBinding.length;++i)r.initializationBinding[i]=o.onnx.StringStringEntryProto.toObject(e.initializationBinding[i],t)}if(e.updateBinding&&e.updateBinding.length)for(r.updateBinding=[],i=0;i<e.updateBinding.length;++i)r.updateBinding[i]=o.onnx.StringStringEntryProto.toObject(e.updateBinding[i],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TrainingInfoProto"},n}(),h.ModelProto=function(){function n(e){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.irVersion=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.opsetImport=a.emptyArray,n.prototype.producerName="",n.prototype.producerVersion="",n.prototype.domain="",n.prototype.modelVersion=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.docString="",n.prototype.graph=null,n.prototype.metadataProps=a.emptyArray,n.prototype.trainingInfo=a.emptyArray,n.prototype.functions=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.irVersion!=null&&Object.hasOwnProperty.call(e,"irVersion")&&t.uint32(8).int64(e.irVersion),e.producerName!=null&&Object.hasOwnProperty.call(e,"producerName")&&t.uint32(18).string(e.producerName),e.producerVersion!=null&&Object.hasOwnProperty.call(e,"producerVersion")&&t.uint32(26).string(e.producerVersion),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(34).string(e.domain),e.modelVersion!=null&&Object.hasOwnProperty.call(e,"modelVersion")&&t.uint32(40).int64(e.modelVersion),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(50).string(e.docString),e.graph!=null&&Object.hasOwnProperty.call(e,"graph")&&o.onnx.GraphProto.encode(e.graph,t.uint32(58).fork()).ldelim(),e.opsetImport!=null&&e.opsetImport.length)for(var r=0;r<e.opsetImport.length;++r)o.onnx.OperatorSetIdProto.encode(e.opsetImport[r],t.uint32(66).fork()).ldelim();if(e.metadataProps!=null&&e.metadataProps.length)for(r=0;r<e.metadataProps.length;++r)o.onnx.StringStringEntryProto.encode(e.metadataProps[r],t.uint32(114).fork()).ldelim();if(e.trainingInfo!=null&&e.trainingInfo.length)for(r=0;r<e.trainingInfo.length;++r)o.onnx.TrainingInfoProto.encode(e.trainingInfo[r],t.uint32(162).fork()).ldelim();if(e.functions!=null&&e.functions.length)for(r=0;r<e.functions.length;++r)o.onnx.FunctionProto.encode(e.functions[r],t.uint32(202).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.ModelProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.irVersion=e.int64();break;case 8:i.opsetImport&&i.opsetImport.length||(i.opsetImport=[]),i.opsetImport.push(o.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:i.producerName=e.string();break;case 3:i.producerVersion=e.string();break;case 4:i.domain=e.string();break;case 5:i.modelVersion=e.int64();break;case 6:i.docString=e.string();break;case 7:i.graph=o.onnx.GraphProto.decode(e,e.uint32());break;case 14:i.metadataProps&&i.metadataProps.length||(i.metadataProps=[]),i.metadataProps.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 20:i.trainingInfo&&i.trainingInfo.length||(i.trainingInfo=[]),i.trainingInfo.push(o.onnx.TrainingInfoProto.decode(e,e.uint32()));break;case 25:i.functions&&i.functions.length||(i.functions=[]),i.functions.push(o.onnx.FunctionProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&!(a.isInteger(e.irVersion)||e.irVersion&&a.isInteger(e.irVersion.low)&&a.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var t=0;t<e.opsetImport.length;++t)if(r=o.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+r}if(e.producerName!=null&&e.hasOwnProperty("producerName")&&!a.isString(e.producerName))return"producerName: string expected";if(e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&!a.isString(e.producerVersion))return"producerVersion: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain))return"domain: string expected";if(e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&!(a.isInteger(e.modelVersion)||e.modelVersion&&a.isInteger(e.modelVersion.low)&&a.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.graph!=null&&e.hasOwnProperty("graph")&&(r=o.onnx.GraphProto.verify(e.graph)))return"graph."+r;if(e.metadataProps!=null&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(t=0;t<e.metadataProps.length;++t)if(r=o.onnx.StringStringEntryProto.verify(e.metadataProps[t]))return"metadataProps."+r}if(e.trainingInfo!=null&&e.hasOwnProperty("trainingInfo")){if(!Array.isArray(e.trainingInfo))return"trainingInfo: array expected";for(t=0;t<e.trainingInfo.length;++t)if(r=o.onnx.TrainingInfoProto.verify(e.trainingInfo[t]))return"trainingInfo."+r}if(e.functions!=null&&e.hasOwnProperty("functions")){if(!Array.isArray(e.functions))return"functions: array expected";for(t=0;t<e.functions.length;++t){var r;if(r=o.onnx.FunctionProto.verify(e.functions[t]))return"functions."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.ModelProto)return e;var t=new o.onnx.ModelProto;if(e.irVersion!=null&&(a.Long?(t.irVersion=a.Long.fromValue(e.irVersion)).unsigned=!1:typeof e.irVersion=="string"?t.irVersion=parseInt(e.irVersion,10):typeof e.irVersion=="number"?t.irVersion=e.irVersion:typeof e.irVersion=="object"&&(t.irVersion=new a.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");t.opsetImport=[];for(var r=0;r<e.opsetImport.length;++r){if(typeof e.opsetImport[r]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");t.opsetImport[r]=o.onnx.OperatorSetIdProto.fromObject(e.opsetImport[r])}}if(e.producerName!=null&&(t.producerName=String(e.producerName)),e.producerVersion!=null&&(t.producerVersion=String(e.producerVersion)),e.domain!=null&&(t.domain=String(e.domain)),e.modelVersion!=null&&(a.Long?(t.modelVersion=a.Long.fromValue(e.modelVersion)).unsigned=!1:typeof e.modelVersion=="string"?t.modelVersion=parseInt(e.modelVersion,10):typeof e.modelVersion=="number"?t.modelVersion=e.modelVersion:typeof e.modelVersion=="object"&&(t.modelVersion=new a.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),e.docString!=null&&(t.docString=String(e.docString)),e.graph!=null){if(typeof e.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");t.graph=o.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(t.metadataProps=[],r=0;r<e.metadataProps.length;++r){if(typeof e.metadataProps[r]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");t.metadataProps[r]=o.onnx.StringStringEntryProto.fromObject(e.metadataProps[r])}}if(e.trainingInfo){if(!Array.isArray(e.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");for(t.trainingInfo=[],r=0;r<e.trainingInfo.length;++r){if(typeof e.trainingInfo[r]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");t.trainingInfo[r]=o.onnx.TrainingInfoProto.fromObject(e.trainingInfo[r])}}if(e.functions){if(!Array.isArray(e.functions))throw TypeError(".onnx.ModelProto.functions: array expected");for(t.functions=[],r=0;r<e.functions.length;++r){if(typeof e.functions[r]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");t.functions[r]=o.onnx.FunctionProto.fromObject(e.functions[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.opsetImport=[],r.metadataProps=[],r.trainingInfo=[],r.functions=[]),t.defaults){if(a.Long){var i=new a.Long(0,0,!1);r.irVersion=t.longs===String?i.toString():t.longs===Number?i.toNumber():i}else r.irVersion=t.longs===String?"0":0;r.producerName="",r.producerVersion="",r.domain="",a.Long?(i=new a.Long(0,0,!1),r.modelVersion=t.longs===String?i.toString():t.longs===Number?i.toNumber():i):r.modelVersion=t.longs===String?"0":0,r.docString="",r.graph=null}if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&(typeof e.irVersion=="number"?r.irVersion=t.longs===String?String(e.irVersion):e.irVersion:r.irVersion=t.longs===String?a.Long.prototype.toString.call(e.irVersion):t.longs===Number?new a.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&(r.producerName=e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&(r.producerVersion=e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&(typeof e.modelVersion=="number"?r.modelVersion=t.longs===String?String(e.modelVersion):e.modelVersion:r.modelVersion=t.longs===String?a.Long.prototype.toString.call(e.modelVersion):t.longs===Number?new a.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&(r.graph=o.onnx.GraphProto.toObject(e.graph,t)),e.opsetImport&&e.opsetImport.length){r.opsetImport=[];for(var l=0;l<e.opsetImport.length;++l)r.opsetImport[l]=o.onnx.OperatorSetIdProto.toObject(e.opsetImport[l],t)}if(e.metadataProps&&e.metadataProps.length)for(r.metadataProps=[],l=0;l<e.metadataProps.length;++l)r.metadataProps[l]=o.onnx.StringStringEntryProto.toObject(e.metadataProps[l],t);if(e.trainingInfo&&e.trainingInfo.length)for(r.trainingInfo=[],l=0;l<e.trainingInfo.length;++l)r.trainingInfo[l]=o.onnx.TrainingInfoProto.toObject(e.trainingInfo[l],t);if(e.functions&&e.functions.length)for(r.functions=[],l=0;l<e.functions.length;++l)r.functions[l]=o.onnx.FunctionProto.toObject(e.functions[l],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ModelProto"},n}(),h.StringStringEntryProto=function(){function n(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.key="",n.prototype.value="",n.create=function(e){return new n(e)},n.encode=function(e,t){return t||(t=s.create()),e.key!=null&&Object.hasOwnProperty.call(e,"key")&&t.uint32(10).string(e.key),e.value!=null&&Object.hasOwnProperty.call(e,"value")&&t.uint32(18).string(e.value),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.StringStringEntryProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.key=e.string();break;case 2:i.value=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){return typeof e!="object"||e===null?"object expected":e.key!=null&&e.hasOwnProperty("key")&&!a.isString(e.key)?"key: string expected":e.value!=null&&e.hasOwnProperty("value")&&!a.isString(e.value)?"value: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.StringStringEntryProto)return e;var t=new o.onnx.StringStringEntryProto;return e.key!=null&&(t.key=String(e.key)),e.value!=null&&(t.value=String(e.value)),t},n.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.key="",r.value=""),e.key!=null&&e.hasOwnProperty("key")&&(r.key=e.key),e.value!=null&&e.hasOwnProperty("value")&&(r.value=e.value),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.StringStringEntryProto"},n}(),h.TensorAnnotation=function(){function n(e){if(this.quantParameterTensorNames=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.tensorName="",n.prototype.quantParameterTensorNames=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.tensorName!=null&&Object.hasOwnProperty.call(e,"tensorName")&&t.uint32(10).string(e.tensorName),e.quantParameterTensorNames!=null&&e.quantParameterTensorNames.length)for(var r=0;r<e.quantParameterTensorNames.length;++r)o.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[r],t.uint32(18).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TensorAnnotation;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.tensorName=e.string();break;case 2:i.quantParameterTensorNames&&i.quantParameterTensorNames.length||(i.quantParameterTensorNames=[]),i.quantParameterTensorNames.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.tensorName!=null&&e.hasOwnProperty("tensorName")&&!a.isString(e.tensorName))return"tensorName: string expected";if(e.quantParameterTensorNames!=null&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var t=0;t<e.quantParameterTensorNames.length;++t){var r=o.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);if(r)return"quantParameterTensorNames."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.TensorAnnotation)return e;var t=new o.onnx.TensorAnnotation;if(e.tensorName!=null&&(t.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");t.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r){if(typeof e.quantParameterTensorNames[r]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");t.quantParameterTensorNames[r]=o.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.quantParameterTensorNames=[]),t.defaults&&(r.tensorName=""),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&(r.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){r.quantParameterTensorNames=[];for(var i=0;i<e.quantParameterTensorNames.length;++i)r.quantParameterTensorNames[i]=o.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[i],t)}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorAnnotation"},n}(),h.GraphProto=function(){function n(e){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.node=a.emptyArray,n.prototype.name="",n.prototype.initializer=a.emptyArray,n.prototype.sparseInitializer=a.emptyArray,n.prototype.docString="",n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.valueInfo=a.emptyArray,n.prototype.quantizationAnnotation=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.node!=null&&e.node.length)for(var r=0;r<e.node.length;++r)o.onnx.NodeProto.encode(e.node[r],t.uint32(10).fork()).ldelim();if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(18).string(e.name),e.initializer!=null&&e.initializer.length)for(r=0;r<e.initializer.length;++r)o.onnx.TensorProto.encode(e.initializer[r],t.uint32(42).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(82).string(e.docString),e.input!=null&&e.input.length)for(r=0;r<e.input.length;++r)o.onnx.ValueInfoProto.encode(e.input[r],t.uint32(90).fork()).ldelim();if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)o.onnx.ValueInfoProto.encode(e.output[r],t.uint32(98).fork()).ldelim();if(e.valueInfo!=null&&e.valueInfo.length)for(r=0;r<e.valueInfo.length;++r)o.onnx.ValueInfoProto.encode(e.valueInfo[r],t.uint32(106).fork()).ldelim();if(e.quantizationAnnotation!=null&&e.quantizationAnnotation.length)for(r=0;r<e.quantizationAnnotation.length;++r)o.onnx.TensorAnnotation.encode(e.quantizationAnnotation[r],t.uint32(114).fork()).ldelim();if(e.sparseInitializer!=null&&e.sparseInitializer.length)for(r=0;r<e.sparseInitializer.length;++r)o.onnx.SparseTensorProto.encode(e.sparseInitializer[r],t.uint32(122).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.GraphProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.node&&i.node.length||(i.node=[]),i.node.push(o.onnx.NodeProto.decode(e,e.uint32()));break;case 2:i.name=e.string();break;case 5:i.initializer&&i.initializer.length||(i.initializer=[]),i.initializer.push(o.onnx.TensorProto.decode(e,e.uint32()));break;case 15:i.sparseInitializer&&i.sparseInitializer.length||(i.sparseInitializer=[]),i.sparseInitializer.push(o.onnx.SparseTensorProto.decode(e,e.uint32()));break;case 10:i.docString=e.string();break;case 11:i.input&&i.input.length||(i.input=[]),i.input.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:i.output&&i.output.length||(i.output=[]),i.output.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:i.valueInfo&&i.valueInfo.length||(i.valueInfo=[]),i.valueInfo.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:i.quantizationAnnotation&&i.quantizationAnnotation.length||(i.quantizationAnnotation=[]),i.quantizationAnnotation.push(o.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var t=0;t<e.node.length;++t)if(r=o.onnx.NodeProto.verify(e.node[t]))return"node."+r}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.initializer!=null&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(t=0;t<e.initializer.length;++t)if(r=o.onnx.TensorProto.verify(e.initializer[t]))return"initializer."+r}if(e.sparseInitializer!=null&&e.hasOwnProperty("sparseInitializer")){if(!Array.isArray(e.sparseInitializer))return"sparseInitializer: array expected";for(t=0;t<e.sparseInitializer.length;++t)if(r=o.onnx.SparseTensorProto.verify(e.sparseInitializer[t]))return"sparseInitializer."+r}if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(t=0;t<e.input.length;++t)if(r=o.onnx.ValueInfoProto.verify(e.input[t]))return"input."+r}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(r=o.onnx.ValueInfoProto.verify(e.output[t]))return"output."+r}if(e.valueInfo!=null&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(t=0;t<e.valueInfo.length;++t)if(r=o.onnx.ValueInfoProto.verify(e.valueInfo[t]))return"valueInfo."+r}if(e.quantizationAnnotation!=null&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(t=0;t<e.quantizationAnnotation.length;++t){var r;if(r=o.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t]))return"quantizationAnnotation."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.GraphProto)return e;var t=new o.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");t.node=[];for(var r=0;r<e.node.length;++r){if(typeof e.node[r]!="object")throw TypeError(".onnx.GraphProto.node: object expected");t.node[r]=o.onnx.NodeProto.fromObject(e.node[r])}}if(e.name!=null&&(t.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(t.initializer=[],r=0;r<e.initializer.length;++r){if(typeof e.initializer[r]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");t.initializer[r]=o.onnx.TensorProto.fromObject(e.initializer[r])}}if(e.sparseInitializer){if(!Array.isArray(e.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");for(t.sparseInitializer=[],r=0;r<e.sparseInitializer.length;++r){if(typeof e.sparseInitializer[r]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");t.sparseInitializer[r]=o.onnx.SparseTensorProto.fromObject(e.sparseInitializer[r])}}if(e.docString!=null&&(t.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(t.input=[],r=0;r<e.input.length;++r){if(typeof e.input[r]!="object")throw TypeError(".onnx.GraphProto.input: object expected");t.input[r]=o.onnx.ValueInfoProto.fromObject(e.input[r])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r){if(typeof e.output[r]!="object")throw TypeError(".onnx.GraphProto.output: object expected");t.output[r]=o.onnx.ValueInfoProto.fromObject(e.output[r])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(t.valueInfo=[],r=0;r<e.valueInfo.length;++r){if(typeof e.valueInfo[r]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");t.valueInfo[r]=o.onnx.ValueInfoProto.fromObject(e.valueInfo[r])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(t.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r){if(typeof e.quantizationAnnotation[r]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");t.quantizationAnnotation[r]=o.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.node=[],r.initializer=[],r.input=[],r.output=[],r.valueInfo=[],r.quantizationAnnotation=[],r.sparseInitializer=[]),t.defaults&&(r.name="",r.docString=""),e.node&&e.node.length){r.node=[];for(var i=0;i<e.node.length;++i)r.node[i]=o.onnx.NodeProto.toObject(e.node[i],t)}if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.initializer&&e.initializer.length)for(r.initializer=[],i=0;i<e.initializer.length;++i)r.initializer[i]=o.onnx.TensorProto.toObject(e.initializer[i],t);if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.input&&e.input.length)for(r.input=[],i=0;i<e.input.length;++i)r.input[i]=o.onnx.ValueInfoProto.toObject(e.input[i],t);if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=o.onnx.ValueInfoProto.toObject(e.output[i],t);if(e.valueInfo&&e.valueInfo.length)for(r.valueInfo=[],i=0;i<e.valueInfo.length;++i)r.valueInfo[i]=o.onnx.ValueInfoProto.toObject(e.valueInfo[i],t);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(r.quantizationAnnotation=[],i=0;i<e.quantizationAnnotation.length;++i)r.quantizationAnnotation[i]=o.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[i],t);if(e.sparseInitializer&&e.sparseInitializer.length)for(r.sparseInitializer=[],i=0;i<e.sparseInitializer.length;++i)r.sparseInitializer[i]=o.onnx.SparseTensorProto.toObject(e.sparseInitializer[i],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.GraphProto"},n}(),h.TensorProto=function(){function n(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.dims=a.emptyArray,n.prototype.dataType=0,n.prototype.segment=null,n.prototype.floatData=a.emptyArray,n.prototype.int32Data=a.emptyArray,n.prototype.stringData=a.emptyArray,n.prototype.int64Data=a.emptyArray,n.prototype.name="",n.prototype.docString="",n.prototype.rawData=a.newBuffer([]),n.prototype.externalData=a.emptyArray,n.prototype.dataLocation=0,n.prototype.doubleData=a.emptyArray,n.prototype.uint64Data=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.dims!=null&&e.dims.length){t.uint32(10).fork();for(var r=0;r<e.dims.length;++r)t.int64(e.dims[r]);t.ldelim()}if(e.dataType!=null&&Object.hasOwnProperty.call(e,"dataType")&&t.uint32(16).int32(e.dataType),e.segment!=null&&Object.hasOwnProperty.call(e,"segment")&&o.onnx.TensorProto.Segment.encode(e.segment,t.uint32(26).fork()).ldelim(),e.floatData!=null&&e.floatData.length){for(t.uint32(34).fork(),r=0;r<e.floatData.length;++r)t.float(e.floatData[r]);t.ldelim()}if(e.int32Data!=null&&e.int32Data.length){for(t.uint32(42).fork(),r=0;r<e.int32Data.length;++r)t.int32(e.int32Data[r]);t.ldelim()}if(e.stringData!=null&&e.stringData.length)for(r=0;r<e.stringData.length;++r)t.uint32(50).bytes(e.stringData[r]);if(e.int64Data!=null&&e.int64Data.length){for(t.uint32(58).fork(),r=0;r<e.int64Data.length;++r)t.int64(e.int64Data[r]);t.ldelim()}if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(66).string(e.name),e.rawData!=null&&Object.hasOwnProperty.call(e,"rawData")&&t.uint32(74).bytes(e.rawData),e.doubleData!=null&&e.doubleData.length){for(t.uint32(82).fork(),r=0;r<e.doubleData.length;++r)t.double(e.doubleData[r]);t.ldelim()}if(e.uint64Data!=null&&e.uint64Data.length){for(t.uint32(90).fork(),r=0;r<e.uint64Data.length;++r)t.uint64(e.uint64Data[r]);t.ldelim()}if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(98).string(e.docString),e.externalData!=null&&e.externalData.length)for(r=0;r<e.externalData.length;++r)o.onnx.StringStringEntryProto.encode(e.externalData[r],t.uint32(106).fork()).ldelim();return e.dataLocation!=null&&Object.hasOwnProperty.call(e,"dataLocation")&&t.uint32(112).int32(e.dataLocation),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TensorProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:if(i.dims&&i.dims.length||(i.dims=[]),(7&l)==2)for(var d=e.uint32()+e.pos;e.pos<d;)i.dims.push(e.int64());else i.dims.push(e.int64());break;case 2:i.dataType=e.int32();break;case 3:i.segment=o.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(i.floatData&&i.floatData.length||(i.floatData=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.floatData.push(e.float());else i.floatData.push(e.float());break;case 5:if(i.int32Data&&i.int32Data.length||(i.int32Data=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.int32Data.push(e.int32());else i.int32Data.push(e.int32());break;case 6:i.stringData&&i.stringData.length||(i.stringData=[]),i.stringData.push(e.bytes());break;case 7:if(i.int64Data&&i.int64Data.length||(i.int64Data=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.int64Data.push(e.int64());else i.int64Data.push(e.int64());break;case 8:i.name=e.string();break;case 12:i.docString=e.string();break;case 9:i.rawData=e.bytes();break;case 13:i.externalData&&i.externalData.length||(i.externalData=[]),i.externalData.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:i.dataLocation=e.int32();break;case 10:if(i.doubleData&&i.doubleData.length||(i.doubleData=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.doubleData.push(e.double());else i.doubleData.push(e.double());break;case 11:if(i.uint64Data&&i.uint64Data.length||(i.uint64Data=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.uint64Data.push(e.uint64());else i.uint64Data.push(e.uint64());break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var t=0;t<e.dims.length;++t)if(!(a.isInteger(e.dims[t])||e.dims[t]&&a.isInteger(e.dims[t].low)&&a.isInteger(e.dims[t].high)))return"dims: integer|Long[] expected"}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&!a.isInteger(e.dataType))return"dataType: integer expected";if(e.segment!=null&&e.hasOwnProperty("segment")&&(r=o.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+r;if(e.floatData!=null&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(t=0;t<e.floatData.length;++t)if(typeof e.floatData[t]!="number")return"floatData: number[] expected"}if(e.int32Data!=null&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(t=0;t<e.int32Data.length;++t)if(!a.isInteger(e.int32Data[t]))return"int32Data: integer[] expected"}if(e.stringData!=null&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(t=0;t<e.stringData.length;++t)if(!(e.stringData[t]&&typeof e.stringData[t].length=="number"||a.isString(e.stringData[t])))return"stringData: buffer[] expected"}if(e.int64Data!=null&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(t=0;t<e.int64Data.length;++t)if(!(a.isInteger(e.int64Data[t])||e.int64Data[t]&&a.isInteger(e.int64Data[t].low)&&a.isInteger(e.int64Data[t].high)))return"int64Data: integer|Long[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.rawData!=null&&e.hasOwnProperty("rawData")&&!(e.rawData&&typeof e.rawData.length=="number"||a.isString(e.rawData)))return"rawData: buffer expected";if(e.externalData!=null&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(t=0;t<e.externalData.length;++t){var r;if(r=o.onnx.StringStringEntryProto.verify(e.externalData[t]))return"externalData."+r}}if(e.dataLocation!=null&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(e.doubleData!=null&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(t=0;t<e.doubleData.length;++t)if(typeof e.doubleData[t]!="number")return"doubleData: number[] expected"}if(e.uint64Data!=null&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(t=0;t<e.uint64Data.length;++t)if(!(a.isInteger(e.uint64Data[t])||e.uint64Data[t]&&a.isInteger(e.uint64Data[t].low)&&a.isInteger(e.uint64Data[t].high)))return"uint64Data: integer|Long[] expected"}return null},n.fromObject=function(e){if(e instanceof o.onnx.TensorProto)return e;var t=new o.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");t.dims=[];for(var r=0;r<e.dims.length;++r)a.Long?(t.dims[r]=a.Long.fromValue(e.dims[r])).unsigned=!1:typeof e.dims[r]=="string"?t.dims[r]=parseInt(e.dims[r],10):typeof e.dims[r]=="number"?t.dims[r]=e.dims[r]:typeof e.dims[r]=="object"&&(t.dims[r]=new a.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber())}if(e.dataType!=null&&(t.dataType=0|e.dataType),e.segment!=null){if(typeof e.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");t.segment=o.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(t.floatData=[],r=0;r<e.floatData.length;++r)t.floatData[r]=Number(e.floatData[r])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(t.int32Data=[],r=0;r<e.int32Data.length;++r)t.int32Data[r]=0|e.int32Data[r]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(t.stringData=[],r=0;r<e.stringData.length;++r)typeof e.stringData[r]=="string"?a.base64.decode(e.stringData[r],t.stringData[r]=a.newBuffer(a.base64.length(e.stringData[r])),0):e.stringData[r].length>=0&&(t.stringData[r]=e.stringData[r])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(t.int64Data=[],r=0;r<e.int64Data.length;++r)a.Long?(t.int64Data[r]=a.Long.fromValue(e.int64Data[r])).unsigned=!1:typeof e.int64Data[r]=="string"?t.int64Data[r]=parseInt(e.int64Data[r],10):typeof e.int64Data[r]=="number"?t.int64Data[r]=e.int64Data[r]:typeof e.int64Data[r]=="object"&&(t.int64Data[r]=new a.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber())}if(e.name!=null&&(t.name=String(e.name)),e.docString!=null&&(t.docString=String(e.docString)),e.rawData!=null&&(typeof e.rawData=="string"?a.base64.decode(e.rawData,t.rawData=a.newBuffer(a.base64.length(e.rawData)),0):e.rawData.length>=0&&(t.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(t.externalData=[],r=0;r<e.externalData.length;++r){if(typeof e.externalData[r]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");t.externalData[r]=o.onnx.StringStringEntryProto.fromObject(e.externalData[r])}}switch(e.dataLocation){default:if(typeof e.dataLocation=="number"){t.dataLocation=e.dataLocation;break}break;case"DEFAULT":case 0:t.dataLocation=0;break;case"EXTERNAL":case 1:t.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(t.doubleData=[],r=0;r<e.doubleData.length;++r)t.doubleData[r]=Number(e.doubleData[r])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(t.uint64Data=[],r=0;r<e.uint64Data.length;++r)a.Long?(t.uint64Data[r]=a.Long.fromValue(e.uint64Data[r])).unsigned=!0:typeof e.uint64Data[r]=="string"?t.uint64Data[r]=parseInt(e.uint64Data[r],10):typeof e.uint64Data[r]=="number"?t.uint64Data[r]=e.uint64Data[r]:typeof e.uint64Data[r]=="object"&&(t.uint64Data[r]=new a.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0))}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dims=[],r.floatData=[],r.int32Data=[],r.stringData=[],r.int64Data=[],r.doubleData=[],r.uint64Data=[],r.externalData=[]),t.defaults&&(r.dataType=0,r.segment=null,r.name="",t.bytes===String?r.rawData="":(r.rawData=[],t.bytes!==Array&&(r.rawData=a.newBuffer(r.rawData))),r.docString="",r.dataLocation=t.enums===String?"DEFAULT":0),e.dims&&e.dims.length){r.dims=[];for(var i=0;i<e.dims.length;++i)typeof e.dims[i]=="number"?r.dims[i]=t.longs===String?String(e.dims[i]):e.dims[i]:r.dims[i]=t.longs===String?a.Long.prototype.toString.call(e.dims[i]):t.longs===Number?new a.LongBits(e.dims[i].low>>>0,e.dims[i].high>>>0).toNumber():e.dims[i]}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&(r.dataType=e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&(r.segment=o.onnx.TensorProto.Segment.toObject(e.segment,t)),e.floatData&&e.floatData.length)for(r.floatData=[],i=0;i<e.floatData.length;++i)r.floatData[i]=t.json&&!isFinite(e.floatData[i])?String(e.floatData[i]):e.floatData[i];if(e.int32Data&&e.int32Data.length)for(r.int32Data=[],i=0;i<e.int32Data.length;++i)r.int32Data[i]=e.int32Data[i];if(e.stringData&&e.stringData.length)for(r.stringData=[],i=0;i<e.stringData.length;++i)r.stringData[i]=t.bytes===String?a.base64.encode(e.stringData[i],0,e.stringData[i].length):t.bytes===Array?Array.prototype.slice.call(e.stringData[i]):e.stringData[i];if(e.int64Data&&e.int64Data.length)for(r.int64Data=[],i=0;i<e.int64Data.length;++i)typeof e.int64Data[i]=="number"?r.int64Data[i]=t.longs===String?String(e.int64Data[i]):e.int64Data[i]:r.int64Data[i]=t.longs===String?a.Long.prototype.toString.call(e.int64Data[i]):t.longs===Number?new a.LongBits(e.int64Data[i].low>>>0,e.int64Data[i].high>>>0).toNumber():e.int64Data[i];if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&(r.rawData=t.bytes===String?a.base64.encode(e.rawData,0,e.rawData.length):t.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(r.doubleData=[],i=0;i<e.doubleData.length;++i)r.doubleData[i]=t.json&&!isFinite(e.doubleData[i])?String(e.doubleData[i]):e.doubleData[i];if(e.uint64Data&&e.uint64Data.length)for(r.uint64Data=[],i=0;i<e.uint64Data.length;++i)typeof e.uint64Data[i]=="number"?r.uint64Data[i]=t.longs===String?String(e.uint64Data[i]):e.uint64Data[i]:r.uint64Data[i]=t.longs===String?a.Long.prototype.toString.call(e.uint64Data[i]):t.longs===Number?new a.LongBits(e.uint64Data[i].low>>>0,e.uint64Data[i].high>>>0).toNumber(!0):e.uint64Data[i];if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.externalData&&e.externalData.length)for(r.externalData=[],i=0;i<e.externalData.length;++i)r.externalData[i]=o.onnx.StringStringEntryProto.toObject(e.externalData[i],t);return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&(r.dataLocation=t.enums===String?o.onnx.TensorProto.DataLocation[e.dataLocation]===void 0?e.dataLocation:o.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorProto"},n.DataType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="UINT8"]=2,t[e[3]="INT8"]=3,t[e[4]="UINT16"]=4,t[e[5]="INT16"]=5,t[e[6]="INT32"]=6,t[e[7]="INT64"]=7,t[e[8]="STRING"]=8,t[e[9]="BOOL"]=9,t[e[10]="FLOAT16"]=10,t[e[11]="DOUBLE"]=11,t[e[12]="UINT32"]=12,t[e[13]="UINT64"]=13,t[e[14]="COMPLEX64"]=14,t[e[15]="COMPLEX128"]=15,t[e[16]="BFLOAT16"]=16,t[e[17]="FLOAT8E4M3FN"]=17,t[e[18]="FLOAT8E4M3FNUZ"]=18,t[e[19]="FLOAT8E5M2"]=19,t[e[20]="FLOAT8E5M2FNUZ"]=20,t}(),n.Segment=function(){function e(t){if(t)for(var r=Object.keys(t),i=0;i<r.length;++i)t[r[i]]!=null&&(this[r[i]]=t[r[i]])}return e.prototype.begin=a.Long?a.Long.fromBits(0,0,!1):0,e.prototype.end=a.Long?a.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,r){return r||(r=s.create()),t.begin!=null&&Object.hasOwnProperty.call(t,"begin")&&r.uint32(8).int64(t.begin),t.end!=null&&Object.hasOwnProperty.call(t,"end")&&r.uint32(16).int64(t.end),r},e.encodeDelimited=function(t,r){return this.encode(t,r).ldelim()},e.decode=function(t,r){t instanceof u||(t=u.create(t));for(var i=r===void 0?t.len:t.pos+r,l=new o.onnx.TensorProto.Segment;t.pos<i;){var d=t.uint32();switch(d>>>3){case 1:l.begin=t.int64();break;case 2:l.end=t.int64();break;default:t.skipType(7&d)}}return l},e.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.begin!=null&&t.hasOwnProperty("begin")&&!(a.isInteger(t.begin)||t.begin&&a.isInteger(t.begin.low)&&a.isInteger(t.begin.high))?"begin: integer|Long expected":t.end!=null&&t.hasOwnProperty("end")&&!(a.isInteger(t.end)||t.end&&a.isInteger(t.end.low)&&a.isInteger(t.end.high))?"end: integer|Long expected":null},e.fromObject=function(t){if(t instanceof o.onnx.TensorProto.Segment)return t;var r=new o.onnx.TensorProto.Segment;return t.begin!=null&&(a.Long?(r.begin=a.Long.fromValue(t.begin)).unsigned=!1:typeof t.begin=="string"?r.begin=parseInt(t.begin,10):typeof t.begin=="number"?r.begin=t.begin:typeof t.begin=="object"&&(r.begin=new a.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber())),t.end!=null&&(a.Long?(r.end=a.Long.fromValue(t.end)).unsigned=!1:typeof t.end=="string"?r.end=parseInt(t.end,10):typeof t.end=="number"?r.end=t.end:typeof t.end=="object"&&(r.end=new a.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber())),r},e.toObject=function(t,r){r||(r={});var i={};if(r.defaults){if(a.Long){var l=new a.Long(0,0,!1);i.begin=r.longs===String?l.toString():r.longs===Number?l.toNumber():l}else i.begin=r.longs===String?"0":0;a.Long?(l=new a.Long(0,0,!1),i.end=r.longs===String?l.toString():r.longs===Number?l.toNumber():l):i.end=r.longs===String?"0":0}return t.begin!=null&&t.hasOwnProperty("begin")&&(typeof t.begin=="number"?i.begin=r.longs===String?String(t.begin):t.begin:i.begin=r.longs===String?a.Long.prototype.toString.call(t.begin):r.longs===Number?new a.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber():t.begin),t.end!=null&&t.hasOwnProperty("end")&&(typeof t.end=="number"?i.end=r.longs===String?String(t.end):t.end:i.end=r.longs===String?a.Long.prototype.toString.call(t.end):r.longs===Number?new a.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber():t.end),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto.Segment"},e}(),n.DataLocation=function(){var e={},t=Object.create(e);return t[e[0]="DEFAULT"]=0,t[e[1]="EXTERNAL"]=1,t}(),n}(),h.SparseTensorProto=function(){function n(e){if(this.dims=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.values=null,n.prototype.indices=null,n.prototype.dims=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.values!=null&&Object.hasOwnProperty.call(e,"values")&&o.onnx.TensorProto.encode(e.values,t.uint32(10).fork()).ldelim(),e.indices!=null&&Object.hasOwnProperty.call(e,"indices")&&o.onnx.TensorProto.encode(e.indices,t.uint32(18).fork()).ldelim(),e.dims!=null&&e.dims.length){t.uint32(26).fork();for(var r=0;r<e.dims.length;++r)t.int64(e.dims[r]);t.ldelim()}return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.SparseTensorProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.values=o.onnx.TensorProto.decode(e,e.uint32());break;case 2:i.indices=o.onnx.TensorProto.decode(e,e.uint32());break;case 3:if(i.dims&&i.dims.length||(i.dims=[]),(7&l)==2)for(var d=e.uint32()+e.pos;e.pos<d;)i.dims.push(e.int64());else i.dims.push(e.int64());break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";var t;if(e.values!=null&&e.hasOwnProperty("values")&&(t=o.onnx.TensorProto.verify(e.values)))return"values."+t;if(e.indices!=null&&e.hasOwnProperty("indices")&&(t=o.onnx.TensorProto.verify(e.indices)))return"indices."+t;if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var r=0;r<e.dims.length;++r)if(!(a.isInteger(e.dims[r])||e.dims[r]&&a.isInteger(e.dims[r].low)&&a.isInteger(e.dims[r].high)))return"dims: integer|Long[] expected"}return null},n.fromObject=function(e){if(e instanceof o.onnx.SparseTensorProto)return e;var t=new o.onnx.SparseTensorProto;if(e.values!=null){if(typeof e.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");t.values=o.onnx.TensorProto.fromObject(e.values)}if(e.indices!=null){if(typeof e.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");t.indices=o.onnx.TensorProto.fromObject(e.indices)}if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");t.dims=[];for(var r=0;r<e.dims.length;++r)a.Long?(t.dims[r]=a.Long.fromValue(e.dims[r])).unsigned=!1:typeof e.dims[r]=="string"?t.dims[r]=parseInt(e.dims[r],10):typeof e.dims[r]=="number"?t.dims[r]=e.dims[r]:typeof e.dims[r]=="object"&&(t.dims[r]=new a.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber())}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dims=[]),t.defaults&&(r.values=null,r.indices=null),e.values!=null&&e.hasOwnProperty("values")&&(r.values=o.onnx.TensorProto.toObject(e.values,t)),e.indices!=null&&e.hasOwnProperty("indices")&&(r.indices=o.onnx.TensorProto.toObject(e.indices,t)),e.dims&&e.dims.length){r.dims=[];for(var i=0;i<e.dims.length;++i)typeof e.dims[i]=="number"?r.dims[i]=t.longs===String?String(e.dims[i]):e.dims[i]:r.dims[i]=t.longs===String?a.Long.prototype.toString.call(e.dims[i]):t.longs===Number?new a.LongBits(e.dims[i].low>>>0,e.dims[i].high>>>0).toNumber():e.dims[i]}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.SparseTensorProto"},n}(),h.TensorShapeProto=function(){function n(e){if(this.dim=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.dim=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.dim!=null&&e.dim.length)for(var r=0;r<e.dim.length;++r)o.onnx.TensorShapeProto.Dimension.encode(e.dim[r],t.uint32(10).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TensorShapeProto;e.pos<r;){var l=e.uint32();l>>>3==1?(i.dim&&i.dim.length||(i.dim=[]),i.dim.push(o.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&l)}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dim!=null&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var t=0;t<e.dim.length;++t){var r=o.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);if(r)return"dim."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.TensorShapeProto)return e;var t=new o.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");t.dim=[];for(var r=0;r<e.dim.length;++r){if(typeof e.dim[r]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");t.dim[r]=o.onnx.TensorShapeProto.Dimension.fromObject(e.dim[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dim=[]),e.dim&&e.dim.length){r.dim=[];for(var i=0;i<e.dim.length;++i)r.dim[i]=o.onnx.TensorShapeProto.Dimension.toObject(e.dim[i],t)}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorShapeProto"},n.Dimension=function(){function e(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}var t;return e.prototype.dimValue=null,e.prototype.dimParam=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:a.oneOfGetter(t=["dimValue","dimParam"]),set:a.oneOfSetter(t)}),e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=s.create()),r.dimValue!=null&&Object.hasOwnProperty.call(r,"dimValue")&&i.uint32(8).int64(r.dimValue),r.dimParam!=null&&Object.hasOwnProperty.call(r,"dimParam")&&i.uint32(18).string(r.dimParam),r.denotation!=null&&Object.hasOwnProperty.call(r,"denotation")&&i.uint32(26).string(r.denotation),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TensorShapeProto.Dimension;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.dimValue=r.int64();break;case 2:d.dimParam=r.string();break;case 3:d.denotation=r.string();break;default:r.skipType(7&g)}}return d},e.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";var i={};if(r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(i.value=1,!(a.isInteger(r.dimValue)||r.dimValue&&a.isInteger(r.dimValue.low)&&a.isInteger(r.dimValue.high))))return"dimValue: integer|Long expected";if(r.dimParam!=null&&r.hasOwnProperty("dimParam")){if(i.value===1)return"value: multiple values";if(i.value=1,!a.isString(r.dimParam))return"dimParam: string expected"}return r.denotation!=null&&r.hasOwnProperty("denotation")&&!a.isString(r.denotation)?"denotation: string expected":null},e.fromObject=function(r){if(r instanceof o.onnx.TensorShapeProto.Dimension)return r;var i=new o.onnx.TensorShapeProto.Dimension;return r.dimValue!=null&&(a.Long?(i.dimValue=a.Long.fromValue(r.dimValue)).unsigned=!1:typeof r.dimValue=="string"?i.dimValue=parseInt(r.dimValue,10):typeof r.dimValue=="number"?i.dimValue=r.dimValue:typeof r.dimValue=="object"&&(i.dimValue=new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber())),r.dimParam!=null&&(i.dimParam=String(r.dimParam)),r.denotation!=null&&(i.denotation=String(r.denotation)),i},e.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.denotation=""),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(typeof r.dimValue=="number"?l.dimValue=i.longs===String?String(r.dimValue):r.dimValue:l.dimValue=i.longs===String?a.Long.prototype.toString.call(r.dimValue):i.longs===Number?new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber():r.dimValue,i.oneofs&&(l.value="dimValue")),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&(l.dimParam=r.dimParam,i.oneofs&&(l.value="dimParam")),r.denotation!=null&&r.hasOwnProperty("denotation")&&(l.denotation=r.denotation),l},e.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TensorShapeProto.Dimension"},e}(),n}(),h.TypeProto=function(){function n(t){if(t)for(var r=Object.keys(t),i=0;i<r.length;++i)t[r[i]]!=null&&(this[r[i]]=t[r[i]])}var e;return n.prototype.tensorType=null,n.prototype.sequenceType=null,n.prototype.mapType=null,n.prototype.optionalType=null,n.prototype.sparseTensorType=null,n.prototype.denotation="",Object.defineProperty(n.prototype,"value",{get:a.oneOfGetter(e=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:a.oneOfSetter(e)}),n.create=function(t){return new n(t)},n.encode=function(t,r){return r||(r=s.create()),t.tensorType!=null&&Object.hasOwnProperty.call(t,"tensorType")&&o.onnx.TypeProto.Tensor.encode(t.tensorType,r.uint32(10).fork()).ldelim(),t.sequenceType!=null&&Object.hasOwnProperty.call(t,"sequenceType")&&o.onnx.TypeProto.Sequence.encode(t.sequenceType,r.uint32(34).fork()).ldelim(),t.mapType!=null&&Object.hasOwnProperty.call(t,"mapType")&&o.onnx.TypeProto.Map.encode(t.mapType,r.uint32(42).fork()).ldelim(),t.denotation!=null&&Object.hasOwnProperty.call(t,"denotation")&&r.uint32(50).string(t.denotation),t.sparseTensorType!=null&&Object.hasOwnProperty.call(t,"sparseTensorType")&&o.onnx.TypeProto.SparseTensor.encode(t.sparseTensorType,r.uint32(66).fork()).ldelim(),t.optionalType!=null&&Object.hasOwnProperty.call(t,"optionalType")&&o.onnx.TypeProto.Optional.encode(t.optionalType,r.uint32(74).fork()).ldelim(),r},n.encodeDelimited=function(t,r){return this.encode(t,r).ldelim()},n.decode=function(t,r){t instanceof u||(t=u.create(t));for(var i=r===void 0?t.len:t.pos+r,l=new o.onnx.TypeProto;t.pos<i;){var d=t.uint32();switch(d>>>3){case 1:l.tensorType=o.onnx.TypeProto.Tensor.decode(t,t.uint32());break;case 4:l.sequenceType=o.onnx.TypeProto.Sequence.decode(t,t.uint32());break;case 5:l.mapType=o.onnx.TypeProto.Map.decode(t,t.uint32());break;case 9:l.optionalType=o.onnx.TypeProto.Optional.decode(t,t.uint32());break;case 8:l.sparseTensorType=o.onnx.TypeProto.SparseTensor.decode(t,t.uint32());break;case 6:l.denotation=t.string();break;default:t.skipType(7&d)}}return l},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";var r={};if(t.tensorType!=null&&t.hasOwnProperty("tensorType")&&(r.value=1,i=o.onnx.TypeProto.Tensor.verify(t.tensorType)))return"tensorType."+i;if(t.sequenceType!=null&&t.hasOwnProperty("sequenceType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Sequence.verify(t.sequenceType))return"sequenceType."+i}if(t.mapType!=null&&t.hasOwnProperty("mapType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Map.verify(t.mapType))return"mapType."+i}if(t.optionalType!=null&&t.hasOwnProperty("optionalType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Optional.verify(t.optionalType))return"optionalType."+i}if(t.sparseTensorType!=null&&t.hasOwnProperty("sparseTensorType")){if(r.value===1)return"value: multiple values";var i;if(r.value=1,i=o.onnx.TypeProto.SparseTensor.verify(t.sparseTensorType))return"sparseTensorType."+i}return t.denotation!=null&&t.hasOwnProperty("denotation")&&!a.isString(t.denotation)?"denotation: string expected":null},n.fromObject=function(t){if(t instanceof o.onnx.TypeProto)return t;var r=new o.onnx.TypeProto;if(t.tensorType!=null){if(typeof t.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");r.tensorType=o.onnx.TypeProto.Tensor.fromObject(t.tensorType)}if(t.sequenceType!=null){if(typeof t.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");r.sequenceType=o.onnx.TypeProto.Sequence.fromObject(t.sequenceType)}if(t.mapType!=null){if(typeof t.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");r.mapType=o.onnx.TypeProto.Map.fromObject(t.mapType)}if(t.optionalType!=null){if(typeof t.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");r.optionalType=o.onnx.TypeProto.Optional.fromObject(t.optionalType)}if(t.sparseTensorType!=null){if(typeof t.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");r.sparseTensorType=o.onnx.TypeProto.SparseTensor.fromObject(t.sparseTensorType)}return t.denotation!=null&&(r.denotation=String(t.denotation)),r},n.toObject=function(t,r){r||(r={});var i={};return r.defaults&&(i.denotation=""),t.tensorType!=null&&t.hasOwnProperty("tensorType")&&(i.tensorType=o.onnx.TypeProto.Tensor.toObject(t.tensorType,r),r.oneofs&&(i.value="tensorType")),t.sequenceType!=null&&t.hasOwnProperty("sequenceType")&&(i.sequenceType=o.onnx.TypeProto.Sequence.toObject(t.sequenceType,r),r.oneofs&&(i.value="sequenceType")),t.mapType!=null&&t.hasOwnProperty("mapType")&&(i.mapType=o.onnx.TypeProto.Map.toObject(t.mapType,r),r.oneofs&&(i.value="mapType")),t.denotation!=null&&t.hasOwnProperty("denotation")&&(i.denotation=t.denotation),t.sparseTensorType!=null&&t.hasOwnProperty("sparseTensorType")&&(i.sparseTensorType=o.onnx.TypeProto.SparseTensor.toObject(t.sparseTensorType,r),r.oneofs&&(i.value="sparseTensorType")),t.optionalType!=null&&t.hasOwnProperty("optionalType")&&(i.optionalType=o.onnx.TypeProto.Optional.toObject(t.optionalType,r),r.oneofs&&(i.value="optionalType")),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TypeProto"},n.Tensor=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&i.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&o.onnx.TensorShapeProto.encode(r.shape,i.uint32(18).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Tensor;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.elemType=r.int32();break;case 2:d.shape=o.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var i=o.onnx.TensorShapeProto.verify(r.shape);if(i)return"shape."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Tensor)return r;var i=new o.onnx.TypeProto.Tensor;if(r.elemType!=null&&(i.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");i.shape=o.onnx.TensorShapeProto.fromObject(r.shape)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=0,l.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(l.shape=o.onnx.TensorShapeProto.toObject(r.shape,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Tensor"},t}(),n.Sequence=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&o.onnx.TypeProto.encode(r.elemType,i.uint32(10).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Sequence;r.pos<l;){var g=r.uint32();g>>>3==1?d.elemType=o.onnx.TypeProto.decode(r,r.uint32()):r.skipType(7&g)}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var i=o.onnx.TypeProto.verify(r.elemType);if(i)return"elemType."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Sequence)return r;var i=new o.onnx.TypeProto.Sequence;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");i.elemType=o.onnx.TypeProto.fromObject(r.elemType)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=o.onnx.TypeProto.toObject(r.elemType,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Sequence"},t}(),n.Map=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.keyType!=null&&Object.hasOwnProperty.call(r,"keyType")&&i.uint32(8).int32(r.keyType),r.valueType!=null&&Object.hasOwnProperty.call(r,"valueType")&&o.onnx.TypeProto.encode(r.valueType,i.uint32(18).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Map;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.keyType=r.int32();break;case 2:d.valueType=o.onnx.TypeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.keyType!=null&&r.hasOwnProperty("keyType")&&!a.isInteger(r.keyType))return"keyType: integer expected";if(r.valueType!=null&&r.hasOwnProperty("valueType")){var i=o.onnx.TypeProto.verify(r.valueType);if(i)return"valueType."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Map)return r;var i=new o.onnx.TypeProto.Map;if(r.keyType!=null&&(i.keyType=0|r.keyType),r.valueType!=null){if(typeof r.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");i.valueType=o.onnx.TypeProto.fromObject(r.valueType)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.keyType=0,l.valueType=null),r.keyType!=null&&r.hasOwnProperty("keyType")&&(l.keyType=r.keyType),r.valueType!=null&&r.hasOwnProperty("valueType")&&(l.valueType=o.onnx.TypeProto.toObject(r.valueType,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Map"},t}(),n.Optional=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&o.onnx.TypeProto.encode(r.elemType,i.uint32(10).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Optional;r.pos<l;){var g=r.uint32();g>>>3==1?d.elemType=o.onnx.TypeProto.decode(r,r.uint32()):r.skipType(7&g)}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var i=o.onnx.TypeProto.verify(r.elemType);if(i)return"elemType."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Optional)return r;var i=new o.onnx.TypeProto.Optional;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");i.elemType=o.onnx.TypeProto.fromObject(r.elemType)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=o.onnx.TypeProto.toObject(r.elemType,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Optional"},t}(),n.SparseTensor=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&i.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&o.onnx.TensorShapeProto.encode(r.shape,i.uint32(18).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.SparseTensor;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.elemType=r.int32();break;case 2:d.shape=o.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var i=o.onnx.TensorShapeProto.verify(r.shape);if(i)return"shape."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.SparseTensor)return r;var i=new o.onnx.TypeProto.SparseTensor;if(r.elemType!=null&&(i.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");i.shape=o.onnx.TensorShapeProto.fromObject(r.shape)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=0,l.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(l.shape=o.onnx.TensorShapeProto.toObject(r.shape,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.SparseTensor"},t}(),n}(),h.OperatorSetIdProto=function(){function n(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.domain="",n.prototype.version=a.Long?a.Long.fromBits(0,0,!1):0,n.create=function(e){return new n(e)},n.encode=function(e,t){return t||(t=s.create()),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(10).string(e.domain),e.version!=null&&Object.hasOwnProperty.call(e,"version")&&t.uint32(16).int64(e.version),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.OperatorSetIdProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.domain=e.string();break;case 2:i.version=e.int64();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){return typeof e!="object"||e===null?"object expected":e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain)?"domain: string expected":e.version!=null&&e.hasOwnProperty("version")&&!(a.isInteger(e.version)||e.version&&a.isInteger(e.version.low)&&a.isInteger(e.version.high))?"version: integer|Long expected":null},n.fromObject=function(e){if(e instanceof o.onnx.OperatorSetIdProto)return e;var t=new o.onnx.OperatorSetIdProto;return e.domain!=null&&(t.domain=String(e.domain)),e.version!=null&&(a.Long?(t.version=a.Long.fromValue(e.version)).unsigned=!1:typeof e.version=="string"?t.version=parseInt(e.version,10):typeof e.version=="number"?t.version=e.version:typeof e.version=="object"&&(t.version=new a.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),t},n.toObject=function(e,t){t||(t={});var r={};if(t.defaults)if(r.domain="",a.Long){var i=new a.Long(0,0,!1);r.version=t.longs===String?i.toString():t.longs===Number?i.toNumber():i}else r.version=t.longs===String?"0":0;return e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.version!=null&&e.hasOwnProperty("version")&&(typeof e.version=="number"?r.version=t.longs===String?String(e.version):e.version:r.version=t.longs===String?a.Long.prototype.toString.call(e.version):t.longs===Number?new a.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.OperatorSetIdProto"},n}(),h.OperatorStatus=function(){var n={},e=Object.create(n);return e[n[0]="EXPERIMENTAL"]=0,e[n[1]="STABLE"]=1,e}(),h.FunctionProto=function(){function n(e){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.name="",n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.attribute=a.emptyArray,n.prototype.attributeProto=a.emptyArray,n.prototype.node=a.emptyArray,n.prototype.docString="",n.prototype.opsetImport=a.emptyArray,n.prototype.domain="",n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(10).string(e.name),e.input!=null&&e.input.length)for(var r=0;r<e.input.length;++r)t.uint32(34).string(e.input[r]);if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)t.uint32(42).string(e.output[r]);if(e.attribute!=null&&e.attribute.length)for(r=0;r<e.attribute.length;++r)t.uint32(50).string(e.attribute[r]);if(e.node!=null&&e.node.length)for(r=0;r<e.node.length;++r)o.onnx.NodeProto.encode(e.node[r],t.uint32(58).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(66).string(e.docString),e.opsetImport!=null&&e.opsetImport.length)for(r=0;r<e.opsetImport.length;++r)o.onnx.OperatorSetIdProto.encode(e.opsetImport[r],t.uint32(74).fork()).ldelim();if(e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(82).string(e.domain),e.attributeProto!=null&&e.attributeProto.length)for(r=0;r<e.attributeProto.length;++r)o.onnx.AttributeProto.encode(e.attributeProto[r],t.uint32(90).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.FunctionProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.name=e.string();break;case 4:i.input&&i.input.length||(i.input=[]),i.input.push(e.string());break;case 5:i.output&&i.output.length||(i.output=[]),i.output.push(e.string());break;case 6:i.attribute&&i.attribute.length||(i.attribute=[]),i.attribute.push(e.string());break;case 11:i.attributeProto&&i.attributeProto.length||(i.attributeProto=[]),i.attributeProto.push(o.onnx.AttributeProto.decode(e,e.uint32()));break;case 7:i.node&&i.node.length||(i.node=[]),i.node.push(o.onnx.NodeProto.decode(e,e.uint32()));break;case 8:i.docString=e.string();break;case 9:i.opsetImport&&i.opsetImport.length||(i.opsetImport=[]),i.opsetImport.push(o.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 10:i.domain=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!a.isString(e.input[t]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!a.isString(e.output[t]))return"output: string[] expected"}if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t)if(!a.isString(e.attribute[t]))return"attribute: string[] expected"}if(e.attributeProto!=null&&e.hasOwnProperty("attributeProto")){if(!Array.isArray(e.attributeProto))return"attributeProto: array expected";for(t=0;t<e.attributeProto.length;++t)if(r=o.onnx.AttributeProto.verify(e.attributeProto[t]))return"attributeProto."+r}if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(t=0;t<e.node.length;++t)if(r=o.onnx.NodeProto.verify(e.node[t]))return"node."+r}if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(t=0;t<e.opsetImport.length;++t){var r;if(r=o.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+r}}return e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain)?"domain: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.FunctionProto)return e;var t=new o.onnx.FunctionProto;if(e.name!=null&&(t.name=String(e.name)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.FunctionProto.input: array expected");t.input=[];for(var r=0;r<e.input.length;++r)t.input[r]=String(e.input[r])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.FunctionProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r)t.output[r]=String(e.output[r])}if(e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");for(t.attribute=[],r=0;r<e.attribute.length;++r)t.attribute[r]=String(e.attribute[r])}if(e.attributeProto){if(!Array.isArray(e.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");for(t.attributeProto=[],r=0;r<e.attributeProto.length;++r){if(typeof e.attributeProto[r]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");t.attributeProto[r]=o.onnx.AttributeProto.fromObject(e.attributeProto[r])}}if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.FunctionProto.node: array expected");for(t.node=[],r=0;r<e.node.length;++r){if(typeof e.node[r]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");t.node[r]=o.onnx.NodeProto.fromObject(e.node[r])}}if(e.docString!=null&&(t.docString=String(e.docString)),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");for(t.opsetImport=[],r=0;r<e.opsetImport.length;++r){if(typeof e.opsetImport[r]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");t.opsetImport[r]=o.onnx.OperatorSetIdProto.fromObject(e.opsetImport[r])}}return e.domain!=null&&(t.domain=String(e.domain)),t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.input=[],r.output=[],r.attribute=[],r.node=[],r.opsetImport=[],r.attributeProto=[]),t.defaults&&(r.name="",r.docString="",r.domain=""),e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.input&&e.input.length){r.input=[];for(var i=0;i<e.input.length;++i)r.input[i]=e.input[i]}if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=e.output[i];if(e.attribute&&e.attribute.length)for(r.attribute=[],i=0;i<e.attribute.length;++i)r.attribute[i]=e.attribute[i];if(e.node&&e.node.length)for(r.node=[],i=0;i<e.node.length;++i)r.node[i]=o.onnx.NodeProto.toObject(e.node[i],t);if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.opsetImport&&e.opsetImport.length)for(r.opsetImport=[],i=0;i<e.opsetImport.length;++i)r.opsetImport[i]=o.onnx.OperatorSetIdProto.toObject(e.opsetImport[i],t);if(e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.attributeProto&&e.attributeProto.length)for(r.attributeProto=[],i=0;i<e.attributeProto.length;++i)r.attributeProto[i]=o.onnx.AttributeProto.toObject(e.attributeProto[i],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.FunctionProto"},n}(),h),M.exports=o},3474:(M,c,y)=>{var m,f=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(m=m||__filename),function(h={}){function p(){return z.buffer!=te.buffer&&Me(),te}function u(){return z.buffer!=te.buffer&&Me(),ae}function s(){return z.buffer!=te.buffer&&Me(),se}function a(){return z.buffer!=te.buffer&&Me(),pe}function o(){return z.buffer!=te.buffer&&Me(),ge}var n,e,t=h;t.ready=new Promise((k,G)=>{n=k,e=G});var r,i,l,d=Object.assign({},t),g="./this.program",b=(k,G)=>{throw G},v=typeof window=="object",w=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=t.ENVIRONMENT_IS_PTHREAD||!1,O="";function P(k){return t.locateFile?t.locateFile(k,O):O+k}if(x){var I=y(1384),R=y(908);let k;O=w?R.dirname(O)+"/":__dirname+"/",r=(G,H)=>(G=G.startsWith("file://")?new URL(G):R.normalize(G),I.readFileSync(G,H?void 0:"utf8")),l=G=>((G=r(G,!0)).buffer||(G=new Uint8Array(G)),G),i=(G,H,Q,ie=!0)=>{G=G.startsWith("file://")?new URL(G):R.normalize(G),I.readFile(G,ie?void 0:"utf8",(ye,$e)=>{ye?Q(ye):H(ie?$e.buffer:$e)})},!t.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),b=(G,H)=>{throw process.exitCode=G,H},t.inspect=()=>"[Emscripten Module object]";try{k=y(9925)}catch(G){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),G}global.Worker=k.Worker}else(v||w)&&(w?O=self.location.href:typeof document<"u"&&document.currentScript&&(O=document.currentScript.src),m&&(O=m),O=O.indexOf("blob:")!==0?O.substr(0,O.replace(/[?#].*/,"").lastIndexOf("/")+1):"",x||(r=k=>{var G=new XMLHttpRequest;return G.open("GET",k,!1),G.send(null),G.responseText},w&&(l=k=>{var G=new XMLHttpRequest;return G.open("GET",k,!1),G.responseType="arraybuffer",G.send(null),new Uint8Array(G.response)}),i=(k,G,H)=>{var Q=new XMLHttpRequest;Q.open("GET",k,!0),Q.responseType="arraybuffer",Q.onload=()=>{Q.status==200||Q.status==0&&Q.response?G(Q.response):H()},Q.onerror=H,Q.send(null)}));x&&typeof performance>"u"&&(global.performance=y(6953).performance);var j=console.log.bind(console),A=console.error.bind(console);x&&(j=(...k)=>I.writeSync(1,k.join(" ")+`
`),A=(...k)=>I.writeSync(2,k.join(" ")+`
`));var C,_=t.print||j,S=t.printErr||A;Object.assign(t,d),d=null,t.thisProgram&&(g=t.thisProgram),t.quit&&(b=t.quit),t.wasmBinary&&(C=t.wasmBinary);var E=t.noExitRuntime||!0;typeof WebAssembly!="object"&&Ye("no native wasm support detected");var z,L,Y,X,te,ae,se,pe,ge,ve=!1;function Me(){var k=z.buffer;t.HEAP8=te=new Int8Array(k),t.HEAP16=new Int16Array(k),t.HEAP32=se=new Int32Array(k),t.HEAPU8=ae=new Uint8Array(k),t.HEAPU16=new Uint16Array(k),t.HEAPU32=pe=new Uint32Array(k),t.HEAPF32=new Float32Array(k),t.HEAPF64=ge=new Float64Array(k)}var De=t.INITIAL_MEMORY||16777216;if(5242880<=De||Ye("INITIAL_MEMORY should be larger than STACK_SIZE, was "+De+"! (STACK_SIZE=5242880)"),T)z=t.wasmMemory;else if(t.wasmMemory)z=t.wasmMemory;else if(!((z=new WebAssembly.Memory({initial:De/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw S("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&S("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Me(),De=z.buffer.byteLength;var je,_e=[],Be=[],Pe=[],Re=0;function Ue(){return E||0<Re}var He,Ze,et=0,ct=null,qe=null;function Qe(){et++,t.monitorRunDependencies&&t.monitorRunDependencies(et)}function tt(){if(et--,t.monitorRunDependencies&&t.monitorRunDependencies(et),et==0&&(ct!==null&&(clearInterval(ct),ct=null),qe)){var k=qe;qe=null,k()}}function Ye(k){throw t.onAbort&&t.onAbort(k),S(k="Aborted("+k+")"),ve=!0,X=1,k=new WebAssembly.RuntimeError(k+". Build with -sASSERTIONS for more info."),e(k),k}function wt(k){return k.startsWith("data:application/octet-stream;base64,")}function ft(k){if(k==He&&C)return new Uint8Array(C);if(l)return l(k);throw"both async and sync fetching of the wasm failed"}function ht(k,G,H){return function(Q){if(!C&&(v||w)){if(typeof fetch=="function"&&!Q.startsWith("file://"))return fetch(Q,{credentials:"same-origin"}).then(ie=>{if(!ie.ok)throw"failed to load wasm binary file at '"+Q+"'";return ie.arrayBuffer()}).catch(()=>ft(Q));if(i)return new Promise((ie,ye)=>{i(Q,$e=>ie(new Uint8Array($e)),ye)})}return Promise.resolve().then(()=>ft(Q))}(k).then(Q=>WebAssembly.instantiate(Q,G)).then(Q=>Q).then(H,Q=>{S("failed to asynchronously prepare wasm: "+Q),Ye(Q)})}function bt(k){this.name="ExitStatus",this.message=`Program terminated with exit(${k})`,this.status=k}function xt(k){k.terminate(),k.onmessage=()=>{}}function Ot(k){(k=de.Fa[k])||Ye(),de.fb(k)}function At(k){var G=de.Za();if(!G)return 6;de.Ia.push(G),de.Fa[k.Ha]=G,G.Ha=k.Ha;var H={cmd:"run",start_routine:k.gb,arg:k.Ya,pthread_ptr:k.Ha};return x&&G.unref(),G.postMessage(H,k.mb),0}wt(He="ort-wasm-threaded.wasm")||(He=P(He));var Ct=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,kt=(k,G,H)=>{var Q=(G>>>=0)+H;for(H=G;k[H]&&!(H>=Q);)++H;if(16<H-G&&k.buffer&&Ct)return Ct.decode(k.buffer instanceof SharedArrayBuffer?k.slice(G,H):k.subarray(G,H));for(Q="";G<H;){var ie=k[G++];if(128&ie){var ye=63&k[G++];if((224&ie)==192)Q+=String.fromCharCode((31&ie)<<6|ye);else{var $e=63&k[G++];65536>(ie=(240&ie)==224?(15&ie)<<12|ye<<6|$e:(7&ie)<<18|ye<<12|$e<<6|63&k[G++])?Q+=String.fromCharCode(ie):(ie-=65536,Q+=String.fromCharCode(55296|ie>>10,56320|1023&ie))}}else Q+=String.fromCharCode(ie)}return Q},pt=(k,G)=>(k>>>=0)?kt(u(),k,G):"";function $t(k){if(T)return we(1,1,k);X=k,Ue()||(de.hb(),t.onExit&&t.onExit(k),ve=!0),b(k,new bt(k))}var Tt=k=>{if(X=k,T)throw mt(k),"unwind";$t(k)},de={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){T?de.ab():de.$a()},$a:function(){_e.unshift(()=>{Qe(),de.bb(()=>tt())})},ab:function(){de.receiveObjectTransfer=de.eb,de.threadInitTLS=de.Sa,de.setExitStatus=de.Ra,E=!1},Ra:function(k){X=k},rb:["$terminateWorker"],hb:function(){for(var k of de.Ia)xt(k);for(k of de.La)xt(k);de.La=[],de.Ia=[],de.Fa=[]},fb:function(k){var G=k.Ha;delete de.Fa[G],de.La.push(k),de.Ia.splice(de.Ia.indexOf(k),1),k.Ha=0,Wt(G)},eb:function(){},Sa:function(){de.Ta.forEach(k=>k())},cb:k=>new Promise(G=>{k.onmessage=ie=>{var ye=(ie=ie.data).cmd;if(ie.targetThread&&ie.targetThread!=St()){var $e=de.Fa[ie.qb];$e?$e.postMessage(ie,ie.transferList):S('Internal error! Worker sent a message "'+ye+'" to target pthread '+ie.targetThread+", but that thread no longer exists!")}else ye==="checkMailbox"?F():ye==="spawnThread"?At(ie):ye==="cleanupThread"?Ot(ie.thread):ye==="killThread"?(ie=ie.thread,ye=de.Fa[ie],delete de.Fa[ie],xt(ye),Wt(ie),de.Ia.splice(de.Ia.indexOf(ye),1),ye.Ha=0):ye==="cancelThread"?de.Fa[ie.thread].postMessage({cmd:"cancel"}):ye==="loaded"?(k.loaded=!0,G(k)):ye==="alert"?alert("Thread "+ie.threadId+": "+ie.text):ie.target==="setimmediate"?k.postMessage(ie):ye==="callHandler"?t[ie.handler](...ie.args):ye&&S("worker sent an unknown command "+ye)},k.onerror=ie=>{throw S("worker sent an error! "+ie.filename+":"+ie.lineno+": "+ie.message),ie},x&&(k.on("message",function(ie){k.onmessage({data:ie})}),k.on("error",function(ie){k.onerror(ie)}));var H,Q=[];for(H of["onExit","onAbort","print","printErr"])t.hasOwnProperty(H)&&Q.push(H);k.postMessage({cmd:"load",handlers:Q,urlOrBlob:t.mainScriptUrlOrBlob||m,wasmMemory:z,wasmModule:Y})}),bb:function(k){k()},Xa:function(){var k=P("ort-wasm-threaded.worker.js");k=new Worker(k),de.La.push(k)},Za:function(){return de.La.length==0&&(de.Xa(),de.cb(de.La[0])),de.La.pop()}};t.PThread=de;var gt=k=>{for(;0<k.length;)k.shift()(t)};function mt(k){if(T)return we(2,0,k);Tt(k)}t.establishStackSpace=function(){var k=St(),G=s()[k+52>>2>>>0];k=s()[k+56>>2>>>0],pn(G,G-k),jt(G)};var U=[];function J(k){this.Oa=k-24,this.Wa=function(G){a()[this.Oa+4>>2>>>0]=G},this.Va=function(G){a()[this.Oa+8>>2>>>0]=G},this.Pa=function(G,H){this.Ua(),this.Wa(G),this.Va(H)},this.Ua=function(){a()[this.Oa+16>>2>>>0]=0}}function ee(k,G,H,Q){return T?we(3,1,k,G,H,Q):le(k,G,H,Q)}function le(k,G,H,Q){if(k>>>=0,G>>>=0,H>>>=0,Q>>>=0,typeof SharedArrayBuffer>"u")return S("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ie=[];return T&&ie.length===0?ee(k,G,H,Q):(k={gb:H,Ha:k,Ya:Q,mb:ie},T?(k.ob="spawnThread",postMessage(k,ie),0):At(k))}function me(k,G,H){return T?we(4,1,k,G,H):0}function Ae(k,G){if(T)return we(5,1,k,G)}t.invokeEntryPoint=function(k,G){var H=U[k];H||(k>=U.length&&(U.length=k+1),U[k]=H=je.get(k)),k=H(G),Ue()?de.Ra(k):Zt(k)};var Ce=k=>{for(var G=0,H=0;H<k.length;++H){var Q=k.charCodeAt(H);127>=Q?G++:2047>=Q?G+=2:55296<=Q&&57343>=Q?(G+=4,++H):G+=3}return G},rt=(k,G,H,Q)=>{if(!(0<Q))return 0;var ie=H>>>=0;Q=H+Q-1;for(var ye=0;ye<k.length;++ye){var $e=k.charCodeAt(ye);if(55296<=$e&&57343>=$e&&($e=65536+((1023&$e)<<10)|1023&k.charCodeAt(++ye)),127>=$e){if(H>=Q)break;G[H++>>>0]=$e}else{if(2047>=$e){if(H+1>=Q)break;G[H++>>>0]=192|$e>>6}else{if(65535>=$e){if(H+2>=Q)break;G[H++>>>0]=224|$e>>12}else{if(H+3>=Q)break;G[H++>>>0]=240|$e>>18,G[H++>>>0]=128|$e>>12&63}G[H++>>>0]=128|$e>>6&63}G[H++>>>0]=128|63&$e}}return G[H>>>0]=0,H-ie},ut=(k,G,H)=>rt(k,u(),G,H);function ot(k,G){if(T)return we(6,1,k,G)}function it(k,G,H){if(T)return we(7,1,k,G,H)}function Pt(k,G,H){return T?we(8,1,k,G,H):0}function It(k,G){if(T)return we(9,1,k,G)}function oe(k,G,H){if(T)return we(10,1,k,G,H)}function Fe(k,G,H,Q){if(T)return we(11,1,k,G,H,Q)}function Xe(k,G,H,Q){if(T)return we(12,1,k,G,H,Q)}function yt(k,G,H,Q){if(T)return we(13,1,k,G,H,Q)}function Et(k){if(T)return we(14,1,k)}function Nt(k,G){if(T)return we(15,1,k,G)}function Lt(k,G,H){if(T)return we(16,1,k,G,H)}var Ft=k=>{if(!ve)try{if(k(),!Ue())try{T?Zt(X):Tt(X)}catch(G){G instanceof bt||G=="unwind"||b(1,G)}}catch(G){G instanceof bt||G=="unwind"||b(1,G)}};function D(k){k>>>=0,typeof Atomics.nb=="function"&&(Atomics.nb(s(),k>>2,k).value.then(F),k+=128,Atomics.store(s(),k>>2,1))}function F(){var k=St();k&&(D(k),Ft(()=>Qt()))}t.__emscripten_thread_mailbox_await=D,t.checkMailbox=F;var V=k=>k%4==0&&(k%100!=0||k%400==0),K=[0,31,60,91,121,152,182,213,244,274,305,335],Z=[0,31,59,90,120,151,181,212,243,273,304,334];function fe(k,G,H,Q,ie,ye,$e,at){return T?we(17,1,k,G,H,Q,ie,ye,$e,at):-52}function be(k,G,H,Q,ie,ye,$e){if(T)return we(18,1,k,G,H,Q,ie,ye,$e)}var xe=k=>{var G=Ce(k)+1,H=Dt(G);return H&&ut(k,H,G),H},Se=k=>{var G=en();return k=k(),jt(G),k};function we(k,G){var H=arguments.length-2,Q=arguments;return Se(()=>{for(var ie=zt(8*H),ye=ie>>3,$e=0;$e<H;$e++){var at=Q[2+$e];o()[ye+$e>>>0]=at}return Jt(k,H,ie,G)})}var Te,ze=[],Ve={},ne=()=>{if(!Te){var k,G={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(k in Ve)Ve[k]===void 0?delete G[k]:G[k]=Ve[k];var H=[];for(k in G)H.push(`${k}=${G[k]}`);Te=H}return Te};function ke(k,G){if(T)return we(19,1,k,G);k>>>=0,G>>>=0;var H=0;return ne().forEach(function(Q,ie){var ye=G+H;for(ie=a()[k+4*ie>>2>>>0]=ye,ye=0;ye<Q.length;++ye)p()[ie++>>0>>>0]=Q.charCodeAt(ye);p()[ie>>0>>>0]=0,H+=Q.length+1}),0}function Ge(k,G){if(T)return we(20,1,k,G);k>>>=0,G>>>=0;var H=ne();a()[k>>2>>>0]=H.length;var Q=0;return H.forEach(function(ie){Q+=ie.length+1}),a()[G>>2>>>0]=Q,0}function _t(k){return T?we(21,1,k):52}function Bt(k,G,H,Q){return T?we(22,1,k,G,H,Q):52}function Ht(k,G,H,Q,ie){return T?we(23,1,k,G,H,Q,ie):70}var on=[null,[],[]];function an(k,G,H,Q){if(T)return we(24,1,k,G,H,Q);G>>>=0,H>>>=0,Q>>>=0;for(var ie=0,ye=0;ye<H;ye++){var $e=a()[G>>2>>>0],at=a()[G+4>>2>>>0];G+=8;for(var vt=0;vt<at;vt++){var lt=u()[$e+vt>>>0],dt=on[k];lt===0||lt===10?((k===1?_:S)(kt(dt,0)),dt.length=0):dt.push(lt)}ie+=at}return a()[Q>>2>>>0]=ie,0}var qt=k=>(qt=(()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return Q=>(Q.set(crypto.getRandomValues(new Uint8Array(Q.byteLength))),Q);if(x)try{var G=y(760);if(G.randomFillSync)return Q=>G.randomFillSync(Q);var H=G.randomBytes;return Q=>(Q.set(H(Q.byteLength)),Q)}catch{}Ye("initRandomDevice")})())(k),Kt=[31,29,31,30,31,30,31,31,30,31,30,31],Xt=[31,28,31,30,31,30,31,31,30,31,30,31],sn=(k,G)=>{p().set(k,G>>>0)};function un(k,G,H,Q){function ie(ue,We,st){for(ue=typeof ue=="number"?ue.toString():ue||"";ue.length<We;)ue=st[0]+ue;return ue}function ye(ue,We){return ie(ue,We,"0")}function $e(ue,We){function st($){return 0>$?-1:0<$?1:0}var Rt;return(Rt=st(ue.getFullYear()-We.getFullYear()))===0&&(Rt=st(ue.getMonth()-We.getMonth()))===0&&(Rt=st(ue.getDate()-We.getDate())),Rt}function at(ue){switch(ue.getDay()){case 0:return new Date(ue.getFullYear()-1,11,29);case 1:return ue;case 2:return new Date(ue.getFullYear(),0,3);case 3:return new Date(ue.getFullYear(),0,2);case 4:return new Date(ue.getFullYear(),0,1);case 5:return new Date(ue.getFullYear()-1,11,31);case 6:return new Date(ue.getFullYear()-1,11,30)}}function vt(ue){var We=ue.Ja;for(ue=new Date(new Date(ue.Ka+1900,0,1).getTime());0<We;){var st=ue.getMonth(),Rt=(V(ue.getFullYear())?Kt:Xt)[st];if(!(We>Rt-ue.getDate())){ue.setDate(ue.getDate()+We);break}We-=Rt-ue.getDate()+1,ue.setDate(1),11>st?ue.setMonth(st+1):(ue.setMonth(0),ue.setFullYear(ue.getFullYear()+1))}return st=new Date(ue.getFullYear()+1,0,4),We=at(new Date(ue.getFullYear(),0,4)),st=at(st),0>=$e(We,ue)?0>=$e(st,ue)?ue.getFullYear()+1:ue.getFullYear():ue.getFullYear()-1}k>>>=0,G>>>=0,H>>>=0,Q>>>=0;var lt=s()[Q+40>>2>>>0];for(var dt in Q={kb:s()[Q>>2>>>0],jb:s()[Q+4>>2>>>0],Ma:s()[Q+8>>2>>>0],Qa:s()[Q+12>>2>>>0],Na:s()[Q+16>>2>>>0],Ka:s()[Q+20>>2>>>0],Ga:s()[Q+24>>2>>>0],Ja:s()[Q+28>>2>>>0],sb:s()[Q+32>>2>>>0],ib:s()[Q+36>>2>>>0],lb:lt?pt(lt):""},H=pt(H),lt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})H=H.replace(new RegExp(dt,"g"),lt[dt]);var nn="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),rn="January February March April May June July August September October November December".split(" ");for(dt in lt={"%a":ue=>nn[ue.Ga].substring(0,3),"%A":ue=>nn[ue.Ga],"%b":ue=>rn[ue.Na].substring(0,3),"%B":ue=>rn[ue.Na],"%C":ue=>ye((ue.Ka+1900)/100|0,2),"%d":ue=>ye(ue.Qa,2),"%e":ue=>ie(ue.Qa,2," "),"%g":ue=>vt(ue).toString().substring(2),"%G":ue=>vt(ue),"%H":ue=>ye(ue.Ma,2),"%I":ue=>((ue=ue.Ma)==0?ue=12:12<ue&&(ue-=12),ye(ue,2)),"%j":ue=>{for(var We=0,st=0;st<=ue.Na-1;We+=(V(ue.Ka+1900)?Kt:Xt)[st++]);return ye(ue.Qa+We,3)},"%m":ue=>ye(ue.Na+1,2),"%M":ue=>ye(ue.jb,2),"%n":()=>`
`,"%p":ue=>0<=ue.Ma&&12>ue.Ma?"AM":"PM","%S":ue=>ye(ue.kb,2),"%t":()=>"	","%u":ue=>ue.Ga||7,"%U":ue=>ye(Math.floor((ue.Ja+7-ue.Ga)/7),2),"%V":ue=>{var We=Math.floor((ue.Ja+7-(ue.Ga+6)%7)/7);if(2>=(ue.Ga+371-ue.Ja-2)%7&&We++,We)We==53&&((st=(ue.Ga+371-ue.Ja)%7)==4||st==3&&V(ue.Ka)||(We=1));else{We=52;var st=(ue.Ga+7-ue.Ja-1)%7;(st==4||st==5&&V(ue.Ka%400-1))&&We++}return ye(We,2)},"%w":ue=>ue.Ga,"%W":ue=>ye(Math.floor((ue.Ja+7-(ue.Ga+6)%7)/7),2),"%y":ue=>(ue.Ka+1900).toString().substring(2),"%Y":ue=>ue.Ka+1900,"%z":ue=>{var We=0<=(ue=ue.ib);return ue=Math.abs(ue)/60,(We?"+":"-")+("0000"+(ue/60*100+ue%60)).slice(-4)},"%Z":ue=>ue.lb,"%%":()=>"%"},H=H.replace(/%%/g,"\0\0"),lt)H.includes(dt)&&(H=H.replace(new RegExp(dt,"g"),lt[dt](Q)));return dt=function(ue){var We=Array(Ce(ue)+1);return rt(ue,We,0,We.length),We}(H=H.replace(/\0\0/g,"%")),dt.length>G?0:(sn(dt,k),dt.length-1)}de.Pa();var ln=[null,$t,mt,ee,me,Ae,ot,it,Pt,It,oe,Fe,Xe,yt,Et,Nt,Lt,fe,be,ke,Ge,_t,Bt,Ht,an],Vt={b:function(k,G,H){throw new J(k>>>=0).Pa(G>>>0,H>>>0),k},N:function(k){Yt(k>>>0,!w,1,!v,131072,!1),de.Sa()},k:function(k){k>>>=0,T?postMessage({cmd:"cleanupThread",thread:k}):Ot(k)},I:le,h:me,T:Ae,E:ot,G:it,U:Pt,R:It,J:oe,Q:Fe,o:Xe,F:yt,C:Et,S:Nt,D:Lt,q:()=>!0,A:function(k,G){(k>>>=0)==G>>>0?setTimeout(()=>F()):T?postMessage({targetThread:k,cmd:"checkMailbox"}):(k=de.Fa[k])&&k.postMessage({cmd:"checkMailbox"})},L:function(){return-1},M:D,p:function(k){x&&de.Fa[k>>>0].ref()},t:function(k,G,H){k=G+2097152>>>0<4194305-!!k?(k>>>0)+4294967296*G:NaN,H>>>=0,k=new Date(1e3*k),s()[H>>2>>>0]=k.getUTCSeconds(),s()[H+4>>2>>>0]=k.getUTCMinutes(),s()[H+8>>2>>>0]=k.getUTCHours(),s()[H+12>>2>>>0]=k.getUTCDate(),s()[H+16>>2>>>0]=k.getUTCMonth(),s()[H+20>>2>>>0]=k.getUTCFullYear()-1900,s()[H+24>>2>>>0]=k.getUTCDay(),k=(k.getTime()-Date.UTC(k.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[H+28>>2>>>0]=k},u:function(k,G,H){k=G+2097152>>>0<4194305-!!k?(k>>>0)+4294967296*G:NaN,H>>>=0,k=new Date(1e3*k),s()[H>>2>>>0]=k.getSeconds(),s()[H+4>>2>>>0]=k.getMinutes(),s()[H+8>>2>>>0]=k.getHours(),s()[H+12>>2>>>0]=k.getDate(),s()[H+16>>2>>>0]=k.getMonth(),s()[H+20>>2>>>0]=k.getFullYear()-1900,s()[H+24>>2>>>0]=k.getDay(),G=(V(k.getFullYear())?K:Z)[k.getMonth()]+k.getDate()-1|0,s()[H+28>>2>>>0]=G,s()[H+36>>2>>>0]=-60*k.getTimezoneOffset(),G=new Date(k.getFullYear(),6,1).getTimezoneOffset();var Q=new Date(k.getFullYear(),0,1).getTimezoneOffset();k=0|(G!=Q&&k.getTimezoneOffset()==Math.min(Q,G)),s()[H+32>>2>>>0]=k},v:function(k){k>>>=0;var G=new Date(s()[k+20>>2>>>0]+1900,s()[k+16>>2>>>0],s()[k+12>>2>>>0],s()[k+8>>2>>>0],s()[k+4>>2>>>0],s()[k>>2>>>0],0),H=s()[k+32>>2>>>0],Q=G.getTimezoneOffset(),ie=new Date(G.getFullYear(),6,1).getTimezoneOffset(),ye=new Date(G.getFullYear(),0,1).getTimezoneOffset(),$e=Math.min(ye,ie);return 0>H?s()[k+32>>2>>>0]=+(ie!=ye&&$e==Q):0<H!=($e==Q)&&(ie=Math.max(ye,ie),G.setTime(G.getTime()+6e4*((0<H?$e:ie)-Q))),s()[k+24>>2>>>0]=G.getDay(),H=(V(G.getFullYear())?K:Z)[G.getMonth()]+G.getDate()-1|0,s()[k+28>>2>>>0]=H,s()[k>>2>>>0]=G.getSeconds(),s()[k+4>>2>>>0]=G.getMinutes(),s()[k+8>>2>>>0]=G.getHours(),s()[k+12>>2>>>0]=G.getDate(),s()[k+16>>2>>>0]=G.getMonth(),s()[k+20>>2>>>0]=G.getYear(),k=G.getTime()/1e3,cn((Ze=k,1<=+Math.abs(Ze)?0<Ze?+Math.floor(Ze/4294967296)>>>0:~~+Math.ceil((Ze-+(~~Ze>>>0))/4294967296)>>>0:0)),k>>>0},r:fe,s:be,z:function(k,G,H){function Q(lt){return(lt=lt.toTimeString().match(/\(([A-Za-z ]+)\)$/))?lt[1]:"GMT"}k>>>=0,G>>>=0,H>>>=0;var ie=new Date().getFullYear(),ye=new Date(ie,0,1),$e=new Date(ie,6,1);ie=ye.getTimezoneOffset();var at=$e.getTimezoneOffset(),vt=Math.max(ie,at);a()[k>>2>>>0]=60*vt,s()[G>>2>>>0]=+(ie!=at),k=Q(ye),G=Q($e),k=xe(k),G=xe(G),at<ie?(a()[H>>2>>>0]=k,a()[H+4>>2>>>0]=G):(a()[H>>2>>>0]=G,a()[H+4>>2>>>0]=k)},c:()=>{Ye("")},l:function(){},i:function(){return Date.now()},V:()=>{throw Re+=1,"unwind"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return x?y(3993).cpus().length:navigator.hardwareConcurrency},K:function(k,G,H,Q){for(de.pb=G>>>0,ze.length=H,G=Q>>>0>>3,Q=0;Q<H;Q++)ze[Q]=o()[G+Q>>>0];return ln[k].apply(null,ze)},y:function(k){k>>>=0;var G=u().length;if(k<=G||4294901760<k)return!1;for(var H=1;4>=H;H*=2){var Q=G*(1+.2/H);Q=Math.min(Q,k+100663296);var ie=Math;Q=Math.max(k,Q);e:{ie=ie.min.call(ie,4294901760,Q+(65536-Q%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(ie),Me();var ye=1;break e}catch{}ye=void 0}if(ye)return!0}return!1},O:ke,P:Ge,j:Tt,g:_t,n:Bt,w:Ht,m:an,x:function(k,G){return k>>>=0,G>>>=0,qt(u().subarray(k>>>0,k+G>>>0)),0},a:z||t.wasmMemory,H:un,d:function(k,G,H,Q){return un(k>>>0,G>>>0,H>>>0,Q>>>0)}};(function(){function k(H,Q){return H=H.exports,L=H=function(ie){var ye=at=>()=>at()>>>0,$e=at=>vt=>at(vt)>>>0;return(ie=Object.assign({},ie)).__errno_location=ye(ie.__errno_location),ie.pthread_self=ye(ie.pthread_self),ie.malloc=$e(ie.malloc),ie.stackSave=ye(ie.stackSave),ie.stackAlloc=$e(ie.stackAlloc),ie}(H),de.Ta.push(L.sa),je=L.ta,Be.unshift(L.W),Y=Q,tt(),H}var G={a:Vt};if(Qe(),t.instantiateWasm)try{return t.instantiateWasm(G,k)}catch(H){S("Module.instantiateWasm callback failed with error: "+H),e(H)}(function(H,Q){var ie=He;return C||typeof WebAssembly.instantiateStreaming!="function"||wt(ie)||ie.startsWith("file://")||x||typeof fetch!="function"?ht(ie,H,Q):fetch(ie,{credentials:"same-origin"}).then(ye=>WebAssembly.instantiateStreaming(ye,H).then(Q,function($e){return S("wasm streaming compile failed: "+$e),S("falling back to ArrayBuffer instantiation"),ht(ie,H,Q)}))})(G,function(H){k(H.instance,H.module)}).catch(e)})(),t._OrtInit=(k,G)=>(t._OrtInit=L.X)(k,G),t._OrtGetLastError=(k,G)=>(t._OrtGetLastError=L.Y)(k,G),t._OrtCreateSessionOptions=(k,G,H,Q,ie,ye,$e,at,vt,lt)=>(t._OrtCreateSessionOptions=L.Z)(k,G,H,Q,ie,ye,$e,at,vt,lt),t._OrtAppendExecutionProvider=(k,G)=>(t._OrtAppendExecutionProvider=L._)(k,G),t._OrtAddSessionConfigEntry=(k,G,H)=>(t._OrtAddSessionConfigEntry=L.$)(k,G,H),t._OrtReleaseSessionOptions=k=>(t._OrtReleaseSessionOptions=L.aa)(k),t._OrtCreateSession=(k,G,H)=>(t._OrtCreateSession=L.ba)(k,G,H),t._OrtReleaseSession=k=>(t._OrtReleaseSession=L.ca)(k),t._OrtGetInputOutputCount=(k,G,H)=>(t._OrtGetInputOutputCount=L.da)(k,G,H),t._OrtGetInputName=(k,G)=>(t._OrtGetInputName=L.ea)(k,G),t._OrtGetOutputName=(k,G)=>(t._OrtGetOutputName=L.fa)(k,G),t._OrtFree=k=>(t._OrtFree=L.ga)(k),t._OrtCreateTensor=(k,G,H,Q,ie)=>(t._OrtCreateTensor=L.ha)(k,G,H,Q,ie),t._OrtGetTensorData=(k,G,H,Q,ie)=>(t._OrtGetTensorData=L.ia)(k,G,H,Q,ie),t._OrtReleaseTensor=k=>(t._OrtReleaseTensor=L.ja)(k),t._OrtCreateRunOptions=(k,G,H,Q)=>(t._OrtCreateRunOptions=L.ka)(k,G,H,Q),t._OrtAddRunConfigEntry=(k,G,H)=>(t._OrtAddRunConfigEntry=L.la)(k,G,H),t._OrtReleaseRunOptions=k=>(t._OrtReleaseRunOptions=L.ma)(k),t._OrtRun=(k,G,H,Q,ie,ye,$e,at)=>(t._OrtRun=L.na)(k,G,H,Q,ie,ye,$e,at),t._OrtEndProfiling=k=>(t._OrtEndProfiling=L.oa)(k);var St=t._pthread_self=()=>(St=t._pthread_self=L.pa)(),Dt=t._malloc=k=>(Dt=t._malloc=L.qa)(k);t._free=k=>(t._free=L.ra)(k),t.__emscripten_tls_init=()=>(t.__emscripten_tls_init=L.sa)();var Yt=t.__emscripten_thread_init=(k,G,H,Q,ie,ye)=>(Yt=t.__emscripten_thread_init=L.ua)(k,G,H,Q,ie,ye);t.__emscripten_thread_crashed=()=>(t.__emscripten_thread_crashed=L.va)();var Mt,Jt=(k,G,H,Q)=>(Jt=L.wa)(k,G,H,Q),Wt=k=>(Wt=L.xa)(k),Zt=t.__emscripten_thread_exit=k=>(Zt=t.__emscripten_thread_exit=L.ya)(k),Qt=t.__emscripten_check_mailbox=()=>(Qt=t.__emscripten_check_mailbox=L.za)(),cn=k=>(cn=L.Aa)(k),pn=(k,G)=>(pn=L.Ba)(k,G),en=()=>(en=L.Ca)(),jt=k=>(jt=L.Da)(k),zt=k=>(zt=L.Ea)(k);function tn(){function k(){if(!Mt&&(Mt=!0,t.calledRun=!0,!ve)&&(T||gt(Be),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),!T)){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;){var G=t.postRun.shift();Pe.unshift(G)}gt(Pe)}}if(!(0<et))if(T)n(t),T||gt(Be),startWorker(t);else{if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)_e.unshift(t.preRun.shift());gt(_e),0<et||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),k()},1)):k())}}if(t.keepRuntimeAlive=Ue,t.wasmMemory=z,t.stackAlloc=zt,t.stackSave=en,t.stackRestore=jt,t.UTF8ToString=pt,t.stringToUTF8=ut,t.lengthBytesUTF8=Ce,t.ExitStatus=bt,t.PThread=de,qe=function k(){Mt||tn(),Mt||(qe=k)},t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return tn(),h.ready});M.exports=f},932:(M,c,y)=>{var m,f=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(m=m||__filename),function(h={}){var p,u,s=h;s.ready=new Promise((U,J)=>{p=U,u=J});var a,o,n,e=Object.assign({},s),t="./this.program",r=(U,J)=>{throw J},i=typeof window=="object",l=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";if(d){var b=y(1384),v=y(908);g=l?v.dirname(g)+"/":__dirname+"/",a=(U,J)=>(U=U.startsWith("file://")?new URL(U):v.normalize(U),b.readFileSync(U,J?void 0:"utf8")),n=U=>((U=a(U,!0)).buffer||(U=new Uint8Array(U)),U),o=(U,J,ee,le=!0)=>{U=U.startsWith("file://")?new URL(U):v.normalize(U),b.readFile(U,le?void 0:"utf8",(me,Ae)=>{me?ee(me):J(le?Ae.buffer:Ae)})},!s.thisProgram&&1<process.argv.length&&(t=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),r=(U,J)=>{throw process.exitCode=U,J},s.inspect=()=>"[Emscripten Module object]"}else(i||l)&&(l?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),m&&(g=m),g=g.indexOf("blob:")!==0?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=U=>{var J=new XMLHttpRequest;return J.open("GET",U,!1),J.send(null),J.responseText},l&&(n=U=>{var J=new XMLHttpRequest;return J.open("GET",U,!1),J.responseType="arraybuffer",J.send(null),new Uint8Array(J.response)}),o=(U,J,ee)=>{var le=new XMLHttpRequest;le.open("GET",U,!0),le.responseType="arraybuffer",le.onload=()=>{le.status==200||le.status==0&&le.response?J(le.response):ee()},le.onerror=ee,le.send(null)});var w,x=s.print||console.log.bind(console),T=s.printErr||console.error.bind(console);Object.assign(s,e),e=null,s.thisProgram&&(t=s.thisProgram),s.quit&&(r=s.quit),s.wasmBinary&&(w=s.wasmBinary);var O=s.noExitRuntime||!0;typeof WebAssembly!="object"&&ge("no native wasm support detected");var P,I,R,j,A,C,_=!1;function S(){var U=P.buffer;s.HEAP8=R=new Int8Array(U),s.HEAP16=new Int16Array(U),s.HEAP32=A=new Int32Array(U),s.HEAPU8=j=new Uint8Array(U),s.HEAPU16=new Uint16Array(U),s.HEAPU32=C=new Uint32Array(U),s.HEAPF32=new Float32Array(U),s.HEAPF64=new Float64Array(U)}var E=[],z=[],L=[];function Y(){var U=s.preRun.shift();E.unshift(U)}var X,te,ae=0,se=null,pe=null;function ge(U){throw s.onAbort&&s.onAbort(U),T(U="Aborted("+U+")"),_=!0,U=new WebAssembly.RuntimeError(U+". Build with -sASSERTIONS for more info."),u(U),U}function ve(U){return U.startsWith("data:application/octet-stream;base64,")}if(!ve(X="ort-wasm.wasm")){var Me=X;X=s.locateFile?s.locateFile(Me,g):g+Me}function De(U){if(U==X&&w)return new Uint8Array(w);if(n)return n(U);throw"both async and sync fetching of the wasm failed"}function je(U,J,ee){return function(le){if(!w&&(i||l)){if(typeof fetch=="function"&&!le.startsWith("file://"))return fetch(le,{credentials:"same-origin"}).then(me=>{if(!me.ok)throw"failed to load wasm binary file at '"+le+"'";return me.arrayBuffer()}).catch(()=>De(le));if(o)return new Promise((me,Ae)=>{o(le,Ce=>me(new Uint8Array(Ce)),Ae)})}return Promise.resolve().then(()=>De(le))}(U).then(le=>WebAssembly.instantiate(le,J)).then(le=>le).then(ee,le=>{T("failed to asynchronously prepare wasm: "+le),ge(le)})}function _e(U){this.name="ExitStatus",this.message=`Program terminated with exit(${U})`,this.status=U}var Be=U=>{for(;0<U.length;)U.shift()(s)};function Pe(U){this.qa=U-24,this.va=function(J){C[this.qa+4>>2>>>0]=J},this.ua=function(J){C[this.qa+8>>2>>>0]=J},this.sa=function(J,ee){this.ta(),this.va(J),this.ua(ee)},this.ta=function(){C[this.qa+16>>2>>>0]=0}}var Re,Ue=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,He=(U,J,ee)=>{var le=(J>>>=0)+ee;for(ee=J;U[ee]&&!(ee>=le);)++ee;if(16<ee-J&&U.buffer&&Ue)return Ue.decode(U.subarray(J,ee));for(le="";J<ee;){var me=U[J++];if(128&me){var Ae=63&U[J++];if((224&me)==192)le+=String.fromCharCode((31&me)<<6|Ae);else{var Ce=63&U[J++];65536>(me=(240&me)==224?(15&me)<<12|Ae<<6|Ce:(7&me)<<18|Ae<<12|Ce<<6|63&U[J++])?le+=String.fromCharCode(me):(me-=65536,le+=String.fromCharCode(55296|me>>10,56320|1023&me))}}else le+=String.fromCharCode(me)}return le},Ze=(U,J)=>(U>>>=0)?He(j,U,J):"",et=U=>{for(var J=0,ee=0;ee<U.length;++ee){var le=U.charCodeAt(ee);127>=le?J++:2047>=le?J+=2:55296<=le&&57343>=le?(J+=4,++ee):J+=3}return J},ct=(U,J,ee,le)=>{if(!(0<le))return 0;var me=ee>>>=0;le=ee+le-1;for(var Ae=0;Ae<U.length;++Ae){var Ce=U.charCodeAt(Ae);if(55296<=Ce&&57343>=Ce&&(Ce=65536+((1023&Ce)<<10)|1023&U.charCodeAt(++Ae)),127>=Ce){if(ee>=le)break;J[ee++>>>0]=Ce}else{if(2047>=Ce){if(ee+1>=le)break;J[ee++>>>0]=192|Ce>>6}else{if(65535>=Ce){if(ee+2>=le)break;J[ee++>>>0]=224|Ce>>12}else{if(ee+3>=le)break;J[ee++>>>0]=240|Ce>>18,J[ee++>>>0]=128|Ce>>12&63}J[ee++>>>0]=128|Ce>>6&63}J[ee++>>>0]=128|63&Ce}}return J[ee>>>0]=0,ee-me},qe=U=>U%4==0&&(U%100!=0||U%400==0),Qe=[0,31,60,91,121,152,182,213,244,274,305,335],tt=[0,31,59,90,120,151,181,212,243,273,304,334],Ye=U=>{var J=et(U)+1,ee=kt(J);return ee&&ct(U,j,ee,J),ee},wt={},ft=()=>{if(!Re){var U,J={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:t||"./this.program"};for(U in wt)wt[U]===void 0?delete J[U]:J[U]=wt[U];var ee=[];for(U in J)ee.push(`${U}=${J[U]}`);Re=ee}return Re},ht=[null,[],[]],bt=U=>(bt=(()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return le=>crypto.getRandomValues(le);if(d)try{var J=y(760);if(J.randomFillSync)return le=>J.randomFillSync(le);var ee=J.randomBytes;return le=>(le.set(ee(le.byteLength)),le)}catch{}ge("initRandomDevice")})())(U),xt=[31,29,31,30,31,30,31,31,30,31,30,31],Ot=[31,28,31,30,31,30,31,31,30,31,30,31];function At(U,J,ee,le){function me(oe,Fe,Xe){for(oe=typeof oe=="number"?oe.toString():oe||"";oe.length<Fe;)oe=Xe[0]+oe;return oe}function Ae(oe,Fe){return me(oe,Fe,"0")}function Ce(oe,Fe){function Xe(Et){return 0>Et?-1:0<Et?1:0}var yt;return(yt=Xe(oe.getFullYear()-Fe.getFullYear()))===0&&(yt=Xe(oe.getMonth()-Fe.getMonth()))===0&&(yt=Xe(oe.getDate()-Fe.getDate())),yt}function rt(oe){switch(oe.getDay()){case 0:return new Date(oe.getFullYear()-1,11,29);case 1:return oe;case 2:return new Date(oe.getFullYear(),0,3);case 3:return new Date(oe.getFullYear(),0,2);case 4:return new Date(oe.getFullYear(),0,1);case 5:return new Date(oe.getFullYear()-1,11,31);case 6:return new Date(oe.getFullYear()-1,11,30)}}function ut(oe){var Fe=oe.ma;for(oe=new Date(new Date(oe.na+1900,0,1).getTime());0<Fe;){var Xe=oe.getMonth(),yt=(qe(oe.getFullYear())?xt:Ot)[Xe];if(!(Fe>yt-oe.getDate())){oe.setDate(oe.getDate()+Fe);break}Fe-=yt-oe.getDate()+1,oe.setDate(1),11>Xe?oe.setMonth(Xe+1):(oe.setMonth(0),oe.setFullYear(oe.getFullYear()+1))}return Xe=new Date(oe.getFullYear()+1,0,4),Fe=rt(new Date(oe.getFullYear(),0,4)),Xe=rt(Xe),0>=Ce(Fe,oe)?0>=Ce(Xe,oe)?oe.getFullYear()+1:oe.getFullYear():oe.getFullYear()-1}U>>>=0,J>>>=0,ee>>>=0;var ot=A[40+(le>>>=0)>>2>>>0];for(var it in le={ya:A[le>>2>>>0],xa:A[le+4>>2>>>0],oa:A[le+8>>2>>>0],ra:A[le+12>>2>>>0],pa:A[le+16>>2>>>0],na:A[le+20>>2>>>0],ha:A[le+24>>2>>>0],ma:A[le+28>>2>>>0],Aa:A[le+32>>2>>>0],wa:A[le+36>>2>>>0],za:ot?Ze(ot):""},ee=Ze(ee),ot={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})ee=ee.replace(new RegExp(it,"g"),ot[it]);var Pt="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),It="January February March April May June July August September October November December".split(" ");for(it in ot={"%a":oe=>Pt[oe.ha].substring(0,3),"%A":oe=>Pt[oe.ha],"%b":oe=>It[oe.pa].substring(0,3),"%B":oe=>It[oe.pa],"%C":oe=>Ae((oe.na+1900)/100|0,2),"%d":oe=>Ae(oe.ra,2),"%e":oe=>me(oe.ra,2," "),"%g":oe=>ut(oe).toString().substring(2),"%G":oe=>ut(oe),"%H":oe=>Ae(oe.oa,2),"%I":oe=>((oe=oe.oa)==0?oe=12:12<oe&&(oe-=12),Ae(oe,2)),"%j":oe=>{for(var Fe=0,Xe=0;Xe<=oe.pa-1;Fe+=(qe(oe.na+1900)?xt:Ot)[Xe++]);return Ae(oe.ra+Fe,3)},"%m":oe=>Ae(oe.pa+1,2),"%M":oe=>Ae(oe.xa,2),"%n":()=>`
`,"%p":oe=>0<=oe.oa&&12>oe.oa?"AM":"PM","%S":oe=>Ae(oe.ya,2),"%t":()=>"	","%u":oe=>oe.ha||7,"%U":oe=>Ae(Math.floor((oe.ma+7-oe.ha)/7),2),"%V":oe=>{var Fe=Math.floor((oe.ma+7-(oe.ha+6)%7)/7);if(2>=(oe.ha+371-oe.ma-2)%7&&Fe++,Fe)Fe==53&&((Xe=(oe.ha+371-oe.ma)%7)==4||Xe==3&&qe(oe.na)||(Fe=1));else{Fe=52;var Xe=(oe.ha+7-oe.ma-1)%7;(Xe==4||Xe==5&&qe(oe.na%400-1))&&Fe++}return Ae(Fe,2)},"%w":oe=>oe.ha,"%W":oe=>Ae(Math.floor((oe.ma+7-(oe.ha+6)%7)/7),2),"%y":oe=>(oe.na+1900).toString().substring(2),"%Y":oe=>oe.na+1900,"%z":oe=>{var Fe=0<=(oe=oe.wa);return oe=Math.abs(oe)/60,(Fe?"+":"-")+("0000"+(oe/60*100+oe%60)).slice(-4)},"%Z":oe=>oe.za,"%%":()=>"%"},ee=ee.replace(/%%/g,"\0\0"),ot)ee.includes(it)&&(ee=ee.replace(new RegExp(it,"g"),ot[it](le)));return it=function(oe){var Fe=Array(et(oe)+1);return ct(oe,Fe,0,Fe.length),Fe}(ee=ee.replace(/\0\0/g,"%")),it.length>J?0:(R.set(it,U>>>0),it.length-1)}var Ct={a:function(U,J,ee){throw new Pe(U>>>=0).sa(J>>>0,ee>>>0),U},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(U,J,ee){U=J+2097152>>>0<4194305-!!U?(U>>>0)+4294967296*J:NaN,ee>>>=0,U=new Date(1e3*U),A[ee>>2>>>0]=U.getUTCSeconds(),A[ee+4>>2>>>0]=U.getUTCMinutes(),A[ee+8>>2>>>0]=U.getUTCHours(),A[ee+12>>2>>>0]=U.getUTCDate(),A[ee+16>>2>>>0]=U.getUTCMonth(),A[ee+20>>2>>>0]=U.getUTCFullYear()-1900,A[ee+24>>2>>>0]=U.getUTCDay(),A[ee+28>>2>>>0]=(U.getTime()-Date.UTC(U.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(U,J,ee){U=J+2097152>>>0<4194305-!!U?(U>>>0)+4294967296*J:NaN,ee>>>=0,U=new Date(1e3*U),A[ee>>2>>>0]=U.getSeconds(),A[ee+4>>2>>>0]=U.getMinutes(),A[ee+8>>2>>>0]=U.getHours(),A[ee+12>>2>>>0]=U.getDate(),A[ee+16>>2>>>0]=U.getMonth(),A[ee+20>>2>>>0]=U.getFullYear()-1900,A[ee+24>>2>>>0]=U.getDay(),A[ee+28>>2>>>0]=(qe(U.getFullYear())?Qe:tt)[U.getMonth()]+U.getDate()-1|0,A[ee+36>>2>>>0]=-60*U.getTimezoneOffset(),J=new Date(U.getFullYear(),6,1).getTimezoneOffset();var le=new Date(U.getFullYear(),0,1).getTimezoneOffset();A[ee+32>>2>>>0]=0|(J!=le&&U.getTimezoneOffset()==Math.min(le,J))},p:function(U){U>>>=0;var J=new Date(A[U+20>>2>>>0]+1900,A[U+16>>2>>>0],A[U+12>>2>>>0],A[U+8>>2>>>0],A[U+4>>2>>>0],A[U>>2>>>0],0),ee=A[U+32>>2>>>0],le=J.getTimezoneOffset(),me=new Date(J.getFullYear(),6,1).getTimezoneOffset(),Ae=new Date(J.getFullYear(),0,1).getTimezoneOffset(),Ce=Math.min(Ae,me);return 0>ee?A[U+32>>2>>>0]=+(me!=Ae&&Ce==le):0<ee!=(Ce==le)&&(me=Math.max(Ae,me),J.setTime(J.getTime()+6e4*((0<ee?Ce:me)-le))),A[U+24>>2>>>0]=J.getDay(),A[U+28>>2>>>0]=(qe(J.getFullYear())?Qe:tt)[J.getMonth()]+J.getDate()-1|0,A[U>>2>>>0]=J.getSeconds(),A[U+4>>2>>>0]=J.getMinutes(),A[U+8>>2>>>0]=J.getHours(),A[U+12>>2>>>0]=J.getDate(),A[U+16>>2>>>0]=J.getMonth(),A[U+20>>2>>>0]=J.getYear(),U=J.getTime()/1e3,$t((te=U,1<=+Math.abs(te)?0<te?+Math.floor(te/4294967296)>>>0:~~+Math.ceil((te-+(~~te>>>0))/4294967296)>>>0:0)),U>>>0},l:function(){return-52},m:function(){},u:function(U,J,ee){function le(ut){return(ut=ut.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ut[1]:"GMT"}ee>>>=0;var me=new Date().getFullYear(),Ae=new Date(me,0,1),Ce=new Date(me,6,1);me=Ae.getTimezoneOffset();var rt=Ce.getTimezoneOffset();C[U>>>0>>2>>>0]=60*Math.max(me,rt),A[J>>>0>>2>>>0]=+(me!=rt),U=le(Ae),J=le(Ce),U=Ye(U),J=Ye(J),rt<me?(C[ee>>2>>>0]=U,C[ee+4>>2>>>0]=J):(C[ee>>2>>>0]=J,C[ee+4>>2>>>0]=U)},d:()=>{ge("")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(U,J,ee){return J>>>=0,j.copyWithin(U>>>0>>>0,J>>>0,J+(ee>>>0)>>>0)},t:function(U){U>>>=0;var J=j.length;if(4294901760<U)return!1;for(var ee=1;4>=ee;ee*=2){var le=J*(1+.2/ee);le=Math.min(le,U+100663296);var me=Math;le=Math.max(U,le);e:{me=me.min.call(me,4294901760,le+(65536-le%65536)%65536)-P.buffer.byteLength+65535>>>16;try{P.grow(me),S();var Ae=1;break e}catch{}Ae=void 0}if(Ae)return!0}return!1},D:function(U,J){U>>>=0,J>>>=0;var ee=0;return ft().forEach(function(le,me){var Ae=J+ee;for(me=C[U+4*me>>2>>>0]=Ae,Ae=0;Ae<le.length;++Ae)R[me++>>0>>>0]=le.charCodeAt(Ae);R[me>>0>>>0]=0,ee+=le.length+1}),0},E:function(U,J){U>>>=0,J>>>=0;var ee=ft();C[U>>2>>>0]=ee.length;var le=0;return ee.forEach(function(me){le+=me.length+1}),C[J>>2>>>0]=le,0},s:U=>{O||(s.onExit&&s.onExit(U),_=!0),r(U,new _e(U))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(U,J,ee,le){J>>>=0,ee>>>=0,le>>>=0;for(var me=0,Ae=0;Ae<ee;Ae++){var Ce=C[J>>2>>>0],rt=C[J+4>>2>>>0];J+=8;for(var ut=0;ut<rt;ut++){var ot=j[Ce+ut>>>0],it=ht[U];ot===0||ot===10?((U===1?x:T)(He(it,0)),it.length=0):it.push(ot)}me+=rt}return C[le>>2>>>0]=me,0},r:function(U,J){return U>>>=0,bt(j.subarray(U>>>0,U+(J>>>0)>>>0)),0},C:At,c:function(U,J,ee,le){return At(U>>>0,J>>>0,ee>>>0,le>>>0)}};(function(){function U(ee){if(ee=ee.exports,I=ee=function(me){var Ae=rt=>()=>rt()>>>0,Ce=rt=>ut=>rt(ut)>>>0;return(me=Object.assign({},me)).__errno_location=Ae(me.__errno_location),me.malloc=Ce(me.malloc),me.stackSave=Ae(me.stackSave),me.stackAlloc=Ce(me.stackAlloc),me}(ee),P=I.L,S(),z.unshift(I.M),ae--,s.monitorRunDependencies&&s.monitorRunDependencies(ae),ae==0&&(se!==null&&(clearInterval(se),se=null),pe)){var le=pe;pe=null,le()}return ee}var J={a:Ct};if(ae++,s.monitorRunDependencies&&s.monitorRunDependencies(ae),s.instantiateWasm)try{return s.instantiateWasm(J,U)}catch(ee){T("Module.instantiateWasm callback failed with error: "+ee),u(ee)}(function(ee,le){var me=X;return w||typeof WebAssembly.instantiateStreaming!="function"||ve(me)||me.startsWith("file://")||d||typeof fetch!="function"?je(me,ee,le):fetch(me,{credentials:"same-origin"}).then(Ae=>WebAssembly.instantiateStreaming(Ae,ee).then(le,function(Ce){return T("wasm streaming compile failed: "+Ce),T("falling back to ArrayBuffer instantiation"),je(me,ee,le)}))})(J,function(ee){U(ee.instance)}).catch(u)})(),s._OrtInit=(U,J)=>(s._OrtInit=I.N)(U,J),s._OrtGetLastError=(U,J)=>(s._OrtGetLastError=I.O)(U,J),s._OrtCreateSessionOptions=(U,J,ee,le,me,Ae,Ce,rt,ut,ot)=>(s._OrtCreateSessionOptions=I.P)(U,J,ee,le,me,Ae,Ce,rt,ut,ot),s._OrtAppendExecutionProvider=(U,J)=>(s._OrtAppendExecutionProvider=I.Q)(U,J),s._OrtAddSessionConfigEntry=(U,J,ee)=>(s._OrtAddSessionConfigEntry=I.R)(U,J,ee),s._OrtReleaseSessionOptions=U=>(s._OrtReleaseSessionOptions=I.S)(U),s._OrtCreateSession=(U,J,ee)=>(s._OrtCreateSession=I.T)(U,J,ee),s._OrtReleaseSession=U=>(s._OrtReleaseSession=I.U)(U),s._OrtGetInputOutputCount=(U,J,ee)=>(s._OrtGetInputOutputCount=I.V)(U,J,ee),s._OrtGetInputName=(U,J)=>(s._OrtGetInputName=I.W)(U,J),s._OrtGetOutputName=(U,J)=>(s._OrtGetOutputName=I.X)(U,J),s._OrtFree=U=>(s._OrtFree=I.Y)(U),s._OrtCreateTensor=(U,J,ee,le,me)=>(s._OrtCreateTensor=I.Z)(U,J,ee,le,me),s._OrtGetTensorData=(U,J,ee,le,me)=>(s._OrtGetTensorData=I._)(U,J,ee,le,me),s._OrtReleaseTensor=U=>(s._OrtReleaseTensor=I.$)(U),s._OrtCreateRunOptions=(U,J,ee,le)=>(s._OrtCreateRunOptions=I.aa)(U,J,ee,le),s._OrtAddRunConfigEntry=(U,J,ee)=>(s._OrtAddRunConfigEntry=I.ba)(U,J,ee),s._OrtReleaseRunOptions=U=>(s._OrtReleaseRunOptions=I.ca)(U),s._OrtRun=(U,J,ee,le,me,Ae,Ce,rt)=>(s._OrtRun=I.da)(U,J,ee,le,me,Ae,Ce,rt),s._OrtEndProfiling=U=>(s._OrtEndProfiling=I.ea)(U);var kt=s._malloc=U=>(kt=s._malloc=I.fa)(U);s._free=U=>(s._free=I.ga)(U);var pt,$t=U=>($t=I.ia)(U),Tt=()=>(Tt=I.ja)(),de=U=>(de=I.ka)(U),gt=U=>(gt=I.la)(U);function mt(){function U(){if(!pt&&(pt=!0,s.calledRun=!0,!_)){if(Be(z),p(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;){var J=s.postRun.shift();L.unshift(J)}Be(L)}}if(!(0<ae)){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)Y();Be(E),0<ae||(s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),U()},1)):U())}}if(s.stackAlloc=gt,s.stackSave=Tt,s.stackRestore=de,s.UTF8ToString=Ze,s.stringToUTF8=(U,J,ee)=>ct(U,j,J,ee),s.lengthBytesUTF8=et,pe=function U(){pt||mt(),pt||(pe=U)},s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return mt(),h.ready});M.exports=f},4537:M=>{"use strict";M.exports=function(c,y){for(var m=new Array(arguments.length-1),f=0,h=2,p=!0;h<arguments.length;)m[f++]=arguments[h++];return new Promise(function(u,s){m[f]=function(a){if(p)if(p=!1,a)s(a);else{for(var o=new Array(arguments.length-1),n=0;n<o.length;)o[n++]=arguments[n];u.apply(null,o)}};try{c.apply(y||null,m)}catch(a){p&&(p=!1,s(a))}})}},7419:(M,c)=>{"use strict";var y=c;y.length=function(u){var s=u.length;if(!s)return 0;for(var a=0;--s%4>1&&u.charAt(s)==="=";)++a;return Math.ceil(3*u.length)/4-a};for(var m=new Array(64),f=new Array(123),h=0;h<64;)f[m[h]=h<26?h+65:h<52?h+71:h<62?h-4:h-59|43]=h++;y.encode=function(u,s,a){for(var o,n=null,e=[],t=0,r=0;s<a;){var i=u[s++];switch(r){case 0:e[t++]=m[i>>2],o=(3&i)<<4,r=1;break;case 1:e[t++]=m[o|i>>4],o=(15&i)<<2,r=2;break;case 2:e[t++]=m[o|i>>6],e[t++]=m[63&i],r=0}t>8191&&((n||(n=[])).push(String.fromCharCode.apply(String,e)),t=0)}return r&&(e[t++]=m[o],e[t++]=61,r===1&&(e[t++]=61)),n?(t&&n.push(String.fromCharCode.apply(String,e.slice(0,t))),n.join("")):String.fromCharCode.apply(String,e.slice(0,t))};var p="invalid encoding";y.decode=function(u,s,a){for(var o,n=a,e=0,t=0;t<u.length;){var r=u.charCodeAt(t++);if(r===61&&e>1)break;if((r=f[r])===void 0)throw Error(p);switch(e){case 0:o=r,e=1;break;case 1:s[a++]=o<<2|(48&r)>>4,o=r,e=2;break;case 2:s[a++]=(15&o)<<4|(60&r)>>2,o=r,e=3;break;case 3:s[a++]=(3&o)<<6|r,e=0}}if(e===1)throw Error(p);return a-n},y.test=function(u){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(u)}},9211:M=>{"use strict";function c(){this._listeners={}}M.exports=c,c.prototype.on=function(y,m,f){return(this._listeners[y]||(this._listeners[y]=[])).push({fn:m,ctx:f||this}),this},c.prototype.off=function(y,m){if(y===void 0)this._listeners={};else if(m===void 0)this._listeners[y]=[];else for(var f=this._listeners[y],h=0;h<f.length;)f[h].fn===m?f.splice(h,1):++h;return this},c.prototype.emit=function(y){var m=this._listeners[y];if(m){for(var f=[],h=1;h<arguments.length;)f.push(arguments[h++]);for(h=0;h<m.length;)m[h].fn.apply(m[h++].ctx,f)}return this}},945:M=>{"use strict";function c(p){return typeof Float32Array<"u"?function(){var u=new Float32Array([-0]),s=new Uint8Array(u.buffer),a=s[3]===128;function o(r,i,l){u[0]=r,i[l]=s[0],i[l+1]=s[1],i[l+2]=s[2],i[l+3]=s[3]}function n(r,i,l){u[0]=r,i[l]=s[3],i[l+1]=s[2],i[l+2]=s[1],i[l+3]=s[0]}function e(r,i){return s[0]=r[i],s[1]=r[i+1],s[2]=r[i+2],s[3]=r[i+3],u[0]}function t(r,i){return s[3]=r[i],s[2]=r[i+1],s[1]=r[i+2],s[0]=r[i+3],u[0]}p.writeFloatLE=a?o:n,p.writeFloatBE=a?n:o,p.readFloatLE=a?e:t,p.readFloatBE=a?t:e}():function(){function u(a,o,n,e){var t=o<0?1:0;if(t&&(o=-o),o===0)a(1/o>0?0:2147483648,n,e);else if(isNaN(o))a(2143289344,n,e);else if(o>34028234663852886e22)a((t<<31|2139095040)>>>0,n,e);else if(o<11754943508222875e-54)a((t<<31|Math.round(o/1401298464324817e-60))>>>0,n,e);else{var r=Math.floor(Math.log(o)/Math.LN2);a((t<<31|r+127<<23|8388607&Math.round(o*Math.pow(2,-r)*8388608))>>>0,n,e)}}function s(a,o,n){var e=a(o,n),t=2*(e>>31)+1,r=e>>>23&255,i=8388607&e;return r===255?i?NaN:t*(1/0):r===0?1401298464324817e-60*t*i:t*Math.pow(2,r-150)*(i+8388608)}p.writeFloatLE=u.bind(null,y),p.writeFloatBE=u.bind(null,m),p.readFloatLE=s.bind(null,f),p.readFloatBE=s.bind(null,h)}(),typeof Float64Array<"u"?function(){var u=new Float64Array([-0]),s=new Uint8Array(u.buffer),a=s[7]===128;function o(r,i,l){u[0]=r,i[l]=s[0],i[l+1]=s[1],i[l+2]=s[2],i[l+3]=s[3],i[l+4]=s[4],i[l+5]=s[5],i[l+6]=s[6],i[l+7]=s[7]}function n(r,i,l){u[0]=r,i[l]=s[7],i[l+1]=s[6],i[l+2]=s[5],i[l+3]=s[4],i[l+4]=s[3],i[l+5]=s[2],i[l+6]=s[1],i[l+7]=s[0]}function e(r,i){return s[0]=r[i],s[1]=r[i+1],s[2]=r[i+2],s[3]=r[i+3],s[4]=r[i+4],s[5]=r[i+5],s[6]=r[i+6],s[7]=r[i+7],u[0]}function t(r,i){return s[7]=r[i],s[6]=r[i+1],s[5]=r[i+2],s[4]=r[i+3],s[3]=r[i+4],s[2]=r[i+5],s[1]=r[i+6],s[0]=r[i+7],u[0]}p.writeDoubleLE=a?o:n,p.writeDoubleBE=a?n:o,p.readDoubleLE=a?e:t,p.readDoubleBE=a?t:e}():function(){function u(a,o,n,e,t,r){var i=e<0?1:0;if(i&&(e=-e),e===0)a(0,t,r+o),a(1/e>0?0:2147483648,t,r+n);else if(isNaN(e))a(0,t,r+o),a(2146959360,t,r+n);else if(e>17976931348623157e292)a(0,t,r+o),a((i<<31|2146435072)>>>0,t,r+n);else{var l;if(e<22250738585072014e-324)a((l=e/5e-324)>>>0,t,r+o),a((i<<31|l/4294967296)>>>0,t,r+n);else{var d=Math.floor(Math.log(e)/Math.LN2);d===1024&&(d=1023),a(4503599627370496*(l=e*Math.pow(2,-d))>>>0,t,r+o),a((i<<31|d+1023<<20|1048576*l&1048575)>>>0,t,r+n)}}}function s(a,o,n,e,t){var r=a(e,t+o),i=a(e,t+n),l=2*(i>>31)+1,d=i>>>20&2047,g=4294967296*(1048575&i)+r;return d===2047?g?NaN:l*(1/0):d===0?5e-324*l*g:l*Math.pow(2,d-1075)*(g+4503599627370496)}p.writeDoubleLE=u.bind(null,y,0,4),p.writeDoubleBE=u.bind(null,m,4,0),p.readDoubleLE=s.bind(null,f,0,4),p.readDoubleBE=s.bind(null,h,4,0)}(),p}function y(p,u,s){u[s]=255&p,u[s+1]=p>>>8&255,u[s+2]=p>>>16&255,u[s+3]=p>>>24}function m(p,u,s){u[s]=p>>>24,u[s+1]=p>>>16&255,u[s+2]=p>>>8&255,u[s+3]=255&p}function f(p,u){return(p[u]|p[u+1]<<8|p[u+2]<<16|p[u+3]<<24)>>>0}function h(p,u){return(p[u]<<24|p[u+1]<<16|p[u+2]<<8|p[u+3])>>>0}M.exports=c(c)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(M){}return null}module.exports=inquire},6662:M=>{"use strict";M.exports=function(c,y,m){var f=m||8192,h=f>>>1,p=null,u=f;return function(s){if(s<1||s>h)return c(s);u+s>f&&(p=c(f),u=0);var a=y.call(p,u,u+=s);return 7&u&&(u=1+(7|u)),a}}},4997:(M,c)=>{"use strict";var y=c;y.length=function(m){for(var f=0,h=0,p=0;p<m.length;++p)(h=m.charCodeAt(p))<128?f+=1:h<2048?f+=2:(64512&h)==55296&&(64512&m.charCodeAt(p+1))==56320?(++p,f+=4):f+=3;return f},y.read=function(m,f,h){if(h-f<1)return"";for(var p,u=null,s=[],a=0;f<h;)(p=m[f++])<128?s[a++]=p:p>191&&p<224?s[a++]=(31&p)<<6|63&m[f++]:p>239&&p<365?(p=((7&p)<<18|(63&m[f++])<<12|(63&m[f++])<<6|63&m[f++])-65536,s[a++]=55296+(p>>10),s[a++]=56320+(1023&p)):s[a++]=(15&p)<<12|(63&m[f++])<<6|63&m[f++],a>8191&&((u||(u=[])).push(String.fromCharCode.apply(String,s)),a=0);return u?(a&&u.push(String.fromCharCode.apply(String,s.slice(0,a))),u.join("")):String.fromCharCode.apply(String,s.slice(0,a))},y.write=function(m,f,h){for(var p,u,s=h,a=0;a<m.length;++a)(p=m.charCodeAt(a))<128?f[h++]=p:p<2048?(f[h++]=p>>6|192,f[h++]=63&p|128):(64512&p)==55296&&(64512&(u=m.charCodeAt(a+1)))==56320?(p=65536+((1023&p)<<10)+(1023&u),++a,f[h++]=p>>18|240,f[h++]=p>>12&63|128,f[h++]=p>>6&63|128,f[h++]=63&p|128):(f[h++]=p>>12|224,f[h++]=p>>6&63|128,f[h++]=63&p|128);return h-s}},3442:(M,c)=>{"use strict";c.__esModule=!0;var y=function(){function m(f){if(!f)throw new TypeError("Invalid argument; `value` has no value.");this.value=m.EMPTY,f&&m.isGuid(f)&&(this.value=f)}return m.isGuid=function(f){var h=f.toString();return f&&(f instanceof m||m.validator.test(h))},m.create=function(){return new m([m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-"))},m.createEmpty=function(){return new m("emptyguid")},m.parse=function(f){return new m(f)},m.raw=function(){return[m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-")},m.gen=function(f){for(var h="",p=0;p<f;p++)h+=(65536*(1+Math.random())|0).toString(16).substring(1);return h},m.prototype.equals=function(f){return m.isGuid(f)&&this.value===f.toString()},m.prototype.isEmpty=function(){return this.value===m.EMPTY},m.prototype.toString=function(){return this.value},m.prototype.toJSON=function(){return{value:this.value}},m.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),m.EMPTY="00000000-0000-0000-0000-000000000000",m}();c.Guid=y},2100:(M,c,y)=>{"use strict";M.exports=y(9482)},9482:(M,c,y)=>{"use strict";var m=c;function f(){m.util._configure(),m.Writer._configure(m.BufferWriter),m.Reader._configure(m.BufferReader)}m.build="minimal",m.Writer=y(1173),m.BufferWriter=y(3155),m.Reader=y(1408),m.BufferReader=y(593),m.util=y(9693),m.rpc=y(5994),m.roots=y(5054),m.configure=f,f()},1408:(M,c,y)=>{"use strict";M.exports=s;var m,f=y(9693),h=f.LongBits,p=f.utf8;function u(i,l){return RangeError("index out of range: "+i.pos+" + "+(l||1)+" > "+i.len)}function s(i){this.buf=i,this.pos=0,this.len=i.length}var a,o=typeof Uint8Array<"u"?function(i){if(i instanceof Uint8Array||Array.isArray(i))return new s(i);throw Error("illegal buffer")}:function(i){if(Array.isArray(i))return new s(i);throw Error("illegal buffer")},n=function(){return f.Buffer?function(i){return(s.create=function(l){return f.Buffer.isBuffer(l)?new m(l):o(l)})(i)}:o};function e(){var i=new h(0,0),l=0;if(!(this.len-this.pos>4)){for(;l<3;++l){if(this.pos>=this.len)throw u(this);if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*l)>>>0,this.buf[this.pos++]<128)return i}return i.lo=(i.lo|(127&this.buf[this.pos++])<<7*l)>>>0,i}for(;l<4;++l)if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*l)>>>0,this.buf[this.pos++]<128)return i;if(i.lo=(i.lo|(127&this.buf[this.pos])<<28)>>>0,i.hi=(i.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return i;if(l=0,this.len-this.pos>4){for(;l<5;++l)if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*l+3)>>>0,this.buf[this.pos++]<128)return i}else for(;l<5;++l){if(this.pos>=this.len)throw u(this);if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*l+3)>>>0,this.buf[this.pos++]<128)return i}throw Error("invalid varint encoding")}function t(i,l){return(i[l-4]|i[l-3]<<8|i[l-2]<<16|i[l-1]<<24)>>>0}function r(){if(this.pos+8>this.len)throw u(this,8);return new h(t(this.buf,this.pos+=4),t(this.buf,this.pos+=4))}s.create=n(),s.prototype._slice=f.Array.prototype.subarray||f.Array.prototype.slice,s.prototype.uint32=(a=4294967295,function(){if(a=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(a=(a|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return a;if((this.pos+=5)>this.len)throw this.pos=this.len,u(this,10);return a}),s.prototype.int32=function(){return 0|this.uint32()},s.prototype.sint32=function(){var i=this.uint32();return i>>>1^-(1&i)|0},s.prototype.bool=function(){return this.uint32()!==0},s.prototype.fixed32=function(){if(this.pos+4>this.len)throw u(this,4);return t(this.buf,this.pos+=4)},s.prototype.sfixed32=function(){if(this.pos+4>this.len)throw u(this,4);return 0|t(this.buf,this.pos+=4)},s.prototype.float=function(){if(this.pos+4>this.len)throw u(this,4);var i=f.float.readFloatLE(this.buf,this.pos);return this.pos+=4,i},s.prototype.double=function(){if(this.pos+8>this.len)throw u(this,4);var i=f.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,i},s.prototype.bytes=function(){var i=this.uint32(),l=this.pos,d=this.pos+i;if(d>this.len)throw u(this,i);return this.pos+=i,Array.isArray(this.buf)?this.buf.slice(l,d):l===d?new this.buf.constructor(0):this._slice.call(this.buf,l,d)},s.prototype.string=function(){var i=this.bytes();return p.read(i,0,i.length)},s.prototype.skip=function(i){if(typeof i=="number"){if(this.pos+i>this.len)throw u(this,i);this.pos+=i}else do if(this.pos>=this.len)throw u(this);while(128&this.buf[this.pos++]);return this},s.prototype.skipType=function(i){switch(i){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(i=7&this.uint32())!=4;)this.skipType(i);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+i+" at offset "+this.pos)}return this},s._configure=function(i){m=i,s.create=n(),m._configure();var l=f.Long?"toLong":"toNumber";f.merge(s.prototype,{int64:function(){return e.call(this)[l](!1)},uint64:function(){return e.call(this)[l](!0)},sint64:function(){return e.call(this).zzDecode()[l](!1)},fixed64:function(){return r.call(this)[l](!0)},sfixed64:function(){return r.call(this)[l](!1)}})}},593:(M,c,y)=>{"use strict";M.exports=h;var m=y(1408);(h.prototype=Object.create(m.prototype)).constructor=h;var f=y(9693);function h(p){m.call(this,p)}h._configure=function(){f.Buffer&&(h.prototype._slice=f.Buffer.prototype.slice)},h.prototype.string=function(){var p=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+p,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+p,this.len))},h._configure()},5054:M=>{"use strict";M.exports={}},5994:(M,c,y)=>{"use strict";c.Service=y(7948)},7948:(M,c,y)=>{"use strict";M.exports=f;var m=y(9693);function f(h,p,u){if(typeof h!="function")throw TypeError("rpcImpl must be a function");m.EventEmitter.call(this),this.rpcImpl=h,this.requestDelimited=!!p,this.responseDelimited=!!u}(f.prototype=Object.create(m.EventEmitter.prototype)).constructor=f,f.prototype.rpcCall=function h(p,u,s,a,o){if(!a)throw TypeError("request must be specified");var n=this;if(!o)return m.asPromise(h,n,p,u,s,a);if(n.rpcImpl)try{return n.rpcImpl(p,u[n.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(e,t){if(e)return n.emit("error",e,p),o(e);if(t!==null){if(!(t instanceof s))try{t=s[n.responseDelimited?"decodeDelimited":"decode"](t)}catch(r){return n.emit("error",r,p),o(r)}return n.emit("data",t,p),o(null,t)}n.end(!0)})}catch(e){return n.emit("error",e,p),void setTimeout(function(){o(e)},0)}else setTimeout(function(){o(Error("already ended"))},0)},f.prototype.end=function(h){return this.rpcImpl&&(h||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(M,c,y)=>{"use strict";M.exports=f;var m=y(9693);function f(s,a){this.lo=s>>>0,this.hi=a>>>0}var h=f.zero=new f(0,0);h.toNumber=function(){return 0},h.zzEncode=h.zzDecode=function(){return this},h.length=function(){return 1};var p=f.zeroHash="\0\0\0\0\0\0\0\0";f.fromNumber=function(s){if(s===0)return h;var a=s<0;a&&(s=-s);var o=s>>>0,n=(s-o)/4294967296>>>0;return a&&(n=~n>>>0,o=~o>>>0,++o>4294967295&&(o=0,++n>4294967295&&(n=0))),new f(o,n)},f.from=function(s){if(typeof s=="number")return f.fromNumber(s);if(m.isString(s)){if(!m.Long)return f.fromNumber(parseInt(s,10));s=m.Long.fromString(s)}return s.low||s.high?new f(s.low>>>0,s.high>>>0):h},f.prototype.toNumber=function(s){if(!s&&this.hi>>>31){var a=1+~this.lo>>>0,o=~this.hi>>>0;return a||(o=o+1>>>0),-(a+4294967296*o)}return this.lo+4294967296*this.hi},f.prototype.toLong=function(s){return m.Long?new m.Long(0|this.lo,0|this.hi,!!s):{low:0|this.lo,high:0|this.hi,unsigned:!!s}};var u=String.prototype.charCodeAt;f.fromHash=function(s){return s===p?h:new f((u.call(s,0)|u.call(s,1)<<8|u.call(s,2)<<16|u.call(s,3)<<24)>>>0,(u.call(s,4)|u.call(s,5)<<8|u.call(s,6)<<16|u.call(s,7)<<24)>>>0)},f.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},f.prototype.zzEncode=function(){var s=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^s)>>>0,this.lo=(this.lo<<1^s)>>>0,this},f.prototype.zzDecode=function(){var s=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^s)>>>0,this.hi=(this.hi>>>1^s)>>>0,this},f.prototype.length=function(){var s=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,o=this.hi>>>24;return o===0?a===0?s<16384?s<128?1:2:s<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:o<128?9:10}},9693:function(M,c,y){"use strict";var m=c;function f(p,u,s){for(var a=Object.keys(u),o=0;o<a.length;++o)p[a[o]]!==void 0&&s||(p[a[o]]=u[a[o]]);return p}function h(p){function u(s,a){if(!(this instanceof u))return new u(s,a);Object.defineProperty(this,"message",{get:function(){return s}}),Error.captureStackTrace?Error.captureStackTrace(this,u):Object.defineProperty(this,"stack",{value:new Error().stack||""}),a&&f(this,a)}return u.prototype=Object.create(Error.prototype,{constructor:{value:u,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return p},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),u}m.asPromise=y(4537),m.base64=y(7419),m.EventEmitter=y(9211),m.float=y(945),m.inquire=y(7199),m.utf8=y(4997),m.pool=y(6662),m.LongBits=y(1945),m.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),m.global=m.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||this,m.emptyArray=Object.freeze?Object.freeze([]):[],m.emptyObject=Object.freeze?Object.freeze({}):{},m.isInteger=Number.isInteger||function(p){return typeof p=="number"&&isFinite(p)&&Math.floor(p)===p},m.isString=function(p){return typeof p=="string"||p instanceof String},m.isObject=function(p){return p&&typeof p=="object"},m.isset=m.isSet=function(p,u){var s=p[u];return!(s==null||!p.hasOwnProperty(u))&&(typeof s!="object"||(Array.isArray(s)?s.length:Object.keys(s).length)>0)},m.Buffer=function(){try{var p=m.inquire("buffer").Buffer;return p.prototype.utf8Write?p:null}catch{return null}}(),m._Buffer_from=null,m._Buffer_allocUnsafe=null,m.newBuffer=function(p){return typeof p=="number"?m.Buffer?m._Buffer_allocUnsafe(p):new m.Array(p):m.Buffer?m._Buffer_from(p):typeof Uint8Array>"u"?p:new Uint8Array(p)},m.Array=typeof Uint8Array<"u"?Uint8Array:Array,m.Long=m.global.dcodeIO&&m.global.dcodeIO.Long||m.global.Long||m.inquire("long"),m.key2Re=/^true|false|0|1$/,m.key32Re=/^-?(?:0|[1-9][0-9]*)$/,m.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,m.longToHash=function(p){return p?m.LongBits.from(p).toHash():m.LongBits.zeroHash},m.longFromHash=function(p,u){var s=m.LongBits.fromHash(p);return m.Long?m.Long.fromBits(s.lo,s.hi,u):s.toNumber(!!u)},m.merge=f,m.lcFirst=function(p){return p.charAt(0).toLowerCase()+p.substring(1)},m.newError=h,m.ProtocolError=h("ProtocolError"),m.oneOfGetter=function(p){for(var u={},s=0;s<p.length;++s)u[p[s]]=1;return function(){for(var a=Object.keys(this),o=a.length-1;o>-1;--o)if(u[a[o]]===1&&this[a[o]]!==void 0&&this[a[o]]!==null)return a[o]}},m.oneOfSetter=function(p){return function(u){for(var s=0;s<p.length;++s)p[s]!==u&&delete this[p[s]]}},m.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},m._configure=function(){var p=m.Buffer;p?(m._Buffer_from=p.from!==Uint8Array.from&&p.from||function(u,s){return new p(u,s)},m._Buffer_allocUnsafe=p.allocUnsafe||function(u){return new p(u)}):m._Buffer_from=m._Buffer_allocUnsafe=null}},1173:(M,c,y)=>{"use strict";M.exports=n;var m,f=y(9693),h=f.LongBits,p=f.base64,u=f.utf8;function s(g,b,v){this.fn=g,this.len=b,this.next=void 0,this.val=v}function a(){}function o(g){this.head=g.head,this.tail=g.tail,this.len=g.len,this.next=g.states}function n(){this.len=0,this.head=new s(a,0,0),this.tail=this.head,this.states=null}var e=function(){return f.Buffer?function(){return(n.create=function(){return new m})()}:function(){return new n}};function t(g,b,v){b[v]=255&g}function r(g,b){this.len=g,this.next=void 0,this.val=b}function i(g,b,v){for(;g.hi;)b[v++]=127&g.lo|128,g.lo=(g.lo>>>7|g.hi<<25)>>>0,g.hi>>>=7;for(;g.lo>127;)b[v++]=127&g.lo|128,g.lo=g.lo>>>7;b[v++]=g.lo}function l(g,b,v){b[v]=255&g,b[v+1]=g>>>8&255,b[v+2]=g>>>16&255,b[v+3]=g>>>24}n.create=e(),n.alloc=function(g){return new f.Array(g)},f.Array!==Array&&(n.alloc=f.pool(n.alloc,f.Array.prototype.subarray)),n.prototype._push=function(g,b,v){return this.tail=this.tail.next=new s(g,b,v),this.len+=b,this},r.prototype=Object.create(s.prototype),r.prototype.fn=function(g,b,v){for(;g>127;)b[v++]=127&g|128,g>>>=7;b[v]=g},n.prototype.uint32=function(g){return this.len+=(this.tail=this.tail.next=new r((g>>>=0)<128?1:g<16384?2:g<2097152?3:g<268435456?4:5,g)).len,this},n.prototype.int32=function(g){return g<0?this._push(i,10,h.fromNumber(g)):this.uint32(g)},n.prototype.sint32=function(g){return this.uint32((g<<1^g>>31)>>>0)},n.prototype.uint64=function(g){var b=h.from(g);return this._push(i,b.length(),b)},n.prototype.int64=n.prototype.uint64,n.prototype.sint64=function(g){var b=h.from(g).zzEncode();return this._push(i,b.length(),b)},n.prototype.bool=function(g){return this._push(t,1,g?1:0)},n.prototype.fixed32=function(g){return this._push(l,4,g>>>0)},n.prototype.sfixed32=n.prototype.fixed32,n.prototype.fixed64=function(g){var b=h.from(g);return this._push(l,4,b.lo)._push(l,4,b.hi)},n.prototype.sfixed64=n.prototype.fixed64,n.prototype.float=function(g){return this._push(f.float.writeFloatLE,4,g)},n.prototype.double=function(g){return this._push(f.float.writeDoubleLE,8,g)};var d=f.Array.prototype.set?function(g,b,v){b.set(g,v)}:function(g,b,v){for(var w=0;w<g.length;++w)b[v+w]=g[w]};n.prototype.bytes=function(g){var b=g.length>>>0;if(!b)return this._push(t,1,0);if(f.isString(g)){var v=n.alloc(b=p.length(g));p.decode(g,v,0),g=v}return this.uint32(b)._push(d,b,g)},n.prototype.string=function(g){var b=u.length(g);return b?this.uint32(b)._push(u.write,b,g):this._push(t,1,0)},n.prototype.fork=function(){return this.states=new o(this),this.head=this.tail=new s(a,0,0),this.len=0,this},n.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new s(a,0,0),this.len=0),this},n.prototype.ldelim=function(){var g=this.head,b=this.tail,v=this.len;return this.reset().uint32(v),v&&(this.tail.next=g.next,this.tail=b,this.len+=v),this},n.prototype.finish=function(){for(var g=this.head.next,b=this.constructor.alloc(this.len),v=0;g;)g.fn(g.val,b,v),v+=g.len,g=g.next;return b},n._configure=function(g){m=g,n.create=e(),m._configure()}},3155:(M,c,y)=>{"use strict";M.exports=h;var m=y(1173);(h.prototype=Object.create(m.prototype)).constructor=h;var f=y(9693);function h(){m.call(this)}function p(u,s,a){u.length<40?f.utf8.write(u,s,a):s.utf8Write?s.utf8Write(u,a):s.write(u,a)}h._configure=function(){h.alloc=f._Buffer_allocUnsafe,h.writeBytesBuffer=f.Buffer&&f.Buffer.prototype instanceof Uint8Array&&f.Buffer.prototype.set.name==="set"?function(u,s,a){s.set(u,a)}:function(u,s,a){if(u.copy)u.copy(s,a,0,u.length);else for(var o=0;o<u.length;)s[a++]=u[o++]}},h.prototype.bytes=function(u){f.isString(u)&&(u=f._Buffer_from(u,"base64"));var s=u.length>>>0;return this.uint32(s),s&&this._push(h.writeBytesBuffer,s,u),this},h.prototype.string=function(u){var s=f.Buffer.byteLength(u);return this.uint32(s),s&&this._push(p,s,u),this},h._configure()},4154:M=>{"use strict";M.exports=`"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},685:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.resolveBackend=c.registerBackend=void 0;let y={},m=[];c.registerBackend=(f,h,p)=>{if(!h||typeof h.init!="function"||typeof h.createSessionHandler!="function")throw new TypeError("not a valid backend");{let u=y[f];if(u===void 0)y[f]={backend:h,priority:p};else{if(u.priority>p)return;if(u.priority===p&&u.backend!==h)throw new Error(`cannot register backend "${f}" using priority ${p}`)}if(p>=0){let s=m.indexOf(f);s!==-1&&m.splice(s,1);for(let a=0;a<m.length;a++)if(y[m[a]].priority<=p)return void m.splice(a,0,f);m.push(f)}}},c.resolveBackend=async f=>{let h=f.length===0?m:f,p=[];for(let u of h){let s=y[u];if(s){if(s.initialized)return s.backend;if(s.aborted)continue;let a=!!s.initPromise;try{return a||(s.initPromise=s.backend.init()),await s.initPromise,s.initialized=!0,s.backend}catch(o){a||p.push({name:u,err:o}),s.aborted=!0}finally{delete s.initPromise}}}throw new Error(`no available backend found. ERR: ${p.map(u=>`[${u.name}] ${u.err}`).join(", ")}`)}},4798:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.registerBackend=void 0;var m=y(685);Object.defineProperty(c,"registerBackend",{enumerable:!0,get:function(){return m.registerBackend}})},3121:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.env=void 0;let m=y(9104),f="warning";c.env={wasm:{},webgl:{},webgpu:{},versions:{common:m.version},set logLevel(h){if(h!==void 0){if(typeof h!="string"||["verbose","info","warning","error","fatal"].indexOf(h)===-1)throw new Error(`Unsupported logging level: ${h}`);f=h}},get logLevel(){return f}},Object.defineProperty(c.env,"logLevel",{enumerable:!0})},2457:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.env=void 0;let m=y(3121);c.env=m.env},2235:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(h,p,u,s){s===void 0&&(s=u);var a=Object.getOwnPropertyDescriptor(p,u);a&&!("get"in a?!p.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return p[u]}}),Object.defineProperty(h,s,a)}:function(h,p,u,s){s===void 0&&(s=u),h[s]=p[u]}),f=this&&this.__exportStar||function(h,p){for(var u in h)u==="default"||Object.prototype.hasOwnProperty.call(p,u)||m(p,h,u)};Object.defineProperty(c,"__esModule",{value:!0}),f(y(4798),c),f(y(2457),c),f(y(3974),c),f(y(963),c),f(y(7852),c)},8036:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.InferenceSession=void 0;let m=y(685),f=y(963);class h{constructor(u){this.handler=u}async run(u,s,a){let o={},n={};if(typeof u!="object"||u===null||u instanceof f.Tensor||Array.isArray(u))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let e=!0;if(typeof s=="object"){if(s===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(s instanceof f.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(s)){if(s.length===0)throw new TypeError("'fetches' cannot be an empty array.");e=!1;for(let i of s){if(typeof i!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(i)===-1)throw new RangeError(`'fetches' contains invalid output name: ${i}.`);o[i]=null}if(typeof a=="object"&&a!==null)n=a;else if(a!==void 0)throw new TypeError("'options' must be an object.")}else{let i=!1,l=Object.getOwnPropertyNames(s);for(let d of this.outputNames)if(l.indexOf(d)!==-1){let g=s[d];(g===null||g instanceof f.Tensor)&&(i=!0,e=!1,o[d]=g)}if(i){if(typeof a=="object"&&a!==null)n=a;else if(a!==void 0)throw new TypeError("'options' must be an object.")}else n=s}}else if(s!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let i of this.inputNames)if(u[i]===void 0)throw new Error(`input '${i}' is missing in 'feeds'.`);if(e)for(let i of this.outputNames)o[i]=null;let t=await this.handler.run(u,o,n),r={};for(let i in t)Object.hasOwnProperty.call(t,i)&&(r[i]=new f.Tensor(t[i].type,t[i].data,t[i].dims));return r}async release(){return this.handler.dispose()}static async create(u,s,a,o){let n,e={};if(typeof u=="string"){if(n=u,typeof s=="object"&&s!==null)e=s;else if(s!==void 0)throw new TypeError("'options' must be an object.")}else if(u instanceof Uint8Array){if(n=u,typeof s=="object"&&s!==null)e=s;else if(s!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(u instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&u instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let l=u,d=0,g=u.byteLength;if(typeof s=="object"&&s!==null)e=s;else if(typeof s=="number"){if(d=s,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=l.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${l.byteLength}).`);if(g=u.byteLength-d,typeof a=="number"){if(g=a,!Number.isSafeInteger(g))throw new RangeError("'byteLength' must be an integer.");if(g<=0||d+g>l.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${l.byteLength-d}].`);if(typeof o=="object"&&o!==null)e=o;else if(o!==void 0)throw new TypeError("'options' must be an object.")}else if(a!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(s!==void 0)throw new TypeError("'options' must be an object.");n=new Uint8Array(l,d,g)}}let t=(e.executionProviders||[]).map(l=>typeof l=="string"?l:l.name),r=await(0,m.resolveBackend)(t),i=await r.createSessionHandler(n,e);return new h(i)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}c.InferenceSession=h},3974:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.InferenceSession=void 0;let m=y(8036);c.InferenceSession=m.InferenceSession},7852:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0})},2350:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tensorToImageData=c.tensorToDataURL=void 0,c.tensorToDataURL=(y,m)=>{let f=document.createElement("canvas");f.width=y.dims[3],f.height=y.dims[2];let h=f.getContext("2d");if(h!=null){let p,u;m?.tensorLayout!==void 0&&m.tensorLayout==="NHWC"?(p=y.dims[2],u=y.dims[3]):(p=y.dims[3],u=y.dims[2]);let s=m?.format!==void 0?m.format:"RGB",a=m?.norm,o,n;a===void 0||a.mean===void 0?o=[255,255,255,255]:typeof a.mean=="number"?o=[a.mean,a.mean,a.mean,a.mean]:(o=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(o[3]=a.mean[3])),a===void 0||a.bias===void 0?n=[0,0,0,0]:typeof a.bias=="number"?n=[a.bias,a.bias,a.bias,a.bias]:(n=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(n[3]=a.bias[3]));let e=u*p,t=0,r=e,i=2*e,l=-1;s==="RGBA"?(t=0,r=e,i=2*e,l=3*e):s==="RGB"?(t=0,r=e,i=2*e):s==="RBG"&&(t=0,i=e,r=2*e);for(let d=0;d<u;d++)for(let g=0;g<p;g++){let b=(y.data[t++]-n[0])*o[0],v=(y.data[r++]-n[1])*o[1],w=(y.data[i++]-n[2])*o[2],x=l===-1?255:(y.data[l++]-n[3])*o[3];h.fillStyle="rgba("+b+","+v+","+w+","+x+")",h.fillRect(g,d,1,1)}return f.toDataURL()}throw new Error("Can not access image data")},c.tensorToImageData=(y,m)=>{let f=document.createElement("canvas").getContext("2d"),h;if(f==null)throw new Error("Can not access image data");{let p,u,s;m?.tensorLayout!==void 0&&m.tensorLayout==="NHWC"?(p=y.dims[2],u=y.dims[1],s=y.dims[3]):(p=y.dims[3],u=y.dims[2],s=y.dims[1]);let a=m!==void 0&&m.format!==void 0?m.format:"RGB",o=m?.norm,n,e;o===void 0||o.mean===void 0?n=[255,255,255,255]:typeof o.mean=="number"?n=[o.mean,o.mean,o.mean,o.mean]:(n=[o.mean[0],o.mean[1],o.mean[2],255],o.mean[3]!==void 0&&(n[3]=o.mean[3])),o===void 0||o.bias===void 0?e=[0,0,0,0]:typeof o.bias=="number"?e=[o.bias,o.bias,o.bias,o.bias]:(e=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(e[3]=o.bias[3]));let t=u*p;if(m!==void 0&&(m.format!==void 0&&s===4&&m.format!=="RGBA"||s===3&&m.format!=="RGB"&&m.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let r=4,i=0,l=1,d=2,g=3,b=0,v=t,w=2*t,x=-1;a==="RGBA"?(b=0,v=t,w=2*t,x=3*t):a==="RGB"?(b=0,v=t,w=2*t):a==="RBG"&&(b=0,w=t,v=2*t),h=f.createImageData(p,u);for(let T=0;T<u*p;i+=r,l+=r,d+=r,g+=r,T++)h.data[i]=(y.data[b++]-e[0])*n[0],h.data[l]=(y.data[v++]-e[1])*n[1],h.data[d]=(y.data[w++]-e[2])*n[2],h.data[g]=x===-1?255:(y.data[x++]-e[3])*n[3]}return h}},4866:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tensorFromImage=c.bufferToTensor=void 0;let m=y(963);c.bufferToTensor=(f,h)=>{if(f===void 0)throw new Error("Image buffer must be defined");if(h.height===void 0||h.width===void 0)throw new Error("Image height and width must be defined");if(h.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:p,width:u}=h,s=h.norm??{mean:255,bias:0},a,o;a=typeof s.mean=="number"?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],o=typeof s.bias=="number"?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let n=h.format!==void 0?h.format:"RGBA",e=h.tensorFormat!==void 0&&h.tensorFormat!==void 0?h.tensorFormat:"RGB",t=p*u,r=e==="RGBA"?new Float32Array(4*t):new Float32Array(3*t),i=4,l=0,d=1,g=2,b=3,v=0,w=t,x=2*t,T=-1;n==="RGB"&&(i=3,l=0,d=1,g=2,b=-1),e==="RGBA"?T=3*t:e==="RBG"?(v=0,x=t,w=2*t):e==="BGR"&&(x=0,w=t,v=2*t);for(let O=0;O<t;O++,l+=i,g+=i,d+=i,b+=i)r[v++]=(f[l]+o[0])/a[0],r[w++]=(f[d]+o[1])/a[1],r[x++]=(f[g]+o[2])/a[2],T!==-1&&b!==-1&&(r[T++]=(f[b]+o[3])/a[3]);return e==="RGBA"?new m.Tensor("float32",r,[1,4,p,u]):new m.Tensor("float32",r,[1,3,p,u])},c.tensorFromImage=async(f,h)=>{let p=typeof HTMLImageElement<"u"&&f instanceof HTMLImageElement,u=typeof ImageData<"u"&&f instanceof ImageData,s=typeof ImageBitmap<"u"&&f instanceof ImageBitmap,a=typeof f=="string",o,n=h??{};if(p){let e=document.createElement("canvas");e.width=f.width,e.height=f.height;let t=e.getContext("2d");if(t==null)throw new Error("Can not access image data");{let r=f.height,i=f.width;if(h!==void 0&&h.resizedHeight!==void 0&&h.resizedWidth!==void 0&&(r=h.resizedHeight,i=h.resizedWidth),h!==void 0){if(n=h,h.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=r,n.width=i}else n.tensorFormat="RGBA",n.height=r,n.width=i;t.drawImage(f,0,0),o=t.getImageData(0,0,i,r).data}}else{if(!u){if(s){if(h===void 0)throw new Error("Please provide image config with format for Imagebitmap");let e=document.createElement("canvas");e.width=f.width,e.height=f.height;let t=e.getContext("2d");if(t!=null){let r=f.height,i=f.width;return t.drawImage(f,0,0,i,r),o=t.getImageData(0,0,i,r).data,n.height=r,n.width=i,(0,c.bufferToTensor)(o,n)}throw new Error("Can not access image data")}if(a)return new Promise((e,t)=>{let r=document.createElement("canvas"),i=r.getContext("2d");if(!f||!i)return t();let l=new Image;l.crossOrigin="Anonymous",l.src=f,l.onload=()=>{r.width=l.width,r.height=l.height,i.drawImage(l,0,0,r.width,r.height);let d=i.getImageData(0,0,r.width,r.height);n.height=r.height,n.width=r.width,e((0,c.bufferToTensor)(d.data,n))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let e,t;if(h!==void 0&&h.resizedWidth!==void 0&&h.resizedHeight!==void 0?(e=h.resizedHeight,t=h.resizedWidth):(e=f.height,t=f.width),h!==void 0&&(n=h),n.format="RGBA",n.height=e,n.width=t,h!==void 0){let r=document.createElement("canvas");r.width=t,r.height=e;let i=r.getContext("2d");if(i==null)throw new Error("Can not access image data");i.putImageData(f,0,0),o=i.getImageData(0,0,t,e).data}else o=f.data}}if(o!==void 0)return(0,c.bufferToTensor)(o,n);throw new Error("Input data provided is not supported - aborted tensor creation")}},5957:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Tensor=void 0;let m=y(2350),f=y(4866),h=y(106),p=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),u=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),s=!1;c.Tensor=class{constructor(a,o,n){let e,t,r;if((()=>{if(!s){s=!0;let l=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",d=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";l&&(p.set("int64",BigInt64Array),u.set(BigInt64Array,"int64")),d&&(p.set("uint64",BigUint64Array),u.set(BigUint64Array,"uint64"))}})(),typeof a=="string")if(e=a,r=n,a==="string"){if(!Array.isArray(o))throw new TypeError("A string tensor's data must be a string array.");t=o}else{let l=p.get(a);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${a}.`);if(Array.isArray(o)){if(a==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t=a==="uint64"||a==="int64"?l.from(o,BigInt):l.from(o)}else{if(!(o instanceof l))throw new TypeError(`A ${e} tensor's data must be type of ${l}`);t=o}}else if(r=o,Array.isArray(a)){if(a.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof a[0];if(l==="string")e="string",t=a;else{if(l!=="boolean")throw new TypeError(`Invalid element type of data array: ${l}.`);e="bool",t=Uint8Array.from(a)}}else{let l=u.get(a.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${a.constructor}.`);e=l,t=a}if(r===void 0)r=[t.length];else if(!Array.isArray(r))throw new TypeError("A tensor's dims must be a number array");let i=(0,h.calculateSize)(r);if(i!==t.length)throw new Error(`Tensor's size(${i}) does not match data length(${t.length}).`);this.dims=r,this.type=e,this.data=t,this.size=i}static async fromImage(a,o){return(0,f.tensorFromImage)(a,o)}toDataURL(a){return(0,m.tensorToDataURL)(this,a)}toImageData(a){return(0,m.tensorToImageData)(this,a)}reshape(a){return(0,h.tensorReshape)(this,a)}}},106:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tensorReshape=c.calculateSize=void 0;let m=y(963);c.calculateSize=f=>{let h=1;for(let p=0;p<f.length;p++){let u=f[p];if(typeof u!="number"||!Number.isSafeInteger(u))throw new TypeError(`dims[${p}] must be an integer, got: ${u}`);if(u<0)throw new RangeError(`dims[${p}] must be a non-negative integer, got: ${u}`);h*=u}return h},c.tensorReshape=(f,h)=>new m.Tensor(f.type,f.data,h)},963:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Tensor=void 0;let m=y(5957);c.Tensor=m.Tensor},9104:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.version=void 0,c.version="1.16.3"},1583:(M,c)=>{var y,m=function(f){"use strict";Object.defineProperty(f,"__esModule",{value:!0}),f.default=void 0;var h=null;try{h=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function p(_,S,E){this.low=0|_,this.high=0|S,this.unsigned=!!E}function u(_){return(_&&_.__isLong__)===!0}function s(_){var S=Math.clz32(_&-_);return _?31-S:S}p.prototype.__isLong__,Object.defineProperty(p.prototype,"__isLong__",{value:!0}),p.isLong=u;var a={},o={};function n(_,S){var E,z,L;return S?(L=0<=(_>>>=0)&&_<256)&&(z=o[_])?z:(E=t(_,0,!0),L&&(o[_]=E),E):(L=-128<=(_|=0)&&_<128)&&(z=a[_])?z:(E=t(_,_<0?-1:0,!1),L&&(a[_]=E),E)}function e(_,S){if(isNaN(_))return S?x:w;if(S){if(_<0)return x;if(_>=g)return R}else{if(_<=-b)return j;if(_+1>=b)return I}return _<0?e(-_,S).neg():t(_%d|0,_/d|0,S)}function t(_,S,E){return new p(_,S,E)}p.fromInt=n,p.fromNumber=e,p.fromBits=t;var r=Math.pow;function i(_,S,E){if(_.length===0)throw Error("empty string");if(typeof S=="number"?(E=S,S=!1):S=!!S,_==="NaN"||_==="Infinity"||_==="+Infinity"||_==="-Infinity")return S?x:w;if((E=E||10)<2||36<E)throw RangeError("radix");var z;if((z=_.indexOf("-"))>0)throw Error("interior hyphen");if(z===0)return i(_.substring(1),S,E).neg();for(var L=e(r(E,8)),Y=w,X=0;X<_.length;X+=8){var te=Math.min(8,_.length-X),ae=parseInt(_.substring(X,X+te),E);if(te<8){var se=e(r(E,te));Y=Y.mul(se).add(e(ae))}else Y=(Y=Y.mul(L)).add(e(ae))}return Y.unsigned=S,Y}function l(_,S){return typeof _=="number"?e(_,S):typeof _=="string"?i(_,S):t(_.low,_.high,typeof S=="boolean"?S:_.unsigned)}p.fromString=i,p.fromValue=l;var d=4294967296,g=d*d,b=g/2,v=n(1<<24),w=n(0);p.ZERO=w;var x=n(0,!0);p.UZERO=x;var T=n(1);p.ONE=T;var O=n(1,!0);p.UONE=O;var P=n(-1);p.NEG_ONE=P;var I=t(-1,2147483647,!1);p.MAX_VALUE=I;var R=t(-1,-1,!0);p.MAX_UNSIGNED_VALUE=R;var j=t(0,-2147483648,!1);p.MIN_VALUE=j;var A=p.prototype;A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},A.toString=function(_){if((_=_||10)<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(j)){var S=e(_),E=this.div(S),z=E.mul(S).sub(this);return E.toString(_)+z.toInt().toString(_)}return"-"+this.neg().toString(_)}for(var L=e(r(_,6),this.unsigned),Y=this,X="";;){var te=Y.div(L),ae=(Y.sub(te.mul(L)).toInt()>>>0).toString(_);if((Y=te).isZero())return ae+X;for(;ae.length<6;)ae="0"+ae;X=""+ae+X}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(j)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,S=31;S>0&&!(_&1<<S);S--);return this.high!=0?S+33:S+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(1&this.low)==1},A.isEven=function(){return(1&this.low)==0},A.equals=function(_){return u(_)||(_=l(_)),(this.unsigned===_.unsigned||this.high>>>31!=1||_.high>>>31!=1)&&this.high===_.high&&this.low===_.low},A.eq=A.equals,A.notEquals=function(_){return!this.eq(_)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(_){return this.comp(_)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(_){return this.comp(_)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(_){return this.comp(_)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(_){return this.comp(_)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(_){if(u(_)||(_=l(_)),this.eq(_))return 0;var S=this.isNegative(),E=_.isNegative();return S&&!E?-1:!S&&E?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(j)?j:this.not().add(T)},A.neg=A.negate,A.add=function(_){u(_)||(_=l(_));var S=this.high>>>16,E=65535&this.high,z=this.low>>>16,L=65535&this.low,Y=_.high>>>16,X=65535&_.high,te=_.low>>>16,ae=0,se=0,pe=0,ge=0;return pe+=(ge+=L+(65535&_.low))>>>16,se+=(pe+=z+te)>>>16,ae+=(se+=E+X)>>>16,ae+=S+Y,t((pe&=65535)<<16|(ge&=65535),(ae&=65535)<<16|(se&=65535),this.unsigned)},A.subtract=function(_){return u(_)||(_=l(_)),this.add(_.neg())},A.sub=A.subtract,A.multiply=function(_){if(this.isZero())return this;if(u(_)||(_=l(_)),h)return t(h.mul(this.low,this.high,_.low,_.high),h.get_high(),this.unsigned);if(_.isZero())return this.unsigned?x:w;if(this.eq(j))return _.isOdd()?j:w;if(_.eq(j))return this.isOdd()?j:w;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(v)&&_.lt(v))return e(this.toNumber()*_.toNumber(),this.unsigned);var S=this.high>>>16,E=65535&this.high,z=this.low>>>16,L=65535&this.low,Y=_.high>>>16,X=65535&_.high,te=_.low>>>16,ae=65535&_.low,se=0,pe=0,ge=0,ve=0;return ge+=(ve+=L*ae)>>>16,pe+=(ge+=z*ae)>>>16,ge&=65535,pe+=(ge+=L*te)>>>16,se+=(pe+=E*ae)>>>16,pe&=65535,se+=(pe+=z*te)>>>16,pe&=65535,se+=(pe+=L*X)>>>16,se+=S*ae+E*te+z*X+L*Y,t((ge&=65535)<<16|(ve&=65535),(se&=65535)<<16|(pe&=65535),this.unsigned)},A.mul=A.multiply,A.divide=function(_){if(u(_)||(_=l(_)),_.isZero())throw Error("division by zero");var S,E,z;if(h)return this.unsigned||this.high!==-2147483648||_.low!==-1||_.high!==-1?t((this.unsigned?h.div_u:h.div_s)(this.low,this.high,_.low,_.high),h.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?x:w;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return x;if(_.gt(this.shru(1)))return O;z=x}else{if(this.eq(j))return _.eq(T)||_.eq(P)?j:_.eq(j)?T:(S=this.shr(1).div(_).shl(1)).eq(w)?_.isNegative()?T:P:(E=this.sub(_.mul(S)),z=S.add(E.div(_)));if(_.eq(j))return this.unsigned?x:w;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();z=w}for(E=this;E.gte(_);){S=Math.max(1,Math.floor(E.toNumber()/_.toNumber()));for(var L=Math.ceil(Math.log(S)/Math.LN2),Y=L<=48?1:r(2,L-48),X=e(S),te=X.mul(_);te.isNegative()||te.gt(E);)te=(X=e(S-=Y,this.unsigned)).mul(_);X.isZero()&&(X=T),z=z.add(X),E=E.sub(te)}return z},A.div=A.divide,A.modulo=function(_){return u(_)||(_=l(_)),h?t((this.unsigned?h.rem_u:h.rem_s)(this.low,this.high,_.low,_.high),h.get_high(),this.unsigned):this.sub(this.div(_).mul(_))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return t(~this.low,~this.high,this.unsigned)},A.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},A.clz=A.countLeadingZeros,A.countTrailingZeros=function(){return this.low?s(this.low):s(this.high)+32},A.ctz=A.countTrailingZeros,A.and=function(_){return u(_)||(_=l(_)),t(this.low&_.low,this.high&_.high,this.unsigned)},A.or=function(_){return u(_)||(_=l(_)),t(this.low|_.low,this.high|_.high,this.unsigned)},A.xor=function(_){return u(_)||(_=l(_)),t(this.low^_.low,this.high^_.high,this.unsigned)},A.shiftLeft=function(_){return u(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?t(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):t(0,this.low<<_-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(_){return u(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?t(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):t(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(_){return u(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?t(this.low>>>_|this.high<<32-_,this.high>>>_,this.unsigned):t(_===32?this.high:this.high>>>_-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.rotateLeft=function(_){var S;return u(_)&&(_=_.toInt()),(_&=63)==0?this:_===32?t(this.high,this.low,this.unsigned):_<32?(S=32-_,t(this.low<<_|this.high>>>S,this.high<<_|this.low>>>S,this.unsigned)):(S=32-(_-=32),t(this.high<<_|this.low>>>S,this.low<<_|this.high>>>S,this.unsigned))},A.rotl=A.rotateLeft,A.rotateRight=function(_){var S;return u(_)&&(_=_.toInt()),(_&=63)==0?this:_===32?t(this.high,this.low,this.unsigned):_<32?(S=32-_,t(this.high<<S|this.low>>>_,this.low<<S|this.high>>>_,this.unsigned)):(S=32-(_-=32),t(this.low<<S|this.high>>>_,this.high<<S|this.low>>>_,this.unsigned))},A.rotr=A.rotateRight,A.toSigned=function(){return this.unsigned?t(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:t(this.low,this.high,!0)},A.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var _=this.high,S=this.low;return[255&S,S>>>8&255,S>>>16&255,S>>>24,255&_,_>>>8&255,_>>>16&255,_>>>24]},A.toBytesBE=function(){var _=this.high,S=this.low;return[_>>>24,_>>>16&255,_>>>8&255,255&_,S>>>24,S>>>16&255,S>>>8&255,255&S]},p.fromBytes=function(_,S,E){return E?p.fromBytesLE(_,S):p.fromBytesBE(_,S)},p.fromBytesLE=function(_,S){return new p(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,S)},p.fromBytesBE=function(_,S){return new p(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],S)};var C=p;return f.default=C,"default"in f?f.default:f}({});(y=function(){return m}.apply(c,[]))===void 0||(M.exports=y)},5686:(M,c,y)=>{"use strict";y.r(c),y.d(c,{flatbuffers:()=>m});var m={};m.Offset,m.Table,m.SIZEOF_SHORT=2,m.SIZEOF_INT=4,m.FILE_IDENTIFIER_LENGTH=4,m.SIZE_PREFIX_LENGTH=4,m.Encoding={UTF8_BYTES:1,UTF16_STRING:2},m.int32=new Int32Array(2),m.float32=new Float32Array(m.int32.buffer),m.float64=new Float64Array(m.int32.buffer),m.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,m.Long=function(f,h){this.low=0|f,this.high=0|h},m.Long.create=function(f,h){return f==0&&h==0?m.Long.ZERO:new m.Long(f,h)},m.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},m.Long.prototype.equals=function(f){return this.low==f.low&&this.high==f.high},m.Long.ZERO=new m.Long(0,0),m.Builder=function(f){if(f)h=f;else var h=1024;this.bb=m.ByteBuffer.allocate(h),this.space=h,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.forceDefaults=function(f){this.force_defaults=f},m.Builder.prototype.dataBuffer=function(){return this.bb},m.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},m.Builder.prototype.prep=function(f,h){f>this.minalign&&(this.minalign=f);for(var p=1+~(this.bb.capacity()-this.space+h)&f-1;this.space<p+f+h;){var u=this.bb.capacity();this.bb=m.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-u}this.pad(p)},m.Builder.prototype.pad=function(f){for(var h=0;h<f;h++)this.bb.writeInt8(--this.space,0)},m.Builder.prototype.writeInt8=function(f){this.bb.writeInt8(this.space-=1,f)},m.Builder.prototype.writeInt16=function(f){this.bb.writeInt16(this.space-=2,f)},m.Builder.prototype.writeInt32=function(f){this.bb.writeInt32(this.space-=4,f)},m.Builder.prototype.writeInt64=function(f){this.bb.writeInt64(this.space-=8,f)},m.Builder.prototype.writeFloat32=function(f){this.bb.writeFloat32(this.space-=4,f)},m.Builder.prototype.writeFloat64=function(f){this.bb.writeFloat64(this.space-=8,f)},m.Builder.prototype.addInt8=function(f){this.prep(1,0),this.writeInt8(f)},m.Builder.prototype.addInt16=function(f){this.prep(2,0),this.writeInt16(f)},m.Builder.prototype.addInt32=function(f){this.prep(4,0),this.writeInt32(f)},m.Builder.prototype.addInt64=function(f){this.prep(8,0),this.writeInt64(f)},m.Builder.prototype.addFloat32=function(f){this.prep(4,0),this.writeFloat32(f)},m.Builder.prototype.addFloat64=function(f){this.prep(8,0),this.writeFloat64(f)},m.Builder.prototype.addFieldInt8=function(f,h,p){(this.force_defaults||h!=p)&&(this.addInt8(h),this.slot(f))},m.Builder.prototype.addFieldInt16=function(f,h,p){(this.force_defaults||h!=p)&&(this.addInt16(h),this.slot(f))},m.Builder.prototype.addFieldInt32=function(f,h,p){(this.force_defaults||h!=p)&&(this.addInt32(h),this.slot(f))},m.Builder.prototype.addFieldInt64=function(f,h,p){!this.force_defaults&&h.equals(p)||(this.addInt64(h),this.slot(f))},m.Builder.prototype.addFieldFloat32=function(f,h,p){(this.force_defaults||h!=p)&&(this.addFloat32(h),this.slot(f))},m.Builder.prototype.addFieldFloat64=function(f,h,p){(this.force_defaults||h!=p)&&(this.addFloat64(h),this.slot(f))},m.Builder.prototype.addFieldOffset=function(f,h,p){(this.force_defaults||h!=p)&&(this.addOffset(h),this.slot(f))},m.Builder.prototype.addFieldStruct=function(f,h,p){h!=p&&(this.nested(h),this.slot(f))},m.Builder.prototype.nested=function(f){if(f!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},m.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},m.Builder.prototype.slot=function(f){this.vtable[f]=this.offset()},m.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},m.Builder.growByteBuffer=function(f){var h=f.capacity();if(3221225472&h)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var p=h<<1,u=m.ByteBuffer.allocate(p);return u.setPosition(p-h),u.bytes().set(f.bytes(),p-h),u},m.Builder.prototype.addOffset=function(f){this.prep(m.SIZEOF_INT,0),this.writeInt32(this.offset()-f+m.SIZEOF_INT)},m.Builder.prototype.startObject=function(f){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=f;for(var h=0;h<f;h++)this.vtable[h]=0;this.isNested=!0,this.object_start=this.offset()},m.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var f=this.offset(),h=this.vtable_in_use-1;h>=0&&this.vtable[h]==0;h--);for(var p=h+1;h>=0;h--)this.addInt16(this.vtable[h]!=0?f-this.vtable[h]:0);this.addInt16(f-this.object_start);var u=(p+2)*m.SIZEOF_SHORT;this.addInt16(u);var s=0,a=this.space;e:for(h=0;h<this.vtables.length;h++){var o=this.bb.capacity()-this.vtables[h];if(u==this.bb.readInt16(o)){for(var n=m.SIZEOF_SHORT;n<u;n+=m.SIZEOF_SHORT)if(this.bb.readInt16(a+n)!=this.bb.readInt16(o+n))continue e;s=this.vtables[h];break}}return s?(this.space=this.bb.capacity()-f,this.bb.writeInt32(this.space,s-f)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-f,this.offset()-f)),this.isNested=!1,f},m.Builder.prototype.finish=function(f,h,p){var u=p?m.SIZE_PREFIX_LENGTH:0;if(h){var s=h;if(this.prep(this.minalign,m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH+u),s.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var a=m.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(s.charCodeAt(a))}this.prep(this.minalign,m.SIZEOF_INT+u),this.addOffset(f),u&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},m.Builder.prototype.finishSizePrefixed=function(f,h){this.finish(f,h,!0)},m.Builder.prototype.requiredField=function(f,h){var p=this.bb.capacity()-f,u=p-this.bb.readInt32(p);if(this.bb.readInt16(u+h)==0)throw new Error("FlatBuffers: field "+h+" must be set")},m.Builder.prototype.startVector=function(f,h,p){this.notNested(),this.vector_num_elems=h,this.prep(m.SIZEOF_INT,f*h),this.prep(p,f*h)},m.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},m.Builder.prototype.createString=function(f){if(f instanceof Uint8Array)var h=f;else{h=[];for(var p=0;p<f.length;){var u,s=f.charCodeAt(p++);(u=s<55296||s>=56320?s:(s<<10)+f.charCodeAt(p++)+-56613888)<128?h.push(u):(u<2048?h.push(u>>6&31|192):(u<65536?h.push(u>>12&15|224):h.push(u>>18&7|240,u>>12&63|128),h.push(u>>6&63|128)),h.push(63&u|128))}}this.addInt8(0),this.startVector(1,h.length,1),this.bb.setPosition(this.space-=h.length),p=0;for(var a=this.space,o=this.bb.bytes();p<h.length;p++)o[a++]=h[p];return this.endVector()},m.Builder.prototype.createLong=function(f,h){return m.Long.create(f,h)},m.ByteBuffer=function(f){this.bytes_=f,this.position_=0},m.ByteBuffer.allocate=function(f){return new m.ByteBuffer(new Uint8Array(f))},m.ByteBuffer.prototype.clear=function(){this.position_=0},m.ByteBuffer.prototype.bytes=function(){return this.bytes_},m.ByteBuffer.prototype.position=function(){return this.position_},m.ByteBuffer.prototype.setPosition=function(f){this.position_=f},m.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},m.ByteBuffer.prototype.readInt8=function(f){return this.readUint8(f)<<24>>24},m.ByteBuffer.prototype.readUint8=function(f){return this.bytes_[f]},m.ByteBuffer.prototype.readInt16=function(f){return this.readUint16(f)<<16>>16},m.ByteBuffer.prototype.readUint16=function(f){return this.bytes_[f]|this.bytes_[f+1]<<8},m.ByteBuffer.prototype.readInt32=function(f){return this.bytes_[f]|this.bytes_[f+1]<<8|this.bytes_[f+2]<<16|this.bytes_[f+3]<<24},m.ByteBuffer.prototype.readUint32=function(f){return this.readInt32(f)>>>0},m.ByteBuffer.prototype.readInt64=function(f){return new m.Long(this.readInt32(f),this.readInt32(f+4))},m.ByteBuffer.prototype.readUint64=function(f){return new m.Long(this.readUint32(f),this.readUint32(f+4))},m.ByteBuffer.prototype.readFloat32=function(f){return m.int32[0]=this.readInt32(f),m.float32[0]},m.ByteBuffer.prototype.readFloat64=function(f){return m.int32[m.isLittleEndian?0:1]=this.readInt32(f),m.int32[m.isLittleEndian?1:0]=this.readInt32(f+4),m.float64[0]},m.ByteBuffer.prototype.writeInt8=function(f,h){this.bytes_[f]=h},m.ByteBuffer.prototype.writeUint8=function(f,h){this.bytes_[f]=h},m.ByteBuffer.prototype.writeInt16=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8},m.ByteBuffer.prototype.writeUint16=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8},m.ByteBuffer.prototype.writeInt32=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8,this.bytes_[f+2]=h>>16,this.bytes_[f+3]=h>>24},m.ByteBuffer.prototype.writeUint32=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8,this.bytes_[f+2]=h>>16,this.bytes_[f+3]=h>>24},m.ByteBuffer.prototype.writeInt64=function(f,h){this.writeInt32(f,h.low),this.writeInt32(f+4,h.high)},m.ByteBuffer.prototype.writeUint64=function(f,h){this.writeUint32(f,h.low),this.writeUint32(f+4,h.high)},m.ByteBuffer.prototype.writeFloat32=function(f,h){m.float32[0]=h,this.writeInt32(f,m.int32[0])},m.ByteBuffer.prototype.writeFloat64=function(f,h){m.float64[0]=h,this.writeInt32(f,m.int32[m.isLittleEndian?0:1]),this.writeInt32(f+4,m.int32[m.isLittleEndian?1:0])},m.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var f="",h=0;h<m.FILE_IDENTIFIER_LENGTH;h++)f+=String.fromCharCode(this.readInt8(this.position_+m.SIZEOF_INT+h));return f},m.ByteBuffer.prototype.__offset=function(f,h){var p=f-this.readInt32(f);return h<this.readInt16(p)?this.readInt16(p+h):0},m.ByteBuffer.prototype.__union=function(f,h){return f.bb_pos=h+this.readInt32(h),f.bb=this,f},m.ByteBuffer.prototype.__string=function(f,h){f+=this.readInt32(f);var p=this.readInt32(f),u="",s=0;if(f+=m.SIZEOF_INT,h===m.Encoding.UTF8_BYTES)return this.bytes_.subarray(f,f+p);for(;s<p;){var a,o=this.readUint8(f+s++);if(o<192)a=o;else{var n=this.readUint8(f+s++);if(o<224)a=(31&o)<<6|63&n;else{var e=this.readUint8(f+s++);a=o<240?(15&o)<<12|(63&n)<<6|63&e:(7&o)<<18|(63&n)<<12|(63&e)<<6|63&this.readUint8(f+s++)}}a<65536?u+=String.fromCharCode(a):(a-=65536,u+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return u},m.ByteBuffer.prototype.__indirect=function(f){return f+this.readInt32(f)},m.ByteBuffer.prototype.__vector=function(f){return f+this.readInt32(f)+m.SIZEOF_INT},m.ByteBuffer.prototype.__vector_len=function(f){return this.readInt32(f+this.readInt32(f))},m.ByteBuffer.prototype.__has_identifier=function(f){if(f.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var h=0;h<m.FILE_IDENTIFIER_LENGTH;h++)if(f.charCodeAt(h)!=this.readInt8(this.position_+m.SIZEOF_INT+h))return!1;return!0},m.ByteBuffer.prototype.createLong=function(f,h){return m.Long.create(f,h)}}},__webpack_module_cache__={};function __webpack_require__(M){var c=__webpack_module_cache__[M];if(c!==void 0)return c.exports;var y=__webpack_module_cache__[M]={exports:{}};return __webpack_modules__[M].call(y.exports,y,y.exports,__webpack_require__),y.exports}__webpack_require__.n=M=>{var c=M&&M.__esModule?()=>M.default:()=>M;return __webpack_require__.d(c,{a:c}),c},__webpack_require__.d=(M,c)=>{for(var y in c)__webpack_require__.o(c,y)&&!__webpack_require__.o(M,y)&&Object.defineProperty(M,y,{enumerable:!0,get:c[y]})},__webpack_require__.o=(M,c)=>Object.prototype.hasOwnProperty.call(M,c),__webpack_require__.r=M=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(M,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(M,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())});var vn=mn((exports,module)=>{(function(M,c){typeof exports=="object"&&typeof module=="object"?module.exports=c():typeof define=="function"&&define.amd?define([],c):typeof exports=="object"?exports.ort=c():M.ort=c()})(self,()=>(()=>{var __webpack_modules__={5716:(M,c,y)=>{"use strict";c.R=void 0;let m=y(6027),f=y(1723);c.R=new class{async init(){}async createSessionHandler(h,p){let u=new m.Session(p);return await u.loadModel(h),new f.OnnxjsSessionHandler(u)}}},2818:(M,c,y)=>{"use strict";c.c8=c.rX=void 0;let m=y(2235),f=y(5381),h=y(9544),p=y(6640);c.rX=()=>{if((typeof m.env.wasm.initTimeout!="number"||m.env.wasm.initTimeout<0)&&(m.env.wasm.initTimeout=0),typeof m.env.wasm.simd!="boolean"&&(m.env.wasm.simd=!0),typeof m.env.wasm.proxy!="boolean"&&(m.env.wasm.proxy=!1),typeof m.env.wasm.numThreads!="number"||!Number.isInteger(m.env.wasm.numThreads)||m.env.wasm.numThreads<=0){let u=typeof navigator>"u"?(0,f.cpus)().length:navigator.hardwareConcurrency;m.env.wasm.numThreads=Math.min(4,Math.ceil((u||1)/2))}},c.c8=new class{async init(){(0,c.rX)(),await(0,h.initializeWebAssemblyInstance)()}async createSessionHandler(u,s){let a=new p.OnnxruntimeWebAssemblySessionHandler;return await a.loadModel(u,s),Promise.resolve(a)}}},1057:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(u,s,a,o){o===void 0&&(o=a);var n=Object.getOwnPropertyDescriptor(s,a);n&&!("get"in n?!s.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return s[a]}}),Object.defineProperty(u,o,n)}:function(u,s,a,o){o===void 0&&(o=a),u[o]=s[a]}),f=this&&this.__exportStar||function(u,s){for(var a in u)a==="default"||Object.prototype.hasOwnProperty.call(s,a)||m(s,u,a)};Object.defineProperty(c,"__esModule",{value:!0}),f(y(2235),c);let h=y(2235),p=y(8408);{let u=y(5716).R;(0,h.registerBackend)("webgl",u,-10)}{let u=y(2818).c8;typeof navigator<"u"&&navigator.gpu&&(0,h.registerBackend)("webgpu",u,5),(0,h.registerBackend)("cpu",u,10),(0,h.registerBackend)("wasm",u,10),(0,h.registerBackend)("xnnpack",u,9),(0,h.registerBackend)("webnn",u,9)}h.env.versions.web=p.version},4910:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createAttributeWithCacheKey=void 0;class y{constructor(f){Object.assign(this,f)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(f=>`${this[f]}`).join(";")),this._cacheKey}}c.createAttributeWithCacheKey=m=>new y(m)},6874:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Attribute=void 0;let m=y(5127),f=y(2446),h=y(9240),p=y(7273);var u=m.onnxruntime.experimental.fbs;class s{constructor(o){if(this._attributes=new Map,o!=null){for(let n of o)n instanceof f.onnx.AttributeProto?this._attributes.set(n.name,[s.getValue(n),s.getType(n)]):n instanceof u.Attribute&&this._attributes.set(n.name(),[s.getValue(n),s.getType(n)]);if(this._attributes.size<o.length)throw new Error("duplicated attribute names")}}set(o,n,e){this._attributes.set(o,[e,n])}delete(o){this._attributes.delete(o)}getFloat(o,n){return this.get(o,"float",n)}getInt(o,n){return this.get(o,"int",n)}getString(o,n){return this.get(o,"string",n)}getTensor(o,n){return this.get(o,"tensor",n)}getFloats(o,n){return this.get(o,"floats",n)}getInts(o,n){return this.get(o,"ints",n)}getStrings(o,n){return this.get(o,"strings",n)}getTensors(o,n){return this.get(o,"tensors",n)}get(o,n,e){let t=this._attributes.get(o);if(t===void 0){if(e!==void 0)return e;throw new Error(`required attribute not found: ${o}`)}if(t[1]!==n)throw new Error(`type mismatch: expected ${n} but got ${t[1]}`);return t[0]}static getType(o){let n=o instanceof f.onnx.AttributeProto?o.type:o.type();switch(n){case f.onnx.AttributeProto.AttributeType.FLOAT:return"float";case f.onnx.AttributeProto.AttributeType.INT:return"int";case f.onnx.AttributeProto.AttributeType.STRING:return"string";case f.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case f.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case f.onnx.AttributeProto.AttributeType.INTS:return"ints";case f.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case f.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${f.onnx.AttributeProto.AttributeType[n]}`)}}static getValue(o){let n=o instanceof f.onnx.AttributeProto?o.type:o.type();if(n===f.onnx.AttributeProto.AttributeType.GRAPH||n===f.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let e=this.getValueNoCheck(o);if(n===f.onnx.AttributeProto.AttributeType.INT&&p.LongUtil.isLong(e))return p.LongUtil.longToNumber(e);if(n===f.onnx.AttributeProto.AttributeType.INTS){let t=e,r=new Array(t.length);for(let i=0;i<t.length;i++){let l=t[i];r[i]=p.LongUtil.longToNumber(l)}return r}if(n===f.onnx.AttributeProto.AttributeType.TENSOR)return o instanceof f.onnx.AttributeProto?h.Tensor.fromProto(e):h.Tensor.fromOrtTensor(e);if(n===f.onnx.AttributeProto.AttributeType.TENSORS){if(o instanceof f.onnx.AttributeProto)return e.map(t=>h.Tensor.fromProto(t));if(o instanceof u.Attribute)return e.map(t=>h.Tensor.fromOrtTensor(t))}if(n===f.onnx.AttributeProto.AttributeType.STRING&&o instanceof f.onnx.AttributeProto){let t=e;return(0,p.decodeUtf8String)(t)}return n===f.onnx.AttributeProto.AttributeType.STRINGS&&o instanceof f.onnx.AttributeProto?e.map(p.decodeUtf8String):e}static getValueNoCheck(o){return o instanceof f.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(o):this.getValueNoCheckFromOrtFormat(o)}static getValueNoCheckFromOnnxFormat(o){switch(o.type){case f.onnx.AttributeProto.AttributeType.FLOAT:return o.f;case f.onnx.AttributeProto.AttributeType.INT:return o.i;case f.onnx.AttributeProto.AttributeType.STRING:return o.s;case f.onnx.AttributeProto.AttributeType.TENSOR:return o.t;case f.onnx.AttributeProto.AttributeType.GRAPH:return o.g;case f.onnx.AttributeProto.AttributeType.FLOATS:return o.floats;case f.onnx.AttributeProto.AttributeType.INTS:return o.ints;case f.onnx.AttributeProto.AttributeType.STRINGS:return o.strings;case f.onnx.AttributeProto.AttributeType.TENSORS:return o.tensors;case f.onnx.AttributeProto.AttributeType.GRAPHS:return o.graphs;default:throw new Error(`unsupported attribute type: ${f.onnx.AttributeProto.AttributeType[o.type]}`)}}static getValueNoCheckFromOrtFormat(o){switch(o.type()){case u.AttributeType.FLOAT:return o.f();case u.AttributeType.INT:return o.i();case u.AttributeType.STRING:return o.s();case u.AttributeType.TENSOR:return o.t();case u.AttributeType.GRAPH:return o.g();case u.AttributeType.FLOATS:return o.floatsArray();case u.AttributeType.INTS:{let n=[];for(let e=0;e<o.intsLength();e++)n.push(o.ints(e));return n}case u.AttributeType.STRINGS:{let n=[];for(let e=0;e<o.stringsLength();e++)n.push(o.strings(e));return n}case u.AttributeType.TENSORS:{let n=[];for(let e=0;e<o.tensorsLength();e++)n.push(o.tensors(e));return n}default:throw new Error(`unsupported attribute type: ${u.AttributeType[o.type()]}`)}}}c.Attribute=s},1975:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.resolveBackend=c.backend=void 0;let m=y(4418),f=new Map;async function h(p){let u=c.backend;if(u[p]!==void 0&&function(s){let a=s;return"initialize"in a&&typeof a.initialize=="function"&&"createSessionHandler"in a&&typeof a.createSessionHandler=="function"&&"dispose"in a&&typeof a.dispose=="function"}(u[p])){let s=u[p],a=s.initialize();if(typeof a=="object"&&"then"in a&&(a=await a),a)return f.set(p,s),s}}c.backend={webgl:new m.WebGLBackend},c.resolveBackend=async function p(u){if(!u)return p(["webgl"]);{let s=typeof u=="string"?[u]:u;for(let a of s){let o=f.get(a);if(o)return o;let n=await h(a);if(n)return n}}throw new Error("no available backend to use")}},4418:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLBackend=void 0;let m=y(2235),f=y(1315),h=y(2171),p=y(3389);c.WebGLBackend=class{get contextId(){return m.env.webgl.contextId}set contextId(u){m.env.webgl.contextId=u}get matmulMaxBatchSize(){return m.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(u){m.env.webgl.matmulMaxBatchSize=u}get textureCacheMode(){return m.env.webgl.textureCacheMode}set textureCacheMode(u){m.env.webgl.textureCacheMode=u}get pack(){return m.env.webgl.pack}set pack(u){m.env.webgl.pack=u}get async(){return m.env.webgl.async}set async(u){m.env.webgl.async=u}initialize(){try{return this.glContext=(0,p.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),f.Logger.setWithEnv(m.env),f.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(u){return f.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${u}`),!1}}createSessionHandler(u){return new h.WebGLSessionHandler(this,u)}dispose(){this.glContext.dispose()}}},6859:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.CoordsGlslLib=void 0;let m=y(7273),f=y(1997),h=y(6757),p=y(7618),u=y(432);class s extends f.GlslLib{constructor(o){super(o)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new f.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new f.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let o=this.context.outputTextureLayout;return o.isPacked?this.getPackedOutputSamplingSnippet(o):this.getUnpackedOutputSamplingSnippet(o)}getPackedOutputSamplingSnippet(o){let n=o.unpackedShape,e=[o.width,o.height],t={},r="getOutputCoords";switch(n.length){case 0:t[r]=this.getOutputScalarCoords();break;case 1:t[r]=this.getOutputPacked1DCoords(n,e);break;case 2:t[r]=this.getOutputPacked2DCoords(n,e);break;case 3:t[r]=this.getOutputPacked3DCoords(n,e);break;default:t[r]=this.getOutputPackedNDCoords(n,e)}let i=`
      void setOutput(vec4 val) {
        ${(0,h.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return t.floatTextureSetRGBA=new f.GlslLibRoutine(i),t}getUnpackedOutputSamplingSnippet(o){let n=o.unpackedShape,e=[o.width,o.height],t={},r="getOutputCoords";switch(n.length){case 0:t[r]=this.getOutputScalarCoords();break;case 1:t[r]=this.getOutputUnpacked1DCoords(n,e);break;case 2:t[r]=this.getOutputUnpacked2DCoords(n,e);break;case 3:t[r]=this.getOutputUnpacked3DCoords(n,e);break;case 4:t[r]=this.getOutputUnpacked4DCoords(n,e);break;case 5:t[r]=this.getOutputUnpacked5DCoords(n,e);break;case 6:t[r]=this.getOutputUnpacked6DCoords(n,e);break;default:throw new Error(`Unsupported output dimensionality: ${n.length}`)}let i=`
        void setOutput(float val) {
          ${(0,h.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return t.floatTextureSetR=new f.GlslLibRoutine(i),t}getOutputScalarCoords(){return new f.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(o,n){let e=n,t="";return e[0]===1?(t=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${e[1]}.0);
          }
        `,new f.GlslLibRoutine(t)):e[1]===1?(t=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${e[0]}.0);
          }
        `,new f.GlslLibRoutine(t)):(t=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${e[0]}, ${e[1]}));
          return 2 * (resTexRC.y * ${e[0]} + resTexRC.x);
        }
      `,new f.GlslLibRoutine(t))}getOutputPacked2DCoords(o,n){let e="";if(m.ArrayUtil.arraysEqual(o,n))return e=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${n[0]}, ${n[1]}));
        }
      `,new f.GlslLibRoutine(e);let t=n,r=Math.ceil(o[1]/2);return e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));

          int index = resTexRC.y * ${t[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${r}) * 2;
          int c = 2 * (index / ${r});

          return ivec2(r, c);
        }
      `,new f.GlslLibRoutine(e)}getOutputPacked3DCoords(o,n){let e=[n[0],n[1]],t=Math.ceil(o[2]/2),r=t*Math.ceil(o[1]/2),i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;

          int b = index / ${r};
          index -= b * ${r};

          // reverse r and c order for packed texture
          int r = imod(index, ${t}) * 2;
          int c = 2 * (index / ${t});

          return ivec3(b, r, c);
        }
      `;return new f.GlslLibRoutine(i)}getOutputPackedNDCoords(o,n){let e=[n[0],n[1]],t=Math.ceil(o[o.length-1]/2),r=t*Math.ceil(o[o.length-2]/2),i=r,l="",d="b, r, c";for(let b=2;b<o.length-1;b++)i*=o[o.length-b-1],l=`
      int b${b} = index / ${i};
      index -= b${b} * ${i};
    `+l,d=`b${b}, `+d;let g=`
      ivec${o.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.y * ${e[0]} + resTexRC.x;

        ${l}

        int b = index / ${r};
        index -= b * ${r};

        // reverse r and c order for packed texture
        int r = imod(index, ${t}) * 2;
        int c = 2 * (index / ${t});

        return ivec${o.length}(${d});
      }
    `;return new f.GlslLibRoutine(g)}getOutputUnpacked1DCoords(o,n){let e=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          return resTexRC.y * ${n[0]} + resTexRC.x;
        }
      `;return new f.GlslLibRoutine(e)}getOutputUnpacked2DCoords(o,n){let e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          int r = index / ${o[1]};
          int c = index - r * ${o[1]};
          return ivec2(r, c);
        }
      `;return new f.GlslLibRoutine(e)}getOutputUnpacked3DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${l}
          return ivec3(r, c, d);
        }
      `,new f.GlslLibRoutine(e)}getOutputUnpacked4DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d","d2"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${l}
          return ivec4(r, c, d, d2);
        }
      `,new f.GlslLibRoutine(e)}getOutputUnpacked5DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d","d2","d3"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${l}
          return ivec5(r, c, d, d2, d3);
        }
      `,new f.GlslLibRoutine(e)}getOutputUnpacked6DCoords(o,n){let e="",t=o.length,r=null;t<2&&(r=[]),r=new Array(t-1),r[t-2]=o[t-1];for(let d=t-3;d>=0;--d)r[d]=r[d+1]*o[d+1];let i=["r","c","d","d2","d3","d4"],l=r.map((d,g)=>`int ${i[g]} = index / ${d}; ${g===r.length-1?`int ${i[g+1]} = index - ${i[g]} * ${d}`:`index -= ${i[g]} * ${d}`};`).join("");return e=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${n[0]}, ${n[1]}));
         int index = resTexRC.y * ${n[0]} + resTexRC.x;
         ${l}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new f.GlslLibRoutine(e)}getCommonUtilFuncs(){let o={},n="uvFromFlat";o[n]=new f.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),n="packedUVfrom1D",o[n]=new f.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom2D",o[n]=new f.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom3D",o[n]=new f.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="sampleTexture";let e=(0,h.getGlsl)(this.context.glContext.version);return o[n]=new f.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${e.texture2D}(textureSampler, uv).r;
        }`),o}getInputsSamplingSnippets(){let o={},n=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((e,t)=>{let r=this.context.inputTextureLayouts[t],i=(0,u.generateShaderFuncNameFromInputSamplerName)(e);r.isPacked?o[i]=this.getPackedSamplerFromInput(i,e,r):o[i]=this.getUnpackedSamplerFromInput(i,e,r);let l=(0,u.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(e);r.unpackedShape.length<=n.unpackedShape.length&&(r.isPacked?o[l]=this.getPackedSamplerAtOutputCoords(l,r,n,e):o[l]=this.getUnpackedSamplerAtOutputCoords(l,r,n,e))}),o}getPackedSamplerAtOutputCoords(o,n,e,t){let r=n.unpackedShape,i=e.unpackedShape,l=t,d=(0,u.generateShaderFuncNameFromInputSamplerName)(l),g=r.length,b=i.length,v=m.BroadcastUtil.getBroadcastDims(r,i),w=(0,u.getCoordsDataType)(b),x=b-g,T,O=(0,u.getGlChannels)();T=g===0?"":b<2&&v.length>=1?"coords = 0;":v.map(C=>`coords.${O[C+x]} = 0;`).join(`
`);let P="";P=b<2&&g>0?"coords":r.map((C,_)=>`coords.${O[_+x]}`).join(", ");let I="return outputValue;",R=m.ShapeUtil.size(r)===1,j=m.ShapeUtil.size(i)===1;if(g!==1||R||j){if(R&&!j)I=b===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(v.length){let C=g-2,_=g-1;v.indexOf(C)>-1&&v.indexOf(_)>-1?I="return vec4(outputValue.x);":v.indexOf(C)>-1?I="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":v.indexOf(_)>-1&&(I="return vec4(outputValue.xx, outputValue.zz);")}}else I=`
        return vec4(outputValue.xy, outputValue.xy);
      `;let A=`
      vec4 ${o}() {
        ${w} coords = getOutputCoords();
        
        int lastDim = coords.${O[b-1]};
        coords.${O[b-1]} = coords.${O[b-2]};
        coords.${O[b-2]} = lastDim;
      
        ${T}
        vec4 outputValue = ${d}(${P});
        ${I}
      }
    `;return new f.GlslLibRoutine(A,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(o,n,e,t){let r=[e.width,e.height],i=[n.width,n.height],l=n.unpackedShape.length,d=e.unpackedShape.length,g=n.unpackedShape,b=e.unpackedShape,v=(0,u.generateShaderFuncNameFromInputSamplerName)(t);if(l===d&&m.ArrayUtil.arraysEqual(i,r)){let j=`
          float ${o}() {
            return sampleTexture(${t}, TexCoords);
          }
        `;return new f.GlslLibRoutine(j,["coordinates.sampleTexture"])}let w=(0,u.getCoordsDataType)(d),x=m.BroadcastUtil.getBroadcastDims(g,b),T=d-l,O,P=(0,u.getGlChannels)();O=l===0?"":d<2&&x.length>=1?"coords = 0;":x.map(j=>`coords.${P[j+T]} = 0;`).join(`
`);let I="";I=d<2&&l>0?"coords":n.unpackedShape.map((j,A)=>`coords.${P[A+T]}`).join(", ");let R=`
        float ${o}() {
          ${w} coords = getOutputCoords();
          ${O}
          return ${v}(${I});
        }
      `;return new f.GlslLibRoutine(R,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(o,n,e){switch(e.unpackedShape.length){case 0:return this.getPackedSamplerScalar(o,n);case 1:return this.getPackedSampler1D(o,n,e);case 2:return this.getPackedSampler2D(o,n,e);case 3:return this.getPackedSampler3D(o,n,e);default:return this.getPackedSamplerND(o,n,e)}}getUnpackedSamplerFromInput(o,n,e){let t=e.unpackedShape;switch(t.length){case 0:return this.getUnpackedSamplerScalar(o,n,e);case 1:return this.getUnpackedSampler1D(o,n,e);case 2:return this.getUnpackedSampler2D(o,n,e);case 3:return this.getUnpackedSampler3D(o,n,e);case 4:return this.getUnpackedSampler4D(o,n,e);case 5:return this.getUnpackedSampler5D(o,n,e);case 6:return this.getUnpackedSampler6D(o,n,e);default:throw new Error(`Unsupported dimension ${t.length}-D`)}}getPackedSamplerScalar(o,n){let e=`
          vec4 ${o}() {
            return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${n}, halfCR);
          }
        `;return new f.GlslLibRoutine(e)}getPackedSampler1D(o,n,e){let t=[e.width,e.height],r=[t[1],t[0]],i=(0,h.getGlsl)(this.context.glContext.version),l=`vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
      ${r[0]}, ${r[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }`;return new f.GlslLibRoutine(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(o,n,e){let t=e.unpackedShape,r=[e.width,e.height],i=(0,h.getGlsl)(this.context.glContext.version),l=r[0],d=r[1];if(r!=null&&m.ArrayUtil.arraysEqual(t,r)){let w=`vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${l}.0);
        return ${i.texture2D}(${n}, uv);
      }`;return new f.GlslLibRoutine(w)}let g=r,b=Math.ceil(t[1]/2),v=`vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${g[1]}, ${g[0]}, ${b}, row, col);
      return ${i.texture2D}(${n}, uv);
    }`;return new f.GlslLibRoutine(v,["coordinates.packedUVfrom2D"])}getPackedSampler3D(o,n,e){let t=e.unpackedShape,r=[e.width,e.height],i=[r[0],r[1]],l=(0,h.getGlsl)(this.context.glContext.version);if(t[0]===1){let w=t.slice(1),x=[1,2],T=(0,u.squeezeInputShape)(t,w),O=["b","row","col"],P=JSON.parse(JSON.stringify(e));P.unpackedShape=T;let I=this.getPackedSamplerFromInput(o,n,P),R=`${I.routineBody}
      vec4 ${o}(int b, int row, int col) {
        return ${o}(${(0,u.getSqueezedParams)(O,x)});
      } `;return new f.GlslLibRoutine(R,I.dependencies)}let d=i[0],g=i[1],b=Math.ceil(t[2]/2),v=`vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${g}, ${d}, ${b*Math.ceil(t[1]/2)}, ${b}, b, row, col);
      return ${l.texture2D}(${n}, uv);}`;return new f.GlslLibRoutine(v,["coordinates.packedUVfrom3D"])}getPackedSamplerND(o,n,e){let t=e.unpackedShape,r=t.length,i=[e.width,e.height],l=(0,h.getGlsl)(this.context.glContext.version),d=[i[0],i[1]],g=d[1],b=d[0],v=Math.ceil(t[r-1]/2),w=v*Math.ceil(t[r-2]/2),x="int b, int row, int col",T=`b * ${w} + (row / 2) * ${v} + (col / 2)`;for(let P=2;P<r-1;P++)x=`int b${P}, `+x,w*=t[r-P-1],T=`b${P} * ${w} + `+T;let O=`vec4 ${o}(${x}) {
      int index = ${T};
      int texR = index / ${b};
      int texC = index - texR * ${b};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${b}, ${g});
      return ${l.texture2D}(${n}, uv);
    }`;return new f.GlslLibRoutine(O)}getUnpackedSamplerScalar(o,n,e){let[t,r]=[e.width,e.height];if(t===1&&r===1){let l=`
          float ${o}() {
            return sampleTexture(${n}, halfCR);
          }
        `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}let i=`
        float ${o}() {
          int offset_${n} = coordsToOffset(TexCoords, ${t}, ${r});
          vec2 uv = uvFromFlat(${t}, ${r}, offset_${n});
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(o,n,e){let t=e.width,r=e.height;if(r===1&&t===1){let l=`
        float ${o}(int index) {
          return sampleTexture(${n}, halfCR);
        }
      `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}if(r===1){let l=`
          float ${o}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${t}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}if(t===1){let l=`
          float ${o}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${r}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(l,["coordinates.sampleTexture"])}let i=`
        float ${o}(int index) {
          vec2 uv = uvFromFlat(${t}, ${r}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(o,n,e){let t=e.unpackedShape,r=[e.height,e.width];if(r!=null&&m.ArrayUtil.arraysEqual(t,r)){let w=`
          float ${o}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.sampleTexture"])}let{newShape:i,keptDims:l}=(0,p.squeezeShape)(t),d=i;if(d.length<t.length){let w=(0,u.squeezeInputShape)(t,d),x=JSON.parse(JSON.stringify(e));x.unpackedShape=w;let T=["col","row"],O=`
          ${this.getUnpackedSamplerFromInput(o,n,x).routineBody}
          float ${o}(int row, int col) {
            return ${o}(${(0,u.getSqueezedParams)(T,l)});
          }
        `;return new f.GlslLibRoutine(O,["coordinates.sampleTexture"])}let g=r[1],b=r[0];if(b===1){let w=`
          float ${o}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${g}, ${b});
            float index = dot(vec3(row, col, offset_${n}), vec3(${t[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${g}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(g===1){let w=`
          float ${o}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${g}, ${b});
            float index = dot(vec3(row, col, offset_${n}), vec3(${t[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${b}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let v=`
        float ${o}(int row, int col) {
          int index = col * ${t[1]} + row;
          vec2 uv = uvFromFlat(${g}, ${b}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(v,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(o,n,e){let t=e.unpackedShape,r=t[1]*t[2],i=t[2],{newShape:l,keptDims:d}=(0,p.squeezeShape)(t),g=l;if(g.length<t.length){let v=(0,u.squeezeInputShape)(t,g),w=["batch","col","row"],x=JSON.parse(JSON.stringify(e));x.unpackedShape=v;let T=this.getUnpackedSamplerFromInput(o,n,x),O=d.reverse(),P=`
          ${T.routineBody}
          float ${o}(int batch, int row, int col) {
            return ${o}(${(0,u.getSqueezedParams)(w,O)});
          }
        `;return new f.GlslLibRoutine(P,T.dependencies)}let b=`
          float ${o}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${r} + col * ${i} + row;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${n}, uv);
          }
      `;return new f.GlslLibRoutine(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(o,n,e){let t=e.unpackedShape,r=t[3],i=t[2]*r,l=`
        float ${o}(int row, int col, int depth, int depth2) {
          int index = row * ${t[1]*i} + col * ${i} +
              depth2 * ${r} + depth;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(l,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(o,n,e){let t=e.unpackedShape,r=t[4],i=t[3]*r,l=t[2]*i,d=t[1]*l,{newShape:g,keptDims:b}=(0,p.squeezeShape)(t);if(g.length<t.length){let w=(0,u.squeezeInputShape)(t,g),x=["row","col","depth","depth2","depth3"],T=JSON.parse(JSON.stringify(e));T.unpackedShape=w;let O=`
          ${this.getUnpackedSamplerFromInput(o,n,T).routineBody}
          float ${o}(int row, int col, int depth, int depth2, int depth3) {
            return ${o}(${(0,u.getSqueezedParams)(x,b)});
          }
        `;return new f.GlslLibRoutine(O,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let v=`
        float ${o}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${d} + col * ${l} + depth * ${i} +
          depth3 * ${r} + depth2;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new f.GlslLibRoutine(v,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(o,n,e){let t=e.unpackedShape,r=t[5],i=t[4]*r,l=t[3]*i,d=t[2]*l,g=t[1]*d,{newShape:b,keptDims:v}=(0,p.squeezeShape)(t);if(b.length<t.length){let x=(0,u.squeezeInputShape)(t,b),T=["row","col","depth","depth2","depth3","depth4"],O=JSON.parse(JSON.stringify(e));O.unpackedShape=x;let P=`
            ${this.getUnpackedSamplerFromInput(o,n,O).routineBody}
            float ${o}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${o}(${(0,u.getSqueezedParams)(T,v)});
            }
          `;return new f.GlslLibRoutine(P,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let w=`
          float ${o}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${g} + col * ${d} + depth * ${l} +
            depth2 * ${i} + depth3 * ${r} + depth4;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${n}, uv);
          }
        `;return new f.GlslLibRoutine(w,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let o=this.context.outputTextureLayout,n=o.shape.length,e=o.strides,t=o.width,r=o.height,i=[];for(let d=0;d<n-1;++d)i.push(`
        c[${d}] = offset / ${e[d]};`),i.push(`
        offset -= c[${d}] * ${e[d]};`);i.push(`
        c[${n-1}] = offset;`);let l=`
      void toVec(vec2 texCoords, out int c[${n}]) {
        int offset = coordsToOffset(texCoords, ${t}, ${r});
        ${i.join("")}
      }
      void toVec(int offset, out int c[${n}]) {
        ${i.join("")}
      }
    `;return{toVec:new f.GlslLibRoutine(l,["coordinates.coordsToOffset"])}}valueFrom(){let o={};return this.context.programInfo.inputNames.forEach((n,e)=>{let t=this.context.inputTextureLayouts[e],r=(t.unpackedShape.length>0?t.unpackedShape:t.shape).length,i=`_${n}`;o[i]=new f.GlslLibRoutine(this.getValueFromSingle(n,r,t.width,t.height,!1),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),i+="_T",o[i]=new f.GlslLibRoutine(this.getValueFromSingle(n,r,t.width,t.height,!0),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),o}getValueFromSingle(o,n,e,t,r){let i=`_${o}`;return r&&(i+="_T"),`
        float ${i}(int m[${n}]) {
          int offset = indicesToOffset${i}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${t});
          float value = getColorAsFloat(${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords));
          return value;
        }
        `}getPackedValueFrom(o,n,e,t,r){let i=`_${o}_Pack`;return r&&(i+="_T"),`
        vec4 ${i}(int m[${n}]) {
          int offset = indicesToOffset_${o}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${t});
          return ${(0,h.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords);
        }
        `}}c.CoordsGlslLib=s},1997:(M,c)=>{"use strict";var y;Object.defineProperty(c,"__esModule",{value:!0}),c.TopologicalSortGlslRoutines=c.GlslLibRoutineNode=c.GlslLibRoutine=c.GlslLib=c.GlslContext=c.FunctionType=void 0,(y=c.FunctionType||(c.FunctionType={}))[y.ValueBased=0]="ValueBased",y[y.Positional=1]="Positional",c.GlslContext=class{constructor(m,f,h,p){this.glContext=m,this.programInfo=f,this.inputTextureLayouts=h,this.outputTextureLayout=p}},c.GlslLib=class{constructor(m){this.context=m}},c.GlslLibRoutine=class{constructor(m,f){this.routineBody=m,this.dependencies=f}},c.GlslLibRoutineNode=class{constructor(m,f,h){this.name=m,this.dependencies=h||[],f&&(this.routineBody=f)}addDependency(m){m&&this.dependencies.push(m)}},c.TopologicalSortGlslRoutines=class{static returnOrderedNodes(m){if(!m||m.length===0)return[];if(m.length===1)return m;let f=new Set,h=new Set,p=new Array;return this.createOrderedNodes(m,f,h,p),p}static createOrderedNodes(m,f,h,p){for(let u=0;u<m.length;++u)this.dfsTraverse(m[u],f,h,p)}static dfsTraverse(m,f,h,p){if(!m||h.has(m.name))return;if(f.has(m.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");f.add(m.name);let u=m.dependencies;if(u&&u.length>0)for(let s=0;s<u.length;++s)this.dfsTraverse(u[s],f,h,p);p.push(m),h.add(m.name),f.delete(m.name)}}},1371:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.EncodingGlslLib=void 0;let m=y(1997);class f extends m.GlslLib{constructor(p){super(p)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new m.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new m.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let p=f.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new m.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${p}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let p=f.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new m.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${p}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let p=new ArrayBuffer(4),u=new Uint32Array(p),s=new Uint8Array(p);if(u[0]=3735928559,s[0]===239)return!0;if(s[0]===222)return!1;throw new Error("unknown endianness")}}c.EncodingGlslLib=f},2691:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.FragColorGlslLib=void 0;let m=y(1997),f=y(6757);class h extends m.GlslLib{constructor(u){super(u)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){let u=(0,f.getGlsl)(this.context.glContext.version);return{setFragColor:new m.GlslLibRoutine(`
        void setFragColor(float value) {
            ${u.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new m.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}c.FragColorGlslLib=h},3878:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.replaceInlines=void 0;let y=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;c.replaceInlines=function(m){let f={},h;for(;(h=y.exec(m))!==null;){let p=h[3].split(",").map(u=>{let s=u.trim().split(" ");return s&&s.length===2?{type:s[0],name:s[1]}:null}).filter(u=>u!==null);f[h[2]]={params:p,body:h[4]}}for(let p in f){let u="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",p),s=new RegExp(u,"gm");for(;(h=s.exec(m))!==null;){let a=h[1],o=h[2],n=h[3].split(","),e=a?`${a} ${o};`:"",t=f[p].body,r="";f[p].params.forEach((l,d)=>{l&&(r+=`${l.type} ${l.name} = ${n[d]};
`)}),t=`${r}
 ${t}`,t=t.replace("return",`${o} = `);let i=`
      ${e}
      {
        ${t}
      }
      `;m=m.replace(h[0],i)}}return m.replace(y,"")}},8897:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.GlslPreprocessor=void 0;let m=y(1997),f=y(3878),h=y(1248),p=y(6757);c.GlslPreprocessor=class{constructor(u,s,a,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new m.GlslContext(u,s,a,o),Object.keys(h.glslRegistry).forEach(e=>{let t=new h.glslRegistry[e](this.context);this.libs[e]=t});let n=this.glslLibRoutineDependencyGraph;for(let e in this.libs){let t=this.libs[e].getFunctions();for(let r in t){let i=e+"."+r,l;n[i]?(l=n[i],l.routineBody=t[r].routineBody):(l=new m.GlslLibRoutineNode(i,t[r].routineBody),n[i]=l);let d=t[r].dependencies;if(d)for(let g=0;g<d.length;++g)if(n[d[g]])l.addDependency(n[d[g]]);else{let b=new m.GlslLibRoutineNode(d[g]);n[d[g]]=b,l.addDependency(b)}}}}preprocess(){let u=this.context.programInfo,s=u.shaderSource;return this.context.programInfo.hasMain||(s=`${s}
      ${(0,p.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),s=(0,f.replaceInlines)(s),`${(0,p.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(u.inputNames,u.variables)}
    ${this.getImports(s)}
    ${s}`}getImports(u){let s=this.selectGlslLibRoutinesToBeIncluded(u);if(s.length===0)return"";let a="";for(let o=0;o<s.length;++o){if(!s[o].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${s[o].name}`);a+=s[o].routineBody+`
`}return a}selectGlslLibRoutinesToBeIncluded(u){let s=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(a=>{let o=a.split(".")[1];u.indexOf(o)!==-1&&s.push(this.glslLibRoutineDependencyGraph[a])}),m.TopologicalSortGlslRoutines.returnOrderedNodes(s)}getUniforms(u,s){let a=[];if(u)for(let o of u)a.push(`uniform sampler2D ${o};`);if(s)for(let o of s)a.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return a.join(`
`)}}},1248:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.glslRegistry=void 0;let m=y(6859),f=y(1371),h=y(2691),p=y(9183),u=y(9314);c.glslRegistry={encoding:f.EncodingGlslLib,fragcolor:h.FragColorGlslLib,vec:u.VecGlslLib,shapeUtils:p.ShapeUtilsGlslLib,coordinates:m.CoordsGlslLib}},9183:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ShapeUtilsGlslLib=void 0;let m=y(1997);class f extends m.GlslLib{constructor(p){super(p)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){let p=this.context.outputTextureLayout.shape.length,u={};return this.context.programInfo.inputNames.forEach((s,a)=>{let o=this.context.inputTextureLayouts[a].unpackedShape;if(o.length<=p){let n=o.length,e=p-n,t=`bcastIndices_${s}`,r="";for(let l=0;l<n;++l)r+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${e+l}]), ${o[l]}.0) );
          `;let i=`
        void ${t} (int bcastedIndices[${p}], out int realIndices[${n}]) {
          ${r}
        }
        `;u[t]=new m.GlslLibRoutine(i)}}),u}bcastMatmulIndex(){let p=this.context.outputTextureLayout.shape.length,u={};return this.context.programInfo.inputNames.forEach((s,a)=>{let o=this.context.inputTextureLayouts[a].shape;if(!(o.length<2||o.length>p)){let n=o.length,e=p-n,t=`bcastMatmulIndices_${s}`,r="";for(let l=0;l<n-2;++l)r+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${e+l}]), ${o[l]}.0) );
          `;let i=`
        void ${t}(int bcastedIndices[${p}], out int realIndices[${n}]) {
          ${r}
          realIndices[${n-1}] = bcastedIndices[${p-1}];
          realIndices[${n-2}] = bcastedIndices[${p-2}];
        }
        `;u[t]=new m.GlslLibRoutine(i)}}),u}indicesToOffset(){let p={};return this.context.programInfo.inputNames.forEach((u,s)=>{let a=this.context.inputTextureLayouts[s].shape,o=this.context.inputTextureLayouts[s].strides,n=a.length,e=`indicesToOffset_${u}`;p[e]=new m.GlslLibRoutine(f.indexToOffsetSingle(e,n,o)),e=`indicesToOffset_${u}_T`,p[e]=new m.GlslLibRoutine(f.indexToOffsetSingle(e,n,o.slice().reverse()))}),p}static indexToOffsetSingle(p,u,s){let a="";for(let o=u-1;o>=0;--o)a+=`
        offset += indices[${o}] * ${s[o]};
        `;return`
      int ${p}(int indices[${u}]) {
        int offset = 0;
        ${a}
        return offset;
      }
      `}offsetToIndices(){let p={};return this.context.programInfo.inputNames.forEach((u,s)=>{let a=this.context.inputTextureLayouts[s].shape,o=this.context.inputTextureLayouts[s].strides,n=a.length,e=`offsetToIndices_${u}`;p[e]=new m.GlslLibRoutine(f.offsetToIndicesSingle(e,n,o)),e=`offsetToIndices_${u}_T`,p[e]=new m.GlslLibRoutine(f.offsetToIndicesSingle(e,n,o.slice().reverse()))}),p}static offsetToIndicesSingle(p,u,s){let a=[];for(let o=0;o<u-1;++o)a.push(`
      indices[${o}] = offset / ${s[o]};`),a.push(`
        offset -= indices[${o}] * ${s[o]};`);return a.push(`
      indices[${u-1}] = offset;`),`
      void ${p}(int offset, out int indices[${u}]) {
        ${a.join("")}
      }
      `}incrementIndices(){let p={};return this.context.programInfo.inputNames.forEach((u,s)=>{let a=this.context.inputTextureLayouts[s].shape,o=a.length,n=`incrementIndices_${u}`,e="";for(let r=0;r<o;++r)e+=`
        shape[${r}] = ${a[r]};`;let t=`
        void ${n}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${e};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;p[n]=new m.GlslLibRoutine(t)}),p}}c.ShapeUtilsGlslLib=f},6757:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getDefaultFragShaderMain=c.getFragShaderPreamble=c.getVertexShaderSource=c.getGlsl=void 0;let y={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},m={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function f(h){return h===1?y:m}c.getGlsl=f,c.getVertexShaderSource=function(h){let p=f(h);return`${p.version}
      precision highp float;
      ${p.attribute} vec3 position;
      ${p.attribute} vec2 textureCoord;

      ${p.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},c.getFragShaderPreamble=function(h){let p=f(h);return`${p.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${p.varyingFrag} vec2 TexCoords;
    ${p.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},c.getDefaultFragShaderMain=function(h,p){return`
  void main() {
    int indices[${p}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${f(h).output} = result;
  }
  `}},9314:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.VecGlslLib=void 0;let m=y(1997);class f extends m.GlslLib{constructor(p){super(p)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){let p=this.context.outputTextureLayout.shape.length,u={add:"+=",sub:"-=",mul:"*=",div:"/="},s={};for(let a in u){let o=`${a}Vec`,n="";for(let t=0;t<p;++t)n+=`
          dest[${t}] ${u[a]} src[${t}];
          `;let e=`
        void ${o}(int src[${p}], out int dest[${p}]) {
          ${n}
        }
        `;s[o]=new m.GlslLibRoutine(e)}return s}copyVec(){let p=this.context.outputTextureLayout.shape.length,u="";for(let a=0;a<p;++a)u+=`
        dest[${a}] = src[${a}];
        `;let s=`
      void copyVec(int src[${p}], out int dest[${p}]) {
        ${u}
      }
      `;return{copyVec:new m.GlslLibRoutine(s)}}setVecItem(){let p=this.context.outputTextureLayout.shape.length,u=`
        if(index < 0)
            index =${p} + index;
        if (index == 0)
            m[0] = value;
        `;for(let a=1;a<p-1;++a)u+=`
        else if (index == ${a})
            m[${a}] = value;
            `;u+=`
        else
            m[${p-1}] = value;
        `;let s=`
      void setVecItem(out int m[${p}], int index, int value) {
        ${u}
      }
        `;return{setVecItem:new m.GlslLibRoutine(s)}}getVecItem(){let p=this.context.outputTextureLayout.shape.length,u=`
        if(index < 0)
            index = ${p} + index;
        if (index == 0)
            return m[0];
      `;for(let a=1;a<p-1;++a)u+=`
        else if (index == ${a})
            return m[${a}];
      `;u+=`
        else
            return m[${p-1}];
        `;let s=`
      int getVecItem(int m[${p}], int index) {
        ${u}
      }
    `;return{getVecItem:new m.GlslLibRoutine(s)}}}c.VecGlslLib=f},7860:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLInferenceHandler=void 0;let m=y(1315),f=y(9240),h=y(7273),p=y(9),u=y(7379),s=y(2488),a=y(540),o=y(3314),n=y(5639);c.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,t){return(0,o.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,t)}executeProgram(e,t){if(t.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let r=[];for(let v=0;v<e.inputNames.length;++v)r[v]=this.getOrCreateTextureData(t[v],e.inputTypes[v]);let i=((v,w)=>{let x=w.map(O=>`${O.unpackedShape.join(",")};${O.width}x${O.height}`).join("_"),T=v.name;return v.cacheHint&&(T+="["+v.cacheHint+"]"),T+=":"+x,T})(e,r),l=this.session.programManager.getArtifact(i),d=l?l.programInfo:typeof e.get=="function"?e.get():e,g=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,d.output.dims,d.output.textureType),b=this.createTextureData(g,d.output.type);return l||(l=this.session.programManager.build(d,r,b),this.session.programManager.setArtifact(i,l)),this.runProgram(l,r,b),b}run(e,t){return this.executeProgram(e,t).tensor}runProgram(e,t,r){for(let i=0;i<t.length;++i)if(!!t[i].isPacked!=(e.programInfo.inputTypes[i]===n.TextureType.packed))throw new Error(`input[${i}] property packed inconsistent`);if(!!r.isPacked!=(e.programInfo.output.textureType===n.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,t,r)}getOrCreateTextureData(e,t){let r=this.getTextureData(e.dataId,t===n.TextureType.packed);if(!r&&(r=this.getTextureData(e.dataId,t!==n.TextureType.packed),r))return t===n.TextureType.packed?this.pack(r):this.unpack(r);if(!r){let i=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,t);if(t===n.TextureType.packedLastDimension){let g=e.dims;if(g.length===4){let b=[g[0],Math.ceil(g[1]*g[2]*g[3]/4)],v=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,b,t),w=e.numberData;if(g[1]*g[2]*g[3]%4!=0){let x=g[0],T=g[1]*g[2]*g[3],O=Math.ceil(T*1/4)*4;w=new Float32Array(x*O);for(let P=0;P<x;++P){let I=P*T,R=P*O+P%1*T;w.set(e.numberData.subarray(I,I+T),R)}}return this.createTextureData(v,e.type,w,e,1)}}if(t===n.TextureType.packed){let l=(0,o.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),d=this.createTextureData(l,e.type,e.numberData,e,1);r=this.pack(d)}else r=this.createTextureData(i,e.type,e.numberData,e,1)}return r}createTextureDataFromLayoutBindTensor(e,t,r,i){return this.createTextureData(e,t,r,i,1)}createTextureData(e,t,r,i,l){m.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let d=this.session.textureManager.createTextureFromLayout(t,e,r,l);return this.createTextureDataFromTexture(e,t,d,i)}reshapeUnpacked(e,t){let r=this.getOrCreateTextureData(e,n.TextureType.unpacked),i={channels:r.channels,height:r.height,width:r.width,shape:t.length!==0?t:[1],strides:h.ShapeUtil.computeStrides(t),unpackedShape:t};return this.createTextureDataFromTexture(i,e.type,r.texture).tensor}reshapePacked(e,t){let r=this.getOrCreateTextureData(e,n.TextureType.packed);if((0,u.isReshapeCheap)(e.dims,t)){let b={channels:r.channels,height:r.height,width:r.width,shape:t.length!==0?t:[1],strides:h.ShapeUtil.computeStrides(t),unpackedShape:t,isPacked:!0};return this.createTextureDataFromTexture(b,e.type,r.texture).tensor}let i=(0,u.processDims3D)(e.dims),l=(0,u.processDims3D)(t),d=this.reshapePacked(e,i),g=this.run((0,u.createPackedReshape3DProgramInfoLoader)(this,d,l),[d]);return this.reshapePacked(g,t)}cast(e,t){let r=this.getOrCreateTextureData(e,n.TextureType.unpacked);return this.createTextureDataFromTexture(r,t,r.texture).tensor}createTextureDataFromTexture(e,t,r,i,l){let d=Object.assign(Object.assign({},e),{tensor:i||new f.Tensor(e.unpackedShape,t,g=>this.readTexture(d),async g=>this.readTextureAsync(d),void 0,l),texture:r});return this.setTextureData(d.tensor.dataId,d,e.isPacked),d}getTextureData(e,t=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,t):t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,r=!1){this.session.isInitializer(e)?this.session.setTextureData(e,t,r):(r?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,t)}isTextureLayoutCached(e,t=!1){return!!this.getTextureData(e.dataId,t)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,s.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,s.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,p.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,a.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},4110:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(Y,X,te,ae){ae===void 0&&(ae=te);var se=Object.getOwnPropertyDescriptor(X,te);se&&!("get"in se?!X.__esModule:se.writable||se.configurable)||(se={enumerable:!0,get:function(){return X[te]}}),Object.defineProperty(Y,ae,se)}:function(Y,X,te,ae){ae===void 0&&(ae=te),Y[ae]=X[te]}),f=this&&this.__setModuleDefault||(Object.create?function(Y,X){Object.defineProperty(Y,"default",{enumerable:!0,value:X})}:function(Y,X){Y.default=X}),h=this&&this.__importStar||function(Y){if(Y&&Y.__esModule)return Y;var X={};if(Y!=null)for(var te in Y)te!=="default"&&Object.prototype.hasOwnProperty.call(Y,te)&&m(X,Y,te);return f(X,Y),X};Object.defineProperty(c,"__esModule",{value:!0}),c.WEBGL_OP_RESOLVE_RULES=void 0;let p=y(8817),u=h(y(5194)),s=y(4752),a=y(6668),o=y(9754),n=y(5042),e=y(6742),t=y(4125),r=y(6149),i=y(5378),l=y(6981),d=y(7413),g=y(7006),b=y(8276),v=y(5565),w=y(2834),x=y(1010),T=y(8126),O=y(2801),P=y(565),I=y(2444),R=y(815),j=y(564),A=y(5416),C=y(1240),_=y(5944),S=y(5707),E=h(y(9087)),z=y(7862),L=y(3980);c.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",E.abs],["Acos","","7+",E.acos],["Add","","7+",u.add],["And","","7+",u.and],["Asin","","7+",E.asin],["Atan","","7+",E.atan],["AveragePool","","7+",w.averagePool,w.parseAveragePoolAttributes],["BatchNormalization","","7+",p.batchNormalization,p.parseBatchNormalizationAttributes],["Cast","","6+",s.cast,s.parseCastAttributes],["Ceil","","6+",E.ceil],["Clip","","6-10",E.clip,E.parseClipAttributes],["Clip","","11+",E.clipV11],["Concat","","4+",a.concat,a.parseConcatAttributes],["Conv","","1+",o.conv,o.parseConvAttributes],["ConvTranspose","","1+",n.convTranspose,n.parseConvTransposeAttributes],["Cos","","7+",E.cos],["Div","","7+",u.div],["Dropout","","7+",E.identity],["DepthToSpace","","1+",e.depthToSpace,e.parseDepthToSpaceAttributes],["Equal","","7+",u.equal],["Elu","","6+",E.elu,E.parseEluAttributes],["Exp","","6+",E.exp],["Flatten","","1+",t.flatten,t.parseFlattenAttributes],["Floor","","6+",E.floor],["FusedConv","com.microsoft","1+",o.conv,o.parseConvAttributes],["Gather","","1+",r.gather,r.parseGatherAttributes],["Gemm","","7-10",i.gemm,i.parseGemmAttributesV7],["Gemm","","11+",i.gemm,i.parseGemmAttributesV11],["GlobalAveragePool","","1+",w.globalAveragePool,w.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",w.globalMaxPool],["Greater","","7+",u.greater],["Identity","","1+",E.identity],["ImageScaler","","1+",l.imageScaler,l.parseImageScalerAttributes],["InstanceNormalization","","6+",d.instanceNormalization,d.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",E.leakyRelu,E.parseLeakyReluAttributes],["Less","","7+",u.less],["LRN","","1+",g.lrn,g.parseLrnAttributes],["Log","","6+",E.log],["MatMul","","1+",b.matMul,b.parseMatMulAttributes],["MaxPool","","1+",w.maxPool,w.parseMaxPoolAttributes],["Mul","","7+",u.mul],["Neg","","6+",E.neg],["Not","","1+",E.not],["Or","","7+",u.or],["Pad","","2-10",v.padV2,v.parsePadAttributesV2],["Pad","","11+",v.padV11,v.parsePadAttributesV11],["Pow","","7+",u.pow],["PRelu","","7+",u.pRelu],["ReduceLogSum","","1+",x.reduceLogSum,x.parseReduceAttributes],["ReduceMax","","1+",x.reduceMax,x.parseReduceAttributes],["ReduceMean","","1+",x.reduceMean,x.parseReduceAttributes],["ReduceMin","","1+",x.reduceMin,x.parseReduceAttributes],["ReduceProd","","1+",x.reduceProd,x.parseReduceAttributes],["ReduceSum","","1-12",x.reduceSum,x.parseReduceAttributes],["ReduceSumSquare","","1+",x.reduceLogSumSquare,x.parseReduceAttributes],["Relu","","6+",E.relu],["Reshape","","5+",T.reshape],["Resize","","10",O.resize,O.parseResizeAttributesV10],["Resize","","11+",O.resize,O.parseResizeAttributesV11],["Shape","","1+",P.shape],["Sigmoid","","6+",E.sigmoid],["Sin","","7+",E.sin],["Slice","","10+",I.sliceV10],["Slice","","1-9",I.slice,I.parseSliceAttributes],["Softmax","","1-12",R.softmax,R.parseSoftmaxAttributes],["Softmax","","13+",R.softmaxV13,R.parseSoftmaxAttributesV13],["Split","","2-12",j.split,j.parseSplitAttributes],["Sqrt","","6+",E.sqrt],["Squeeze","","1-12",A.squeeze,A.parseSqueezeAttributes],["Squeeze","","13+",A.squeezeV13],["Sub","","7+",u.sub],["Sum","","6+",C.sum],["Tan","","7+",E.tan],["Tanh","","6+",E.tanh],["Tile","","6+",_.tile],["Transpose","","1+",S.transpose,S.parseTransposeAttributes],["Upsample","","7-8",L.upsample,L.parseUpsampleAttributesV7],["Upsample","","9",L.upsample,L.parseUpsampleAttributesV9],["Unsqueeze","","1-12",z.unsqueeze,z.parseUnsqueezeAttributes],["Unsqueeze","","13+",z.unsqueezeV13],["Xor","","7+",u.xor]]},8817:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseBatchNormalizationAttributes=c.batchNormalization=void 0;let m=y(4910),f=y(6757),h=y(5639),p={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]};c.batchNormalization=(a,o,n)=>(s(o),[a.run(Object.assign(Object.assign({},p),{cacheHint:n.cacheKey,get:()=>u(a,o,n)}),o)]),c.parseBatchNormalizationAttributes=a=>{let o=a.attributes.getFloat("epsilon",1e-5),n=a.attributes.getFloat("momentum",.9),e=a.attributes.getInt("spatial",1);return(0,m.createAttributeWithCacheKey)({epsilon:o,momentum:n,spatial:e})};let u=(a,o,n)=>{let e=(0,f.getGlsl)(a.session.backend.glContext.version),t=o[0].dims.length,[r,i]=a.calculateTextureWidthAndHeight(o[1].dims,h.TextureType.unpacked),l=`
  float process(int[${t}] indices) {
    vec2 position = offsetToCoords(indices[1], ${r}, ${i});
    float scale = getColorAsFloat(${e.texture2D}(Scale, position));
    float mean = getColorAsFloat(${e.texture2D}(Mean, position));
    float variance = getColorAsFloat(${e.texture2D}(Variance, position));
    float b = getColorAsFloat(${e.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},p),{output:{dims:o[0].dims,type:o[0].type,textureType:h.TextureType.unpacked},shaderSource:l})},s=a=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let o=a[0],n=a[1],e=a[2],t=a[3],r=a[4];if(o.dims.length<3||n.dims.length!==1||e.dims.length!==1||t.dims.length!==1||r.dims.length!==1)throw new Error("invalid input shape.");if(n.dims[0]!==o.dims[1]||e.dims[0]!==o.dims[1]||t.dims[0]!==o.dims[1]||r.dims[0]!==o.dims[1])throw new Error("invalid input shape.");if(o.type!=="float32"&&o.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||r.type!=="float32"&&r.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.xor=c.sub=c.pRelu=c.pow=c.or=c.mul=c.less=c.greater=c.equal=c.div=c.and=c.add=c.glslPRelu=c.glslPow=c.glslXor=c.glslOr=c.glslAnd=c.glslLess=c.glslGreater=c.glslEqual=c.glslSub=c.glslMul=c.glslDiv=c.glslAdd=void 0;let m=y(7273),f=y(1997),h=y(6757),p=y(5639);function u(){let w="add_";return{body:`
  float ${w}(float a, float b) {
    return a + b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function s(){let w="div_";return{body:`
  float ${w}(float a, float b) {
    return a / b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function a(){let w="mul_";return{body:`
  float ${w}(float a, float b) {
    return a * b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function o(){let w="sub_";return{body:`
  float ${w}(float a, float b) {
    return a - b;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:w,type:f.FunctionType.ValueBased}}function n(){let w="equal_";return{body:`
  float ${w}(float a, float b) {
    return float(a == b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:w,type:f.FunctionType.ValueBased}}function e(){let w="greater_";return{body:`
  float ${w}(float a, float b) {
    return float(a > b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function t(){let w="less_";return{body:`
  float ${w}(float a, float b) {
    return float(a < b);
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function r(){let w="and_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function i(){let w="or_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function l(){let w="xor_";return{body:`
  float ${w}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:w,type:f.FunctionType.ValueBased}}function d(){return function(w){let x=`${w}_`;return{body:`
  float ${x}(float a, float b) {
    return ${w}(a, b);
  }
  vec4 ${x}(vec4 v1, vec4 v2) {
    return ${w}(v1, v2);
  }
  `,name:x,type:f.FunctionType.ValueBased}}("pow")}function g(){let w="prelu_";return{body:`
  float ${w}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${w}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:w,type:f.FunctionType.ValueBased}}c.glslAdd=u,c.glslDiv=s,c.glslMul=a,c.glslSub=o,c.glslEqual=n,c.glslGreater=e,c.glslLess=t,c.glslAnd=r,c.glslOr=i,c.glslXor=l,c.glslPow=d,c.glslPRelu=g;let b=(w,x,T,O=x[0].type,P)=>{let I=w.session.pack?p.TextureType.packed:p.TextureType.unpacked;return{name:T.name,inputNames:["A","B"],inputTypes:[I,I],cacheHint:P,get:()=>v(w,x,T,O)}},v=(w,x,T,O=x[0].type)=>{let P=w.session.pack?p.TextureType.packed:p.TextureType.unpacked,I=!m.ShapeUtil.areEqual(x[0].dims,x[1].dims),R=x[0].dims,j=w.session.pack;if(I){let _=m.BroadcastUtil.calcShape(x[0].dims,x[1].dims,!1);if(!_)throw new Error("Can't perform binary op on the given tensors");R=_;let S=R.length,E=x[0].dims.length!==0?x[0].dims.length:1,z=x[1].dims.length!==0?x[1].dims.length:1,L=x[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",Y=x[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",X=(0,h.getGlsl)(w.session.backend.glContext.version),te=j?`
      ${T.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${T.name}(a, b);
        ${X.output} = result;
      }`:`
      ${T.body}
      float process(int indices[${S}]) {
        int aindices[${E}];
        int bindices[${z}];
        ${L}
        ${Y}
        return ${T.name}(_A(aindices), _B(bindices));
      }`;return{name:T.name,inputNames:["A","B"],inputTypes:[P,P],output:{dims:R,type:O,textureType:P},shaderSource:te,hasMain:j}}let A=(0,h.getGlsl)(w.session.backend.glContext.version),C=`
    ${T.body}
    void main() {
      vec4 v1 = ${A.texture2D}(A, TexCoords);
      vec4 v2 = ${A.texture2D}(B, TexCoords);
      vec4 result = ${T.name}(v1, v2);
      ${A.output} = result;
    }
    `;return{name:T.name,inputNames:["A","B"],inputTypes:[P,P],output:{dims:x[0].dims,type:O,textureType:P},shaderSource:C,hasMain:!0}};c.add=(w,x)=>[w.run(b(w,x,u()),x)],c.and=(w,x)=>[w.run(b(w,x,r(),"bool"),x)],c.div=(w,x)=>[w.run(b(w,x,s()),x)],c.equal=(w,x)=>[w.run(b(w,x,n(),"bool"),x)],c.greater=(w,x)=>[w.run(b(w,x,e(),"bool"),x)],c.less=(w,x)=>[w.run(b(w,x,t(),"bool"),x)],c.mul=(w,x)=>[w.run(b(w,x,a()),x)],c.or=(w,x)=>[w.run(b(w,x,i(),"bool"),x)],c.pow=(w,x)=>[w.run(b(w,x,d()),x)],c.pRelu=(w,x)=>[w.run(b(w,x,g()),x)],c.sub=(w,x)=>[w.run(b(w,x,o()),x)],c.xor=(w,x)=>[w.run(b(w,x,l(),"bool"),x)]},4752:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseCastAttributes=c.cast=void 0;let m=y(7273);c.cast=(h,p,u)=>(f(p),[h.cast(p[0],u)]),c.parseCastAttributes=h=>m.ProtoUtil.tensorDataTypeFromProto(h.attributes.getInt("to"));let f=h=>{if(!h||h.length!==1)throw new Error("Cast requires 1 input.");if(h[0].type==="string")throw new Error("Invalid input type.")}},4595:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackedConcatProgramInfoLoader=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614);c.createPackedConcatProgramInfoLoader=(s,a,o)=>{let n=(e=a.length,t=o.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:e},(r,i)=>`X${i}`),inputTypes:Array(e).fill(f.TextureType.packed),cacheHint:t});var e,t;return Object.assign(Object.assign({},n),{get:()=>((r,i,l,d)=>{let g=l[0].dims.slice();if(d>=g.length||d<-1*g.length)throw new Error("axis specified for concat doesn't match input dimensionality");d<0&&(d=g.length+d);let b=g.slice(0);for(let L=1;L<l.length;L++){let Y=l[L].dims.slice();for(let X=0;X<g.length;X++)if(X===d)b[d]+=Y[X];else if(g[X]!==Y[X])throw new Error("non concat dimensions must match")}let v=b.length,w=(0,p.getChannels)("coords",v),x=(0,h.getCoordsDataType)(v),T=(0,p.unpackFromChannel)(),O=l.map(L=>L.dims),P=(0,h.getGlChannels)(v),I=new Array(O.length-1);I[0]=O[0][d];for(let L=1;L<I.length;L++)I[L]=I[L-1]+O[L][d];let R=P[d],j=P.slice(-2),A=P.join(),C=`if (${R} < ${I[0]}) {
        return getChannel(
            getX0(${A}), vec2(${j.join()}));
        }`;for(let L=1;L<I.length;L++){let Y=I[L-1];C+=`
            if (${R} < ${I[L]}  && ${R} >= ${I[L-1]}) {
              return getChannel(
                getX${L}(${u(P,R,Y)}),
                vec2(${u(j,R,Y)}));
            }`}let _=I.length,S=I[I.length-1];C+=`
            return getChannel(
              getX${_}(${u(P,R,S)}),
              vec2(${u(j,R,S)}));`;let E=(0,m.getGlsl)(r.session.backend.glContext.version),z=`
          ${T}
          float getValue(${P.map(L=>"int "+L)}) {
            ${C}
          }

          void main() {
            ${x} coords = getOutputCoords();
            int lastDim = coords.${P[v-1]};
            coords.${P[v-1]} = coords.${P[v-2]};
            coords.${P[v-2]} = lastDim;

            vec4 result = vec4(getValue(${w}), 0., 0., 0.);

            ${w[v-1]} = ${w[v-1]} + 1;
            if (${w[v-1]} < ${b[v-1]}) {
              result.g = getValue(${w});
            }

            ${w[v-2]} = ${w[v-2]} + 1;
            if (${w[v-2]} < ${b[v-2]}) {
              result.a = getValue(${w});
            }

            ${w[v-1]} = ${w[v-1]} - 1;
            if (${w[v-2]} < ${b[v-2]} &&
                ${w[v-1]} < ${b[v-1]}) {
              result.b = getValue(${w});
            }
            ${E.output} = result;
          }
        `;return Object.assign(Object.assign({},i),{output:{dims:b,type:l[0].type,textureType:f.TextureType.packed},shaderSource:z,hasMain:!0})})(s,n,a,o.axis)})};let u=(s,a,o)=>{let n=s.indexOf(a);return s.map((e,t)=>t===n?`${e} - ${o}`:e).join()}},6668:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseConcatAttributes=c.concat=void 0;let m=y(4910),f=y(5639),h=y(4595);c.concat=(e,t,r)=>(n(t),e.session.pack&&t[0].dims.length>1?[e.run((0,h.createPackedConcatProgramInfoLoader)(e,t,r),t)]:[e.run(p(e,t,r),t)]);let p=(e,t,r)=>{let i=(l=t.length,d=r.cacheKey,{name:"Concat",inputNames:Array.from({length:l},(g,b)=>`X${b}`),inputTypes:Array(l).fill(f.TextureType.unpacked),cacheHint:d});var l,d;return Object.assign(Object.assign({},i),{get:()=>((g,b,v,w)=>{let x=v[0].dims.slice();if(w>=x.length||w<-1*x.length)throw new Error("axis specified for concat doesn't match input dimensionality");w<0&&(w=x.length+w);let T=x.slice(0);for(let A=1;A<v.length;A++){let C=v[A].dims.slice();for(let _=0;_<x.length;_++)if(_===w)T[w]+=C[_];else if(x[_]!==C[_])throw new Error("non concat dimensions must match")}let O=T.length,P=new Array(v.length),I=0;for(let A=0;A<P.length;++A)I+=v[A].dims[w],P[A]=I;let R="";R=v.length<5?u(P):s(P);let j=`
        ${a(v.length,O)}
        ${o(P)}
        ${R}
        float process(int indices[${O}]) {
          int textureIndex = getTextureWhereDataResides (indices[${w}]);

          if(textureIndex != 0) {
            indices[${w}] = indices[${w}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},b),{output:{dims:T,type:v[0].type,textureType:f.TextureType.unpacked},shaderSource:j})})(0,i,t,r.axis)})},u=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((t,r)=>`if(index<${t}) {return ${r};}
`).join("")}
    }`,s=e=>u(e),a=(e,t)=>{let r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let i=0;i<e;++i)i===0?r.push(`	if (textureIndex == ${i}) { return _X${i}(indices); }`):i===e-1?r.push(`	else { return _X${i}(indices); }`):r.push(`	else if (textureIndex == ${i}) { return _X${i}(indices); }`);return r.push("	}"),r.join(`
`)},o=e=>{let t=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<e.length;++r)r===0?t.push(`	if (index == ${r}) { return ${e[r]}; }`):r===e.length-1?t.push(`	else { return ${e[r]}; }`):t.push(`	else if (index == ${r}) { return ${e[r]}; }`);return t.push("	}"),t.join(`
`)};c.parseConcatAttributes=e=>(0,m.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});let n=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].type,r=e[0].dims.length;if(t==="string")throw new Error("string tensor is not supported yet");for(let i of e){if(i.type!==t)throw new Error("input tensors should be one type");if(i.dims.length!==r)throw new Error("input tensors should have the same shape")}}},7825:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createUnpackedGroupedConvProgramInfoLoader=void 0;let m=y(1315),f=y(6757),h=y(5639),p=y(9754),u=y(2150);c.createUnpackedGroupedConvProgramInfoLoader=(s,a,o)=>{let n=(e=a.length>2,t=o.cacheKey,{name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:t});var e,t;return Object.assign(Object.assign({},n),{get:()=>((r,i,l,d)=>{let g=i.length>2?"value += getBias(output_channel);":"",b=i[0].dims.slice(),v=i[1].dims.slice(),w=v[0]/d.group;m.Logger.verbose("GroupedConv",`autpPad:${d.autoPad}, dilations:${d.dilations}, group:${d.group}, kernelShape:${d.kernelShape}, pads:${d.pads}, strides:${d.strides}`);let x=(0,p.calculateOutputShape)(b,v,d.dilations,d.pads,d.strides),T=(0,f.getGlsl)(r.session.backend.glContext.version),{activationFunction:O,applyActivation:P}=(0,u.getActivationSnippet)(d),I=`
  const ivec2 strides = ivec2(${d.strides[0]}, ${d.strides[1]});
  const ivec2 pads = ivec2(${d.pads[0]}, ${d.pads[1]});
  ${O}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${w};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${v[1]}; wInChannel++) {
      int input_channel = group_id * ${v[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${v[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${d.dilations[0]};

        if (xHeight < 0 || xHeight >= ${b[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${v[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${d.dilations[1]};
          if (xWidth < 0 || xWidth >= ${b[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${g}
    ${P}
    ${T.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},l),{output:{dims:x,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:I,hasMain:!0})})(s,a,n,o)})}},7708:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.conv2DPacked=c.conv2DPackedPointwise=void 0;let m=y(9754),f=y(5950),h=y(5632);c.conv2DPackedPointwise=(p,u,s)=>{let a=u[0].dims,o=u[1].dims,n=(0,m.calculateOutputShape)(a,o,s.dilations,s.pads,s.strides),e=p.reshapePacked(u[0],[a[1],a[2]*a[3]]),t=p.reshapePacked(u[1],[o[0],o[1]]),r=u.length>2?[t,e,u[2]]:[t,e],i=p.run((0,h.createPackedMatmulProgramInfoLoader)(p,r,s),r);return p.reshapePacked(i,n)},c.conv2DPacked=(p,u,s)=>{let a=u[0].dims,o=u[1].dims,n=(0,m.calculateOutputShape)(a,o,s.dilations,s.pads,s.strides),e=p.run((0,f.createPackedIm2ColProgramInfoLoader)(p,u[0],u[1],n,s),[u[0]]),t=p.reshapePacked(u[1],[o[0],o[1]*o[2]*o[3]]),r=u.length===3?[t,e,u[2]]:[t,e],i=p.run((0,h.createPackedMatmulProgramInfoLoader)(p,r,s),r);return p.reshapePacked(i,n)}},5042:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseConvTransposeAttributes=c.convTranspose=void 0;let m=y(4910),f=y(6757),h=y(5639),p=y(2150),u=(t,r,i,l,d,g)=>(t-1)*r+i+(l-1)*d+1-g,s=(t,r,i,l,d)=>{let g=Math.floor(t/2);r==="SAME_UPPER"?(i[l]=g,i[d]=t-g):r==="SAME_LOWER"&&(i[l]=t-g,i[d]=g)};c.convTranspose=(t,r,i)=>(e(r,i),a(t,r,i));let a=(t,r,i)=>{let l=n(i,r);return[o(t,r,l)]},o=(t,r,i)=>t.run(((l,d,g)=>{let b=(v=d.length>2,w=g.cacheKey,{name:"ConvTranspose",inputNames:v?["X","W","B"]:["X","W"],inputTypes:v?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],cacheHint:w});var v,w;return Object.assign(Object.assign({},b),{get:()=>((x,T,O,P)=>{let I=T.length>2?"getB(output_channel)":"0.0",R=T[0].dims,j=T[1].dims,A=j[1],C=j[0]/P.group,_=[T[0].dims[0],T[1].dims[1]*P.group,...P.outputShape],S=(0,f.getGlsl)(x.session.backend.glContext.version),{activationFunction:E,applyActivation:z}=(0,p.getActivationSnippet)(P),L=`
  const ivec2 strides = ivec2(${P.strides[0]}, ${P.strides[1]});
  const ivec2 pads = ivec2(${P.pads[0]}, ${P.pads[1]});
  ${E}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${A};
    int wOutChannel = output_channel - group_id * ${A};

    float value = ${I};
    for (int inChannelOffset = 0; inChannelOffset < ${C}; inChannelOffset++) {
      int input_channel = group_id * ${C} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${j[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${j[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${P.dilations[0]}, wHOff * ${P.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${R[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${R[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${z}
    ${S.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},O),{output:{dims:_,type:T[0].type,textureType:h.TextureType.unpacked},shaderSource:L,hasMain:!0})})(l,d,b,g)})})(t,r,i),r),n=(t,r)=>{let i=t.kernelShape.slice();if(t.kernelShape.length===0)for(let b=2;b<r[1].dims.length;++b)i.push(r[1].dims[b]);let l=t.pads.slice(),d=t.outputShape.slice();((b,v,w,x,T,O,P,I)=>{let R=b.length-2,j=I.length===0;for(let A=0;A<R;++A){let C=j?b[A+2]*O[A]:I[A],_=u(b[A+2],O[A],T[A],v[A],w[A],C);s(_,x,T,A,A+R),j&&I.push(O[A]*(b[A+2]-1)+P[A]+(v[A]-1)*w[A]+1-T[A]-T[A+R])}})(r[0].dims,i,t.dilations,t.autoPad,l,t.strides,t.outputPadding,d);let g=Object.assign({},t);return Object.assign(g,{kernelShape:i,pads:l,outputShape:d,cacheKey:t.cacheKey}),g};c.parseConvTransposeAttributes=t=>{let r=t.attributes,i=(0,p.parseInternalActivationAttributes)(r),l=r.getString("auto_pad","NOTSET"),d=r.getInts("dilations",[1,1]),g=r.getInt("group",1),b=r.getInts("kernel_shape",[]),v=r.getInts("output_padding",[0,0]),w=r.getInts("output_shape",[]),x=r.getInts("pads",[0,0,0,0]),T=r.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:l,dilations:d,group:g,kernelShape:b,outputPadding:v,outputShape:w,pads:x,strides:T},i))};let e=(t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4||t[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(t[0].dims[1]!==t[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==i))throw new Error("invalid bias");let l=t[0].dims.length-2;if(r.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(r.strides.length!==l)throw new Error(`strides should be ${l}D`);if(r.pads.length!==2*l)throw new Error(`pads should be ${2*l}D`);if(r.outputPadding.length!==l)throw new Error(`output_padding should be ${l}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if(t[0].type!=="float32"||t[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(t.length===3&&t[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseConvAttributes=c.conv=c.calculateOutputShape=void 0;let m=y(4910),f=y(7273),h=y(7825),p=y(7708),u=y(3281),s=y(2150),a=y(1625),o=y(8276);c.calculateOutputShape=(l,d,g,b,v)=>{let w=l[0],x=l.slice(2),T=x.length,O=d[0],P=d.slice(2).map((R,j)=>R+(R-1)*(g[j]-1)),I=x.map((R,j)=>R+b[j]+b[j+T]).map((R,j)=>Math.floor((R-P[j]+v[j])/v[j]));return[w,O].concat(...I)},c.conv=(l,d,g)=>(i(d,g),n(l,d,g));let n=(l,d,g)=>{let b=r(g,d),v=l.session.pack,w=b.kernelShape[0]===1&&b.kernelShape[1]===1;return b.group>1?[l.run((0,h.createUnpackedGroupedConvProgramInfoLoader)(l,d,b),d)]:w&&v?[e(l,d,b)]:v&&d[0].dims.length===4&&d[0].dims[0]===1&&!w?[(0,p.conv2DPacked)(l,d,b)]:[t(l,d,b)]},e=(l,d,g)=>{let b=d[0].dims,v=d[1].dims,w=(0,c.calculateOutputShape)(b,v,g.dilations,g.pads,g.strides),x=l.reshapeUnpacked(d[0],[b[1],b[2]*b[3]]),T=l.reshapeUnpacked(d[1],[v[0],v[1]]),O=d.length>2?[T,x,d[2]]:[T,x],P=l.run((0,o.createMatmulProgramInfoLoader)(O,g),O);return l.reshapeUnpacked(P,w)},t=(l,d,g)=>{let b=d[0].dims,v=d[1].dims,w=(0,c.calculateOutputShape)(b,v,g.dilations,g.pads,g.strides),x=l.run((0,a.createIm2ColProgramInfoLoader)(l,d[0],d[1],w,g),[d[0]]),T=d.length===3?[x,d[1],d[2]]:[x,d[1]];return l.run((0,u.createDotProductProgramInfoLoader)(l,d,w,g),T)},r=(l,d)=>{let g=l.kernelShape.slice();if(l.kernelShape.length===0)for(let w=2;w<d[1].dims.length;++w)g.push(d[1].dims[w]);let b=l.pads.slice();f.PoolConvUtil.adjustPadsBasedOnAutoPad(d[0].dims,l.strides,l.dilations,g,b,l.autoPad);let v=Object.assign({},l);return Object.assign(v,{kernelShape:g,pads:b,cacheKey:l.cacheKey}),v};c.parseConvAttributes=l=>{let d=l.attributes,g=(0,s.parseInternalActivationAttributes)(d),b=d.getString("auto_pad","NOTSET"),v=d.getInts("dilations",[1,1]),w=d.getInt("group",1),x=d.getInts("kernel_shape",[]),T=d.getInts("pads",[0,0,0,0]),O=d.getInts("strides",[1,1]);return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:b,dilations:v,group:w,kernelShape:x,pads:T,strides:O},g))};let i=(l,d)=>{if(!l||l.length!==2&&l.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(l[0].dims.length!==4||l[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(l[0].dims[1]!==l[1].dims[1]*d.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(l.length===3&&(l[2].dims.length!==1||l[1].dims[0]!==l[2].dims[0]))throw new Error("invalid bias");let g=l[0].dims.length-2;if(d.dilations.length!==g)throw new Error(`dilations should be ${g}D`);if(d.strides.length!==g)throw new Error(`strides should be ${g}D`);if(d.pads.length!==2*g)throw new Error(`pads should be ${2*g}D`);if(d.kernelShape.length!==0&&d.kernelShape.length!==l[1].dims.length-2)throw new Error("invalid kernel shape");if(l[0].type!=="float32"||l[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(l.length===3&&l[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseDepthToSpaceAttributes=c.depthToSpace=void 0;let m=y(5707);c.depthToSpace=(h,p,u)=>{f(p);let s=u.blocksize,a=s*s,o=u.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],n=u.mode==="DCR"?[p[0].dims[0],s,s,p[0].dims[1]/a,p[0].dims[2],p[0].dims[3]]:[p[0].dims[0],p[0].dims[1]/a,s,s,p[0].dims[2],p[0].dims[3]],e=h.reshapeUnpacked(p[0],n),t={perm:o,cacheKey:`${o}`},[r]=(0,m.transpose)(h,[e],t),i=[p[0].dims[0],p[0].dims[1]/a,p[0].dims[2]*s,p[0].dims[3]*s];return[h.reshapeUnpacked(r,i)]},c.parseDepthToSpaceAttributes=h=>{let p=h.attributes.getInt("blocksize");if(p<1)throw new Error(`blocksize must be >= 1, but got : ${p} for DepthToSpace`);let u=h.attributes.getString("mode","DCR");if(u!=="DCR"&&u!=="CRD")throw new Error(`unrecognized mode: ${u} for DepthToSpace`);return{mode:u,blocksize:p}};let f=h=>{if(h.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${h.length}`);if(h[0].type==="string"||h[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createDotProductProgramInfoLoader=void 0;let m=y(7273),f=y(6757),h=y(5639),p=y(2150),u=y(1625);c.createDotProductProgramInfoLoader=(s,a,o,n)=>{let e=((t,r)=>({name:"ConvDotProduct",inputNames:t?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:t?[h.TextureType.unpacked,h.TextureType.packedLastDimension,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.packedLastDimension],cacheKey:r.activationCacheKey}))(a.length>2,n);return Object.assign(Object.assign({},e),{get:()=>((t,r,i,l,d)=>{let g=i[0].dims,b=i[1].dims,v=[b[0],Math.ceil(g[1]*b[2]*b[3]/4)],w=(0,u.calculateIm2ColDims)(g,b,l),[x,T]=t.calculateTextureWidthAndHeight(v,h.TextureType.packedLastDimension),O=m.ShapeUtil.computeStrides(w),[P,I]=t.calculateTextureWidthAndHeight(w,h.TextureType.packedLastDimension),R=l.length,j=i.length<3?"0.0":"_B(b)",A=Math.ceil(g[1]*b[2]*b[3]/4),{activationFunction:C,applyActivation:_}=(0,p.getActivationSnippet)(d),S=(0,f.getGlsl)(t.session.backend.glContext.version),E=`
${C}
float process(int indices[${R}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${O[0]} + im2col[1] * ${O[1]} + im2col[2] * ${O[2]};
  int kernelOffset = indices[1] * ${v[1]};
  float value = ${j};
  for (int i = 0; i < ${A}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${P}, ${I});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${x}, ${T});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${_}
  return value;
}`;return Object.assign(Object.assign({},r),{output:{dims:l,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:E})})(s,e,a,o,n)})}},4125:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseFlattenAttributes=c.flatten=void 0;let m=y(7273);c.flatten=(h,p,u)=>{f(p,u);let s=m.ShapeUtil.flattenShape(p[0].dims,u);return[h.reshapeUnpacked(p[0],s)]},c.parseFlattenAttributes=h=>h.attributes.getInt("axis",1);let f=(h,p)=>{if(!h||h.length!==1)throw new Error("Flatten requires 1 input.");let u=h[0].dims.length;if(u===0)throw new Error("scalar tensor is not supported.");if(p<-u||p>u)throw new Error("Invalid axis");if(h[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseInternalActivationAttributes=c.getActivationSnippet=void 0;let m=y(7273),f=y(9087);c.getActivationSnippet=function(h){let p;switch(h.activation){case"Relu":p=(0,f.glslRelu)();break;case"Sigmoid":p=(0,f.glslSigmoid)();break;case"Clip":p=(0,f.glslClip)(h.clipMin,h.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let u=p.name;return{activationFunction:p.body,applyActivation:`value = ${u}_(value);`}},c.parseInternalActivationAttributes=h=>{let p=h.getString("activation","");if(p==="Clip"){let[u,s]=h.getFloats("activation_params",[m.MIN_CLIP,m.MAX_CLIP]);return{activation:p,clipMax:s,clipMin:u,activationCacheKey:`${p}:${u},${s}`}}return{activation:p,activationCacheKey:p}}},6149:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseGatherAttributes=c.gather=void 0;let m=y(4910),f=y(6145),h=y(7273),p=y(5639);c.gather=(o,n,e)=>(a(n,e.axis),[o.run(s(o,n,e),n)]),c.parseGatherAttributes=o=>(0,m.createAttributeWithCacheKey)({axis:o.attributes.getInt("axis",0)});let u={name:"Gather",inputNames:["A","B"],inputTypes:[p.TextureType.unpacked,p.TextureType.unpacked]},s=(o,n,e)=>{let t=Object.assign(Object.assign({},u),{cacheHint:e.cacheKey});return Object.assign(Object.assign({},t),{get:()=>((r,i,l,d)=>{let g=l[0].dims.slice(),b=l[1].dims.slice(),v=new Array(g.length+b.length-1);d=h.ShapeUtil.normalizeAxis(d,g.length);let w=[];for(let T=0;T<v.length;T++)T<d?(v[T]=g[T],w.push(`inputIdx[${T}] = outputIdx[${T}];`)):T<d+b.length?(v[T]=b[T-d],w.push(`indexDataIdx[${T-d}] = outputIdx[${T}];`)):(v[T]=g[T-b.length+1],w.push(`inputIdx[${T-b.length+1}] = outputIdx[${T}];`));let x=`
      float process(int outputIdx[${v.length||1}]) {
        int inputIdx[${g.length}];
        int indexDataIdx[${b.length||1}];
        indexDataIdx[0] = 0;
        ${w.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${d}] = idx < 0 ? idx + ${g[d]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},i),{output:{dims:v,type:l[0].type,textureType:p.TextureType.unpacked},shaderSource:x})})(0,t,n,e.axis)})},a=(o,n)=>{if(!o||o.length!==2)throw new Error("Gather requires 2 inputs.");let e=o[0].dims.length;if(e<1)throw new Error("Invalid input shape.");if(n<-e||n>e-1)throw new Error("Invalid axis.");if(f.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invaid input type.");if(o[1].type!=="int32"&&o[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseGemmAttributesV11=c.parseGemmAttributesV7=c.gemm=void 0;let m=y(4910),f=y(7273),h=y(5639);c.gemm=(o,n,e)=>(a(n,e),[o.run(u(n,e),n)]);let p=(o,n)=>{let e=o.attributes.getInt("transA",0)!==0,t=o.attributes.getInt("transB",0)!==0,r=o.attributes.getFloat("alpha",1),i=o.attributes.getFloat("beta",1);return(0,m.createAttributeWithCacheKey)({transA:e,transB:t,alpha:r,beta:i,isOptionalC:n})};c.parseGemmAttributesV7=o=>p(o,!1),c.parseGemmAttributesV11=o=>p(o,!0);let u=(o,n)=>{let e={name:"Gemm",inputNames:o.length===3?["A","B","C"]:["A","B"],inputTypes:o.length===3?[h.TextureType.unpacked,h.TextureType.unpacked,h.TextureType.unpacked]:[h.TextureType.unpacked,h.TextureType.unpacked],key:n.cacheKey};return Object.assign(Object.assign({},e),{get:()=>s(e,o,n)})},s=(o,n,e)=>{let t=n[0].dims.slice(),r=n[1].dims.slice(),[i,l]=f.GemmUtil.getShapeOfGemmResult(t,e.transA,r,e.transB,n.length===3?n[2].dims:void 0),d=[i,l];if(!d)throw new Error("Can't use gemm on the given tensors");let g=t[t.length-1],b="";e.transA&&(g=t[0]),e.transA&&e.transB?b="value += _A_T(a) * _B_T(b);":e.transA&&!e.transB?b="value += _A_T(a) * _B(b);":!e.transA&&e.transB?b="value += _A(a) * _B_T(b);":e.transA||e.transB||(b="value += _A(a) * _B(b);");let v=d.length,w=`
      float process(int indices[${v}]) {
          int a[${v}];
          int b[${v}];
          ${n.length===3?`int c[${n[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${n.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${g}; ++k) {
              a[${v-1}] = k;
              b[${v-2}] = k;
              ${b}
          }

          value = value * alpha;
          ${n.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},o),{output:{dims:d,type:n[0].type,textureType:h.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:e.alpha},{name:"beta",type:"float",data:e.beta}],shaderSource:w})},a=(o,n)=>{if(!o)throw new Error("Input is missing");if(n.isOptionalC&&(o.length<2||o.length>3))throw new Error("Invaid input shape.");if(!n.isOptionalC&&o.length!==3)throw new Error("Gemm requires 3 inputs");if(o.length===3&&o[2].dims.length!==1&&o[2].dims.length!==2)throw new Error("Invalid input shape of C");if(o[0].type!=="float32"&&o[0].type!=="float64"||o[1].type!=="float32"&&o[1].type!=="float64"||o.length===3&&o[2].type!=="float32"&&o[2].type!=="float64")throw new Error("Invalid input type.");if(o[0].type!==o[1].type||o.length===3&&o[0].type!==o[2].type)throw new Error("Input types are mismatched")}},5950:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackedIm2ColProgramInfoLoader=void 0;let m=y(6757),f=y(5639),h=y(5614);c.createPackedIm2ColProgramInfoLoader=(p,u,s,a,o)=>{let n=(e=o.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[f.TextureType.packed],cacheHint:e});var e;return Object.assign(Object.assign({},n),{get:()=>((t,r,i,l,d,g)=>{let b=i.dims,v=l.dims,w=d.length,x=[v[1]*v[2]*v[3],d[2]*d[3]],T=v[2]*v[3],O=(0,h.unpackFromChannel)(),P=(0,m.getGlsl)(t.session.backend.glContext.version),I="";for(let j=0;j<=1;j++)for(let A=0;A<=1;A++)I+=`
            blockIndex = rc.x + ${A};
            pos = rc.y + ${j};

            if(blockIndex < ${x[1]} && pos < ${x[0]}) {
              offsetY = int(blockIndex / (${d[w-1]})) * ${g.strides[0]} -
                ${g.pads[0]};
              d0 = offsetY + ${g.dilations[0]} * (imod(pos, ${T}) / ${v[2]});

              if(d0 < ${b[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${d[w-1]}) * ${g.strides[1]} -
                  ${g.pads[1]};
                d1 = offsetX + ${g.dilations[1]} * imod(imod(pos, ${T}), ${v[2]});

                if(d1 < ${b[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${T}.);
                    innerDims = vec2(d0, d1);
                    result[${2*j+A}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let R=`
      ${O}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${I}
          ${P.output} = result;
      }
            `;return Object.assign(Object.assign({},r),{output:{dims:x,type:i.type,textureType:f.TextureType.packed},shaderSource:R,hasMain:!0})})(p,n,u,s,a,o)})}},1625:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.calculateIm2ColDims=c.createIm2ColProgramInfoLoader=void 0;let m=y(5639);c.createIm2ColProgramInfoLoader=(f,h,p,u,s)=>{let a=(o=s.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[m.TextureType.unpacked],cacheHint:o});var o;return Object.assign(Object.assign({},a),{get:()=>((n,e,t,r,i,l)=>{let d=t.dims,g=r.dims,b=i.length,v=(0,c.calculateIm2ColDims)(d,g,i,4),w=`
        const int XC = ${d[1]};
        const int XH = ${d[2]};
        const int XW = ${d[3]};
        const int KH = ${l.kernelShape[0]};
        const int KW = ${l.kernelShape[1]};
        const int dilationH = ${l.dilations[0]};
        const int dilationW = ${l.dilations[1]};
        const int strideH = ${l.strides[0]};
        const int strideW = ${l.strides[1]};
        const int padH = ${l.pads[0]};
        const int padW = ${l.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${b}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${d.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},e),{output:{dims:v,type:t.type,textureType:m.TextureType.packedLastDimension},shaderSource:w})})(0,a,h,p,u,s)})},c.calculateIm2ColDims=(f,h,p,u=4)=>[p[0],p[2],p[3],Math.ceil(f[1]*h[2]*h[3]/u)]},6981:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseImageScalerAttributes=c.imageScaler=void 0;let m=y(4910),f=y(5639);c.imageScaler=(a,o,n)=>(s(o),[a.run(p(a,o,n),o)]),c.parseImageScalerAttributes=a=>{let o=a.attributes.getFloat("scale"),n=a.attributes.getFloats("bias");return(0,m.createAttributeWithCacheKey)({scale:o,bias:n})};let h={name:"ImageScaler",inputNames:["X"],inputTypes:[f.TextureType.unpacked]},p=(a,o,n)=>{let e=Object.assign(Object.assign({},h),{cacheHint:n.cacheKey});return Object.assign(Object.assign({},e),{get:()=>((t,r,i,l)=>{let d=i[0].dims.slice(),g=d.length,b=`
      ${u(l.bias.length)}
      float process(int indices[${g}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},r),{output:{dims:d,type:i[0].type,textureType:f.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:l.bias.length,data:l.bias},{name:"scale",type:"float",data:l.scale}],shaderSource:b})})(0,e,o,n)})},u=a=>{let o=[`float getBias(float bias[${a}], int channel) {`];for(let n=0;n<a;++n)n===0?o.push(`	if (channel == ${n}) { return bias[${n}]; }`):n===a-1?o.push(`	else { return bias[${n}]; }`):o.push(`	else if (channel == ${n}) { return bias[${n}]; }`);return o.push("	}"),o.join(`
`)},s=a=>{if(!a||a.length!==1)throw new Error("ImageScaler requires 1 input.");if(a[0].dims.length!==4)throw new Error("Invalid input shape.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseInstanceNormalizationAttributes=c.instanceNormalization=void 0;let m=y(6757),f=y(5639);c.instanceNormalization=(o,n,e)=>{a(n);let t=o.run(p(n[0]),n);return[o.run(s(o,n[0],e,t.dims),[n[0],t,n[1],n[2]])]},c.parseInstanceNormalizationAttributes=o=>o.attributes.getFloat("epsilon",1e-5);let h={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[f.TextureType.unpacked]},p=o=>Object.assign(Object.assign({},h),{get:()=>((n,e)=>{let t=e.dims.slice(),r=t[1],i=t[2]*t[3],l=[t[0],r],d=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${t[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${t[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i});
        temp = 0.0;
        for(int a2=0; a2<${t[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${t[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i});

        return v;
      }`;return Object.assign(Object.assign({},n),{output:{dims:l,type:e.type,textureType:f.TextureType.packedLastDimension},shaderSource:d})})(h,o)}),u={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[f.TextureType.unpacked,f.TextureType.packedLastDimension,f.TextureType.unpacked,f.TextureType.unpacked]},s=(o,n,e,t)=>{let r=Object.assign(Object.assign({},u),{cacheHint:`${e}`});return Object.assign(Object.assign({},r),{get:()=>((i,l,d,g,b)=>{let v=(0,m.getGlsl)(i.session.backend.glContext.version),[w,x]=i.calculateTextureWidthAndHeight(b,f.TextureType.packedLastDimension),[T,O]=[w/4,x],P=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${T}, ${O});
        return ${v.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},l),{output:{dims:d.dims,type:d.type,textureType:f.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:g}],shaderSource:P})})(o,r,n,e,t)})},a=o=>{if(!o||o.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let n=o[0],e=o[1],t=o[2];if(n.dims.length<3||e.dims.length!==1||t.dims.length!==1)throw new Error("Invalid input shape.");if(e.dims[0]!==n.dims[1]||t.dims[0]!==n.dims[1])throw new Error("Input shapes are mismatched.");if(n.type!=="float32"&&n.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||t.type!=="float32"&&t.type!=="float64")throw new Error("Invalid input type.");if(o[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createLrnProgramInfoLoader=c.parseLrnAttributes=c.lrn=void 0;let m=y(4910),f=y(5639);c.lrn=(s,a,o)=>(u(a),[s.run(p(a,o),a)]),c.parseLrnAttributes=s=>{let a=s.attributes.getFloat("alpha",1e-4),o=s.attributes.getFloat("beta",.75),n=s.attributes.getFloat("bias",1),e=s.attributes.getInt("size");return(0,m.createAttributeWithCacheKey)({alpha:a,beta:o,bias:n,size:e})};let h={name:"LRN",inputNames:["X"],inputTypes:[f.TextureType.unpacked]};function p(s,a){return Object.assign(Object.assign({},h),{cacheHint:a.cacheKey,get:()=>function(o,n){let e=o[0].dims[1],t=o[0].dims.length,r=-Math.floor((n.size-1)/2),i=Math.ceil((n.size-1)/2),l=`float(${n.alpha}) / float(${n.size})`,d=`
    float process(int indices[${t}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${r}; i <= ${i}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${e}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${n.bias}) + ${l} * square_sum, float(${n.beta}));
    }`;return Object.assign(Object.assign({},h),{cacheHint:n.cacheKey,output:{dims:o[0].dims,type:o[0].type,textureType:f.TextureType.unpacked},shaderSource:d})}(s,a)})}c.createLrnProgramInfoLoader=p;let u=s=>{if(!s||s.length!==1)throw new Error("LRN requires 1 input.");if(s[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(s[0].type!=="float32")throw new Error("input should be float type")}},5632:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackedMatmulProgramInfoLoader=void 0;let m=y(7273),f=y(6757),h=y(5639),p=y(432),u=y(2150),s=y(8276);c.createPackedMatmulProgramInfoLoader=(a,o,n)=>{let e=(t=o.length>2,r=n.activationCacheKey,{name:"MatMul (packed)",inputNames:t?["A","B","Bias"]:["A","B"],inputTypes:t?[h.TextureType.packed,h.TextureType.packed,h.TextureType.packed]:[h.TextureType.packed,h.TextureType.packed],cacheHint:r});var t,r;return Object.assign(Object.assign({},e),{get:()=>((i,l,d,g)=>{let b=d.length>2,v=b?"value += getBiasForMatmul();":"",w=d[0].dims,x=d[1].dims,T=m.BroadcastUtil.calcShape(w,x,!0),O=!m.ShapeUtil.areEqual(d[0].dims,d[1].dims);if(!T)throw new Error("Can't use matmul on the given tensors");let P=w[w.length-1],I=Math.ceil(P/2),R=w.length,j=x.length,A=(0,f.getGlsl)(i.session.backend.glContext.version),C=(0,p.getCoordsDataType)(T.length),_=T.length,S=(0,p.getGlChannels)(),{activationFunction:E,applyActivation:z}=(0,u.getActivationSnippet)(g),L=b?`${(0,s.getBiasForMatmul)(C,S,d[2].dims,T,!0)}`:"",Y=O?`${function(se,pe,ge,ve){let Me=[],De=[],je=ge[0].dims,_e=ge[1].dims,Be=je.length,Pe=_e.length,Re=ve.length,Ue=Re-Be,He=Re-Pe;Me=je.map((tt,Ye)=>`coords.${pe[Ye+Ue]}`),Me[Be-1]="i*2",Me.join(", "),De=_e.map((tt,Ye)=>`coords.${pe[Ye+He]}`),De[Pe-2]="i*2",De.join(", ");let Ze=m.BroadcastUtil.getBroadcastDims(je,ve),et=m.BroadcastUtil.getBroadcastDims(_e,ve),ct=Ze.map(tt=>`coords.${pe[tt+Ue]} = 0;`).join(`
`),qe=et.map(tt=>`coords.${pe[tt+He]} = 0;`).join(`
`),Qe=`int lastDim = coords.${pe[Re-1]};
  coords.${pe[Re-1]} = coords.${pe[Re-2]};
  coords.${pe[Re-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${se} coords = getOutputCoords();
  ${Qe}
  ${ct}
  vec4 outputValue = getA(${Me});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${se} coords = getOutputCoords();
  ${Qe}
  ${qe}
  vec4 outputValue = getB(${De});
  return outputValue;
}`}(C,S,d,T)}`:"",X=O?"getAAtOutCoordsMatmul(i)":`getA(${function(se,pe){let ge="";for(let ve=0;ve<pe-2;ve++)ge+=`rc.${se[ve]}, `;return ge+=`rc.${se[pe-2]}, i*2`,ge}(S,R)})`,te=O?"getBAtOutCoordsMatmul(i)":`getB(${function(se,pe){let ge="";for(let ve=0;ve<pe-2;ve++)ge+=`rc.${se[ve]}, `;return ge+=`i*2, rc.${se[pe-1]}`,ge}(S,j)})`,ae=`
            ${Y}
            ${L}
            ${E}
            void main() {
              ${O?"":`${C} rc =
          getOutputCoords(); int lastDim = rc.${S[_-1]}; rc.${S[_-1]} =
          rc.${S[_-2]}; rc.${S[_-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${I}; i++) {
                vec4 a = ${X};
                vec4 b = ${te};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${v}
              ${z}
              ${A.output} = value;
            }`;return Object.assign(Object.assign({},l),{output:{dims:T,type:d[0].type,textureType:h.TextureType.packed},shaderSource:ae,hasMain:!0})})(a,e,o,n)})}},8276:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getBiasForMatmul=c.createMatmulProgramInfoLoader=c.parseMatMulAttributes=c.matMul=void 0;let m=y(7273),f=y(5639),h=y(432),p=y(2150),u=y(5632);c.matMul=(e,t,r)=>(o(t),e.session.pack?[e.run((0,u.createPackedMatmulProgramInfoLoader)(e,t,r),t)]:[e.run(a(t,r),t)]),c.parseMatMulAttributes=e=>(0,p.parseInternalActivationAttributes)(e.attributes);let s=(e,t)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[f.TextureType.unpacked,f.TextureType.unpacked,f.TextureType.unpacked]:[f.TextureType.unpacked,f.TextureType.unpacked],cacheHint:t});function a(e,t){let r=s(e.length>2,t.activationCacheKey);return Object.assign(Object.assign({},r),{get:()=>function(i,l,d){let g=l[0].dims,b=l[1].dims,v=m.BroadcastUtil.calcShape(g,b,!0);if(!v)throw new Error("Can't use matmul on the given tensors");let w=(0,h.getCoordsDataType)(v.length),x=(0,h.getGlChannels)(),{activationFunction:T,applyActivation:O}=(0,p.getActivationSnippet)(d),P=l.length>2,I=P?"value += getBiasForMatmul();":"",R=P?`${n(w,x,l[2].dims,v,!1)}`:"",j=v.length,A=g.length,C=b.length,_=`
    ${T}
    ${R}
    float process(int indices[${j}]) {
        int a[${A}];
        int b[${C}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${g[g.length-1]}; ++k) {
            a[${A-1}] = k;
            b[${C-2}] = k;
            value += _A(a) * _B(b);
        }
        ${I}
        ${O}
        return value;
    }`;return Object.assign(Object.assign({},i),{output:{dims:v,type:l[0].type,textureType:f.TextureType.unpacked},shaderSource:_})}(r,e,t)})}c.createMatmulProgramInfoLoader=a;let o=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function n(e,t,r,i,l){let d="",g=r.length,b=i.length,v=b-g;d=b<2&&g>0?"coords":r.map((T,O)=>`coords.${t[O+v]}`).join(", ");let w=m.BroadcastUtil.getBroadcastDims(r,i).map(T=>`coords.${t[T+v]} = 0;`).join(`
`),x="vec4(outputValue.xx, outputValue.yy)";return m.ShapeUtil.size(r)===1&&(x="vec4(outputValue.x)"),l?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${w}
  vec4 outputValue = getBias(${d});
  return ${x};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${w}
  return getBias(coords.x);
}`}c.getBiasForMatmul=n},9:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createPackProgramInfoLoader=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614),u={name:"pack",inputNames:["A"],inputTypes:[f.TextureType.unpackedReversed]};c.createPackProgramInfoLoader=(s,a)=>Object.assign(Object.assign({},u),{get:()=>((o,n)=>{let e=(0,m.getGlsl)(o.session.backend.glContext.version),t=n.dims,r=t.length,i=n.dims.length,l=(0,h.getCoordsDataType)(i),d=(0,p.getChannels)("rc",i),g=(b=i,v=d,w=t[t.length-2],x=t[t.length-1],b===0||b===1?"":`
    int r = ${v[b-2]};
    int c = ${v[b-1]};
    int rp1 = ${v[b-2]} + 1;
    int cp1 = ${v[b-1]} + 1;
    bool rEdge = rp1 >= ${x};
    bool cEdge = cp1 >= ${w};
    `);var b,v,w,x;let T;T=r===0?[1,1]:r===1?[t[0],1]:[t[i-1],t[i-2]];let O=function(R,j,A){if(R===0)return"false";if(R===1)return`rc > ${j[0]}`;let C="";for(let _=R-2;_<R;_++)C+=`${A[_]} >= ${j[_-R+2]}`,_<R-1&&(C+="||");return C}(i,T,d),P=function(R,j){let A=R.length;if(A===0)return"getA(), 0, 0, 0";if(A===1)return`getA(rc),
            rc + 1 >= ${R[0]} ? 0. : getA(rc + 1),
            0, 0`;let C="";if(A>2)for(let _=0;_<A-2;++_)C+=`${j[_]},`;return`getA(${C}r, c),
          rEdge ? 0. : getA(${C}rp1, c),
          cEdge ? 0. : getA(${C}r, cp1),
          rEdge || cEdge ? 0. : getA(${C}rp1, cp1)`}(t,d),I=`
        void main() {
          ${l} rc = getOutputCoords();

          if(${O}) {
            ${e.output} = vec4(0);
          } else {
            ${g}

            ${e.output} = vec4(${P});
          }
        }
      `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:n.dims,type:n.type,textureType:f.TextureType.packed},shaderSource:I})})(s,a)})},5614:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.unpackFromChannel=c.getChannels=c.getVecChannels=void 0;let m=y(432);function f(h,p){return(0,m.getGlChannels)(p).map(u=>`${h}.${u}`)}c.getVecChannels=f,c.getChannels=function(h,p){return p===1?[h]:f(h,p)},c.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parsePadAttributesV11=c.padV11=c.parsePadAttributesV2=c.padV2=void 0;let m=y(4910),f=y(7273),h=y(6757),p=y(5639),u={name:"Pad",inputNames:["A"],inputTypes:[p.TextureType.unpacked]};c.padV2=(l,d,g)=>(o(d),[l.run(Object.assign(Object.assign({},u),{cacheHint:g.cacheKey,get:()=>a(l,d[0],g)}),d)]),c.parsePadAttributesV2=l=>{let d=l.attributes.getString("mode","constant"),g=l.attributes.getFloat("value",0),b=l.attributes.getInts("pads");return(0,m.createAttributeWithCacheKey)({mode:d,value:g,pads:b})},c.padV11=(l,d,g)=>{n(d);let b=s(l,d,g);return(0,c.padV2)(l,[d[0]],b)},c.parsePadAttributesV11=l=>l.attributes.getString("mode","constant");let s=(l,d,g)=>{if(!l.session.isInitializer(d[1].dataId)||d.length>=3&&!l.session.isInitializer(d[2].dataId))throw new Error("dynamic pad attributes are not allowed");let b=Array.from(d[1].integerData),v=d.length>=3?d[2].floatData[0]:0;return(0,m.createAttributeWithCacheKey)({mode:g,pads:b,value:v})},a=(l,d,g)=>{let b=f.ShapeUtil.padShape(d.dims.slice(),g.pads),v=b.length,w=`
      ${e(l,d,g)}
      float process(int[${v}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[p.TextureType.unpacked],output:{dims:b,type:d.type,textureType:p.TextureType.unpacked},shaderSource:w}},o=l=>{if(!l||l.length!==1)throw new Error("Pad requires 1 input");if(l[0].type!=="float32"&&l[0].type!=="float64")throw new Error("Invalid input type.")},n=l=>{if(!l||l.length!==2&&l.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(l[1].type!=="int32")throw new Error("Invalid input type.");if(l.length>=3&&l[2].type==="string")throw new Error("Invalid input type.")},e=(l,d,g)=>{let b=(0,h.getGlsl)(l.session.backend.glContext.version),[v,w]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),x=f.ShapeUtil.computeStrides(d.dims);switch(g.mode){case"constant":return t(b,d.dims,x,v,w,g.pads,g.value);case"reflect":return r(b,d.dims,x,v,w,g.pads);case"edge":return i(b,d.dims,x,v,w,g.pads);default:throw new Error("Invalid mode")}},t=(l,d,g,b,v,w,x)=>{let T=d.length,O="";for(let P=T-1;P>=0;--P)O+=`
        k = m[${P}] - ${w[P]};
        if (k < 0)  return constant;
        if (k >= ${d[P]}) return constant;
        offset += k * ${g[P]};
        `;return`
      float padA(int m[${T}]) {
        const float constant = float(${x});
        int offset = 0;
        int k = 0;
        ${O}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${l.texture2D}(A, coords));
        return value;
      }
      `},r=(l,d,g,b,v,w)=>{let x=d.length,T="";for(let O=x-1;O>=0;--O)T+=`
        k = m[${O}] - ${w[O]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(d[O]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${d[O]}) { k = _2n_1 - k; }
        }
        offset += k * ${g[O]};
        `;return`
      float padA(int m[${x}]) {
        int offset = 0;
        int k = 0;
        ${T}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${l.texture2D}(A, coords));
        return value;
      }
      `},i=(l,d,g,b,v,w)=>{let x=d.length,T="";for(let O=x-1;O>=0;--O)T+=`
        k = m[${O}] - ${w[O]};
        if (k < 0)  k = 0;
        if (k >= ${d[O]}) k = ${d[O]-1};
        offset += k * ${g[O]};
      `;return`
      float padA(int m[${x}]) {
        int offset = 0;
        int k = 0;
        ${T}
        vec2 coords = offsetToCoords(offset, ${b}, ${v});
        float value = getColorAsFloat(${l.texture2D}(A, coords));
        return value;
      }
      `}},2834:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.globalMaxPool=c.parseMaxPoolAttributes=c.maxPool=c.parseGlobalAveragePoolAttributes=c.globalAveragePool=c.parseAveragePoolAttributes=c.averagePool=void 0;let m=y(4910),f=y(7273),h=y(5639);c.averagePool=(i,l,d)=>{n(l);let g={name:"AveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:d.cacheKey};return[i.run(Object.assign(Object.assign({},g),{get:()=>p(l,g,!1,d)}),l)]},c.parseAveragePoolAttributes=i=>{let l=i.attributes.getString("auto_pad","NOTSET"),d=i.attributes.getInt("ceil_mode",0),g=i.attributes.getInt("count_include_pad",0)!==0,b=i.attributes.getInts("kernel_shape"),v=i.attributes.getInts("strides",[]),w=i.attributes.getInts("pads",[]);if(d!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,m.createAttributeWithCacheKey)({autoPad:l,ceilMode:d,countIncludePad:g,kernelShape:b,strides:v,pads:w})};let p=(i,l,d,g)=>{let[b,v]=s(i,g,d),w=f.ShapeUtil.size(b.kernelShape),x="";b.countIncludePad?x+=`value /= float(${w});`:x+=`value /= float(${w} - pad);`;let T=`
        ${e(i[0].dims,b,"value += _X(x);",x,"0.0")}
      `;return Object.assign(Object.assign({},l),{output:{dims:v,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:T})};c.globalAveragePool=(i,l,d)=>{n(l);let g={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:`${d.countIncludePad}`};return[i.run(Object.assign(Object.assign({},g),{get:()=>p(l,g,!0,d)}),l)]},c.parseGlobalAveragePoolAttributes=i=>{let l=i.attributes.getInt("count_include_pad",0)!==0;return(0,m.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:l,kernelShape:[],strides:[],pads:[]})},c.maxPool=(i,l,d)=>{n(l);let g={name:"MaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked],cacheHint:d.cacheKey};return[i.run(Object.assign(Object.assign({},g),{get:()=>u(l,g,!1,d)}),l)]},c.parseMaxPoolAttributes=i=>{let l=i.attributes.getString("auto_pad","NOTSET"),d=i.attributes.getInt("ceil_mode",0),g=i.attributes.getInts("kernel_shape"),b=i.attributes.getInts("strides",[]),v=i.attributes.getInts("pads",[]),w=i.attributes.getInt("storage_order",0),x=i.attributes.getInts("dilations",[]);if(w!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,m.createAttributeWithCacheKey)({autoPad:l,ceilMode:d,countIncludePad:!1,kernelShape:g,strides:b,pads:v,storageOrder:w,dilations:x})};let u=(i,l,d,g)=>{let[b,v]=s(i,g,d),w=`
      ${e(i[0].dims,b,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},l),{output:{dims:v,type:i[0].type,textureType:h.TextureType.unpacked},shaderSource:w})},s=(i,l,d)=>{let g=i[0].dims.slice(),b=Object.hasOwnProperty.call(l,"dilations"),v=l.kernelShape.slice(),w=l.strides.slice(),x=b?l.dilations.slice():[],T=l.pads.slice();f.PoolConvUtil.adjustPoolAttributes(d,g,v,w,x,T);let O=f.PoolConvUtil.computePoolOutputShape(d,g,w,x,v,T,l.autoPad),P=Object.assign({},l);return b?Object.assign(P,{kernelShape:v,strides:w,pads:T,dilations:x,cacheKey:l.cacheKey}):Object.assign(P,{kernelShape:v,strides:w,pads:T,cacheKey:l.cacheKey}),[P,O]},a={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},o={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};c.globalMaxPool=(i,l)=>(n(l),[i.run(Object.assign(Object.assign({},o),{get:()=>u(l,o,!0,a)}),l)]);let n=i=>{if(!i||i.length!==1)throw new Error("Pool ops requires 1 input.");if(i[0].type!=="float32"&&i[0].type!=="float64")throw new Error("Invalid input type.")},e=(i,l,d,g,b)=>{let v=i.length;if(l.kernelShape.length<=2){let w=l.kernelShape[l.kernelShape.length-1],x=l.strides[l.strides.length-1],T=l.pads[l.pads.length/2-1],O=l.pads[l.pads.length-1],P=i[v-1],I="",R="",j="";if(I=T+O!==0?`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${x} - ${T} + i;
            if (x[${v} - 1] < 0 || x[${v} - 1] >= ${P}) {
              pad++;
              continue;
            }
            ${d}
          }`:`
          for (int i = 0; i < ${w}; i++) {
            x[${v} - 1] = indices[${v} - 1] * ${x} - ${T} + i;
            ${d}
          }`,l.kernelShape.length===2){let A=l.kernelShape[l.kernelShape.length-2],C=l.strides[l.strides.length-2],_=l.pads[l.pads.length/2-2],S=l.pads[l.pads.length-2],E=i[v-2];R=_+S!==0?`
            for (int j = 0; j < ${A}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${C} - ${_} + j;
              if (x[${v} - 2] < 0 || x[${v} - 2] >= ${E}) {
                pad+= ${w};
                continue;
              }
          `:`
            for (int j = 0; j < ${A}; j++) {
              x[${v} - 2] = indices[${v} - 2] * ${C} - ${_} + j;
            `,j=`
          }
        `}return`
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);

          float value = ${b};
          int pad = 0;
          ${R}
          ${I}
          ${j}
          ${g}
          return value;
        }
      `}{let w=f.ShapeUtil.size(l.kernelShape),x=f.ShapeUtil.computeStrides(l.kernelShape),T=x.length,O=l.pads.length,P=r(T),I=t(i,"inputDims"),R=t(l.pads,"pads"),j=t(x,"kernelStrides"),A=t(l.strides,"strides"),C="";return C=l.pads.reduce((_,S)=>_+S)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${d}
          }`:`
          }
          ${d}
        `,`
        ${P}
        float process(int indices[${v}]) {
          int x[${v}];
          copyVec(indices, x);
          int offset[${T}];
          int pads[${O}];
          int inputDims[${v}];
          int kernelStrides[${T}];
          int strides[${T}];
          ${R}
          ${I}
          ${A}
          ${j}

          float value = ${b};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${w}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${v} - ${T}; j < ${v}; j++) {
              x[j] = indices[j] * strides[j - ${v} + ${T}]
                + offset[j - ${v} + ${T}] - pads[j - 2];
              ${C}
          }
          ${g}

          return value;
        }
      `}},t=(i,l)=>{let d="";for(let g=0;g<i.length;g++)d+=`
      ${l}[${g}] = ${i[g]};
    `;return d},r=i=>`
  void offsetToIndices(int offset, int[${i}] strides, out int[${i}] indices) {
    if (${i} == 0) {
      return;
    }
    for (int i = 0; i < ${i} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${i} - 1] = offset;
  }`},1010:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.reduceLogSumSquare=c.reduceLogSum=c.reduceProd=c.reduceMin=c.reduceMax=c.reduceMean=c.reduceSum=c.parseReduceAttributes=void 0;let m=y(4910),f=y(6145),h=y(7273),p=y(5639),u=(o,n,e,t,r)=>{a(n);let i={name:t,inputNames:["A"],inputTypes:[p.TextureType.unpacked]};return[o.run(Object.assign(Object.assign({},i),{cacheHint:e.cacheKey,get:()=>s(o,n,e,t,r,i)}),n)]};c.parseReduceAttributes=o=>{let n=o.attributes.getInts("axes",[]),e=o.attributes.getInt("keepdims",1)===1;return(0,m.createAttributeWithCacheKey)({axes:n,keepDims:e})};let s=(o,n,e,t,r,i)=>{let l=[],d=n[0].dims.length||1,g=[],b=h.ShapeUtil.normalizeAxes(e.axes,n[0].dims.length),v=r(n,b),w=v[1];for(let T=0;T<n[0].dims.length;T++)b.indexOf(T)>=0||b.length===0?(e.keepDims&&l.push(1),w=`
          for(int j${T} = 0; j${T} < ${n[0].dims[T]}; j${T}++) {
            inputIdx[${T}] = j${T};
            ${w}
          }`):(g.push(`inputIdx[${T}] = outputIdx[${l.length}];`),l.push(n[0].dims[T]));let x=`
      float process(int outputIdx[${l.length||1}]) {
        float value;                 // final result
        int inputIdx[${d}];      // addressing input data
        ${g.join(`
`)}
        ${v[0]}       // init ops for reduce max/min
        ${w}
        ${v[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},i),{output:{dims:l,type:n[0].type,textureType:p.TextureType.unpacked},shaderSource:x})},a=o=>{if(!o||o.length!==1)throw new Error("Reduce op requires 1 input.");if(f.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invalid input type.")};c.reduceSum=(o,n,e)=>u(o,n,e,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),c.reduceMean=(o,n,e)=>u(o,n,e,"ReduceMean",(t,r)=>{let i=1;for(let l=0;l<t[0].dims.length;l++)(r.indexOf(l)>=0||r.length===0)&&(i*=t[0].dims[l]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${i}.;`]}),c.reduceMax=(o,n,e)=>u(o,n,e,"ReduceMax",(t,r)=>{let i=[];for(let l=0;l<t[0].dims.length;l++)(r.indexOf(l)>=0||r.length===0)&&i.push(`inputIdx[${l}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),c.reduceMin=(o,n,e)=>u(o,n,e,"ReduceMin",(t,r)=>{let i=[];for(let l=0;l<t[0].dims.length;l++)(r.indexOf(l)>=0||r.length===0)&&i.push(`inputIdx[${l}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),c.reduceProd=(o,n,e)=>u(o,n,e,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),c.reduceLogSum=(o,n,e)=>u(o,n,e,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),c.reduceLogSumSquare=(o,n,e)=>u(o,n,e,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.isReshapeCheap=c.processDims3D=c.createPackedReshape3DProgramInfoLoader=void 0;let m=y(7273),f=y(6757),h=y(5639),p=y(5614);c.createPackedReshape3DProgramInfoLoader=(u,s,a)=>{let o=(n=>({name:"Reshape (packed)",inputTypes:[h.TextureType.packed],inputNames:["A"],cacheHint:`${n}`}))(a);return Object.assign(Object.assign({},o),{get:()=>((n,e,t,r)=>{let i=e.dims,l=r,d="";for(let v=0;v<4;v++){let w="";switch(v){case 0:w="outputCoords = rc;";break;case 1:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:w="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:w="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}d+=`
        ${w}
        ${v>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${v}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${v>0?"}":""}
      `}let g=(0,f.getGlsl)(n.session.backend.glContext.version),b=`
      ${function(v){let w=m.ShapeUtil.computeStrides(v),x=["b","r","c"],T="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${w.map((O,P)=>`int ${x[P]} = ${T} / ${O}; ${P===w.length-1?`int ${x[P+1]} = ${T} - ${x[P]} * ${O}`:`index -= ${x[P]} * ${O}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(i)}
      ${function(v){let w=m.ShapeUtil.computeStrides(v);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${w[0]} + coords.z * ${w[1]} + coords.y;
  }
`}(l)}
      ${(0,p.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${l[2]};
        int cols = ${l[1]};

        ${d}
        ${g.output} = result;
      }
    `;return Object.assign(Object.assign({},t),{output:{dims:l,type:e.type,textureType:h.TextureType.packed},shaderSource:b,hasMain:!0})})(u,s,o,a)})},c.processDims3D=function(u){if(u.length===0)return[1,1,1];let s=1;for(let a=0;a<u.length-2;++a)s*=u[a];return[s,u.length>1?u[u.length-2]:1,u[u.length-1]]},c.isReshapeCheap=function(u,s){let a=!1;return a=u.length===0||s.length===0||(u.length<2||s.length<2?u[u.length-1]===s[s.length-1]:u[u.length-1]===s[s.length-1]&&u[u.length-2]===s[s.length-2]),a}},8126:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.reshape=void 0;let m=y(7273);c.reshape=(f,h)=>{let p=m.ShapeUtil.calculateReshapedDims(h[0].dims,h[1].integerData);return f.session.pack?[f.reshapePacked(h[0],p)]:[f.reshapeUnpacked(h[0],p)]}},2801:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseResizeAttributesV11=c.parseResizeAttributesV10=c.resize=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614),u=y(3980),s={name:"Resize",inputNames:["A"],inputTypes:[f.TextureType.packed]};c.resize=(t,r,i)=>((0,u.validateInputs)(r,i),[t.run(Object.assign(Object.assign({},s),{cacheHint:i.cacheKey,get:()=>a(t,r,i)}),r)]),c.parseResizeAttributesV10=t=>(0,u.parseUpsampleAttributes)(t,10),c.parseResizeAttributesV11=t=>(0,u.parseUpsampleAttributes)(t,11);let a=(t,r,i)=>{let l=(0,m.getGlsl)(t.session.backend.glContext.version),[d,g]=o(r,i);if(d.every(C=>C===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},s),{output:{dims:g,type:r[0].type,textureType:f.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${l.texture2D}(X, TexCoords);
                    ${l.output} = v;
                }`});let b=g.length;if(b<2)throw new Error(`output dimension should be at least 2, but got ${b}`);let v=g[b-2],w=g[b-1],x=r[0].dims;if(b!==x.length)throw new Error(`output dimension should match input ${x.length}, but got ${b}`);let T=x[b-2],O=x[b-1],P=d[b-2],I=d[b-1],R="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${w}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${w}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${v}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":R=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${w}.0 - 1.0, ${v}.0 - 1.0, ${w}.0 - 1.0,
                            ${v}.0 - 1.0);
                        vec4 original = vec4(${O}.0 - 1.0, ${T}.0 - 1.0, ${O}.0 - 1.0,
                            ${T}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let j=(0,h.getCoordsDataType)(b),A=`
            const vec2 inputWH = vec2(${T}.0, ${O}.0);
            const vec4 scaleWHWH = vec4(float(${P}), float(${I}), float(${P}), float(${I}));
            ${(0,p.unpackFromChannel)()}
            ${R}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${j} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${v-1};
                bool hasNextCol = rc.z < ${w-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${l.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},s),{output:{dims:g,type:r[0].type,textureType:f.TextureType.packed},hasMain:!0,shaderSource:A})},o=(t,r)=>{let i=t[0].dims,l,d=r.scales;if(d.length===0){let b=t[r.scalesInputIdx];if(b&&b.size!==0){if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");d=n(b,r.mode,r.isResize)}else{let v=t[r.sizesInputIdx];if(!v||v.size===0)throw new Error("Either scales or sizes MUST be provided as input.");l=Array.from(v.integerData),d=e(l,i,r.mode,r.isResize)}}else if(t[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let g=l||i.map((b,v)=>Math.floor(b*d[v]));return[d,g]},n=(t,r,i)=>{let l=Array.from(t.floatData);return(0,u.scalesValidation)(l,r,i),l},e=(t,r,i,l)=>{let d=r.length,g=new Array(d);for(let b=0,v=d;b<v;b++)if(r[b]===0){if(t[b]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");g[b]=1}else g[b]=t[b]/r[b];return(0,u.scalesValidation)(g,i,l),g}},565:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.shape=void 0;let m=y(9240);c.shape=(h,p)=>(f(p),[new m.Tensor([p[0].dims.length],"int32",void 0,void 0,new Int32Array(p[0].dims))]);let f=h=>{if(!h||h.length!==1)throw new Error("Shape requires 1 input.")}},2444:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.sliceV10=c.parseSliceAttributes=c.slice=void 0;let m=y(4910),f=y(6145),h=y(7273),p=y(5639),u={name:"Slice",inputNames:["A"],inputTypes:[p.TextureType.unpacked]};c.slice=(e,t,r)=>(a(t),[e.run(Object.assign(Object.assign({},u),{cacheHint:r.cacheKey,get:()=>s(e,t[0],r)}),t)]),c.parseSliceAttributes=e=>{let t=e.attributes.getInts("starts"),r=e.attributes.getInts("ends"),i=e.attributes.getInts("axes",[]);return(0,m.createAttributeWithCacheKey)({starts:t,ends:r,axes:i})};let s=(e,t,r)=>{let i=r.axes.length===0?t.dims.slice(0).map((x,T)=>T):r.axes,l=h.ShapeUtil.normalizeAxes(i,t.dims.length),d=r.starts.map((x,T)=>x>t.dims[l[T]]-1?t.dims[l[T]]:h.ShapeUtil.normalizeAxis(x,t.dims[l[T]])),g=r.ends.map((x,T)=>x>t.dims[l[T]]-1?t.dims[l[T]]:h.ShapeUtil.normalizeAxis(x,t.dims[l[T]])),b=t.dims.slice(),v=[];for(let x=0;x<l.length;x++)b[l[x]]=g[x]-d[x],d[x]>0&&v.push(`outputIdx[${l[x]}] += ${d[x]};`);let w=`
      float process(int outputIdx[${b.length}]) {
        ${v.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},u),{output:{dims:b,type:t.type,textureType:p.TextureType.unpacked},shaderSource:w})},a=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(f.NUMBER_TYPES.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")};c.sliceV10=(e,t)=>{n(t);let r=o(e,t);return[e.run(Object.assign(Object.assign({},u),{cacheHint:r.cacheKey,get:()=>s(e,t[0],r)}),[t[0]])]};let o=(e,t)=>{if(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)||t.length>=4&&!e.session.isInitializer(t[3].dataId)||t.length>=5&&!e.session.isInitializer(t[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(t.length>=5&&t[4].integerData.some(d=>d!==1))throw new Error("currently non-1 steps is not supported for Slice");let r=Array.from(t[1].integerData),i=Array.from(t[2].integerData),l=t.length>=4?Array.from(t[3].integerData):[];return{starts:r,ends:i,axes:l,cacheKey:`${l};${r};${i}`}},n=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.softmaxV13=c.parseSoftmaxAttributesV13=c.parseSoftmaxAttributes=c.softmax=void 0;let m=y(4910),f=y(7273),h=y(6757),p=y(5639),u=y(5707),s={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[p.TextureType.unpacked]},a={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[p.TextureType.unpacked,p.TextureType.unpacked]},o={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[p.TextureType.unpacked,p.TextureType.unpacked,p.TextureType.unpacked]};c.softmax=(l,d,g)=>{i(d);let b=d[0].dims.slice(),v=f.ShapeUtil.normalizeAxis(g.axis,b.length),w=f.ShapeUtil.sizeToDimension(b,v),x=f.ShapeUtil.sizeFromDimension(b,v);return n(l,d,g,w,x)},c.parseSoftmaxAttributes=l=>(0,m.createAttributeWithCacheKey)({axis:l.attributes.getInt("axis",1)}),c.parseSoftmaxAttributesV13=l=>(0,m.createAttributeWithCacheKey)({axis:l.attributes.getInt("axis",-1)}),c.softmaxV13=(l,d,g)=>{i(d);let b=d[0].dims.slice(),v=f.ShapeUtil.normalizeAxis(g.axis,b.length),w=b.length,x=v!==w-1,T=[],O,P=[],I=[];x&&(P=Array.from({length:w}).map((C,_)=>_),P[v]=w-1,P[w-1]=v,P.map(C=>T.push(b[C])),O=(0,m.createAttributeWithCacheKey)({perm:P}),I=(0,u.transpose)(l,d,O));let R=x?f.ShapeUtil.sizeToDimension(T,w-1):f.ShapeUtil.sizeToDimension(b,w-1),j=x?f.ShapeUtil.sizeFromDimension(T,w-1):f.ShapeUtil.sizeFromDimension(b,w-1),A=n(l,x?I:d,g,R,j);return x?(0,u.transpose)(l,A,O):A};let n=(l,d,g,b,v)=>{let w=e(l,d[0],b,v,[b]),x=l.run(Object.assign(Object.assign({},s),{cacheHint:g.cacheKey,get:()=>w}),d),T=t(l,d[0],b,v,w.output.dims,[b]),O=l.run(Object.assign(Object.assign({},a),{cacheHint:g.cacheKey,get:()=>T}),[d[0],x]),P=r(l,d[0],b,v,w.output.dims,T.output.dims);return[l.run(Object.assign(Object.assign({},o),{cacheHint:g.cacheKey,get:()=>P}),[d[0],x,O])]},e=(l,d,g,b,v)=>{let[w,x]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),T=v.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1)throw new Error("Dimensionality of the output should be 1");if(v[0]!==g)throw new Error("Shape of the output should be equal to logical row count");let O=(0,h.getGlsl)(l.session.backend.glContext.version),P=`
      float process(int[${T}] indices) {
        int logical_row_start_offset = indices[0] * ${b};

        float max = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset, ${w},
        ${x} )));
        for(int i=1; i<${b}; ++i)
        {
          float current = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${w}, ${x})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},s),{output:{dims:v,type:d.type,textureType:p.TextureType.unpacked},shaderSource:P})},t=(l,d,g,b,v,w)=>{let[x,T]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),O=w.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(w.length!==1)throw new Error("Dimensionality of the output should be 1");if(w[0]!==g)throw new Error("Shape of the output should be equal to logical row count");if(v.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");let P=`
      float process(int[${O}] indices) {
        int logical_row_start_offset = indices[0] * ${b};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${b}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,h.getGlsl)(l.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${x}, ${T}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},a),{output:{dims:w,type:d.type,textureType:p.TextureType.unpacked},shaderSource:P})},r=(l,d,g,b,v,w)=>{let[x,T]=l.calculateTextureWidthAndHeight(d.dims,p.TextureType.unpacked),O=d.dims.length;if(g<1||b<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(v.length!==1||w.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(v[0]!==g||w[0]!==g)throw new Error("Shape of the intermediate results should be equal to logical row count");let P=`
      float process(int[${O}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${x}, ${T});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${b};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},o),{output:{dims:d.dims,type:d.type,textureType:p.TextureType.unpacked},shaderSource:P})},i=l=>{if(!l||l.length!==1)throw new Error("Softmax requires 1 input.");if(l[0].type!=="float32"&&l[0].type!=="float64")throw new Error("Invalid input type")}},564:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSplitAttributes=c.split=void 0;let m=y(4910),f=y(7273),h=y(5639),p={name:"Split",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};c.split=(o,n,e)=>{a(n);let t=f.ShapeUtil.normalizeAxis(e.axis,n[0].dims.length),r=u(o,n,t,e),i=[];for(let l=0;l<r;++l)i.push(o.run(Object.assign(Object.assign({},p),{cacheHint:`${e.cacheKey};${l}`,get:()=>s(o,n[0],e,t,l)}),n));return i},c.parseSplitAttributes=o=>{let n=o.attributes.getInt("axis",0),e=o.attributes.getInts("split",[]),t=o.outputs.length;return(0,m.createAttributeWithCacheKey)({axis:n,split:e,numOutputs:t})};let u=(o,n,e,t)=>{let[,r]=f.SplitUtil.splitShape(n[0].dims,e,t.split,t.numOutputs);return r.length},s=(o,n,e,t,r)=>{let[i,l]=f.SplitUtil.splitShape(n.dims,t,e.split,e.numOutputs),d=l[r],g=i[r],b=`
      float process(int indices[${g.length}]) {
        indices[${t}] += ${d};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},p),{cacheHint:`${e.cacheKey}:${r}`,output:{dims:g,type:n.type,textureType:h.TextureType.unpacked},shaderSource:b})},a=o=>{if(!o||o.length!==1)throw new Error("Split requires one input.");if(o[0].type!=="int8"&&o[0].type!=="uint8"&&o[0].type!=="int16"&&o[0].type!=="uint16"&&o[0].type!=="int32"&&o[0].type!=="uint32"&&o[0].type!=="float32"&&o[0].type!=="float64"&&o[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSqueezeAttributes=c.squeezeV13=c.squeeze=void 0;let m=y(7273);c.squeeze=(p,u,s)=>{f(u);let a=m.ShapeUtil.squeezeShape(u[0].dims,s);return[p.reshapeUnpacked(u[0],a)]},c.squeezeV13=(p,u)=>(h(u),(0,c.squeeze)(p,[u[0]],Array.from(u[1].integerData))),c.parseSqueezeAttributes=p=>p.attributes.getInts("axes");let f=p=>{if(!p||p.length!==1)throw new Error("Squeeze requires 1 input.");if(p[0].type==="string")throw new Error("invalid input tensor types.")},h=p=>{if(!p||p.length!==2)throw new Error("Squeeze requires 2 inputs.");if(p[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.sum=void 0;let m=y(6757),f=y(5639);c.sum=(u,s)=>{p(s);let a={name:"Sum",inputNames:s.map((o,n)=>`X${n}`),inputTypes:new Array(s.length).fill(f.TextureType.unpacked)};return[u.run(Object.assign(Object.assign({},a),{get:()=>h(u,s,a)}),s)]};let h=(u,s,a)=>{let o=(0,m.getGlsl)(u.session.backend.glContext.version),n=s[0].dims.slice(),e=`
      void main() {
        vec4 result = ${s.map((t,r)=>`${o.texture2D}(X${r},TexCoords)`).join(" + ")};
        ${o.output} = result;
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:n,type:s[0].type,textureType:f.TextureType.unpacked},hasMain:!0,shaderSource:e})},p=u=>{if(!u||u.length===0)throw new Error("Sum requires inputs.");let s=u[0].dims.length;for(let a=1;a<u.length;a++){if(s!==u[a].dims.length)throw new Error("Input shapes are mismatched.");for(let o=0;o<s;o++)if(u[0].dims[o]!==u[a].dims[o])throw new Error("Input shapes are not matched.")}if(u[0].type!=="float32"&&u[0].type!=="float64")throw new Error("Invalid input type.");for(let a=1;a<u.length;a++)if(u[0].type!==u[a].type)throw new Error("Input types are not matched.")}},5944:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tile=void 0;let m=y(6145),f=y(5639);c.tile=(u,s)=>{p(s);let a={name:"Tile",inputNames:["A"],inputTypes:[f.TextureType.unpacked]};return[u.run(Object.assign(Object.assign({},a),{get:()=>h(u,s,a)}),s)]};let h=(u,s,a)=>{let o=s[0].dims.slice(),n=new Array(o.length),e=[];for(let i=0;i<o.length;i++)n[i]=o[i]*s[1].numberData[i],e.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${o[i]}.));`);let t=n.length,r=`
      float process(int outputIdx[${t}]) {
        int inputIdx[${t}];
        ${e.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:n,type:s[0].type,textureType:f.TextureType.unpacked},shaderSource:r})},p=u=>{if(!u||u.length!==2)throw new Error("Tile requires 2 input.");if(u[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(u[1].dims[0]!==u[0].dims.length)throw new Error("Invalid input shape.");if(m.NUMBER_TYPES.indexOf(u[0].type)===-1)throw new Error("Invalid input type.");if(u[1].type!=="int32"&&u[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseTransposeAttributes=c.transpose=void 0;let m=y(4910),f=y(7273),h=y(5639),p={name:"Transpose",inputNames:["A"],inputTypes:[h.TextureType.unpacked]};c.transpose=(e,t,r)=>(n(t),[e.run(Object.assign(Object.assign({},p),{cacheHint:r.cacheKey,get:()=>u(e,t[0],r.perm)}),t)]),c.parseTransposeAttributes=e=>(0,m.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});let u=(e,t,r)=>{let i=t.dims;r=s(i,r);let l=a(i,r),d=i.length,g=`
      ${o("perm",r,d)}
      float process(int indices[${d}]) {
        int a[${d}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},p),{output:{dims:l,type:t.type,textureType:h.TextureType.unpacked},shaderSource:g})},s=(e,t)=>(t&&t.length!==e.length&&(t=[...e.keys()].reverse()),t),a=(e,t)=>(t=s(e,t),f.ShapeUtil.sortBasedOnPerm(e,t)),o=(e,t,r)=>{let i=[];i.push(`void ${e}(out int a[${r}], int src[${r}]) {`);for(let l=0;l<r;++l)i.push(`	a[${t[l]}]=src[${l}];`);return i.push("	}"),i.join(`
`)},n=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.encodeAsUint8=void 0;let m=y(6757),f=y(5639);c.encodeAsUint8=(h,p)=>{let u=p.shape,s=(0,m.getGlsl)(h.session.backend.glContext.version),a=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${s.texture2D}(X,TexCoords).r;
      ${s.output} = encodeAsUint8(value);
    }`,o={name:"Uint8Encode",inputTypes:[f.TextureType.unpacked],inputNames:["X"],output:{dims:u,type:p.tensor.type,textureType:f.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return h.executeProgram(o,[p.tensor])}},9087:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tanh=c.tan=c.sqrt=c.sin=c.sigmoid=c.relu=c.not=c.neg=c.log=c.parseLeakyReluAttributes=c.leakyRelu=c.identity=c.floor=c.exp=c.parseEluAttributes=c.elu=c.cos=c.ceil=c.clipV11=c.parseClipAttributes=c.clip=c.atan=c.asin=c.acos=c.abs=c.glslTanh=c.glslTan=c.glslSqrt=c.glslSigmoid=c.glslRelu=c.glslSin=c.glslNot=c.glslNeg=c.glslLog=c.glslLeakyRelu=c.glslIdentity=c.glslClip=c.glslFloor=c.glslExp=c.glslElu=c.glslCos=c.glslCeil=c.glslAtan=c.glslAsin=c.glslAcos=c.glslAbs=void 0;let m=y(4910),f=y(7273),h=y(1997),p=y(6757),u=y(5639);function s(){return A("abs")}function a(){return A("acos")}function o(){return A("asin")}function n(){return A("atan")}function e(){return A("ceil")}function t(){return A("cos")}function r(S){let E="elu";return{body:`
  const float alpha = float(${S});

  float ${E}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${E}_(vec4 v) {
    return vec4(${E}_(v.x), ${E}_(v.y), ${E}_(v.z), ${E}_(v.w));
  }
  `,name:E,type:h.FunctionType.ValueBased}}function i(){return A("exp")}function l(){return A("floor")}function d(S,E){let z="clip";return{body:`
  const float min = float(${S});
  const float max = float(${E});

  float ${z}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${z}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:z,type:h.FunctionType.ValueBased}}function g(){let S="indentity";return{body:`
  float ${S}_(float a) {
    return a;
  }
  vec4 ${S}_(vec4 v) {
    return v;
  }
  `,name:S,type:h.FunctionType.ValueBased}}function b(S){let E="leakyRelu";return{body:`
  const float alpha = float(${S});

  float ${E}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${E}_(vec4 v) {
    return vec4(${E}_(v.x), ${E}_(v.y), ${E}_(v.z), ${E}_(v.w));
  }
  `,name:E,type:h.FunctionType.ValueBased}}function v(){return A("log")}function w(){let S="neg";return{body:`
  float ${S}_(float a) {
    return -a;
  }
  vec4 ${S}_(vec4 v) {
    return -v;
  }
  `,name:S,type:h.FunctionType.ValueBased}}function x(){let S="not";return{body:`
  float ${S}_(float a) {
    return float( ! bool(a) );
  }
  bool ${S}_(bool a) {
    return !a;
  }
  vec4 ${S}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${S}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:S,type:h.FunctionType.ValueBased}}function T(){return A("sin")}function O(){let S="relu";return{body:`
  float ${S}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${S}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:S,type:h.FunctionType.ValueBased}}function P(){let S="sigmoid";return{body:`
  float ${S}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${S}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:S,type:h.FunctionType.ValueBased}}function I(){return A("sqrt")}function R(){return A("tan")}function j(){let S="tanh";return{body:`
  float ${S}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${S}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:S,type:h.FunctionType.ValueBased}}function A(S){return{body:`
  float ${S}_(float a) {
    return ${S}(a);
  }
  vec4 ${S}_(vec4 v) {
    return ${S}(v);
  }
  `,name:S,type:h.FunctionType.ValueBased}}c.glslAbs=s,c.glslAcos=a,c.glslAsin=o,c.glslAtan=n,c.glslCeil=e,c.glslCos=t,c.glslElu=r,c.glslExp=i,c.glslFloor=l,c.glslClip=d,c.glslIdentity=g,c.glslLeakyRelu=b,c.glslLog=v,c.glslNeg=w,c.glslNot=x,c.glslSin=T,c.glslRelu=O,c.glslSigmoid=P,c.glslSqrt=I,c.glslTan=R,c.glslTanh=j;let C=(S,E,z,L)=>{let Y=S.session.pack?u.TextureType.packed:u.TextureType.unpacked,X={name:z.name,inputTypes:[Y],inputNames:["A"],cacheHint:L};return Object.assign(Object.assign({},X),{get:()=>((te,ae,se,pe)=>{let ge=te.session.pack?u.TextureType.packed:u.TextureType.unpacked,ve=(0,p.getGlsl)(te.session.backend.glContext.version);return Object.assign(Object.assign({},ae),{output:{dims:se.dims,type:se.type,textureType:ge},shaderSource:`
     ${pe.body}
     void main() {
       vec4 v = ${ve.texture2D}(A, TexCoords);
       v = ${pe.name}_(v);
       ${ve.output} = v;
     }
     `,hasMain:!0})})(S,X,E,z)})};c.abs=(S,E)=>[S.run(C(S,E[0],s()),E)],c.acos=(S,E)=>[S.run(C(S,E[0],a()),E)],c.asin=(S,E)=>[S.run(C(S,E[0],o()),E)],c.atan=(S,E)=>[S.run(C(S,E[0],n()),E)],c.clip=(S,E,z)=>[S.run(C(S,E[0],d(z.min,z.max),z.cacheKey),E)],c.parseClipAttributes=S=>(0,m.createAttributeWithCacheKey)({min:S.attributes.getFloat("min",f.MIN_CLIP),max:S.attributes.getFloat("max",f.MAX_CLIP)}),c.clipV11=(S,E)=>{let z=_(S,E);return(0,c.clip)(S,[E[0]],z)};let _=(S,E)=>{if(E.length>=3&&(!S.session.isInitializer(E[1].dataId)||!S.session.isInitializer(E[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let z=E.length>=3?E[1].numberData[0]:f.MIN_CLIP,L=E.length>=3?E[2].numberData[0]:f.MAX_CLIP;return(0,m.createAttributeWithCacheKey)({min:z,max:L})};c.ceil=(S,E)=>[S.run(C(S,E[0],e()),E)],c.cos=(S,E)=>[S.run(C(S,E[0],t()),E)],c.elu=(S,E,z)=>[S.run(C(S,E[0],r(z.alpha),z.cacheKey),E)],c.parseEluAttributes=S=>(0,m.createAttributeWithCacheKey)({alpha:S.attributes.getFloat("alpha",1)}),c.exp=(S,E)=>[S.run(C(S,E[0],i()),E)],c.floor=(S,E)=>[S.run(C(S,E[0],l()),E)],c.identity=(S,E)=>[S.run(C(S,E[0],g()),E)],c.leakyRelu=(S,E,z)=>[S.run(C(S,E[0],b(z.alpha),z.cacheKey),E)],c.parseLeakyReluAttributes=S=>(0,m.createAttributeWithCacheKey)({alpha:S.attributes.getFloat("alpha",.01)}),c.log=(S,E)=>[S.run(C(S,E[0],v()),E)],c.neg=(S,E)=>[S.run(C(S,E[0],w()),E)],c.not=(S,E)=>[S.run(C(S,E[0],x()),E)],c.relu=(S,E)=>[S.run(C(S,E[0],O()),E)],c.sigmoid=(S,E)=>[S.run(C(S,E[0],P()),E)],c.sin=(S,E)=>[S.run(C(S,E[0],T()),E)],c.sqrt=(S,E)=>[S.run(C(S,E[0],I()),E)],c.tan=(S,E)=>[S.run(C(S,E[0],R()),E)],c.tanh=(S,E)=>[S.run(C(S,E[0],j()),E)]},540:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createUnpackProgramInfoLoader=c.createUnpackProgramInfo=void 0;let m=y(6757),f=y(5639),h=y(432),p=y(5614),u={name:"unpack",inputNames:["A"],inputTypes:[f.TextureType.packed]};c.createUnpackProgramInfo=(s,a)=>{let o=a.dims.length,n=(0,p.getChannels)("rc",o),e=n.slice(-2),t=(0,h.getCoordsDataType)(o),r=(0,p.unpackFromChannel)(),i=a.dims.length===0?"":function(g,b){if(g===1)return"rc";let v="";for(let w=0;w<g;w++)v+=b[w],w<g-1&&(v+=",");return v}(o,n),l=o<=1?"rc":`vec2(${e.join(",")})`,d=`
    ${r}
    void main() {
      ${t} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${i});

       ${(0,m.getGlsl)(s.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},u),{hasMain:!0,output:{dims:a.dims,type:a.type,textureType:f.TextureType.unpacked},shaderSource:d})},c.createUnpackProgramInfoLoader=(s,a)=>Object.assign(Object.assign({},u),{get:()=>(0,c.createUnpackProgramInfo)(s,a)})},7862:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseUnsqueezeAttributes=c.unsqueezeV13=c.unsqueeze=void 0;let m=y(7273);c.unsqueeze=(p,u,s)=>{f(u);let a=m.ShapeUtil.unsqueezeShape(u[0].dims,s);return[p.reshapeUnpacked(u[0],a)]},c.unsqueezeV13=(p,u)=>(h(u),(0,c.unsqueeze)(p,[u[0]],Array.from(u[1].integerData))),c.parseUnsqueezeAttributes=p=>p.attributes.getInts("axes");let f=p=>{if(!p||p.length!==1)throw new Error("Unsqueeze requires 1 input.");if(p[0].type==="string")throw new Error("invalid input tensor types.")},h=p=>{if(!p||p.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(p[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.scalesValidation=c.validateInputs=c.parseUpsampleAttributes=c.parseUpsampleAttributesV9=c.parseUpsampleAttributesV7=c.upsample=void 0;let m=y(4910),f=y(6757),h=y(5639),p={name:"Upsample",inputNames:["X"],inputTypes:[h.TextureType.unpacked]};c.upsample=(s,a,o)=>((0,c.validateInputs)(a,o),[s.run(Object.assign(Object.assign({},p),{cacheHint:o.cacheKey,get:()=>u(s,a,o)}),a)]),c.parseUpsampleAttributesV7=s=>(0,c.parseUpsampleAttributes)(s,7),c.parseUpsampleAttributesV9=s=>(0,c.parseUpsampleAttributes)(s,9),c.parseUpsampleAttributes=(s,a)=>{let o=a>=10,n=s.attributes.getString("mode","nearest");if(n!=="nearest"&&n!=="linear"&&(a<11||n!=="cubic"))throw new Error(`unrecognized mode: ${n}`);let e=[];a<9&&(e=s.attributes.getFloats("scales"),(0,c.scalesValidation)(e,n,o));let t=s.attributes.getFloat("extrapolation_value",0),r=a>10?s.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(r)===-1)throw new Error(`coordinate_transform_mode '${r}' is not supported`);let i=r==="tf_crop_and_resize",l=i,d=n==="nearest"&&a>=11?s.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(d)===-1)throw new Error(`nearest_mode '${d}' is not supported`);let g=s.attributes.getFloat("cubic_coeff_a",-.75),b=s.attributes.getInt("exclude_outside",0)!==0;if(b&&n!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let v=a<11||n==="nearest"&&r==="asymmetric"&&d==="floor",w=0,x=0,T=0;return a>10?s.inputs.length>2?(w=1,x=2,T=3):(x=1,T=2):a===9&&(x=1),(0,m.createAttributeWithCacheKey)({opset:a,isResize:o,mode:n,scales:e,extrapolationValue:t,coordinateTransformMode:r,useExtrapolation:l,needRoiInput:i,nearestMode:d,cubicCoefficientA:g,excludeOutside:b,useNearest2xOptimization:v,roiInputIdx:w,scalesInputIdx:x,sizesInputIdx:T})};let u=(s,a,o)=>{let n=(0,f.getGlsl)(s.session.backend.glContext.version),[e,t]=s.calculateTextureWidthAndHeight(a[0].dims,h.TextureType.unpacked),r=a[0].dims.map((T,O)=>Math.floor(T*o.scales[O])),[i,l]=s.calculateTextureWidthAndHeight(r,h.TextureType.unpacked),d=r.length,g=new Array(d),b=new Array(d),v=`
      int output_pitches[${d}];
      int input_pitches[${d}];
      `;for(let T=d-1;T>=0;T--)g[T]=T===d-1?1:g[T+1]*r[T+1],b[T]=T===d-1?1:b[T+1]*a[0].dims[T+1],v+=`
        output_pitches[${T}] = ${g[T]};
        input_pitches[${T}] = ${b[T]};
        `;let w=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${e}, ${t});
        float value = getColorAsFloat(${n.texture2D}(X, coords));
        return value;
      }
      `,x=o.mode==="nearest"?`
    ${w}
    float process(int indices[${d}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${l});

      ${v}

      int d, m;
      for (int dim = 0; dim < ${d}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:d===4?`
    ${w}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${l});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${a[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${w}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${l});

      ${v}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${a[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},p),{output:{dims:r,type:a[0].type,textureType:h.TextureType.unpacked},shaderSource:x,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(T=>Math.ceil(T))}]})};c.validateInputs=(s,a)=>{if(!s||a.opset<9&&s.length!==1||a.opset>=9&&a.opset<11&&s.length!==2||a.opset>=11&&s.length<2)throw new Error("invalid inputs.");if(a.scales.length>0&&s[0].dims.length!==a.scales.length)throw new Error("Invalid input shape.");if(s[0].type==="string")throw new Error("Invalid input tensor types.")},c.scalesValidation=(s,a,o)=>{if(o){for(let n of s)if(n<=0)throw new Error("Scale value should be greater than 0.")}else for(let n of s)if(n<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(a!=="linear"&&a!=="cubic"||s.length===2||s.length===4&&s[0]===1&&s[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}},2757:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ProgramManager=void 0;let m=y(2235),f=y(1315),h=y(8897),p=y(6757);c.ProgramManager=class{constructor(u,s,a){this.profiler=u,this.glContext=s,this.textureLayoutStrategy=a,this.repo=new Map,this.attributesBound=!1}getArtifact(u){return this.repo.get(u)}setArtifact(u,s){this.repo.set(u,s)}run(u,s,a){var o;this.profiler.event("op",`ProgramManager.run ${(o=u.programInfo.name)!==null&&o!==void 0?o:"unknown kernel"}`,()=>{var n;let e=this.glContext.gl,t=u.program;e.useProgram(t);try{this.bindOutput(a),this.attributesBound||this.bindAttributes(u.attribLocations),this.bindUniforms(u.uniformLocations,(n=u.programInfo.variables)!==null&&n!==void 0?n:[],s)}catch(r){throw f.Logger.error("ProgramManager",u.programInfo.shaderSource),r}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(u=>this.glContext.deleteProgram(u.program))}build(u,s,a){return this.profiler.event("backend","ProgramManager.build",()=>{let o=new h.GlslPreprocessor(this.glContext,u,s,a),n=o.preprocess(),e=this.compile(n);return{programInfo:u,program:e,uniformLocations:this.getUniformLocations(e,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(e)}})}compile(u){if(!this.vertexShader){f.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let o=(0,p.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}m.env.debug&&f.Logger.verbose("ProrgramManager",`FragShader:
${u}
`);let s=this.glContext.compileShader(u,this.glContext.gl.FRAGMENT_SHADER),a=this.glContext.createProgram(this.vertexShader,s);return this.glContext.deleteShader(s),a}bindOutput(u){let s=u.width,a=u.height;f.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${s}/${a}, shape=${u.shape}, type=${u.tensor.type}`),this.glContext.attachFramebuffer(u.texture,s,a)}bindAttributes(u){let s=u.position,a=u.textureCoord;this.glContext.setVertexAttributes(s,a),this.attributesBound=!0}bindUniforms(u,s,a){var o;let n=this.glContext.gl,e=0;for(let{name:t,type:r,location:i,arrayLength:l}of u){let d=(o=s.find(g=>g.name===t))===null||o===void 0?void 0:o.data;if(r!=="sampler2D"&&!d)throw new Error(`variable '${t}' does not have data defined in program info`);switch(r){case"sampler2D":this.bindTexture(a[e],i,e),e++;break;case"float":l?n.uniform1fv(i,d):n.uniform1f(i,d);break;case"int":l?n.uniform1iv(i,d):n.uniform1i(i,d);break;default:throw new Error(`Uniform not implemented: ${r}`)}}}bindTexture(u,s,a){this.glContext.bindTextureToUniform(u.texture,a,s)}getAttribLocations(u){return{position:this.getAttribLocation(u,"position"),textureCoord:this.getAttribLocation(u,"textureCoord")}}getUniformLocations(u,s,a){let o=[];if(s)for(let n of s)o.push({name:n,type:"sampler2D",location:this.getUniformLocation(u,n)});if(a)for(let n of a)o.push(Object.assign(Object.assign({},n),{location:this.getUniformLocation(u,n.name)}));return o}getUniformLocation(u,s){let a=this.glContext.gl.getUniformLocation(u,s);if(a===null)throw new Error(`Uniform ${s} not found.`);return a}getAttribLocation(u,s){return this.glContext.gl.getAttribLocation(u,s)}}},2171:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLSessionHandler=void 0;let m=y(1315),f=y(5881),h=y(7860),p=y(4110),u=y(2757),s=y(7618),a=y(5243);c.WebGLSessionHandler=class{constructor(o,n){this.backend=o,this.context=n,this.layoutStrategy=new s.PreferLogicalStrategy(o.glContext.maxTextureSize),this.programManager=new u.ProgramManager(this.context.profiler,o.glContext,this.layoutStrategy),this.textureManager=new a.TextureManager(o.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:o.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=o.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new h.WebGLInferenceHandler(this)}onGraphInitialized(o){let n=o.getValues().filter(e=>e.from===-1&&e.tensor).map(e=>e.tensor.dataId);this.initializers=new Set(n)}isInitializer(o){return!!this.initializers&&this.initializers.has(o)}addInitializer(o){this.initializers.add(o)}getTextureData(o,n){return n?this.packedTextureDataCache.get(o):this.unpackedTextureDataCache.get(o)}setTextureData(o,n,e=!1){m.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),e?this.packedTextureDataCache.set(o,n):this.unpackedTextureDataCache.set(o,n)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.unpackedTextureDataCache=new Map}resolve(o,n,e){let t=(0,f.resolveOperator)(o,n,p.WEBGL_OP_RESOLVE_RULES);return{impl:t.opImpl,context:t.opInit?t.opInit(o,e):o}}}},9622:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Uint8DataEncoder=c.RGBAFloatDataEncoder=c.RedFloat32DataEncoder=void 0;let m=y(1315);c.RedFloat32DataEncoder=class{constructor(f,h=1){if(h===1)this.internalFormat=f.R32F,this.format=f.RED,this.textureType=f.FLOAT,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=f.RGBA32F,this.format=f.RGBA,this.textureType=f.FLOAT,this.channelSize=h}}encode(f,h){let p,u;return f.constructor!==Float32Array&&(m.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),u=new Float32Array(f)),h*this.channelSize>f.length?(m.Logger.warning("Encoder","Source data too small. Allocating larger array"),u=f,p=this.allocate(h*this.channelSize),u.forEach((s,a)=>p[a]=s)):(u=f,p=u),p}allocate(f){return new Float32Array(4*f)}decode(f,h){return this.channelSize===1?f.filter((p,u)=>u%4==0).subarray(0,h):f.subarray(0,h)}},c.RGBAFloatDataEncoder=class{constructor(f,h=1,p){if(h!==1&&h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=f.RGBA,this.format=f.RGBA,this.channelSize=h,this.textureType=p||f.FLOAT}encode(f,h){let p=f;return this.channelSize===1&&(m.Logger.verbose("Encoder","Exploding into a larger array"),p=this.allocate(h),f.forEach((u,s)=>p[4*s]=u)),p}allocate(f){return new Float32Array(4*f)}decode(f,h){return this.channelSize===1?f.filter((p,u)=>u%4==0).subarray(0,h):f.subarray(0,h)}},c.Uint8DataEncoder=class{constructor(f,h=1){if(this.channelSize=4,h===1)this.internalFormat=f.ALPHA,this.format=f.ALPHA,this.textureType=f.UNSIGNED_BYTE,this.channelSize=h;else{if(h!==4)throw new Error(`Invalid number of channels: ${h}`);this.internalFormat=f.RGBA,this.format=f.RGBA,this.textureType=f.UNSIGNED_BYTE,this.channelSize=h}}encode(f,h){return new Uint8Array(f.buffer,f.byteOffset,f.byteLength)}allocate(f){return new Uint8Array(f*this.channelSize)}decode(f,h){if(f instanceof Uint8Array)return f.subarray(0,h);throw new Error(`Invalid array type: ${f.constructor}`)}}},7618:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getBatchDim=c.sizeToSquarishShape=c.getRowsCols=c.sizeFromShape=c.isInt=c.parseAxisParam=c.squeezeShape=c.PreferLogicalStrategy=c.AlwaysKeepOriginalSizeStrategy=void 0;let m=y(1315),f=y(7273);function h(o,n){let e=[],t=[],r=n!=null&&Array.isArray(n)&&n.length===0,i=n==null||r?null:p(n,o).sort(),l=0;for(let d=0;d<o.length;++d){if(i!=null){if(i[l]===d&&o[d]!==1)throw new Error(`Can't squeeze axis ${d} since its dim '${o[d]}' is not 1`);(i[l]==null||i[l]>d)&&o[d]===1&&(e.push(o[d]),t.push(d)),i[l]<=d&&l++}o[d]!==1&&(e.push(o[d]),t.push(d))}return{newShape:e,keptDims:t}}function p(o,n){let e=n.length;return o=o==null?n.map((t,r)=>r):[].concat(o),(0,f.assert)(o.every(t=>t>=-e&&t<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${o}`),(0,f.assert)(o.every(u),()=>`All values in axis param must be integers but got axis ${o}`),o.map(t=>t<0?e+t:t)}function u(o){return o%1==0}function s(o){if(o.length===0)return 1;let n=o[0];for(let e=1;e<o.length;e++)n*=o[e];return n}function a(o){let n=Math.ceil(Math.sqrt(o));return[n,Math.ceil(o/n)]}c.AlwaysKeepOriginalSizeStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,n){if(o.length===0)return[1,1];let e=this.maxTextureSize;if(n&&n.breakAxis!==void 0){let i=n.breakAxis>=o.length?1:o.slice(n.breakAxis).reduce((d,g)=>d*g),l=n.breakAxis<=0?1:o.slice(0,n.breakAxis).reduce((d,g)=>d*g);if(!(i>e||l>e))return[i,l];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${n.breakAxis}`)}let t=o.reduce((i,l)=>i*l),r=Math.floor(Math.sqrt(t));for(;r<e&&r<t&&t%r!=0;r++);if(r>=e||t%r!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${o}`);return[r,t/r]}},c.PreferLogicalStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,n){let e=this.computeTexture(o,n);return n&&n.isPacked&&(e[0]/=2,e[1]/=2),n&&n.reverseWH?[e[1],e[0]]:e}computeTexture(o,n){let e=n&&n.isPacked;if(o.length===0)return e?[2,2]:[1,1];let t=this.maxTextureSize;if(n&&n.breakAxis!==void 0){let l=n.breakAxis>=o.length?1:o.slice(n.breakAxis).reduce((g,b)=>g*b),d=n.breakAxis<=0?1:o.slice(0,n.breakAxis).reduce((g,b)=>g*b);if(!(l>t||d>t))return[l,d];m.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${n.breakAxis}`)}let r=o.slice(0);e&&(t*=2,r=r.map((l,d)=>d>=r.length-2?r[d]%2==0?r[d]:r[d]+1:r[d]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=h(r).newShape);let i=s(r);return r.length<=1&&i<=t?[1,i]:r.length===2&&r[0]<=t&&r[1]<=t?r:r.length===3&&r[0]*r[1]<=t&&r[2]<=t?[r[0]*r[1],r[2]]:r.length===3&&r[0]<=t&&r[1]*r[2]<=t?[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t?[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t?[r[0],r[1]*r[2]*r[3]]:e?a(i/4).map(l=>2*l):a(i)}},c.squeezeShape=h,c.parseAxisParam=p,c.isInt=u,c.sizeFromShape=s,c.getRowsCols=function(o){if(o.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[o.length>1?o[o.length-2]:1,o[o.length-1]]},c.sizeToSquarishShape=a,c.getBatchDim=function(o,n=2){return s(o.slice(0,o.length-n))}},3314:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createTextureLayoutFromShape=c.calculateTextureWidthAndHeight=c.createTextureLayoutFromTextureType=void 0;let m=y(7273),f=y(5639);c.createTextureLayoutFromTextureType=(h,p,u)=>{let s=u===f.TextureType.unpacked||u===f.TextureType.unpackedReversed?1:4,a=u===f.TextureType.packed,o=u===f.TextureType.unpackedReversed||u===f.TextureType.packed,n=u===f.TextureType.packedLastDimension?p.length-1:void 0,e=u===f.TextureType.packedLastDimension?p.map((t,r)=>r===p.length-1?4*t:t):void 0;return(0,c.createTextureLayoutFromShape)(h,p,s,e,{isPacked:a,reverseWH:o,breakAxis:n})},c.calculateTextureWidthAndHeight=(h,p,u)=>{let s=(0,c.createTextureLayoutFromTextureType)(h,p,u);return[s.width,s.height]},c.createTextureLayoutFromShape=(h,p,u=1,s,a)=>{let o=!(!a||!a.isPacked),[n,e]=h.computeTextureWH(o&&s||p,a),t=p.length,r=p.slice(0);if(t===0&&(r=[1]),u===1)s=p;else if(o){if(u!==4)throw new Error("a packed texture must be 4-channel");s=p,t>0&&(r[t-1]=Math.ceil(r[t-1]/2)),t>1&&(r[t-2]=Math.ceil(r[t-2]/2))}else if(!s)throw new Error("Unpacked shape is needed when using channels > 1");return{width:n,height:e,channels:u,isPacked:o,shape:r,strides:m.ShapeUtil.computeStrides(r),unpackedShape:s,reversedWH:a&&a.reverseWH}}},5243:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.TextureManager=void 0;let m=y(1315);c.TextureManager=class{constructor(f,h,p,u){this.glContext=f,this.layoutStrategy=h,this.profiler=p,this.config=u,this.pendingRead=new Map,u.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(f,h,p,u){let s=this.toEncoderType(f),a=this.glContext.getEncoder(s,h.channels||1,u);if(h.isPacked&&u===1)throw new Error("not implemented");let o=h.width,n=h.height,e,t;if(this.config.reuseTextures){e=`${o}x${n}_${a.format}_${a.internalFormat}_${a.textureType}`,t=this.inUseTextures.get(e),t||(t=[],this.inUseTextures.set(e,t));let i=this.idleTextures.get(e);if(i&&i.length>0){let l=i.pop();return t.push(l),u===1&&this.glContext.updateTexture(l,o,n,a,this.toTextureData(f,p)),l}}m.Logger.verbose("TextureManager",`Creating new texture of size ${h.width}x${h.height}`);let r=this.glContext.allocateTexture(o,n,a,this.toTextureData(f,p));return this.config.reuseTextures&&(t.push(r),this.textureLookup.set(r,e)),r}readTexture(f,h,p){return p||(p=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let u=f.shape.reduce((a,o)=>a*o)*p,s=this.glContext.readTexture(f.texture,f.width,f.height,u,this.toEncoderType(h),p);return this.toTensorData(h,s)})}async readTextureAsync(f,h,p){let u=f.tensor.dataId;if(p||(p=1),this.pendingRead.has(u)){let s=this.pendingRead.get(u);return new Promise(a=>s?.push(a))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(u,[]);let s=f.shape.reduce((e,t)=>e*t)*p;await this.glContext.createAndWaitForFence();let a=this.glContext.readTexture(f.texture,f.width,f.height,s,this.toEncoderType(h),p),o=this.toTensorData(h,a),n=this.pendingRead.get(u);return this.pendingRead.delete(u),n?.forEach(e=>e(o)),o})}readUint8TextureAsFloat(f){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let h=f.shape.reduce((u,s)=>u*s),p=this.glContext.readTexture(f.texture,f.width,f.height,4*h,"byte",4);return new Float32Array(p.buffer,p.byteOffset,h)})}releaseTexture(f,h){let p;if(this.config.reuseTextures&&(p=this.textureLookup.get(f.texture),p)){h&&this.textureLookup.delete(p);let u=this.inUseTextures.get(p);if(u){let s=u.indexOf(f.texture);if(s!==-1){u.splice(s,1);let a=this.idleTextures.get(p);a||(a=[],this.idleTextures.set(p,a)),a.push(f.texture)}}}p&&!h||(m.Logger.verbose("TextureManager",`Deleting texture of size ${f.width}x${f.height}`),this.glContext.deleteTexture(f.texture))}toTensorData(f,h){switch(f){case"int16":return h instanceof Int16Array?h:Int16Array.from(h);case"int32":return h instanceof Int32Array?h:Int32Array.from(h);case"int8":return h instanceof Int8Array?h:Int8Array.from(h);case"uint16":return h instanceof Uint16Array?h:Uint16Array.from(h);case"uint32":return h instanceof Uint32Array?h:Uint32Array.from(h);case"uint8":case"bool":return h instanceof Uint8Array?h:Uint8Array.from(h);case"float32":return h instanceof Float32Array?h:Float32Array.from(h);case"float64":return h instanceof Float64Array?h:Float64Array.from(h);default:throw new Error(`TensorData type ${f} is not supported`)}}toTextureData(f,h){if(h)return h instanceof Float32Array?h:new Float32Array(h)}toEncoderType(f){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(M,c)=>{"use strict";var y;Object.defineProperty(c,"__esModule",{value:!0}),c.TextureType=void 0,(y=c.TextureType||(c.TextureType={}))[y.unpacked=0]="unpacked",y[y.unpackedReversed=1]="unpackedReversed",y[y.packed=2]="packed",y[y.downloadUint8AsFloat=3]="downloadUint8AsFloat",y[y.packedLastDimension=4]="packedLastDimension"},432:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getGlChannels=c.getCoordsDataType=c.getSqueezedParams=c.squeezeInputShape=c.generateShaderFuncNameFromInputSamplerNameAtOutCoords=c.generateShaderFuncNameFromInputSamplerName=c.repeatedTry=c.getPackedShape=void 0;let m=y(7273);c.getPackedShape=function(f){let h=f.length;return f.slice(0,h-1).concat(f[h-1]/4)},c.repeatedTry=async function(f,h=u=>0,p){return new Promise((u,s)=>{let a=0,o=()=>{if(f())return void u();a++;let n=h(a);p!=null&&a>=p?s():setTimeout(o,n)};o()})},c.generateShaderFuncNameFromInputSamplerName=function(f){return(0,m.assert)(f!==void 0&&f.length!==0,()=>"empty string found for sampler name"),"get"+f.charAt(0).toUpperCase()+f.slice(1)},c.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(f){return(0,m.assert)(f!==void 0&&f.length!==0,()=>"empty string found for sampler name"),"get"+f.charAt(0).toUpperCase()+f.slice(1)+"AtOutCoords"},c.squeezeInputShape=function(f,h){let p=JSON.parse(JSON.stringify(f));return p=h,p},c.getSqueezedParams=function(f,h){return h.map(p=>f[p]).join(", ")},c.getCoordsDataType=function(f){if(f<=1)return"int";if(f===2)return"ivec2";if(f===3)return"ivec3";if(f===4)return"ivec4";if(f===5)return"ivec5";if(f===6)return"ivec6";throw Error(`GPU for rank ${f} is not yet supported`)},c.getGlChannels=function(f=6){return["x","y","z","w","u","v"].slice(0,f)}},3389:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createNewWebGLContext=c.createWebGLContext=void 0;let m=y(1315),f=y(3524),h={};function p(u,s){let a,o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!s||s==="webgl2")&&(a=u.getContext("webgl2",o),a))try{return new f.WebGLContext(a,2)}catch(n){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${n}`)}if((!s||s==="webgl")&&(a=u.getContext("webgl",o)||u.getContext("experimental-webgl",o),a))try{return new f.WebGLContext(a,1)}catch(n){m.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${n}`)}throw new Error("WebGL is not supported")}c.createWebGLContext=function u(s){let a;if(s&&s!=="webgl2"||!("webgl2"in h)?s&&s!=="webgl"||!("webgl"in h)||(a=h.webgl):a=h.webgl2,!a)try{a=p(function(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}(),s)}catch{a=p(function(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let e=document.createElement("canvas");return e.width=1,e.height=1,e}(),s)}s=s||a.version===1?"webgl":"webgl2";let o=a.gl;return h[s]=a,o.isContextLost()?(delete h[s],u(s)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),a)},c.createNewWebGLContext=p},3524:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(o,n,e,t){t===void 0&&(t=e);var r=Object.getOwnPropertyDescriptor(n,e);r&&!("get"in r?!n.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return n[e]}}),Object.defineProperty(o,t,r)}:function(o,n,e,t){t===void 0&&(t=e),o[t]=n[e]}),f=this&&this.__setModuleDefault||(Object.create?function(o,n){Object.defineProperty(o,"default",{enumerable:!0,value:n})}:function(o,n){o.default=n}),h=this&&this.__importStar||function(o){if(o&&o.__esModule)return o;var n={};if(o!=null)for(var e in o)e!=="default"&&Object.prototype.hasOwnProperty.call(o,e)&&m(n,o,e);return f(n,o),n};Object.defineProperty(c,"__esModule",{value:!0}),c.WebGLContext=c.linearSearchLastTrue=void 0;let p=y(2235),u=h(y(9622)),s=y(432);function a(o){let n=0;for(;n<o.length&&o[n]();++n);return n-1}c.linearSearchLastTrue=a,c.WebGLContext=class{constructor(o,n){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=o,this.version=n,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(o,n,e,t){let r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE);let l=t?e.encode(t,o*n):null;return r.texImage2D(r.TEXTURE_2D,0,e.internalFormat,o,n,0,e.format,e.textureType,l),this.checkError(),i}updateTexture(o,n,e,t,r){let i=this.gl;i.bindTexture(i.TEXTURE_2D,o);let l=t.encode(r,n*e);i.texSubImage2D(i.TEXTURE_2D,0,0,0,n,e,t.format,t.textureType,l),this.checkError()}attachFramebuffer(o,n,e){let t=this.gl;t.bindTexture(t.TEXTURE_2D,o),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),this.checkError(),t.viewport(0,0,n,e),t.scissor(0,0,n,e)}readTexture(o,n,e,t,r,i){let l=this.gl;i||(i=1),this.frameBufferBound||this.attachFramebuffer(o,n,e);let d=this.getEncoder(r,i),g=d.allocate(n*e);return l.bindTexture(l.TEXTURE_2D,o),l.framebufferTexture2D(l.FRAMEBUFFER,l.COLOR_ATTACHMENT0,l.TEXTURE_2D,o,0),l.readPixels(0,0,n,e,l.RGBA,d.textureType,g),this.checkError(),d.decode(g,t)}isFramebufferReady(){return!0}getActiveTexture(){let o=this.gl;return"TEXTURE"+(o.getParameter(this.gl.ACTIVE_TEXTURE)-o.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(o,n){let e=this.gl;e.vertexAttribPointer(o,3,e.FLOAT,!1,20,0),e.enableVertexAttribArray(o),n!==-1&&(e.vertexAttribPointer(n,2,e.FLOAT,!1,20,12),e.enableVertexAttribArray(n)),this.checkError()}createProgram(o,n){let e=this.gl,t=e.createProgram();return e.attachShader(t,o),e.attachShader(t,n),e.linkProgram(t),t}compileShader(o,n){let e=this.gl,t=e.createShader(n);if(!t)throw new Error(`createShader() returned null with type ${n}`);if(e.shaderSource(t,o),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${e.getShaderInfoLog(t)}
Shader source:
${o}`);return t}deleteShader(o){this.gl.deleteShader(o)}bindTextureToUniform(o,n,e){let t=this.gl;t.activeTexture(t.TEXTURE0+n),this.checkError(),t.bindTexture(t.TEXTURE_2D,o),this.checkError(),t.uniform1i(e,n),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(p.env.debug){let o=this.gl,n=o.getError(),e="";switch(n){case o.NO_ERROR:return;case o.INVALID_ENUM:e="INVALID_ENUM";break;case o.INVALID_VALUE:e="INVALID_VALUE";break;case o.INVALID_OPERATION:e="INVALID_OPERATION";break;case o.INVALID_FRAMEBUFFER_OPERATION:e="INVALID_FRAMEBUFFER_OPERATION";break;case o.OUT_OF_MEMORY:e="OUT_OF_MEMORY";break;case o.CONTEXT_LOST_WEBGL:e="CONTEXT_LOST_WEBGL";break;default:e=`Unknown WebGL Error: ${n.toString(16)}`}throw new Error(e)}}deleteTexture(o){this.gl.deleteTexture(o)}deleteProgram(o){this.gl.deleteProgram(o)}getEncoder(o,n,e=0){if(this.version===2)return new u.RedFloat32DataEncoder(this.gl,n);switch(o){case"float":return e===1||this.isRenderFloat32Supported?new u.RGBAFloatDataEncoder(this.gl,n):new u.RGBAFloatDataEncoder(this.gl,n,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new u.Uint8DataEncoder(this.gl,n);default:throw new Error(`Invalid dataType: ${o}`)}}clearActiveTextures(){let o=this.gl;for(let n=0;n<this.maxTextureImageUnits;++n)o.activeTexture(o.TEXTURE0+n),o.bindTexture(o.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let o=this.gl;o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(this.framebuffer),o.bindBuffer(o.ARRAY_BUFFER,null),o.deleteBuffer(this.vertexbuffer),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null),o.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let o=this.gl,n=o.createBuffer();if(!n)throw new Error("createBuffer() returned null");let e=this.createDefaultGeometry();return o.bindBuffer(o.ARRAY_BUFFER,n),o.bufferData(o.ARRAY_BUFFER,e,o.STATIC_DRAW),this.checkError(),n}createFramebuffer(){let o=this.gl.createFramebuffer();if(!o)throw new Error("createFramebuffer returned null");return o}queryVitalParameters(){let o=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=o.getParameter(o.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=o.getParameter(o.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let o=this.gl,n=o.createTexture();o.bindTexture(o.TEXTURE_2D,n);let e=this.version===2?o.RGBA32F:o.RGBA;o.texImage2D(o.TEXTURE_2D,0,e,1,1,0,o.RGBA,o.FLOAT,null);let t=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,t),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,n,0);let r=o.checkFramebufferStatus(o.FRAMEBUFFER)===o.FRAMEBUFFER_COMPLETE;return o.bindTexture(o.TEXTURE_2D,null),o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteTexture(n),o.deleteFramebuffer(t),r}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let o=this.gl,n,e,t,r,i;try{n=o.createTexture(),e=o.createFramebuffer(),o.bindTexture(o.TEXTURE_2D,n);let l=this.version===2?o.RGBA32F:o.RGBA;return o.texImage2D(o.TEXTURE_2D,0,l,1,1,0,o.RGBA,o.FLOAT,null),o.bindFramebuffer(o.FRAMEBUFFER,e),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,n,0),o.enable(o.BLEND),t=o.createShader(o.VERTEX_SHADER),!!t&&(o.shaderSource(t,"void main(){}"),o.compileShader(t),r=o.createShader(o.FRAGMENT_SHADER),!!r&&(o.shaderSource(r,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),o.compileShader(r),i=o.createProgram(),!!i&&(o.attachShader(i,t),o.attachShader(i,r),o.linkProgram(i),o.useProgram(i),o.drawArrays(o.POINTS,0,1),o.getError()===o.NO_ERROR)))}finally{o.disable(o.BLEND),i&&o.deleteProgram(i),t&&o.deleteShader(t),r&&o.deleteShader(r),e&&(o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(e)),n&&(o.bindTexture(o.TEXTURE_2D,null),o.deleteTexture(n))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let o=this.gl,n=this.disjointTimerQueryWebgl2Extension,e=o.createQuery();return o.beginQuery(n.TIME_ELAPSED_EXT,e),e}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{let o=this.gl,n=this.disjointTimerQueryWebgl2Extension;o.endQuery(n.TIME_ELAPSED_EXT)}}isTimerResultAvailable(o){let n=!1,e=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{let t=this.gl,r=this.disjointTimerQueryWebgl2Extension;n=t.getQueryParameter(o,t.QUERY_RESULT_AVAILABLE),e=t.getParameter(r.GPU_DISJOINT_EXT)}return n&&!e}getTimerResult(o){let n=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{let e=this.gl;n=e.getQueryParameter(o,e.QUERY_RESULT),e.deleteQuery(o)}return n/1e6}async waitForQueryAndGetTime(o){return await(0,s.repeatedTry)(()=>this.isTimerResultAvailable(o)),this.getTimerResult(o)}async createAndWaitForFence(){let o=this.createFence(this.gl);return this.pollFence(o)}createFence(o){let n,e=o,t=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return o.flush(),n=t===null?()=>!0:()=>{let r=e.clientWaitSync(t,0,0);return r===e.ALREADY_SIGNALED||r===e.CONDITION_SATISFIED},{query:t,isFencePassed:n}}async pollFence(o){return new Promise(n=>{this.addItemToPoll(()=>o.isFencePassed(),()=>n())})}pollItems(){let o=a(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=o;++n){let{resolveFn:e}=this.itemsToPoll[n];e()}this.itemsToPoll=this.itemsToPoll.slice(o+1)}async addItemToPoll(o,n){this.itemsToPoll.push({isDoneFn:o,resolveFn:n}),this.itemsToPoll.length>1||await(0,s.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ExecutionPlan=void 0;let m=y(1315);class f{constructor(p,u){this.op=p,this.node=u}}c.ExecutionPlan=class{constructor(h,p,u){this.graph=h,this.profiler=u,this.initialize(p)}initialize(h){this.profiler.event("session","ExecutionPlan.initialize",()=>{let p=this.graph.getNodes();if(p.length!==h.length)throw new Error("The size of nodes and OPs do not match.");this._ops=h.map((u,s)=>new f(u,p[s])),this.reset(),this._starter=[],this._ops.forEach((u,s)=>{let a=!0;for(let o of u.node.inputs)if(!this._values[o]&&this.graph.getInputIndices().indexOf(o)===-1){a=!1;break}a&&this._starter.push(s)})})}reset(){this._values=this.graph.getValues().map(h=>h.tensor)}async execute(h,p){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let u=h.createInferenceHandler(),s=this.graph.getInputIndices();if(p.length!==s.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${p.length} expected: ${s.length}`);p.forEach((r,i)=>{let l=s[i];this._values[l]=r});let a=this._starter.slice(0),o=this.graph.getValues(),n=this.graph.getNodes(),e=0;for(;e<a.length;){let r=a[e++],i=this._ops[r],l=i.node.inputs.map(v=>this._values[v]);if(l.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${i.node}`);let d=l;m.Logger.verbose("ExecPlan",`Runing op:${i.node.name} (${d.map((v,w)=>`'${i.node.inputs[w]}': ${v.type}[${v.dims.join(",")}]`).join(", ")})`);let g=await this.profiler.event("node",i.node.name,async()=>i.op.impl(u,d,i.op.context));if(g.length!==i.node.outputs.length)throw new Error("the size of output does not match model definition.");g.forEach((v,w)=>{let x=i.node.outputs[w];if(this._values[x])throw new Error(`output [${x}] already has value: op:${i.node.name}`);this._values[x]=v});let b=new Set;g.forEach((v,w)=>{let x=i.node.outputs[w];for(let T of o[x].to){let O=n[T],P=!0;for(let I of O.inputs)if(!this._values[I]){P=!1;break}P&&b.add(T)}}),a.push(...b)}let t=[];for(let r=0;r<this.graph.getOutputIndices().length;r++){let i=this.graph.getOutputIndices()[r],l=this._values[i];if(l===void 0)throw new Error(`required output [${i}] does not have value`);i===0?await l.getData():l.data,t.push(l)}return m.Logger.verbose("ExecPlan","disposing of inferenceHandler"),u.dispose(),t})}}},4662:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Graph=void 0;let m=y(6874),f=y(5127),h=y(2446),p=y(9240),u=y(7273);var s=f.onnxruntime.experimental.fbs;c.Graph={from:(e,t)=>new n(e,t)};class a{constructor(t){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,t&&(this.type=u.ProtoUtil.tensorValueTypeFromProto(t.type.tensorType))}get from(){return this._from}get to(){return this._to}}class o{constructor(t,r){t instanceof h.onnx.NodeProto?(this.name=t.name,this.opType=t.opType,this.attributes=new m.Attribute(t.attribute)):t instanceof s.Node&&(this.name=r??t.name(),this.opType=t.opType(),this.attributes=new m.Attribute(u.ProtoUtil.tensorAttributesFromORTFormat(t))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class n{constructor(t,r){if(!t)throw new TypeError("graph is empty");this.buildGraph(t),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(t){if(t instanceof h.onnx.GraphProto)this.buildGraphFromOnnxFormat(t);else{if(!(t instanceof s.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(t)}}buildGraphFromOnnxFormat(t){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!t.input)throw new Error("missing information in graph: input");let l=[];for(let d of t.input){if(r.has(d.name))throw new Error(`duplicated input name: ${d.name}`);let g=this._allData.push(new a(d))-1;r.set(d.name,g),l.push(d.name)}if(!t.initializer)throw new Error("missing information in graph: initializer");for(let d of t.initializer){let g=r.get(d.name);if(g===void 0){let b=new a;b.type={shape:{dims:u.ProtoUtil.tensorDimsFromProto(d.dims)},tensorType:u.ProtoUtil.tensorDataTypeFromProto(d.dataType)},g=this._allData.push(b)-1,r.set(d.name,g)}this._allData[g]._from=-1,this._allData[g].tensor=p.Tensor.fromProto(d)}for(let d=0;d<this._allData.length;d++)this._allData[d].tensor||(this._allInputIndices.push(d),this._allInputNames.push(l[d]));if(!t.output)throw new Error("missing information in graph: output");for(let d of t.output){if(r.has(d.name))throw new Error(`duplicated output name: ${d.name}`);let g=this._allData.push(new a(d))-1;r.set(d.name,g),this._allOutputIndices.push(g),this._allOutputNames.push(d.name)}if(!t.node)throw new Error("missing information in graph: node");for(let d of t.node){if(!d.name)for(let b=0;;b++){let v=`unnamed_${d.opType}_${b}`;if(!i.has(v)){d.name=v;break}}if(i.has(d.name))throw new Error(`duplicated node name: ${d.name}`);let g=this._nodes.push(new o(d))-1;i.set(d.name,g)}for(let d=0;d<this._nodes.length;d++){let g=this._nodes[d],b=t.node[d];if(!b.output)throw new Error(`missing output for node: ${b.name}`);for(let v of b.output){let w=r.get(v);if(w===void 0&&(w=this._allData.push(new a)-1,r.set(v,w)),g.outputs.push(w),this._allData[w]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${w}`);if(this._allData[w]._from=d,b.opType==="Constant"){if(!b.attribute||b.attribute.length!==1||!b.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!b.output||b.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");g.outputs.pop(),g.executeNode=!1,this._allData[w]._from=-1,this._allData[w].tensor=p.Tensor.fromProto(b.attribute[0].t)}}}for(let d=0;d<this._nodes.length;d++){let g=this._nodes[d],b=t.node[d];if(!b.input)throw new Error(`missing input for node: ${b.name}`);for(let v of b.input){let w=r.get(v);if(w===void 0){if(v===""&&(b.input.length===3||b.input.length===4)&&b.opType==="Resize")continue;throw new Error(`unrecognized input '${v}' for node: ${b.name}`)}g.inputs.push(w),this._allData[w]._to.push(d)}}return!0}buildGraphFromOrtFormat(t){var r,i,l;let d=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let g=new Map,b=[];for(let v=0;v<t.inputsLength();v++){let w=t.inputs(v);if(d.has(w))throw new Error(`duplicated input name: ${w}`);for(let x=0;x<t.nodeArgsLength();x++)if(((r=t.nodeArgs(x))===null||r===void 0?void 0:r.name())===w){let T=new a;if(((l=(i=t.nodeArgs(x))===null||i===void 0?void 0:i.type())===null||l===void 0?void 0:l.valueType())!==s.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let O=t.nodeArgs(x).type().value(new s.TensorTypeAndShape),P=u.ProtoUtil.tensorDataTypeFromProto(O.elemType()),I=O.shape(),R=[];for(let A=0;A<I.dimLength();A++)R.push(u.LongUtil.longToNumber(I.dim(A).value().dimValue()));T.type={shape:{dims:R},tensorType:P};let j=this._allData.push(T)-1;d.set(w,j),b.push(w)}}for(let v=0;v<t.initializersLength();v++){let w=t.initializers(v),x=d.get(w.name());if(x===void 0){let T=new a,O=u.ProtoUtil.tensorDimsFromORTFormat(w),P=u.ProtoUtil.tensorDataTypeFromProto(w.dataType());T.type={shape:{dims:O},tensorType:P},x=this._allData.push(T)-1,d.set(w.name(),x)}this._allData[x]._from=-1,this._allData[x].tensor=p.Tensor.fromOrtTensor(w)}for(let v=0;v<this._allData.length;v++)this._allData[v].tensor||(this._allInputIndices.push(v),this._allInputNames.push(b[v]));for(let v=0;v<t.outputsLength();v++){let w=t.outputs(v);if(d.has(w))throw new Error(`duplicated output name: ${w}`);let x=this._allData.push(new a)-1;d.set(w,x),this._allOutputIndices.push(x),this._allOutputNames.push(w)}if(!t.nodes)throw new Error("missing information in graph: node");for(let v=0;v<t.nodesLength();v++){let w=t.nodes(v),x=w.name();if(!x)for(let O=0;x=`unnamed_${w.opType()}_${O}`,g.has(x);O++);if(g.has(x))throw new Error(`duplicated node name: ${x}`);let T=this._nodes.push(new o(w,x))-1;g.set(x,T)}for(let v=0;v<this._nodes.length;v++){let w=this._nodes[v],x=t.nodes(v);if(x==null)throw new Error(`No node exists at index ${v}`);if(x?.outputsLength()===0)throw new Error(`missing output for node: ${x.name}`);for(let T=0;T<x?.outputsLength();T++){let O=x?.outputs(T),P=d.get(O);if(P===void 0&&(P=this._allData.push(new a)-1,d.set(O,P)),w.outputs.push(P),this._allData[P]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${P}`);if(this._allData[P]._from=v,x.opType()==="Constant"){if(x.attributesLength()!==1||!x.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(x.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");w.outputs.pop(),w.executeNode=!1,this._allData[P]._from=-1,this._allData[P].tensor=p.Tensor.fromOrtTensor(x.attributes(0).t())}}}for(let v=0;v<this._nodes.length;v++){let w=this._nodes[v],x=t.nodes(v);if(x.inputsLength()===0)throw new Error(`missing input for node: ${x.name}`);for(let T=0;T<x.inputsLength();T++){let O=x.inputs(T),P=d.get(O);if(P===void 0)throw new Error(`unrecognized input '${O}' for node: ${x.name()}`);w.inputs.push(P),this._allData[P]._to.push(v)}}}checkIsAcyclic(){let t=new Set;this._allInputIndices.forEach(l=>{this._allData[l]._to.forEach(d=>{t.add(d)})});let r=Array.from(t),i=new Array(this._nodes.length).fill("white");for(;r.length>0;){let l=r.pop();i[l]==="gray"?i[l]="black":(r.push(l),i[l]="gray",this._nodes[l].outputs.forEach(d=>{let g=this._allData[d];if(g.tensor!==void 0)throw new Error("node outputs should not be initialized");if(g._from!==l)throw new Error("from property of the Value object doesn't match index of Node being processed");g._to.forEach(b=>{if(i[b]==="gray")throw new Error("model graph is cyclic");i[b]==="white"&&r.push(b)})}))}}transformGraph(t){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),t&&t.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let t=0,r=new Array(this._nodes.length,0),i=0;for(let l=0;l<this._nodes.length;l++)r[l]=i,this._nodes[l].executeNode?(i!==l&&(this._nodes[i]=this._nodes[l]),i++):this._nodes[l].outputs.forEach(d=>{this._allData[d]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let l=0;l<this._allData.length;l++){let d=this._allData[l];d._from!==void 0&&d._from!==-1&&d._from!==-2&&(d._from=r[d._from]);for(let g=0;g<d._to.length;g++){if(!(d._to[g]>=0))throw new Error("Trying to update a removed node");d._to[g]=r[d._to[g]]}}t=0;for(let l=0;l<this._allData.length;l++)if(this._allData[l].from!==-2||this._allOutputIndices.indexOf(l+t)!==-1){if(t>0){let d=-1;this._allData[l].from!==void 0&&this._allData[l].from!==-1?(d=this._nodes[this._allData[l].from].outputs.indexOf(l+t),d!==-1&&(this._nodes[this._allData[l].from].outputs[d]=l)):(d=this._allInputIndices.indexOf(l+t),d!==-1&&(this._allInputIndices[d]=l)),this._allData[l].to.forEach(g=>{d=this._nodes[g].inputs.indexOf(l+t),d!==-1&&(this._nodes[g].inputs[d]=l)}),this._allData[l].to.length===0&&(d=this._allOutputIndices.indexOf(l+t),d!==-1&&(this._allOutputIndices[d]=l))}}else t++,this._allData.splice(l,1),l--}deleteNode(t){let r=this._nodes[t];if(r.outputs.length>1){for(let b=1;b<r.outputs.length;b++)if(this._allData[r.outputs[b]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let i=r.inputs[0],l=r.outputs[0],d=this._allData[l].to;for(let b=0;b<r.inputs.length;b++){let v=this._allData[r.inputs[b]].to.indexOf(t);if(v===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[b]].to.splice(v,1)}this._allData[l]._to=[];let g=this._allOutputIndices.indexOf(l);if(g!==-1&&(this._allOutputIndices[g]=i),d&&d.length>0)for(let b of d){let v=this._nodes[b].inputs.indexOf(l);if(v===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[b].inputs[v]=i,this._allData[i].to.push(b)}}removeAllDropoutNodes(){let t=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(t)}t++}}removeAllIdentityNodes(){let t=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(t),t++}isActivation(t){switch(t.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let t of this._nodes)if(t.opType==="Conv"){let r=this._allData[t.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let i=this._nodes[r[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{t.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{t.attributes.set("activation_params","floats",[u.MIN_CLIP,u.MAX_CLIP])}else{if(!(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0))continue;t.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]])}t.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}},1315:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.now=c.Profiler=c.Logger=void 0;let y={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},m={none:new class{log(o,n,e){}},console:new class{log(o,n,e){console.log(`${this.color(o)} ${e?"\x1B[35m"+e+"\x1B[0m ":""}${n}`)}color(o){switch(o){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${o}`)}}}},f={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},h={"":f};function p(o,n,e,t){if(n===void 0)return r=o,{verbose:p.verbose.bind(null,r),info:p.info.bind(null,r),warning:p.warning.bind(null,r),error:p.error.bind(null,r),fatal:p.fatal.bind(null,r)};if(e===void 0)u(o,n);else if(typeof e=="number"&&t===void 0)u(o,n);else if(typeof e=="string"&&t===void 0)u(o,e,0,n);else{if(typeof e!="string"||typeof t!="number")throw new TypeError("input is valid");u(o,e,0,n)}var r}function u(o,n,e,t){let r=h[t||""]||h[""];y[o]<y[r.minimalSeverity]||(r.logDateTime&&(n=`${new Date().toISOString()}|${n}`),r.logSourceLocation,m[r.provider].log(o,n,t))}(function(o){function n(t){h={},e("",t||{})}function e(t,r){if(t==="*")n(r);else{let i=h[t]||f;h[t]={provider:r.provider||i.provider,minimalSeverity:r.minimalSeverity||i.minimalSeverity,logDateTime:r.logDateTime===void 0?i.logDateTime:r.logDateTime,logSourceLocation:r.logSourceLocation===void 0?i.logSourceLocation:r.logSourceLocation}}}o.verbose=function(t,r){o("verbose",t,r)},o.info=function(t,r){o("info",t,r)},o.warning=function(t,r){o("warning",t,r)},o.error=function(t,r){o("error",t,r)},o.fatal=function(t,r){o("fatal",t,r)},o.reset=n,o.set=e,o.setWithEnv=function(t){let r={};t.logLevel&&(r.minimalSeverity=t.logLevel),e("",r)}})(p||(p={})),c.Logger=p;class s{constructor(n,e,t,r,i,l){this.category=n,this.name=e,this.startTime=t,this.endCallback=r,this.timer=i,this.ctx=l}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class a{constructor(n,e,t,r){this.category=n,this.name=e,this.startTime=t,this.endTime=r}}c.Profiler=class{static create(o){return o===void 0?new this:new this(o.maxNumberEvents,o.flushBatchSize,o.flushIntervalInMilliseconds)}constructor(o,n,e){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=o===void 0?1e4:o,this._flushBatchSize=n===void 0?10:n,this._flushIntervalInMilliseconds=e===void 0?5e3:e}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,c.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(o,n,e,t){let r=this._started?this.begin(o,n,t):void 0,i=!1,l=e();if(l&&typeof l.then=="function")return i=!0,new Promise((d,g)=>{l.then(async b=>{r&&await r.end(),d(b)},async b=>{r&&await r.end(),g(b)})});if(!i&&r){let d=r.end();if(d&&typeof d.then=="function")return new Promise((g,b)=>{d.then(()=>{g(l)},v=>{b(v)})})}return l}begin(o,n,e){if(!this._started)throw new Error("profiler is not started yet");if(e===void 0){let t=(0,c.now)();return this.flush(t),new s(o,n,t,r=>this.endSync(r))}{let t=e.beginTimer();return new s(o,n,0,async r=>this.end(r),t,e)}}async end(o){let n=await o.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,n)),this.flush(n))}endSync(o){let n=(0,c.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,n)),this.flush(n))}logOneEvent(o){c.Logger.verbose(`Profiler.${o.category}`,`${(o.endTime-o.startTime).toFixed(2)}ms on event '${o.name}' at ${o.endTime.toFixed(2)}`)}flush(o){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||o-this._flushTime>=this._flushIntervalInMilliseconds){for(let n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,c.now)()}}get started(){return this._started}},c.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Model=void 0;let m=y(5686),f=y(4662),h=y(5127),p=y(2446),u=y(7273);var s=h.onnxruntime.experimental.fbs;c.Model=class{constructor(){}load(a,o,n){if(!n)try{return void this.loadFromOnnxFormat(a,o)}catch(e){if(n!==void 0)throw e}this.loadFromOrtFormat(a,o)}loadFromOnnxFormat(a,o){let n=p.onnx.ModelProto.decode(a);if(u.LongUtil.longToNumber(n.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=n.opsetImport.map(e=>({domain:e.domain,version:u.LongUtil.longToNumber(e.version)})),this._graph=f.Graph.from(n.graph,o)}loadFromOrtFormat(a,o){let n=new m.flatbuffers.ByteBuffer(a),e=s.InferenceSession.getRootAsInferenceSession(n).model();if(u.LongUtil.longToNumber(e.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let t=0;t<e.opsetImportLength();t++){let r=e.opsetImport(t);this._opsets.push({domain:r?.domain(),version:u.LongUtil.longToNumber(r.version())})}this._graph=f.Graph.from(e.graph(),o)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.FLOAT_TYPES=c.INT_TYPES=c.NUMBER_TYPES=void 0,c.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],c.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],c.FLOAT_TYPES=["float32","float64"]},5881:(M,c)=>{"use strict";function y(m,f){if(f.endsWith("+")){let h=Number.parseInt(f.substring(0,f.length-1),10);return!isNaN(h)&&h<=m}if(f.split("-").length===2){let h=f.split("-"),p=Number.parseInt(h[0],10),u=Number.parseInt(h[1],10);return!isNaN(p)&&!isNaN(u)&&p<=m&&m<=u}return Number.parseInt(f,10)===m}Object.defineProperty(c,"__esModule",{value:!0}),c.resolveOperator=void 0,c.resolveOperator=function(m,f,h){for(let p of h){let u=p[0],s=p[1],a=p[2],o=p[3],n=p[4];if(m.opType===u){for(let e of f)if((e.domain===s||e.domain==="ai.onnx"&&s==="")&&y(e.version,a))return{opImpl:o,opInit:n}}}throw new TypeError(`cannot resolve operator '${m.opType}' with opsets: ${f.map(p=>`${p.domain||"ai.onnx"} v${p.version}`).join(", ")}`)}},5127:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.onnxruntime=void 0;let m=y(5686);var f,h;f=c.onnxruntime||(c.onnxruntime={}),function(p){let u;(function(s){s[s.UNDEFINED=0]="UNDEFINED",s[s.FLOAT=1]="FLOAT",s[s.INT=2]="INT",s[s.STRING=3]="STRING",s[s.TENSOR=4]="TENSOR",s[s.GRAPH=5]="GRAPH",s[s.FLOATS=6]="FLOATS",s[s.INTS=7]="INTS",s[s.STRINGS=8]="STRINGS",s[s.TENSORS=9]="TENSORS",s[s.GRAPHS=10]="GRAPHS",s[s.SPARSE_TENSOR=11]="SPARSE_TENSOR",s[s.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(u=p.AttributeType||(p.AttributeType={}))}((h=f.experimental||(f.experimental={})).fbs||(h.fbs={})),function(p){(function(u){(function(s){let a;(function(o){o[o.UNKNOWN=0]="UNKNOWN",o[o.VALUE=1]="VALUE",o[o.PARAM=2]="PARAM"})(a=s.DimensionValueType||(s.DimensionValueType={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){let a;(function(o){o[o.UNDEFINED=0]="UNDEFINED",o[o.FLOAT=1]="FLOAT",o[o.UINT8=2]="UINT8",o[o.INT8=3]="INT8",o[o.UINT16=4]="UINT16",o[o.INT16=5]="INT16",o[o.INT32=6]="INT32",o[o.INT64=7]="INT64",o[o.STRING=8]="STRING",o[o.BOOL=9]="BOOL",o[o.FLOAT16=10]="FLOAT16",o[o.DOUBLE=11]="DOUBLE",o[o.UINT32=12]="UINT32",o[o.UINT64=13]="UINT64",o[o.COMPLEX64=14]="COMPLEX64",o[o.COMPLEX128=15]="COMPLEX128",o[o.BFLOAT16=16]="BFLOAT16",o[o.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",o[o.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",o[o.FLOAT8E5M2=19]="FLOAT8E5M2",o[o.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"})(a=s.TensorDataType||(s.TensorDataType={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){let a;(function(o){o[o.Primitive=0]="Primitive",o[o.Fused=1]="Fused"})(a=s.NodeType||(s.NodeType={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){let a;(function(o){o[o.NONE=0]="NONE",o[o.tensor_type=1]="tensor_type",o[o.sequence_type=2]="sequence_type",o[o.map_type=3]="map_type"})(a=s.TypeInfoValue||(s.TypeInfoValue={}))})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsShape(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsShape(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}dim(n,e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new p.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}dimLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}static startShape(n){n.startObject(1)}static addDim(n,e){n.addFieldOffset(0,e,0)}static createDimVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startDimVector(n,e){n.startVector(4,e,4)}static endShape(n){return n.endObject()}static createShape(n,e){return a.startShape(n),a.addDim(n,e),a.endShape(n)}}s.Shape=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsDimension(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimension(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}value(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}denotation(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}static startDimension(n){n.startObject(2)}static addValue(n,e){n.addFieldOffset(0,e,0)}static addDenotation(n,e){n.addFieldOffset(1,e,0)}static endDimension(n){return n.endObject()}static createDimension(n,e,t){return a.startDimension(n),a.addValue(n,e),a.addDenotation(n,t),a.endDimension(n)}}s.Dimension=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsDimensionValue(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsDimensionValue(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}dimType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt8(this.bb_pos+n):p.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}dimParam(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}static startDimensionValue(n){n.startObject(3)}static addDimType(n,e){n.addFieldInt8(0,e,p.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(n,e){n.addFieldInt64(1,e,n.createLong(0,0))}static addDimParam(n,e){n.addFieldOffset(2,e,0)}static endDimensionValue(n){return n.endObject()}static createDimensionValue(n,e,t,r){return a.startDimensionValue(n),a.addDimType(n,e),a.addDimValue(n,t),a.addDimParam(n,r),a.endDimensionValue(n)}}s.DimensionValue=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTensorTypeAndShape(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensorTypeAndShape(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}elemType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.TensorDataType.UNDEFINED}shape(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startTensorTypeAndShape(n){n.startObject(2)}static addElemType(n,e){n.addFieldInt32(0,e,p.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(n,e){n.addFieldOffset(1,e,0)}static endTensorTypeAndShape(n){return n.endObject()}static createTensorTypeAndShape(n,e,t){return a.startTensorTypeAndShape(n),a.addElemType(n,e),a.addShape(n,t),a.endTensorTypeAndShape(n)}}s.TensorTypeAndShape=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsMapType(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsMapType(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}keyType(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.TensorDataType.UNDEFINED}valueType(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startMapType(n){n.startObject(2)}static addKeyType(n,e){n.addFieldInt32(0,e,p.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(n,e){n.addFieldOffset(1,e,0)}static endMapType(n){return n.endObject()}static createMapType(n,e,t){return a.startMapType(n),a.addKeyType(n,e),a.addValueType(n,t),a.endMapType(n)}}s.MapType=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSequenceType(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSequenceType(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}elemType(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSequenceType(n){n.startObject(1)}static addElemType(n,e){n.addFieldOffset(0,e,0)}static endSequenceType(n){return n.endObject()}static createSequenceType(n,e){return a.startSequenceType(n),a.addElemType(n,e),a.endSequenceType(n)}}s.SequenceType=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(u.fbs||(u.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(s,a){return this.bb_pos=s,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(s,a,o,n){return s.prep(4,12),s.writeInt32(n),s.writeInt32(o),s.writeInt32(a),s.offset()}}})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsNodeEdge(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNodeEdge(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}nodeIndex(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readUint32(this.bb_pos+n):0}inputEdges(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+t)+12*n,this.bb):null}inputEdgesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}outputEdges(n,e){let t=this.bb.__offset(this.bb_pos,8);return t?(e||new p.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+t)+12*n,this.bb):null}outputEdgesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNodeEdge(n){n.startObject(3)}static addNodeIndex(n,e){n.addFieldInt32(0,e,0)}static addInputEdges(n,e){n.addFieldOffset(1,e,0)}static startInputEdgesVector(n,e){n.startVector(12,e,4)}static addOutputEdges(n,e){n.addFieldOffset(2,e,0)}static startOutputEdgesVector(n,e){n.startVector(12,e,4)}static endNodeEdge(n){return n.endObject()}static createNodeEdge(n,e,t,r){return a.startNodeEdge(n),a.addNodeIndex(n,e),a.addInputEdges(n,t),a.addOutputEdges(n,r),a.endNodeEdge(n)}}s.NodeEdge=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsNode(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsNode(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}domain(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}sinceVersion(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):0}index(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readUint32(this.bb_pos+n):0}opType(n){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,n):null}type(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.NodeType.Primitive}executionProviderType(n){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,n):null}inputs(n,e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}attributes(n,e){let t=this.bb.__offset(this.bb_pos,24);return t?(e||new p.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}attributesLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCounts(n){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*n):0}inputArgCountsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}inputArgCountsArray(){let n=this.bb.__offset(this.bb_pos,26);return n?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}implicitInputs(n,e){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}implicitInputsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startNode(n){n.startObject(13)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addDomain(n,e){n.addFieldOffset(2,e,0)}static addSinceVersion(n,e){n.addFieldInt32(3,e,0)}static addIndex(n,e){n.addFieldInt32(4,e,0)}static addOpType(n,e){n.addFieldOffset(5,e,0)}static addType(n,e){n.addFieldInt32(6,e,p.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(n,e){n.addFieldOffset(7,e,0)}static addInputs(n,e){n.addFieldOffset(8,e,0)}static createInputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startInputsVector(n,e){n.startVector(4,e,4)}static addOutputs(n,e){n.addFieldOffset(9,e,0)}static createOutputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startOutputsVector(n,e){n.startVector(4,e,4)}static addAttributes(n,e){n.addFieldOffset(10,e,0)}static createAttributesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startAttributesVector(n,e){n.startVector(4,e,4)}static addInputArgCounts(n,e){n.addFieldOffset(11,e,0)}static createInputArgCountsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addInt32(e[t]);return n.endVector()}static startInputArgCountsVector(n,e){n.startVector(4,e,4)}static addImplicitInputs(n,e){n.addFieldOffset(12,e,0)}static createImplicitInputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startImplicitInputsVector(n,e){n.startVector(4,e,4)}static endNode(n){return n.endObject()}static createNode(n,e,t,r,i,l,d,g,b,v,w,x,T,O){return a.startNode(n),a.addName(n,e),a.addDocString(n,t),a.addDomain(n,r),a.addSinceVersion(n,i),a.addIndex(n,l),a.addOpType(n,d),a.addType(n,g),a.addExecutionProviderType(n,b),a.addInputs(n,v),a.addOutputs(n,w),a.addAttributes(n,x),a.addInputArgCounts(n,T),a.addImplicitInputs(n,O),a.endNode(n)}}s.Node=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsValueInfo(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsValueInfo(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}type(n){let e=this.bb.__offset(this.bb_pos,8);return e?(n||new p.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startValueInfo(n){n.startObject(3)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addType(n,e){n.addFieldOffset(2,e,0)}static endValueInfo(n){return n.endObject()}static createValueInfo(n,e,t,r){return a.startValueInfo(n),a.addName(n,e),a.addDocString(n,t),a.addType(n,r),a.endValueInfo(n)}}s.ValueInfo=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTypeInfo(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTypeInfo(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}denotation(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}valueType(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readUint8(this.bb_pos+n):p.experimental.fbs.TypeInfoValue.NONE}value(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(n,this.bb_pos+e):null}static startTypeInfo(n){n.startObject(3)}static addDenotation(n,e){n.addFieldOffset(0,e,0)}static addValueType(n,e){n.addFieldInt8(1,e,p.experimental.fbs.TypeInfoValue.NONE)}static addValue(n,e){n.addFieldOffset(2,e,0)}static endTypeInfo(n){return n.endObject()}static createTypeInfo(n,e,t,r){return a.startTypeInfo(n),a.addDenotation(n,e),a.addValueType(n,t),a.addValue(n,r),a.endTypeInfo(n)}}s.TypeInfo=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsOperatorSetId(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsOperatorSetId(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}domain(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}version(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}static startOperatorSetId(n){n.startObject(2)}static addDomain(n,e){n.addFieldOffset(0,e,0)}static addVersion(n,e){n.addFieldInt64(1,e,n.createLong(0,0))}static endOperatorSetId(n){return n.endObject()}static createOperatorSetId(n,e,t){return a.startOperatorSetId(n),a.addDomain(n,e),a.addVersion(n,t),a.endOperatorSetId(n)}}s.OperatorSetId=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsTensor(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsTensor(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}dims(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}dataType(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.TensorDataType.UNDEFINED}rawData(n){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+n):0}rawDataLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}rawDataArray(){let n=this.bb.__offset(this.bb_pos,12);return n?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}stringData(n,e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}stringDataLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}static startTensor(n){n.startObject(6)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addDims(n,e){n.addFieldOffset(2,e,0)}static createDimsVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startDimsVector(n,e){n.startVector(8,e,8)}static addDataType(n,e){n.addFieldInt32(3,e,p.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(n,e){n.addFieldOffset(4,e,0)}static createRawDataVector(n,e){n.startVector(1,e.length,1);for(let t=e.length-1;t>=0;t--)n.addInt8(e[t]);return n.endVector()}static startRawDataVector(n,e){n.startVector(1,e,1)}static addStringData(n,e){n.addFieldOffset(5,e,0)}static createStringDataVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startStringDataVector(n,e){n.startVector(4,e,4)}static endTensor(n){return n.endObject()}static createTensor(n,e,t,r,i,l,d){return a.startTensor(n),a.addName(n,e),a.addDocString(n,t),a.addDims(n,r),a.addDataType(n,i),a.addRawData(n,l),a.addStringData(n,d),a.endTensor(n)}}s.Tensor=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSparseTensor(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSparseTensor(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}values(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}indices(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}dims(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}dimsLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSparseTensor(n){n.startObject(3)}static addValues(n,e){n.addFieldOffset(0,e,0)}static addIndices(n,e){n.addFieldOffset(1,e,0)}static addDims(n,e){n.addFieldOffset(2,e,0)}static createDimsVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startDimsVector(n,e){n.startVector(8,e,8)}static endSparseTensor(n){return n.endObject()}static createSparseTensor(n,e,t,r){return a.startSparseTensor(n),a.addValues(n,e),a.addIndices(n,t),a.addDims(n,r),a.endSparseTensor(n)}}s.SparseTensor=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsAttribute(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsAttribute(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}name(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}docString(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,n):null}type(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.readInt32(this.bb_pos+n):p.experimental.fbs.AttributeType.UNDEFINED}f(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readFloat32(this.bb_pos+n):0}i(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}s(n){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,n):null}t(n){let e=this.bb.__offset(this.bb_pos,16);return e?(n||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}g(n){let e=this.bb.__offset(this.bb_pos,18);return e?(n||new p.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}floats(n){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*n):0}floatsLength(){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__vector_len(this.bb_pos+n):0}floatsArray(){let n=this.bb.__offset(this.bb_pos,20);return n?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}ints(n){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}intsLength(){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__vector_len(this.bb_pos+n):0}strings(n,e){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}stringsLength(){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__vector_len(this.bb_pos+n):0}tensors(n,e){let t=this.bb.__offset(this.bb_pos,26);return t?(e||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}tensorsLength(){let n=this.bb.__offset(this.bb_pos,26);return n?this.bb.__vector_len(this.bb_pos+n):0}graphs(n,e){let t=this.bb.__offset(this.bb_pos,28);return t?(e||new p.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}graphsLength(){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__vector_len(this.bb_pos+n):0}static startAttribute(n){n.startObject(13)}static addName(n,e){n.addFieldOffset(0,e,0)}static addDocString(n,e){n.addFieldOffset(1,e,0)}static addType(n,e){n.addFieldInt32(2,e,p.experimental.fbs.AttributeType.UNDEFINED)}static addF(n,e){n.addFieldFloat32(3,e,0)}static addI(n,e){n.addFieldInt64(4,e,n.createLong(0,0))}static addS(n,e){n.addFieldOffset(5,e,0)}static addT(n,e){n.addFieldOffset(6,e,0)}static addG(n,e){n.addFieldOffset(7,e,0)}static addFloats(n,e){n.addFieldOffset(8,e,0)}static createFloatsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addFloat32(e[t]);return n.endVector()}static startFloatsVector(n,e){n.startVector(4,e,4)}static addInts(n,e){n.addFieldOffset(9,e,0)}static createIntsVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startIntsVector(n,e){n.startVector(8,e,8)}static addStrings(n,e){n.addFieldOffset(10,e,0)}static createStringsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startStringsVector(n,e){n.startVector(4,e,4)}static addTensors(n,e){n.addFieldOffset(11,e,0)}static createTensorsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startTensorsVector(n,e){n.startVector(4,e,4)}static addGraphs(n,e){n.addFieldOffset(12,e,0)}static createGraphsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startGraphsVector(n,e){n.startVector(4,e,4)}static endAttribute(n){return n.endObject()}static createAttribute(n,e,t,r,i,l,d,g,b,v,w,x,T,O){return a.startAttribute(n),a.addName(n,e),a.addDocString(n,t),a.addType(n,r),a.addF(n,i),a.addI(n,l),a.addS(n,d),a.addT(n,g),a.addG(n,b),a.addFloats(n,v),a.addInts(n,w),a.addStrings(n,x),a.addTensors(n,T),a.addGraphs(n,O),a.endAttribute(n)}}s.Attribute=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsGraph(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsGraph(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}initializers(n,e){let t=this.bb.__offset(this.bb_pos,4);return t?(e||new p.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}initializersLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeArgs(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}nodeArgsLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}nodes(n,e){let t=this.bb.__offset(this.bb_pos,8);return t?(e||new p.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}nodesLength(){let n=this.bb.__offset(this.bb_pos,8);return n?this.bb.__vector_len(this.bb_pos+n):0}maxNodeIndex(){let n=this.bb.__offset(this.bb_pos,10);return n?this.bb.readUint32(this.bb_pos+n):0}nodeEdges(n,e){let t=this.bb.__offset(this.bb_pos,12);return t?(e||new p.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}nodeEdgesLength(){let n=this.bb.__offset(this.bb_pos,12);return n?this.bb.__vector_len(this.bb_pos+n):0}inputs(n,e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}inputsLength(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__vector_len(this.bb_pos+n):0}outputs(n,e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb.__vector(this.bb_pos+t)+4*n,e):null}outputsLength(){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__vector_len(this.bb_pos+n):0}sparseInitializers(n,e){let t=this.bb.__offset(this.bb_pos,18);return t?(e||new p.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}sparseInitializersLength(){let n=this.bb.__offset(this.bb_pos,18);return n?this.bb.__vector_len(this.bb_pos+n):0}static startGraph(n){n.startObject(8)}static addInitializers(n,e){n.addFieldOffset(0,e,0)}static createInitializersVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startInitializersVector(n,e){n.startVector(4,e,4)}static addNodeArgs(n,e){n.addFieldOffset(1,e,0)}static createNodeArgsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startNodeArgsVector(n,e){n.startVector(4,e,4)}static addNodes(n,e){n.addFieldOffset(2,e,0)}static createNodesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startNodesVector(n,e){n.startVector(4,e,4)}static addMaxNodeIndex(n,e){n.addFieldInt32(3,e,0)}static addNodeEdges(n,e){n.addFieldOffset(4,e,0)}static createNodeEdgesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startNodeEdgesVector(n,e){n.startVector(4,e,4)}static addInputs(n,e){n.addFieldOffset(5,e,0)}static createInputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startInputsVector(n,e){n.startVector(4,e,4)}static addOutputs(n,e){n.addFieldOffset(6,e,0)}static createOutputsVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startOutputsVector(n,e){n.startVector(4,e,4)}static addSparseInitializers(n,e){n.addFieldOffset(7,e,0)}static createSparseInitializersVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startSparseInitializersVector(n,e){n.startVector(4,e,4)}static endGraph(n){return n.endObject()}static createGraph(n,e,t,r,i,l,d,g,b){return a.startGraph(n),a.addInitializers(n,e),a.addNodeArgs(n,t),a.addNodes(n,r),a.addMaxNodeIndex(n,i),a.addNodeEdges(n,l),a.addInputs(n,d),a.addOutputs(n,g),a.addSparseInitializers(n,b),a.endGraph(n)}}s.Graph=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsModel(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsModel(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}irVersion(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}opsetImport(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}opsetImportLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}producerName(n){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,n):null}producerVersion(n){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,n):null}domain(n){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,n):null}modelVersion(){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.readInt64(this.bb_pos+n):this.bb.createLong(0,0)}docString(n){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,n):null}graph(n){let e=this.bb.__offset(this.bb_pos,18);return e?(n||new p.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}graphDocString(n){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,n):null}static startModel(n){n.startObject(9)}static addIrVersion(n,e){n.addFieldInt64(0,e,n.createLong(0,0))}static addOpsetImport(n,e){n.addFieldOffset(1,e,0)}static createOpsetImportVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startOpsetImportVector(n,e){n.startVector(4,e,4)}static addProducerName(n,e){n.addFieldOffset(2,e,0)}static addProducerVersion(n,e){n.addFieldOffset(3,e,0)}static addDomain(n,e){n.addFieldOffset(4,e,0)}static addModelVersion(n,e){n.addFieldInt64(5,e,n.createLong(0,0))}static addDocString(n,e){n.addFieldOffset(6,e,0)}static addGraph(n,e){n.addFieldOffset(7,e,0)}static addGraphDocString(n,e){n.addFieldOffset(8,e,0)}static endModel(n){return n.endObject()}static createModel(n,e,t,r,i,l,d,g,b,v){return a.startModel(n),a.addIrVersion(n,e),a.addOpsetImport(n,t),a.addProducerName(n,r),a.addProducerVersion(n,i),a.addDomain(n,l),a.addModelVersion(n,d),a.addDocString(n,g),a.addGraph(n,b),a.addGraphDocString(n,v),a.endModel(n)}}s.Model=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsKernelCreateInfos(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsKernelCreateInfos(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}nodeIndices(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*n):0}nodeIndicesLength(){let n=this.bb.__offset(this.bb_pos,4);return n?this.bb.__vector_len(this.bb_pos+n):0}nodeIndicesArray(){let n=this.bb.__offset(this.bb_pos,4);return n?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+n),this.bb.__vector_len(this.bb_pos+n)):null}kernelDefHashes(n){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*n):this.bb.createLong(0,0)}kernelDefHashesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startKernelCreateInfos(n){n.startObject(2)}static addNodeIndices(n,e){n.addFieldOffset(0,e,0)}static createNodeIndicesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addInt32(e[t]);return n.endVector()}static startNodeIndicesVector(n,e){n.startVector(4,e,4)}static addKernelDefHashes(n,e){n.addFieldOffset(1,e,0)}static createKernelDefHashesVector(n,e){n.startVector(8,e.length,8);for(let t=e.length-1;t>=0;t--)n.addInt64(e[t]);return n.endVector()}static startKernelDefHashesVector(n,e){n.startVector(8,e,8)}static endKernelCreateInfos(n){return n.endObject()}static createKernelCreateInfos(n,e,t){return a.startKernelCreateInfos(n),a.addNodeIndices(n,e),a.addKernelDefHashes(n,t),a.endKernelCreateInfos(n)}}s.KernelCreateInfos=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSubGraphSessionState(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSubGraphSessionState(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}graphId(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}sessionState(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSubGraphSessionState(n){n.startObject(2)}static addGraphId(n,e){n.addFieldOffset(0,e,0)}static addSessionState(n,e){n.addFieldOffset(1,e,0)}static endSubGraphSessionState(n){let e=n.endObject();return n.requiredField(e,4),e}static createSubGraphSessionState(n,e,t){return a.startSubGraphSessionState(n),a.addGraphId(n,e),a.addSessionState(n,t),a.endSubGraphSessionState(n)}}s.SubGraphSessionState=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsSessionState(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsSessionState(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}kernels(n){let e=this.bb.__offset(this.bb_pos,4);return e?(n||new p.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}subGraphSessionStates(n,e){let t=this.bb.__offset(this.bb_pos,6);return t?(e||new p.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+t)+4*n),this.bb):null}subGraphSessionStatesLength(){let n=this.bb.__offset(this.bb_pos,6);return n?this.bb.__vector_len(this.bb_pos+n):0}static startSessionState(n){n.startObject(2)}static addKernels(n,e){n.addFieldOffset(0,e,0)}static addSubGraphSessionStates(n,e){n.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(n,e){n.startVector(4,e.length,4);for(let t=e.length-1;t>=0;t--)n.addOffset(e[t]);return n.endVector()}static startSubGraphSessionStatesVector(n,e){n.startVector(4,e,4)}static endSessionState(n){return n.endObject()}static createSessionState(n,e,t){return a.startSessionState(n),a.addKernels(n,e),a.addSubGraphSessionStates(n,t),a.endSessionState(n)}}s.SessionState=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={})),function(p){(function(u){(function(s){class a{constructor(){this.bb=null,this.bb_pos=0}__init(n,e){return this.bb_pos=n,this.bb=e,this}static getRootAsInferenceSession(n,e){return(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static getSizePrefixedRootAsInferenceSession(n,e){return n.setPosition(n.position()+m.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(n.readInt32(n.position())+n.position(),n)}static bufferHasIdentifier(n){return n.__has_identifier("ORTM")}ortVersion(n){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,n):null}model(n){let e=this.bb.__offset(this.bb_pos,6);return e?(n||new p.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}sessionState(n){let e=this.bb.__offset(this.bb_pos,8);return e?(n||new p.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startInferenceSession(n){n.startObject(3)}static addOrtVersion(n,e){n.addFieldOffset(0,e,0)}static addModel(n,e){n.addFieldOffset(1,e,0)}static addSessionState(n,e){n.addFieldOffset(2,e,0)}static endInferenceSession(n){return n.endObject()}static finishInferenceSessionBuffer(n,e){n.finish(e,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(n,e){n.finish(e,"ORTM",!0)}static createInferenceSession(n,e,t,r){return a.startInferenceSession(n),a.addOrtVersion(n,e),a.addModel(n,t),a.addSessionState(n,r),a.endInferenceSession(n)}}s.InferenceSession=a})(u.fbs||(u.fbs={}))})(p.experimental||(p.experimental={}))}(c.onnxruntime||(c.onnxruntime={}))},1723:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.OnnxjsSessionHandler=void 0;let m=y(2235),f=y(9240);c.OnnxjsSessionHandler=class{constructor(h){this.session=h,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(h,p,u){let s=new Map;for(let n in h)if(Object.hasOwnProperty.call(h,n)){let e=h[n];s.set(n,new f.Tensor(e.dims,e.type,void 0,void 0,e.data))}let a=await this.session.run(s),o={};return a.forEach((n,e)=>{o[e]=new m.Tensor(n.type,n.data,n.dims)}),o}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Session=void 0;let m=y(7067),f=y(1296),h=y(1975),p=y(6496),u=y(1315),s=y(1745);c.Session=class{constructor(a={}){this._initialized=!1,this.backendHint=a.backendHint,this.profiler=u.Profiler.create(a.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(a,o,n){await this.profiler.event("session","Session.loadModel",async()=>{let e=await(0,h.resolveBackend)(this.backendHint);if(this.sessionHandler=e.createSessionHandler(this.context),this._model=new s.Model,typeof a=="string"){let t=a.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let r=await(0,f.promisify)(m.readFile)(a);this.initialize(r,t)}else{let r=await fetch(a),i=await r.arrayBuffer();this.initialize(new Uint8Array(i),t)}}else if(ArrayBuffer.isView(a))this.initialize(a);else{let t=new Uint8Array(a,o||0,n||a.byteLength);this.initialize(t)}})}initialize(a,o){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let n=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(a,n,o),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new p.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(a){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let o=this.normalizeAndValidateInputs(a),n=await this._executionPlan.execute(this.sessionHandler,o);return this.createOutput(n)})}normalizeAndValidateInputs(a){let o=this._model.graph.getInputNames();if(Array.isArray(a)){if(a.length!==o.length)throw new Error(`incorrect input array length: expected ${o.length} but got ${a.length}`)}else{if(a.size!==o.length)throw new Error(`incorrect input map size: expected ${o.length} but got ${a.size}`);let n=new Array(a.size),e=0;for(let t=0;t<o.length;++t){let r=a.get(o[t]);if(!r)throw new Error(`missing input tensor for: '${name}'`);n[e++]=r}a=n}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,a,!1);else{let n=this._model.graph.getInputIndices(),e=this._model.graph.getValues(),t=new Array(n.length);for(let r=0;r<n.length;++r){let i=e[n[r]];t[r]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(a[r].dims)}this.validateInputTensorDims(t,a,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,a),a}validateInputTensorTypes(a,o){for(let n=0;n<o.length;n++){let e=a[n],t=o[n].type;if(e!==t)throw new Error(`input tensor[${n}] check failed: expected type '${e}' but got ${t}`)}}validateInputTensorDims(a,o,n){for(let e=0;e<o.length;e++){let t=a[e],r=o[e].dims;if(!this.compareTensorDims(t,r,n))throw new Error(`input tensor[${e}] check failed: expected shape '[${t.join(",")}]' but got [${r.join(",")}]`)}}compareTensorDims(a,o,n){if(a.length!==o.length)return!1;for(let e=0;e<a.length;++e)if(a[e]!==o[e]&&(!n||a[e]!==0))return!1;return!0}createOutput(a){let o=this._model.graph.getOutputNames();if(a.length!==o.length)throw new Error("expected number of outputs do not match number of generated outputs");let n=new Map;for(let e=0;e<o.length;++e)n.set(o[e],a[e]);return n}initializeOps(a){let o=a.getNodes();this._ops=new Array(o.length);for(let n=0;n<o.length;n++)this._ops[n]=this.sessionHandler.resolve(o[n],this._model.opsets,a)}}},9240:function(M,c,y){"use strict";var m=this&&this.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(c,"__esModule",{value:!0}),c.Tensor=void 0;let f=y(3442),h=m(y(1583)),p=y(5127),u=y(2446),s=y(7273);var a=p.onnxruntime.experimental.fbs;class o{get data(){if(this.cache===void 0){let l=this.dataProvider(this.dataId);if(l.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=l}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(l){return this.data[s.ShapeUtil.indicesToOffset(l,this.strides)]}set(l,d){this.data[s.ShapeUtil.indicesToOffset(l,this.strides)]=d}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=s.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(l,d,g,b,v,w=f.Guid.create()){this.dims=l,this.type=d,this.dataProvider=g,this.asyncDataProvider=b,this.cache=v,this.dataId=w,this.size=s.ShapeUtil.validateDimsAndCalcSize(l);let x=this.size,T=g===void 0&&b===void 0&&v===void 0;if(v!==void 0&&v.length!==x)throw new RangeError("Input dims doesn't match data length.");if(d==="string"){if(!(v===void 0||Array.isArray(v)&&v.every(O=>typeof O=="string")))throw new TypeError("cache should be a string array");T&&(this.cache=new Array(x))}else{if(v!==void 0){let O=e(d);if(!(v instanceof O))throw new TypeError(`cache should be type ${O.name}`)}if(T){let O=new ArrayBuffer(x*function(P){switch(P){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${P}`)}}(d));this.cache=function(P,I){return new(e(I))(P)}(O,d)}}}static fromProto(l){if(!l)throw new Error("cannot construct Value from an empty tensor");let d=s.ProtoUtil.tensorDataTypeFromProto(l.dataType),g=s.ProtoUtil.tensorDimsFromProto(l.dims),b=new o(g,d);if(d==="string")l.stringData.forEach((v,w)=>{b.data[w]=(0,s.decodeUtf8String)(v)});else if(l.rawData&&typeof l.rawData.byteLength=="number"&&l.rawData.byteLength>0){let v=b.data,w=new DataView(l.rawData.buffer,l.rawData.byteOffset,l.rawData.byteLength),x=n(l.dataType),T=l.rawData.byteLength/x;if(l.rawData.byteLength%x!=0)throw new Error("invalid buffer length");if(v.length!==T)throw new Error("buffer length mismatch");for(let O=0;O<T;O++){let P=r(w,l.dataType,O*x);v[O]=P}}else{let v;switch(l.dataType){case u.onnx.TensorProto.DataType.FLOAT:v=l.floatData;break;case u.onnx.TensorProto.DataType.INT32:case u.onnx.TensorProto.DataType.INT16:case u.onnx.TensorProto.DataType.UINT16:case u.onnx.TensorProto.DataType.INT8:case u.onnx.TensorProto.DataType.UINT8:case u.onnx.TensorProto.DataType.BOOL:v=l.int32Data;break;case u.onnx.TensorProto.DataType.INT64:v=l.int64Data;break;case u.onnx.TensorProto.DataType.DOUBLE:v=l.doubleData;break;case u.onnx.TensorProto.DataType.UINT32:case u.onnx.TensorProto.DataType.UINT64:v=l.uint64Data;break;default:throw new Error("unspecific error")}if(v==null)throw new Error("failed to populate data from a tensorproto value");let w=b.data;if(w.length!==v.length)throw new Error("array length mismatch");for(let x=0;x<v.length;x++){let T=v[x];h.default.isLong(T)?w[x]=t(T,l.dataType):w[x]=T}}return b}static fromData(l,d,g){return new o(d,g,void 0,void 0,l)}static fromOrtTensor(l){if(!l)throw new Error("cannot construct Value from an empty tensor");let d=s.ProtoUtil.tensorDimsFromORTFormat(l),g=s.ProtoUtil.tensorDataTypeFromProto(l.dataType()),b=new o(d,g);if(g==="string")for(let v=0;v<l.stringDataLength();v++)b.data[v]=l.stringData(v);else if(l.rawDataArray()&&typeof l.rawDataLength()=="number"&&l.rawDataLength()>0){let v=b.data,w=new DataView(l.rawDataArray().buffer,l.rawDataArray().byteOffset,l.rawDataLength()),x=n(l.dataType()),T=l.rawDataLength()/x;if(l.rawDataLength()%x!=0)throw new Error("invalid buffer length");if(v.length!==T)throw new Error("buffer length mismatch");for(let O=0;O<T;O++){let P=r(w,l.dataType(),O*x);v[O]=P}}return b}}function n(i){switch(i){case u.onnx.TensorProto.DataType.UINT8:case u.onnx.TensorProto.DataType.INT8:case u.onnx.TensorProto.DataType.BOOL:return 1;case u.onnx.TensorProto.DataType.UINT16:case u.onnx.TensorProto.DataType.INT16:return 2;case u.onnx.TensorProto.DataType.FLOAT:case u.onnx.TensorProto.DataType.INT32:case u.onnx.TensorProto.DataType.UINT32:return 4;case u.onnx.TensorProto.DataType.INT64:case u.onnx.TensorProto.DataType.DOUBLE:case u.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${u.onnx.TensorProto.DataType[i]}`)}}function e(i){switch(i){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function t(i,l){if(l===u.onnx.TensorProto.DataType.INT64||l===a.TensorDataType.INT64){if(i.greaterThanOrEqual(2147483648)||i.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(l!==u.onnx.TensorProto.DataType.UINT32&&l!==a.TensorDataType.UINT32&&l!==u.onnx.TensorProto.DataType.UINT64&&l!==a.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${u.onnx.TensorProto.DataType[l]}`);if(i.greaterThanOrEqual(4294967296)||i.lessThan(0))throw new TypeError("uint64 is not supported")}return i.toNumber()}function r(i,l,d){switch(l){case u.onnx.TensorProto.DataType.BOOL:case u.onnx.TensorProto.DataType.UINT8:return i.getUint8(d);case u.onnx.TensorProto.DataType.INT8:return i.getInt8(d);case u.onnx.TensorProto.DataType.UINT16:return i.getUint16(d,!0);case u.onnx.TensorProto.DataType.INT16:return i.getInt16(d,!0);case u.onnx.TensorProto.DataType.FLOAT:return i.getFloat32(d,!0);case u.onnx.TensorProto.DataType.INT32:return i.getInt32(d,!0);case u.onnx.TensorProto.DataType.UINT32:return i.getUint32(d,!0);case u.onnx.TensorProto.DataType.INT64:return t(h.default.fromBits(i.getUint32(d,!0),i.getUint32(d+4,!0),!1),l);case u.onnx.TensorProto.DataType.DOUBLE:return i.getFloat64(d,!0);case u.onnx.TensorProto.DataType.UINT64:return t(h.default.fromBits(i.getUint32(d,!0),i.getUint32(d+4,!0),!0),l);default:throw new Error(`cannot read from DataView for type ${u.onnx.TensorProto.DataType[l]}`)}}c.Tensor=o},7273:function(M,c,y){"use strict";var m=this&&this.__importDefault||function(l){return l&&l.__esModule?l:{default:l}};Object.defineProperty(c,"__esModule",{value:!0}),c.decodeUtf8String=c.MAX_CLIP=c.MIN_CLIP=c.PoolConvUtil=c.ReduceUtil=c.SplitUtil=c.MathUtil=c.ShapeUtil=c.LongUtil=c.ProtoUtil=c.GemmUtil=c.arrayCopyHelper=c.BroadcastUtil=c.MatMulUtil=c.ArrayUtil=c.assert=c.checkInputsShape=void 0;let f=y(5686),h=m(y(1583)),p=y(2446),u=y(9240);c.checkInputsShape=function(l,...d){if(!l||l.length!==d.length)return!1;for(let g=0;g<l.length;g++)if(!l[g].dims||l[g].dims.length!==d[g])return!1;return!0},c.assert=function(l,d){if(!l)throw new Error(typeof d=="string"?d:d())},c.ArrayUtil=class{static arraysEqual(l,d){if(l.length!==d.length)return!1;for(let g=0;g<l.length;g++)if(l[g]!==d[g])return!1;return!0}};class s{static preprocessInputShapes(d,g){return[d.length===1?[1,d[0]]:d,g.length===1?[g[0],1]:g]}static postprocessOutputShape(d,g,b){g===1&&d.splice(d.length-2,1),b===1&&d.pop()}static calcMatMulShape(d,g){return d[1]!==g[0]?void 0:[d[0],g[1]]}}c.MatMulUtil=s;class a{static calcShape(d,g,b=!1){let v=d.length,w=g.length;if(v===0)return g;if(w===0)return d;let x=Math.max(d.length,g.length),T=new Array(x);if(b){if(v<2||w<2)return;let O=s.calcMatMulShape([d[v-2],d[v-1]],[g[w-2],g[w-1]]);if(O===void 0)return;[T[x-2],T[x-1]]=O}for(let O=b?3:1;O<=x;O++){let P=v-O<0?1:d[v-O],I=w-O<0?1:g[w-O];if(P!==I&&P>1&&I>1)return;T[x-O]=Math.max(P,I)}return T}static index(d,g){let b=new Array(g.length);return a.fillIndex(d,g,b),b}static fillIndex(d,g,b){let v=d.length-g.length;for(let w=0;w<g.length;w++)b[w]=d[v+w]%g[w]}static calc(d,g,b,v,w){let x=a.calcShape(d.dims,g.dims);if(x){if(v&&!e.areEqual(x,d.dims))return;let T=e.size(x),O=v?d:new u.Tensor(x,w||d.type);if(x.length===0)O.set([],b(d.get([]),g.get([])));else{let P=new Array(x.length),I=new Array(d.dims.length),R=new Array(g.dims.length),j,A=0,C=0,_=!1,S=!1;d.dims.length===0&&(A=d.get([]),_=!0),g.dims.length===0&&(C=g.get([]),S=!0);for(let E=0;E<T;E++){j=E;for(let z=x.length-1;z>=0;z--)P[z]=j%x[z],j=Math.floor(j/x[z]);_||(a.fillIndex(P,d.dims,I),A=d.get(I)),S||(a.fillIndex(P,g.dims,R),C=g.get(R)),O.set(P,b(A,C))}}return O}}static isValidBroadcast(d,g){let b=d.length,v=g.length;if(b>v)return!1;for(let w=1;w<=b;w++)if(d[b-w]!==1&&d[b-w]!==g[v-w])return!1;return!0}static getBroadcastDims(d,g){let b=d.length,v=[];for(let w=0;w<b;w++){let x=b-1-w,T=d[x]||1;(g[g.length-1-w]||1)>1&&T===1&&v.unshift(x)}return v}}c.BroadcastUtil=a,c.arrayCopyHelper=function(l,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)l[g+w]=d[b+w]},c.GemmUtil=class{static getShapeOfGemmResult(l,d,g,b,v){if(l.length!==2||g.length!==2)throw new Error("shape need to be of size 2");let w,x,T;d?(w=l[1],x=l[0]):(w=l[0],x=l[1]);let O=-1;if(b?(T=g[0],O=1):(T=g[1],O=0),g[O]!==x)throw new Error("dimension mismatch");if(w<=0||T<=0||x<=0)throw new Error("invalid shape specified");if(v&&!a.isValidBroadcast(v,[w,T]))throw new Error("gemm: invalid bias shape for broadcast");return[w,T,x]}};class o{static tensorDataTypeFromProto(d){switch(d){case p.onnx.TensorProto.DataType.INT8:return"int8";case p.onnx.TensorProto.DataType.UINT8:return"uint8";case p.onnx.TensorProto.DataType.BOOL:return"bool";case p.onnx.TensorProto.DataType.INT16:return"int16";case p.onnx.TensorProto.DataType.UINT16:return"uint16";case p.onnx.TensorProto.DataType.INT32:return"int32";case p.onnx.TensorProto.DataType.UINT32:return"uint32";case p.onnx.TensorProto.DataType.FLOAT:return"float32";case p.onnx.TensorProto.DataType.DOUBLE:return"float64";case p.onnx.TensorProto.DataType.STRING:return"string";case p.onnx.TensorProto.DataType.INT64:return"int32";case p.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${p.onnx.TensorProto.DataType[d]}`)}}static tensorDataTypeStringToEnum(d){switch(d){case"int8":return p.onnx.TensorProto.DataType.INT8;case"uint8":return p.onnx.TensorProto.DataType.UINT8;case"bool":return p.onnx.TensorProto.DataType.BOOL;case"int16":return p.onnx.TensorProto.DataType.INT16;case"uint16":return p.onnx.TensorProto.DataType.UINT16;case"int32":return p.onnx.TensorProto.DataType.INT32;case"uint32":return p.onnx.TensorProto.DataType.UINT32;case"float32":return p.onnx.TensorProto.DataType.FLOAT;case"float64":return p.onnx.TensorProto.DataType.DOUBLE;case"string":return p.onnx.TensorProto.DataType.STRING;case"int64":return p.onnx.TensorProto.DataType.INT64;case"uint64":return p.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${d}`)}}static tensorDimsFromProto(d){return d.map(g=>h.default.isLong(g)?g.toNumber():g)}static tensorValueTypeFromProto(d){return{tensorType:o.tensorDataTypeFromProto(d.elemType),shape:{dims:o.tensorDimsFromProto(d.shape.dim.map(g=>g.dimValue))}}}static tensorDimsFromORTFormat(d){let g=[];for(let b=0;b<d.dimsLength();b++)g.push(n.longToNumber(d.dims(b)));return g}static tensorAttributesFromORTFormat(d){let g=[];for(let b=0;b<d.attributesLength();b++)g.push(d.attributes(b));return g}}c.ProtoUtil=o;class n{static longToNumber(d,g){return h.default.isLong(d)?d.toNumber():d instanceof f.flatbuffers.Long?h.default.fromValue({low:d.low,high:d.high,unsigned:g!=null&&g}).toNumber():d}static isLong(d){return h.default.isLong(d)||d instanceof f.flatbuffers.Long}}c.LongUtil=n;class e{static size(d){return e.getSizeFromDimensionRange(d,0,d.length)}static sizeFromDimension(d,g){if(g<0||g>d.length)throw new Error(`invalid dimension of ${g} for sizeFromDimension as Tensor has ${d.length} dimensions.`);return e.getSizeFromDimensionRange(d,g,d.length)}static sizeToDimension(d,g){if(g<0||g>d.length)throw new Error(`invalid dimension of ${g} for sizeToDimension as Tensor has ${d.length} dimensions.`);return e.getSizeFromDimensionRange(d,0,g)}static getSizeFromDimensionRange(d,g,b){let v=1;for(let w=g;w<b;w++){if(d[w]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");v*=d[w]}return v}static computeStrides(d){let g=d.length;if(g===0)return[];if(g===1)return[1];let b=new Array(g);b[g-1]=1,b[g-2]=d[g-1];for(let v=g-3;v>=0;--v)b[v]=b[v+1]*d[v+1];return b}static transpose(d){return d.slice().reverse()}static indicesToOffset(d,g,b){b===void 0&&(b=d.length);let v=0;for(let w=0;w<b;++w)v+=g[w]*d[w];return v}static offsetToIndices(d,g){let b=g.length;if(b===0)return[];if(b===1)return[d*g[0]];let v=new Array(g.length);for(let w=0;w<v.length-1;++w)v[w]=Math.floor(d/g[w]),d-=v[w]*g[w];return v[v.length-1]=d,v}static normalizeAxis(d,g){if(d<-g&&d>=g)throw new Error("unsupported axis for this operation.");return d<0?d+g:d}static normalizeAxes(d,g){return d.map(b=>this.normalizeAxis(b,g))}static incrementIndex(d,g,b){if(g.length===0||d.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(b===void 0)b=g.length;else if(b<=0||b>g.length)throw new Error("Incorrect axis to increment on");for(let v=b-1;v>=0&&(d[v]++,!(d[v]<g[v]));--v)d[v]=0}static calculateReshapedDims(d,g){if(g.length===0){if(d.length===0||e.size(d)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let b=g.length,v=new Array(b),w=-1,x=1;for(let O=0;O<b;O++){if(g[O]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(g[O]===-1){if(w!==-1)throw new Error("at most one dimension in shape hints can be -1");w=O}else{if(g[O]===0){if(O>=d.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");v[O]=d[O]}else v[O]=g[O];x*=v[O]}}let T=e.size(d);if(w!==-1){if(T%x!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${d}] Output shape: [${g}]`);v[w]=T/x}else if(x!==T)throw new Error("reshapedDims and originalDims don't have matching sizes");return v}static sortBasedOnPerm(d,g){return g?g.map(b=>d[b]):d.slice().reverse()}static padShape(d,g){let b=d.length;return d.map((v,w)=>v+g[w]+g[w+b])}static areEqual(d,g){return d.length===g.length&&d.every((b,v)=>b===g[v])}static validateDimsAndCalcSize(d){if(d.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let g=1;for(let b of d){if(!Number.isInteger(b))throw new TypeError(`Invalid shape: ${b} is not an integer`);if(b<0||b>2147483647)throw new TypeError(`Invalid shape: length ${b} is not allowed`);g*=b}return g}static flattenShape(d,g){g<0&&(g+=d.length);let b=d.reduce((w,x)=>w*x,1),v=d.slice(g).reduce((w,x)=>w*x,1);return[b/v,v]}static squeezeShape(d,g){let b=new Array;g=e.normalizeAxes(g,d.length);for(let v=0;v<d.length;v++){let w=g.indexOf(v)>=0;if(w&&d[v]!==1)throw new Error("squeeze an axis of size different than 1");(g.length===0&&d[v]>1||g.length>0&&!w)&&b.push(d[v])}return b}static unsqueezeShape(d,g){let b=new Array(d.length+g.length);b.fill(0);for(let w=0;w<g.length;w++){let x=e.normalizeAxis(g[w],b.length);if(x>=b.length)throw new Error("'axes' has an out of range axis");if(b[x]!==0)throw new Error("'axes' has a duplicate axis");b[x]=1}let v=0;for(let w=0;w<b.length;w++)b[w]===0&&(b[w]=d[v++]);if(v!==d.length)throw new Error("the unsqueezed dimension could not be established");return b}}c.ShapeUtil=e,c.MathUtil=class{static sqr(l,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)l[g+w]+=Math.pow(d[b+w],2)}static axpy(l,d,g,b,v,w){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let x=0;x<v;x++)l[g+x]+=w*d[b+x]}static powx(l,d,g,b,v,w){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let x=0;x<v;x++)l[g+x]=Math.pow(d[b+x],w)}static mul(l,d,g,b,v){if(b<0||b>=d.length)throw new Error("sourceIndex out of bounds");if(g<0||g>=l.length)throw new Error("targetIndex out of bounds");if(b+v>d.length)throw new Error("source indices to be copied are outside bounds");if(g+v>l.length)throw new Error("target array is too small to hold result");for(let w=0;w<v;w++)l[g+w]=d[b+w]*l[g+w]}};class t{static splitShape(d,g,b,v){if(b.length===0){if(!v)throw new Error("need to know number of outputs when the 'split' attribute is not specified");t.determineSplit(d[g],v,b)}let w=[],x=[0];for(let T=0;T<b.length;++T){T!==0&&x.push(x[T-1]+b[T-1]);let O=d.slice();O[g]=b[T],w.push(O)}return[w,x]}static determineSplit(d,g,b){if(d%g!=0)throw new Error("cannot split tensor to equal sized parts");for(let v=0;v<g;++v)b.push(d/g)}}c.SplitUtil=t;class r{static calcReduce(d,g,b,v,w){let x=d.dims.slice(0);g.length===0&&x.forEach((A,C)=>g.push(C));let T=r.calcReduceShape(x,g,!0),O=e.size(T),P=new u.Tensor(T,d.type),I=e.computeStrides(T),R=e.computeStrides(x),j=new Array(x.length);for(let A=0;A<O;A++){let C=e.offsetToIndices(A,I);a.fillIndex(C,x,j),P.set(C,r.calcReduceByAxis(d.numberData,g,x,0,e.indicesToOffset(j,R),v,w))}return b?P:new u.Tensor(r.calcReduceShape(x,g,b),P.type,void 0,void 0,P.data,P.dataId)}static calcReduceByAxis(d,g,b,v,w,x,T){let O=0;if(v>=g.length)return x(d[w]);let P=g[v],I=P>=b.length?1:e.size(b.slice(P+1));for(let R=0;R<b[P];R++)O=R===0?r.calcReduceByAxis(d,g,b,v+1,w,x,T):T(O,r.calcReduceByAxis(d,g,b,v+1,w,x,T)),w+=I;return O}static calcReduceShape(d,g,b){let v=d.slice();for(let w=0;w<g.length;w++)v[g[w]]=b?1:0;return v.filter(w=>w!==0)}}c.ReduceUtil=r;class i{static adjustPoolAttributes(d,g,b,v,w,x){if(!d&&b.length!==g.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(d)for(let T=0;T<g.length-2;T++)T>=b.length?b.push(g[T+2]):b[T]=g[T+2];for(let T=0;T<b.length;T++)if(T<v.length){if(v[T]<0)throw new Error("strides should be greater than or equal to 1")}else v.push(1);for(let T=0;T<b.length;T++)if(T<w.length){if(w[T]<0)throw new Error("dilations should be greater than or equal to 1")}else w.push(1);for(let T=0;T<2*b.length;T++)if(T<x.length){if(x[T]<0)throw new Error("pad should be greater than or equal to 1")}else x.push(0);for(let T=0;T<b.length;T++){if(b[T]<=0)throw new Error("kernel shapes need to be greater than 0");if(x[T]>=b[T]||x[T+b.length]>=b[T])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(d,g,b,v,w,x){if(x){if(w.length!==2*(d.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(g.length!==d.length-2)throw new Error("length of strides should be the length of data dimensions");if(v.length!==d.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let T=0;T<d.length-2;T++)i.adjustPadAndReturnShape(d[T+2],g[T],b[T],v[T],w,T,T+d.length-2,x)}}static computePoolOutputShape(d,g,b,v,w,x,T){if(g.length<=0)throw new Error("input shape must be of size greater than 0");let O=[g[0],g[1]];return i.computeShapeHelper(d,g,O,b,v,w,x,T),O}static computeConvOutputShape(d,g,b,v,w,x,T){if(d.length<=0||g.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let O=[d[0],g[0]];return i.computeShapeHelper(!1,d,O,b,v,w,x,T),O}static computeShapeHelper(d,g,b,v,w,x,T,O){if(d)for(let P=0;P<g.length-2;P++)b.push(1);else for(let P=0;P<g.length-2;P++)b.push(i.adjustPadAndReturnShape(g[P+2],v[P],w[P],x[P],T,P,P+g.length-2,O))}static adjustPadAndReturnShape(d,g,b,v,w,x,T,O){let P=b*(v-1)+1;if(!O||O==="NOTSET")return Math.floor((d+w[x]+w[T]-P)/g+1);switch(O){case"VALID":return w[x]=0,w[T]=0,Math.floor((d-P)/g+1);case"SAME_LOWER":case"SAME_UPPER":if(b!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let I=((d+g-1)/g-1)*g+v-d;return w[x]=Math.floor(O==="SAME_LOWER"?(I+1)/2:I/2),w[T]=I-w[x],Math.floor((d+I-v)/g+1)}default:throw new Error("Unsupported AutoPad type")}}}c.PoolConvUtil=i,c.MIN_CLIP=-34028234663852886e22,c.MAX_CLIP=34028234663852886e22,c.decodeUtf8String=function(l){return new TextDecoder().decode(l)}},8408:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.version=void 0,c.version="1.16.3"},3838:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.WebGpuBackend=void 0;let m=y(4955),f=y(7771),h=y(8510),p=y(8305);c.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.supportTimestampQuery=!1}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let u=this.kernelCustomData.get(this.currentKernelId);return u||(u={},this.kernelCustomData.set(this.currentKernelId,u)),u}async initialize(u){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let s=await navigator.gpu.requestAdapter();if(!s)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=u;let a={requiredLimits:{maxComputeWorkgroupStorageSize:s.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.limits.maxStorageBufferBindingSize,maxBufferSize:s.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:s.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:s.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:s.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:s.limits.maxComputeWorkgroupSizeZ}};s.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,a.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await s.requestDevice(a),this.gpuDataManager=(0,f.createGpuDataManager)(this),this.programManager=new p.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,(0,m.configureLogger)(u.logLevel,!!u.debug),this.device.onuncapturederror=o=>{o.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${o.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(u,s,a,o,n){if(s.length!==u.inputTypes.length)throw new Error(`Input size must be equal to ${u.inputTypes.length}.`);let e=[];for(let v=0;v<s.length;++v){let w=this.gpuDataManager.get(s[v].data);if(!w)throw new Error(`no GPU data for input: ${s[v].data}`);e[v]=w}let t=((v,w)=>{let x=w.map(O=>`${O.dataType};${O.dims.join(",")}`).join("|"),T=v.name;return v.cacheHint&&(T+="["+v.cacheHint+"]"),T+=":"+x,T})(u,s),r=this.programManager.getArtifact(t),i=r?r.programInfo:typeof u.get=="function"?u.get():u,l=a.length===0?i.outputs.map((v,w)=>w):a;if(l.length!==i.outputs.length)throw new Error(`Output size ${l.length} must be equal to ${i.outputs.length}.`);let d=[],g=[];for(let v=0;v<i.outputs.length;++v){if(!Number.isInteger(l[v])||l[v]<-3||l[v]>=i.outputs.length)throw new Error(`Invalid output index: ${l[v]}`);if(l[v]===-3)continue;let w=l[v]===-1,x=l[v]===-2,T=w||x?n(i.outputs[v].dataType,i.outputs[v].dims):o(l[v],i.outputs[v].dataType,i.outputs[v].dims),O=this.gpuDataManager.get(T.data);if(!O)throw new Error(`no GPU data for output: ${T.data}`);if(w&&this.temporaryData.push(O),x){let P=this.kernelPersistentData.get(this.currentKernelId);P||(P=[],this.kernelPersistentData.set(this.currentKernelId,P)),P.push(O)}d.push(T),g.push(O)}let b=this.programManager.normalizeDispatchGroupSize(i.dispatchGroup(s));return r||(r=this.programManager.build(i,b),this.programManager.setArtifact(t,r)),(0,m.LOG_DEBUG)("info",()=>`[ProgramManager] run "${i.name}" (key=${t}) with ${b[0]}x${b[1]}x${b[2]}`),this.programManager.run(r,e,g,b),d}upload(u,s){this.gpuDataManager.upload(u,s)}memcpy(u,s){this.gpuDataManager.memcpy(u,s)}async download(u,s){let a=await this.gpuDataManager.download(u),o=s();o.set(new Uint8Array(a,0,o.byteLength))}alloc(u){return this.gpuDataManager.create(u).id}free(u){return this.gpuDataManager.release(u)}createKernel(u,s,a){let o=h.WEBGPU_OP_RESOLVE_RULES.get(u);if(!o)throw new Error(`kernel not implemented: ${u}`);this.kernels.set(s,[u,o[0],[o[1],a]])}releaseKernel(u){let s=this.kernelPersistentData.get(u);if(s){for(let a of s)this.gpuDataManager.release(a.id);this.kernelPersistentData.delete(u)}this.kernelCustomData.delete(u),this.kernels.delete(u)}computeKernel(u,s){let a=this.kernels.get(u);if(!a)throw new Error(`kernel not created: ${u}`);let[o,n,e]=a;if(this.currentKernelId!==null)throw new Error(`kernel "${o}" is not allowed to be called recursively`);this.currentKernelId=u,e[0]&&(e[1]=e[0](e[1]),e[0]=void 0),(0,m.LOG_DEBUG)("info",()=>`[WebGPU] Start to run kernel "${o}"...`),this.temporaryData=[];try{return n(s,e[1]),0}catch(t){return(0,m.LOG_DEBUG)("warning",`[WebGPU] Kernel "${o}" failed. Error: ${t}`),1}finally{for(let t of this.temporaryData)this.gpuDataManager.release(t.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(M,c,y)=>{"use strict";c.S=void 0;let m=y(7917),f=y(3838),h=y(4955),p=y(6952);class u{constructor(o,n,e,t){this.module=o,this.dataType=n,this.data=e,this.dims=t}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let o=p.ShapeUtil.size(this.dims);return o===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,o)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let o=p.ShapeUtil.size(this.dims);return o===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,o)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let o=p.ShapeUtil.size(this.dims);return o===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,o)}reshape(o){if(p.ShapeUtil.size(o)!==p.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new u(this.module,this.dataType,this.data,o)}}class s{get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}constructor(o,n,e){this.module=o,this.backend=n,this.customDataOffset=0,this.customDataSize=0;let t=o.HEAPU32,r=e>>2;this.opKernelContext=t[r++];let i=t[r++];this.outputCount=t[r++],this.customDataOffset=t[r++],this.customDataSize=t[r++];let l=[];for(let d=0;d<i;d++){let g=t[r++],b=t[r++],v=t[r++],w=[];for(let x=0;x<v;x++)w.push(t[r++]);l.push(new u(o,g,b,w))}this.inputs=l}compute(o,n){var e,t,r;let i=(t=(e=n?.inputs)===null||e===void 0?void 0:e.map(d=>typeof d=="number"?this.inputs[d]:d))!==null&&t!==void 0?t:this.inputs,l=(r=n?.outputs)!==null&&r!==void 0?r:[];return this.backend.run(o,i,l,(d,g,b)=>new u(this.module,g,this.output(d,b),b),(d,g)=>{let b=(0,m.getTensorElementSize)(d);if(!b)throw new Error(`Unsupported data type: ${d}`);let v=b*p.ShapeUtil.size(g);return new u(this.module,d,this.backend.gpuDataManager.create(v).id,g)})}output(o,n){let e=this.module.stackSave();try{let t=this.module.stackAlloc(4*(1+n.length)),r=t>>2;this.module.HEAPU32[r++]=n.length;for(let i=0;i<n.length;i++)this.module.HEAPU32[r++]=n[i];return this.module._JsepOutput(this.opKernelContext,o,t)}finally{this.module.stackRestore(e)}}}c.S=async(a,o)=>{let n=a.jsepInit;if(n&&navigator.gpu){if(!o.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let e=new f.WebGpuBackend;await e.initialize(o),n({backend:e},t=>e.alloc(t),t=>e.free(t),(t,r,i,l=!1)=>{if(l)(0,h.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${r}, size=${i}`),e.memcpy(t,r);else{(0,h.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${r}, size=${i}`);let d=a.HEAPU8.subarray(t,t+i);e.upload(r,d)}},async(t,r,i)=>{(0,h.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${r}, size=${i}`),await e.download(t,()=>a.HEAPU8.subarray(r,r+i))},(t,r,i)=>e.createKernel(t,r,i),t=>e.releaseKernel(t),(t,r)=>{(0,h.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepRun: kernel=${t}, contextDataOffset=${r}`);let i=new s(a,e,r);return e.computeKernel(t,i)})}}},4955:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.LOG_DEBUG=c.LOG=c.configureLogger=void 0;let m=y(7917),f=["V","I","W","E","F"],h,p;c.configureLogger=(u,s)=>{h=u,p=s},c.LOG=(u,s)=>{let a=(0,m.logLevelStringToEnum)(u);var o,n;a>=(0,m.logLevelStringToEnum)(h)&&(o=a,n=typeof s=="function"?s():s,console.log(`[${f[o]},${new Date().toISOString()}]${n}`))},c.LOG_DEBUG=(...u)=>{p&&(0,c.LOG)(...u)}},6952:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.MAX_CLIP=c.MIN_CLIP=c.GemmUtil=c.PoolConvUtil=c.ShapeUtil=c.BroadcastUtil=c.MatMulUtil=void 0;class y{static calcMatMulShape(u,s){return u[1]!==s[0]?void 0:[u[0],s[1]]}}c.MatMulUtil=y;class m{static calcShape(u,s,a=!1){let o=u.length,n=s.length;if(o===0)return s;if(n===0)return u;let e=Math.max(u.length,s.length),t=new Array(e);if(a){if(o<2||n<2)return;let r=y.calcMatMulShape([u[o-2],u[o-1]],[s[n-2],s[n-1]]);if(r===void 0)return;[t[e-2],t[e-1]]=r}for(let r=a?3:1;r<=e;r++){let i=o-r<0?1:u[o-r],l=n-r<0?1:s[n-r];if(i!==l&&i>1&&l>1)return;t[e-r]=Math.max(i,l)}return t}static isValidBroadcast(u,s){let a=u.length,o=s.length;if(a>o)return!1;for(let n=1;n<=a;n++)if(u[a-n]!==1&&u[a-n]!==s[o-n])return!1;return!0}}c.BroadcastUtil=m;class f{static size(u){return f.getSizeFromDimensionRange(u,0,u.length)}static sizeFromDimension(u,s){if(s<0||s>u.length)throw new Error(`invalid dimension of ${s} for sizeFromDimension as Tensor has ${u.length} dimensions.`);return f.getSizeFromDimensionRange(u,s,u.length)}static sizeToDimension(u,s){if(s<0||s>u.length)throw new Error(`invalid dimension of ${s} for sizeToDimension as Tensor has ${u.length} dimensions.`);return f.getSizeFromDimensionRange(u,0,s)}static getSizeFromDimensionRange(u,s,a){let o=1;for(let n=s;n<a;n++){if(u[n]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");o*=u[n]}return o}static computeStrides(u){let s=u.length;if(s===0)return[];if(s===1)return[1];let a=new Array(s);a[s-1]=1,a[s-2]=u[s-1];for(let o=s-3;o>=0;--o)a[o]=a[o+1]*u[o+1];return a}static normalizeAxis(u,s){if(u<-s&&u>=s)throw new Error("unsupported axis for this operation.");return u<0?u+s:u}static normalizeAxes(u,s){return u.map(a=>this.normalizeAxis(a,s??u.length))}static sortBasedOnPerm(u,s){return s?s.map(a=>u[a]):u.slice().reverse()}static padShape(u,s){let a=u.length;return u.map((o,n)=>o+s[n]+s[n+a])}static areEqual(u,s){return u.length===s.length&&u.every((a,o)=>a===s[o])}}c.ShapeUtil=f;class h{static adjustPoolAttributes(u,s,a,o,n,e){if(!u&&a.length!==s.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(u)for(let t=0;t<s.length-2;t++)t>=a.length?a.push(s[t+2]):a[t]=s[t+2];for(let t=0;t<a.length;t++)if(t<o.length){if(o[t]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let t=0;t<a.length;t++)if(t<n.length){if(n[t]<0)throw new Error("dilations should be greater than or equal to 1")}else n.push(1);for(let t=0;t<2*a.length;t++)if(t<e.length){if(e[t]<0)throw new Error("pad should be greater than or equal to 1")}else e.push(0);for(let t=0;t<a.length;t++){if(a[t]<=0)throw new Error("kernel shapes need to be greater than 0");if(e[t]>=a[t]||e[t+a.length]>=a[t])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(u,s,a,o,n,e,t){if(t){if(n.length!==2*(u.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(s.length!==u.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==u.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let r=0;r<u.length-2;r++)h.adjustPadAndReturnShape(u[r+(e?1:2)],s[r],a[r],o[r],n,r,r+u.length-2,t)}}static computePoolOutputShape(u,s,a,o,n,e,t){if(s.length<=0)throw new Error("input shape must be of size greater than 0");let r=[s[0],s[1]];return h.computeShapeHelper(u,s,r,a,o,n,e,t),r}static computeConvOutputShape(u,s,a,o,n,e,t){if(u.length<=0||s.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let r=[u[0],s[0]];return h.computeShapeHelper(!1,u,r,a,o,n,e,t),r}static computeShapeHelper(u,s,a,o,n,e,t,r){if(u)for(let i=0;i<s.length-2;i++)a.push(1);else for(let i=0;i<s.length-2;i++)a.push(h.adjustPadAndReturnShape(s[i+2],o[i],n[i],e[i],t,i,i+s.length-2,r))}static adjustPadAndReturnShape(u,s,a,o,n,e,t,r){let i=a*(o-1)+1;if(!r||r==="NOTSET")return Math.floor((u+n[e]+n[t]-i)/s+1);switch(r){case"VALID":return n[e]=0,n[t]=0,Math.floor((u-i)/s+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let l=((u+s-1)/s-1)*s+o-u;return n[e]=Math.floor(r==="SAME_LOWER"?(l+1)/2:l/2),n[t]=l-n[e],Math.floor((u+l-o)/s+1)}default:throw new Error("Unsupported AutoPad type")}}}c.PoolConvUtil=h,c.GemmUtil=class{static getShapeOfGemmResult(p,u,s,a,o){if(p.length!==2||s.length!==2)throw new Error("shape need to be of size 2");let n,e,t;u?(n=p[1],e=p[0]):(n=p[0],e=p[1]);let r=-1;if(a?(t=s[0],r=1):(t=s[1],r=0),s[r]!==e)throw new Error("dimension mismatch");if(n<=0||t<=0||e<=0)throw new Error("invalid shape specified");if(o&&!m.isValidBroadcast(o,[n,t]))throw new Error("gemm: invalid bias shape for broadcast");return[n,t,e]}},c.MIN_CLIP=-34028234663852886e22,c.MAX_CLIP=34028234663852886e22},387:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createAttributeWithCacheKey=void 0;class y{constructor(f){Object.assign(this,f)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(f=>`${this[f]}`).join(";")),this._cacheKey}}c.createAttributeWithCacheKey=m=>new y(m)},7771:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createGpuDataManager=void 0;let m=y(4955),f=y(1163),h=s=>16*Math.ceil(s/16),p=0;class u{constructor(a){this.backend=a,this.storageCache=new Map,this.downloadCache=new Map,this.freeBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(a,o){let n=o.buffer,e=o.byteOffset,t=o.byteLength,r=h(t),i=this.storageCache.get(a);if(!i)throw new Error("gpu data for uploading does not exist");if(i.originalSize!==t)throw new Error(`inconsistent data size. gpu data size=${i.originalSize}, data size=${t}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:r,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),d=l.getMappedRange();new Uint8Array(d).set(new Uint8Array(n,e,t)),l.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(l,0,i.gpuData.buffer,0,r),(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${a})`),this.buffersForUploadingPending.push(l)}memcpy(a,o){let n=this.storageCache.get(a);if(!n)throw new Error("source gpu data for memcpy does not exist");let e=this.storageCache.get(o);if(!e)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==e.originalSize)throw new Error("inconsistent source and destination gpu data size");let t=h(n.originalSize),r=this.backend.getCommandEncoder();this.backend.endComputePass(),r.copyBufferToBuffer(n.gpuData.buffer,0,e.gpuData.buffer,0,t)}create(a,o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=h(a),e;if((o&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let r=this.freeBuffers.get(n);r||(r=[],this.freeBuffers.set(n,r)),e=r.length>0?r.pop():this.backend.device.createBuffer({size:n,usage:o})}else e=this.backend.device.createBuffer({size:n,usage:o});let t={id:p++,type:f.GpuDataType.default,buffer:e};return this.storageCache.set(t.id,{gpuData:t,originalSize:a}),(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.create(size=${a}) => id=${t.id}`),t}get(a){var o;return(o=this.storageCache.get(a))===null||o===void 0?void 0:o.gpuData}release(a){let o=this.storageCache.get(a);if(!o)throw new Error("releasing data does not exist");return(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.release(id=${a}), gpuDataId=${o.gpuData.id}`),this.storageCache.delete(a),this.buffersPending.push(o.gpuData.buffer),this.downloadCache.get(a)&&this.downloadCache.delete(a),o.originalSize}async download(a){let o=this.downloadCache.get(a);if(o)return o.data;let n=this.storageCache.get(a);if(!n)throw new Error("data does not exist");let e=this.backend.getCommandEncoder();this.backend.endComputePass();let t=h(n.originalSize),r=this.backend.device.createBuffer({size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});e.copyBufferToBuffer(n.gpuData.buffer,0,r,0,t),this.backend.flush();let i=new Promise(l=>{r.mapAsync(GPUMapMode.READ).then(()=>{let d=r.getMappedRange().slice(0);r.destroy(),l(d)})});return this.downloadCache.set(a,{data:i}),i}refreshPendingBuffers(){for(let a of this.buffersForUploadingPending)a.destroy();this.buffersForUploadingPending=[];for(let a of this.buffersPending)(a.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(a.size).push(a):a.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(a=>{a.forEach(o=>{o.destroy()})}),this.storageCache.forEach(a=>{a.gpuData.buffer.destroy()}),this.storageCache=new Map,this.downloadCache=new Map,this.freeBuffers=new Map}}c.createGpuDataManager=(...s)=>new u(...s)},8510:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(R,j,A,C){C===void 0&&(C=A);var _=Object.getOwnPropertyDescriptor(j,A);_&&!("get"in _?!j.__esModule:_.writable||_.configurable)||(_={enumerable:!0,get:function(){return j[A]}}),Object.defineProperty(R,C,_)}:function(R,j,A,C){C===void 0&&(C=A),R[C]=j[A]}),f=this&&this.__setModuleDefault||(Object.create?function(R,j){Object.defineProperty(R,"default",{enumerable:!0,value:j})}:function(R,j){R.default=j}),h=this&&this.__importStar||function(R){if(R&&R.__esModule)return R;var j={};if(R!=null)for(var A in R)A!=="default"&&Object.prototype.hasOwnProperty.call(R,A)&&m(j,R,A);return f(j,R),j};Object.defineProperty(c,"__esModule",{value:!0}),c.WEBGPU_OP_RESOLVE_RULES=void 0;let p=y(1868),u=h(y(504)),s=y(513),a=y(9770),o=y(7640),n=y(8856),e=y(8405),t=y(4271),r=y(1798),i=y(2915),l=y(1522),d=h(y(5262)),g=y(6031),b=y(4566),v=y(8906),w=y(5101),x=y(6198),T=y(2067),O=y(8699),P=y(2625),I=h(y(9302));c.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[I.abs]],["Acos",[I.acos]],["Acosh",[I.acosh]],["Add",[u.add]],["ArgMax",[p.argMax,p.parseArgMinMaxAttributes]],["ArgMin",[p.argMin,p.parseArgMinMaxAttributes]],["Asin",[I.asin]],["Asinh",[I.asinh]],["Atan",[I.atan]],["Atanh",[I.atanh]],["AveragePool",[d.averagePool,d.parseAveragePoolAttributes]],["Cast",[I.cast,I.parseCastAttributes]],["Ceil",[I.ceil]],["ClipV10",[I.clipV10]],["Clip",[I.clip]],["Concat",[s.concat,s.parseConcatAttributes]],["Conv",[a.conv,a.parseConvAttributes]],["ConvTranspose",[o.convTranspose,o.parseConvTransposeAttributes]],["Cos",[I.cos]],["Cosh",[I.cosh]],["Div",[u.div]],["Elu",[I.elu,I.parseAlphaAttributes]],["Erf",[I.erf]],["Exp",[I.exp]],["Expand",[n.expand]],["Floor",[I.floor]],["Gather",[e.gather,e.parseGatherAttributes]],["Gelu",[I.gelu]],["Gemm",[t.gemm,t.parseGemmAttributes]],["GlobalAveragePool",[d.globalAveragePool,d.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[d.globalMaxPool,d.parseGlobalMaxPoolAttributes]],["InstanceNormalization",[r.instanceNorm,r.parseInstanceNormAttributes]],["LayerNormalization",[i.layerNorm,i.parseLayerNormAttributes]],["LeakyRelu",[I.leakyRelu,I.parseAlphaAttributes]],["Log",[I.log]],["MatMul",[l.matMul]],["MaxPool",[d.maxPool,d.parseMaxPoolAttributes]],["Mul",[u.mul]],["Neg",[I.neg]],["Pow",[u.pow]],["Reciprocal",[I.reciprocal]],["ReduceMin",[g.reduceMin,g.parseReduceAttributes]],["ReduceMean",[g.reduceMean,g.parseReduceAttributes]],["ReduceMax",[g.reduceMax,g.parseReduceAttributes]],["ReduceSum",[g.reduceSum,g.parseReduceAttributes]],["ReduceProd",[g.reduceProd,g.parseReduceAttributes]],["ReduceL1",[g.reduceL1,g.parseReduceAttributes]],["ReduceL2",[g.reduceL2,g.parseReduceAttributes]],["ReduceLogSum",[g.reduceLogSum,g.parseReduceAttributes]],["ReduceLogSumExp",[g.reduceLogSumExp,g.parseReduceAttributes]],["ReduceSumSquare",[g.reduceSumSquare,g.parseReduceAttributes]],["Relu",[I.relu]],["Resize",[b.resize,b.parseResizeAttributes]],["Sigmoid",[I.sigmoid]],["Sin",[I.sin]],["Sinh",[I.sinh]],["Slice",[w.slice,w.parseSliceAttributes]],["SkipLayerNormalization",[v.skipLayerNorm,v.parseSkipLayerNormAttributes]],["Split",[T.split,T.parseSplitAttributes]],["Sqrt",[I.sqrt]],["Softmax",[x.softmax,x.parseSoftmaxAttributes]],["Sub",[u.sub]],["Tan",[I.tan]],["Tanh",[I.tanh]],["ThresholdedRelu",[I.thresholdedRelu,I.parseAlphaAttributes]],["Tile",[O.tile]],["Transpose",[P.transpose,P.parseTransposeAttributes]]])},1427:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.biasActivationSnippet=c.activationFnSnippet=c.typeSnippet=void 0,c.typeSnippet=y=>{switch(y){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${y}-component is not supported.`)}},c.activationFnSnippet=(y,m=!1,f=!1,h=3)=>"",c.biasActivationSnippet=(y,m)=>`
      ${y?"value = value + getBiasByOutputCoords(coords);":""}
      ${m?"value = activation(value, coords);":""}
      `},9456:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createConv2DMatMulProgramInfo=void 0;let m=y(4955),f=y(6952),h=y(1163),p=y(1427),u=y(4085),s=y(158);c.createConv2DMatMulProgramInfo=(a,o,n,e,t,r,i,l,d)=>{let g=n.format==="NHWC",b=g?a[0].dims[3]:a[0].dims[1],v=e[0],w=g?e[2]:e[3],x=g?e[1]:e[2],T=g?e[3]:e[1],O=((b%4==0||b%3==0)&&g||w%4==0&&!g)&&T%4==0,P=g?T:w*x,I=g?w*x:T,R=O?[8,8,1]:[P<=4?4:16,P>4&&I<=4?4:16,1],j=O?[4,4,1]:[P<=4?1:2,P>4&&I<=4?1:2,1],A=[Math.ceil(P/R[0]/j[0]),Math.ceil(I/R[1]/j[1]),Math.ceil(v/R[2]/j[1])];(0,m.LOG_DEBUG)("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${A}`);let C=O?g&&b%4!=0?3:4:j[0],_=R[1]*j[1],S=R[0]*j[0],E=Math.max(R[0]*C,R[1]),z=t%_==0,L=r%S==0,Y=i%E==0,X=O?[C,4,4]:[1,1,1],te=[`@group(0) @binding(0) var<storage, read> x: array<${O&&C===4?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${O?"vec4<f32>":"f32"}>;`],ae=`
      fn setOutputAtIndex(flatIndex : i32, value : ${O?"vec4<f32>":"f32"}) {
        result[flatIndex] = ${O?"vec4<f32>":"f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${O?"vec4<f32>":"f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${O?"/ 4":""}, value);
      }`;return l&&(te.push(`@group(0) @binding(2) var<storage, read> bias: array<${O?"vec4<f32>":"f32"}>;`),ae+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${O?"vec4<f32>":"f32"} {
          return bias[coords.${g?"w":"y"}${O?"/ 4":""}];
        }`),Object.assign(Object.assign({},o),{outputs:[{dims:e,dataType:a[0].dataType,gpuDataType:h.GpuDataType.default}],dispatchGroup:()=>({x:A[0],y:A[1],z:A[2]}),getShaderSource:()=>`
        ${u.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${te.join("")}
        @group(0) @binding(${te.length}) var<storage, read_write> result: array<${O?"vec4<f32>":"f32"}>;
        //@group(0) @binding(${te.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${a[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${a[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${f.ShapeUtil.computeStrides(e).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${n.kernelShape[0]}, ${n.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${n.pads[0]}, ${n.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${n.strides[0]}, ${n.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${n.dilations[0]}, ${n.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${r};
        const dimInner : i32 = ${i};
        ${ae}
        ${((se,pe,ge,ve,Me=!1,De,je=!1,_e=4,Be=4,Pe=4)=>{let Re=se?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,Ue=se?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,He=se?"xShape[1]":"xShape[2]",Ze=se?"xShape[2]":"xShape[3]",et=se?"row":"col",ct=se?"col":"row",qe=`
    let inChannels = wShape[2];
    let outWidth = ${se?"outShape[2]":"outShape[3]"};
    let outRow = ${et} / outWidth;
    let outCol = ${et} % outWidth;

    let WRow = ${ct} / (filterDims[1] * inChannels);
    let WCol = ${ct} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${ct} % inChannels;
    var resData = ${(0,p.typeSnippet)(_e)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${He} && xCol >= 0 && xCol < ${Ze}) {
      ${Re}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(ht=>{switch(ht){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${ht} is not supported.`)}})(_e)}
    }
    return resData;`,Qe=se?pe&&ve?`
    let col = colIn * ${_e};
    ${qe}`:`
    let col = colIn * ${_e};
    if (row < dimAOuter && col < dimInner) {
      ${qe}
    }
    return ${(0,p.typeSnippet)(_e)}(0.0);`:ve&&ge?`
    let col = colIn * ${_e};
    ${qe}`:`
    let col = colIn * ${_e};
    if (row < dimInner && col < dimBOuter) {
      ${qe}
    }
    return ${(0,p.typeSnippet)(_e)}(0.0);`,tt=`${(ht=>{switch(ht){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${ht} is not supported.`)}})(Be)}`,Ye=(0,p.typeSnippet)(Pe),wt=se?(0,p.typeSnippet)(_e):(0,p.typeSnippet)(Be),ft=se?(0,p.typeSnippet)(Be):(0,p.typeSnippet)(_e);return`
    ${(0,p.activationFnSnippet)(De,je,Pe===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${wt} {
      ${se?Qe:tt}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${ft} {
      ${se?tt:Qe}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${Ye}) {
      let col = colIn * ${Pe};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${se?"outShape[2]":"outShape[3]"};
      ${Ue}
      ${(0,p.biasActivationSnippet)(Me,De)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`})(g,z,L,Y,l,void 0,!1,X[0],X[1],X[2])}
            ${O?(0,s.makeMatMulPackedVec4Source)(j,R,!g,E):(0,s.makeMatMulPackedSource)(j,R,!g,E,!1,void 0,d)}`})}},6514:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createConvTranspose2DProgramInfo=void 0;let m=y(4955),f=y(6952),h=y(1163),p=y(2075);c.createConvTranspose2DProgramInfo=(u,s,a,o)=>{let n=u.length>2,e=a.outputShape,t=f.ShapeUtil.size(e),r=[Math.ceil(t/64),1,1];return(0,m.LOG_DEBUG)("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${r}`),Object.assign(Object.assign({},s),{outputs:[{dims:o?o(e):e,dataType:u[0].dataType,gpuDataType:h.GpuDataType.default}],dispatchGroup:()=>({x:r[0],y:r[1],z:r[2]}),getShaderSource:i=>((l,d,g,b,v,w,x=!1)=>{let T=g.format==="NHWC",O=T?1:2,P=T?2:3,I=T?3:1,R=f.ShapeUtil.size(b),j=x?2:1,A=g.group,C=d[1].dims,_=C[0]/A,S=C[1],E=`
  fn setOutputAtIndex(flatIndex : u32, value : ${x?"vec4<f32>":"f32"}) {
    result[flatIndex] = ${x?"vec4<f32>":"f32"}(value);
  }`;v&&(E+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${x?"vec4<f32>":"f32"} {
      return bias[coords.${T?"w":"y"}${x?"/ 4":""}];
    }`);let z=x?4:1,L=(0,p.inputVariable)("W",d[1].dataType,d[1].dims,z),Y=(0,p.inputVariable)("Dy",d[0].dataType,d[0].dims,z),X=[Y,L];v&&X.push((0,p.inputVariable)("bias",d[2].dataType,[b[I]],z));let te=(0,p.outputVariable)("result",d[0].dataType,b,z),ae=`{
        let batch: u32 = ${w?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${w?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${w?"global_id.y":"workgroup_id.y"} * ${j};
        let d1: u32 = ${w?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<f32>, ${j}>;
        for (var i = 0; i < ${j}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (f32(dyCorner.x) + f32(wR)) / f32(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (f32(dyCorner.y) + f32(wC)) / f32(strides.y);
            let dyC2 = (f32(dyCorner.y) + 1.0 + f32(wC)) / f32(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= f32(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= f32(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<f32>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${Y.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${I}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<f32>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${L.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${Y.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<f32>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${j}; i = i + 1) {
          let value = dotProd[i] + ${v?"bias[c+i]":"0.0"};
          ${te.set("batch","r","c + i","d1","value")};
        }
      }`,se=`
          let outputIndices = ${te.offsetToIndices("global_idx")};
          let batch = ${te.indicesGet("outputIndices",0)};
          let d1 = ${te.indicesGet("outputIndices",I)};
          let r = ${te.indicesGet("outputIndices",O)};
          let c = ${te.indicesGet("outputIndices",P)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${S};
          let wOutChannel = d1 - groupId * ${S};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (f32(dyRCorner) + f32(wR)) / f32(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= f32(outBackprop[${O}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (f32(dyCCorner) + f32(wC)) / f32(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= f32(outBackprop[${P}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);

              for (var d2: u32 = 0; d2 < ${_}; d2 = d2 + 1) {
                let inputChannel = groupId * ${_} + d2;
                let xValue = ${T?Y.get("batch","idyR","idyC","inputChannel"):Y.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${L.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
              }
            }
          }
          let value = dotProd + ${v?"bias[d1]":"0.0"};
          ${te.setByOffset("global_idx","value")};
        `;return`
  ${l.declareVariables(...X,te)}
  ${E}
  const outShape : vec4<u32> = vec4<u32>(${b.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${d[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${g.strides[0]}, ${g.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${g.kernelShape[T?1:2]}, ${g.kernelShape[T?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${g.dilations[0]}, ${g.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${g.dilations[0]<=1?0:(g.kernelShape[T?1:2]-1)*(g.dilations[0]-1)},
          ${g.dilations[1]<=1?0:(g.kernelShape[T?2:3]-1)*(g.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${g.pads[0]+g.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${g.pads[1]+g.pads[3]})/2);
    ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes(R)};
  ${x?ae:se}}`})(i,u,a,e,n,r[1]===1&&r[2]===1)})}},4085:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.utilFunctions=void 0,c.utilFunctions=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`},158:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.makeMatMulPackedSource=c.makeMatMulPackedVec4Source=void 0,c.makeMatMulPackedVec4Source=(m,f,h=!1,p=32,u=!1,s=32,a=!1)=>{let o=f[1]*m[1],n=f[0]*m[0],e=h?o:p,t=h?p:o,r=e/f[0],i=p/f[1];if((!h||r!==4||m[1]!==4)&&(h||r!==3&&r!==4)||e%f[0]!=0||p%f[1]!=0||m[0]!==4)throw new Error(`If transposeA ${h} is true, innerElementSize ${r} and workPerThread[1] ${m[1]} must be 4.
      Otherwise, innerElementSize ${r} must be 3 or 4.
  tileAWidth ${e} must be divisible by workgroupSize[0]${f[0]}. tileInner ${p} must be divisible by workgroupSize[1] ${f[1]}. colPerThread ${m[0]} must be 4.`);return`
var<workgroup> mm_Asub : array<array<vec${r}<f32>, ${e/r}>, ${t}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${n/m[0]}>, ${p}>;

const rowPerThread = ${m[1]};
const colPerThread = ${m[0]};
const innerElementSize = ${r};
const tileInner = ${p};

@compute @workgroup_size(${f[0]}, ${f[1]}, ${f[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${a?"0":"localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${a?"0":"i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${o};

  let numTiles = ${u?`${Math.ceil(s/p)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${s}`:"0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${i};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${l=h,l?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${i}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${r===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${((d,g)=>d?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${g===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${g===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${g===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(h,r)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;var l};let y=m=>m?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol);
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol);
            `;c.makeMatMulPackedSource=(m,f,h=!1,p=32,u=!1,s=32,a=!1)=>{let o=m[1]*f[1],n=m[0]*f[0],e=h?o:p,t=h?p:o;if(t%f[1]!=0||e%f[0]!=0||p%f[1]!=0)throw new Error(`tileAHight ${t} must be divisible by workgroupSize[1]${f[1]}, tileAWidth ${e} must be divisible by workgroupSize[0]${f[0]}, tileInner ${p} must be divisible by workgroupSize[1]${f[1]}`);let r=t/f[1],i=e/f[0],l=p/f[1],d=a?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${o};
    let globalColStart = i32(workgroupId.x) * ${n};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${t}; inputRow = inputRow + ${f[1]}) {
        for (var inputCol = localCol; inputCol < ${e}; inputCol = inputCol + ${f[0]}) {
          ${y(h)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${f[1]}) {
            for (var inputCol = localCol; inputCol < ${n}; inputCol = inputCol + ${f[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${f[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${h?`mm_Asub[k][localRow + innerRow * ${f[1]}];`:`mm_Asub[localRow + innerRow * ${f[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${f[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${f[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${o};

let tileRowA = i32(localId.y) * ${r};
let tileColA = i32(localId.x) * ${i};
let tileRowB = i32(localId.y) * ${l};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${r}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${i}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${y(h)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${l}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${(g=>g?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(h)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<f32, ${e}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${p}>;
  const rowPerThread = ${m[1]};
  const colPerThread = ${m[0]};
  const tileInner = ${p};

@compute @workgroup_size(${f[0]}, ${f[1]}, ${f[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    let numTiles = ${u?`${Math.ceil(s/p)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${s}`:"0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${d}
  }
`}},1868:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseArgMinMaxAttributes=c.argMax=c.argMin=void 0;let m=y(387),f=y(1163),h=y(6031),p=s=>{if(!s||s.length===0||s.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(s[0].dataType!==1)throw new Error("Invalid input type.")},u=(s,a,o,n)=>{let e=s.length===1?o:((i,l)=>(0,m.createAttributeWithCacheKey)({axis:l.axis,keepDims:l.keepDims,selectLastIndex:l.selectLastIndex}))(0,o),t=e.cacheKey+s.map(i=>i.dims.toString()).join("_"),r={name:a,inputTypes:[f.GpuDataType.default],cacheHint:t};return Object.assign(Object.assign({},r),{get:()=>(0,h.createReduceProgramInfo)(r,[s[0]],n,[e.axis],7,e.keepDims)})};c.argMin=(s,a)=>{p(s.inputs),s.compute(u(s.inputs,"ArgMin",a,(o,n,e)=>{let t=[];for(let r=0;r<o.shape.length;r++)(e.indexOf(r)>=0||e.length===0)&&t.push(`inputIndices[${r}] = 0;`);return[`${t.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${a.selectLastIndex>0?"<=":"<"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",n.setByOffset("global_idx","bestIndex")]}),{inputs:[0]})},c.argMax=(s,a)=>{p(s.inputs),s.compute(u(s.inputs,"argMax",a,(o,n,e)=>{let t=[];for(let r=0;r<o.shape.length;r++)(e.indexOf(r)>=0||e.length===0)&&t.push(`inputIndices[${r}] = 0;`);return[`${t.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${a.selectLastIndex>0?">=":">"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",n.setByOffset("global_idx","bestIndex")]}),{inputs:[0]})},c.parseArgMinMaxAttributes=s=>(0,m.createAttributeWithCacheKey)(s)},504:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.sub=c.pow=c.mul=c.div=c.add=void 0;let m=y(6952),f=y(1163),h=y(2075),p=(u,s,a,o,n)=>{let e={name:s,inputTypes:[f.GpuDataType.default,f.GpuDataType.default],cacheHint:n};return Object.assign(Object.assign({},e),{get:()=>((t,r,i,l,d,g=r.dataType)=>{var b,v;let w=!m.ShapeUtil.areEqual(r.dims,i.dims),x=r.dims,T=m.ShapeUtil.size(r.dims),O=!1;if(w){let P=m.BroadcastUtil.calcShape(r.dims,i.dims,!1);if(!P)throw new Error("Can't perform binary op on the given tensors");x=P,T=m.ShapeUtil.size(x);let I=1;for(let R=0;R<x.length;R++){let j=(b=r.dims[r.dims.length-R])!==null&&b!==void 0?b:1;if(j!==((v=i.dims[i.dims.length-R])!==null&&v!==void 0?v:1))break;I*=j}I%4==0&&(O=!0)}else O=!0;return Object.assign(Object.assign({},t),{getShaderSource:P=>((I,R,j,A,C,_,S,E,z,L,Y)=>{let X=m.ShapeUtil.size(A),te=Math.ceil(X/4),ae,se;typeof S=="string"?ae=se=(je,_e)=>`${S}((${je}),(${_e}))`:typeof S=="function"?ae=se=S:(ae=S.scalar,se=S.vector);let pe="",ge=(0,h.outputVariable)("outputData",L,A,4),ve=(0,h.inputVariable)("aData",E,R,4),Me=(0,h.inputVariable)("bData",z,j,4);if(_){let je=_e=>{let Be=m.ShapeUtil.computeStrides(_e),Pe=[];for(let Re=_e.length-1;Re>=0;Re--){let Ue=A.length===0?"0u":A.length===1?"outputIndices":`outputIndices[${Re+A.length-_e.length}]`;Pe.push(`${Be[Re]}u * (${Ue} % ${_e[Re]}u)`)}return Pe.length>0?Pe.join("+"):"0u"};pe=`
  fn calcOffsetA(outputIndices: ${ge.type.indices}) -> u32 {
    return ${je(R)};
  }

  fn calcOffsetB(outputIndices: ${ge.type.indices}) -> u32 {
    return ${je(j)};
  }
  `}let De;if(C)De=_?`
      let outputIndices = ${ge.offsetToIndices("global_idx * 4u")};
      let offsetA = calcOffsetA(outputIndices);
      let offsetB = calcOffsetB(outputIndices);
      ${ge.setByOffset("global_idx",se(ve.getByOffset("offsetA / 4u"),Me.getByOffset("offsetB / 4u")))}`:ge.setByOffset("global_idx",se(ve.getByOffset("global_idx"),Me.getByOffset("global_idx")));else{if(!_)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let je=_e=>{let Be=`aData[indexA${_e}][componentA${_e}]`,Pe=`bData[indexB${_e}][componentB${_e}]`;return`
      let outputIndices${_e} = ${ge.offsetToIndices(`global_idx * 4u + ${_e}u`)};
      let offsetA${_e} = calcOffsetA(outputIndices${_e});
      let offsetB${_e} = calcOffsetB(outputIndices${_e});
      let indexA${_e} = offsetA${_e} / 4u;
      let indexB${_e} = offsetB${_e} / 4u;
      let componentA${_e} = offsetA${_e} % 4u;
      let componentB${_e} = offsetB${_e} % 4u;
      outputData[global_idx][${_e}] = ${ae(Be,Pe)};`};De=`
      ${je(0)}
      ${je(1)}
      ${je(2)}
      ${je(3)}`}return`
  ${I.declareVariables(ve,Me,ge)}

  ${Y??""}
  ${pe}

  ${I.mainStart()}
    ${I.guardAgainstOutOfBoundsWorkgroupSizes(te)}
    ${De}
  }`})(P,r.dims,i.dims,x,O,w,l,r.dataType,i.dataType,g,d),outputs:[{dims:x,dataType:g,gpuDataType:f.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(T/64/(O?4:1))})})})(e,u[0],u[1],a,o)})};c.add=u=>{u.compute(p(u.inputs,"Add",(s,a)=>`${s}+${a}`))},c.div=u=>{u.compute(p(u.inputs,"Div",(s,a)=>`${s}/${a}`))},c.mul=u=>{u.compute(p(u.inputs,"Mul",(s,a)=>`${s}*${a}`))},c.pow=u=>{let s=(0,h.inputVariable)("input",u.inputs[0].dataType,u.inputs[0].dims).type.value,a=s==="i32"?"round":"";u.compute(p(u.inputs,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`
    fn pow_custom(a : ${s}, b : ${s}) -> ${s} {
      if (b == ${s}(0.0)) {
        return ${s}(1.0);
      } else if (a < ${s}(0.0) && f32(b) != floor(f32(b))) {
        return ${s}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${s}(1.0), round(f32(abs(b) % ${s}(2.0))) != 1.0) * ${s}(${a}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${s}>, b : vec4<${s}>) -> vec4<${s}> {
      // TODO: implement vectorized pow
      return vec4<${s}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `))},c.sub=u=>{u.compute(p(u.inputs,"Sub",(s,a)=>`${s}-${a}`))}},2075:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createShaderHelper=c.outputVariable=c.inputVariable=c.tensorTypeToWsglStorageType=c.WORKGROUP_SIZE=void 0;let m=y(6952);c.WORKGROUP_SIZE=64;let f=(u,s)=>{switch(u){case 1:return s>1?`vec${s}<f32>`:"f32";case 6:return s>1?`vec${s}<i32>`:"i32";case 12:return s>1?`vec${s}<u32>`:"u32";case 7:if(s>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(s>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(s!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${u}`)}};c.tensorTypeToWsglStorageType=(u,s=1)=>{let a=f(u,s);return typeof a=="string"?a:a[0]};let h=(u,s,a,o,n)=>{let e=a.length,t=e<2?"u32":e<=4?`vec${e}<u32>`:`array<u32, ${e}>`,r=f(s,n),i=typeof r=="string"?r:r[1],l=typeof r=="string"?r:r[0],d={indices:t,value:i,storage:l,tensor:s},g=S=>typeof S=="string"?S:`${S}u`,b={offsetToIndices:!1,indicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},v=m.ShapeUtil.computeStrides(a),w="";for(let S=0;S<e-1;S++)w+=`
    let dim${S} = current / ${v[S]}u;
    let rest${S} = current % ${v[S]}u;
    indices[${S}] = dim${S};
    current = rest${S};
    `;w+=`indices[${e-1}] = current;`;let x=e<2?"":`
  fn o2i_${u}(offset: u32) -> ${d.indices} {
    var indices: ${d.indices};
    var current = offset;
    ${w}
    return indices;
  }`,T=[];if(e>=2)for(let S=e-1;S>=0;S--)T.push(`${v[S]}u * (indices[${S}])`);let O=e<2?"":`
  fn i2o_${u}(indices: ${d.indices}) -> u32 {
    return ${T.join("+")};
  }`,P=(...S)=>e===0?"0u":`${d.indices}(${S.map(g).join(",")})`,I=(S,E)=>(()=>{if(d.storage===d.value)return`${u}[${S}]=${E};`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`${u}[${S}]=vec2<u32>(u32(${E}), select(0u, 0xFFFFFFFFu, ${E} < 0));`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`${u}[${S}]=vec2<u32>(u32(${E}), 0u);`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`${u}[${S}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${E}));`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),R=S=>(()=>{if(d.storage===d.value)return`${u}[${S}]`;if(d.storage==="vec2<u32>"&&d.value==="i32")return`i32(${u}[${S}].x)`;if(d.storage==="vec2<u32>"&&d.value==="u32")return`u32(${u}[${S}].x)`;if(d.storage==="u32"&&d.value==="vec4<bool>")return`vec4<bool>(bool(${u}[${S}] & 0xFFu), bool(${u}[${S}] & 0xFF00u), bool(${u}[${S}] & 0xFF0000u), bool(${u}[${S}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${d.storage} and value type ${d.value} yet`)})(),j=e<2?"":`
  fn get_${u}ByIndices(indices: ${d.indices}) -> ${i} {
    return ${u}[i2o_${u}(indices)];
  }`,A=e<2?"":(()=>{let S=a.map((z,L)=>`d${L}: u32`).join(", "),E=a.map((z,L)=>`d${L}`).join(", ");return`
  fn get_${u}(${S}) -> ${i} {
    return get_${u}ByIndices(${P(E)});
  }`})(),C=e<2?"":`
  fn set_${u}ByIndices(indices: ${d.indices}, value: ${i}) {
    ${I(`i2o_${u}(indices)`,"value")}
  }`,_=e<2?"":(()=>{let S=a.map((z,L)=>`d${L}: u32`).join(", "),E=a.map((z,L)=>`d${L}`).join(", ");return`
  fn set_${u}(${S}, value: ${i}) {
    set_${u}ByIndices(${P(E)}, value);
  }`})();return{impl:()=>{let S=[];return b.offsetToIndices&&S.push(x),b.indicesToOffset&&S.push(O),b.set&&S.push(_),b.setByIndices&&S.push(C),b.get&&S.push(A),b.getByIndices&&S.push(j),S.join(`
`)},type:d,offsetToIndices:S=>(b.offsetToIndices=!0,e<2?S:`o2i_${u}(${S})`),indicesToOffset:S=>(b.indicesToOffset=!0,e<2?S:`i2o_${u}(${S})`),indices:P,indicesGet:(S,E)=>e<2?`${S}`:`${S}[${E}]`,indicesSet:(S,E,z)=>e<2?`${S}=${z};`:`${S}[${E}]=${z};`,set:(...S)=>{if(S.length!==e+1)throw new Error(`indices length must be ${e}`);let E=S[e];if(typeof E!="string")throw new Error("value must be string");let z=S.slice(0,e).map(g).join(",");return e===0?I("0u",E):e===1?I(z[0],E):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${u}(${z}, ${E})`)},setByOffset:I,setByIndices:(S,E)=>e<2?I(S,E):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${u}ByIndices(${S}, ${E});`),get:(...S)=>{if(S.length!==e)throw new Error(`indices length must be ${e}`);let E=S.map(g).join(",");return e===0?R("0u"):e===1?R(E[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${u}(${E})`)},getByOffset:R,getByIndices:S=>e<2?R(S):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${u}ByIndices(${S})`),usage:o?"input":"output",name:u,shape:a}};c.inputVariable=(u,s,a,o=1)=>h(u,s,a,!0,o),c.outputVariable=(u,s,a,o=1)=>h(u,s,a,!1,o);class p{constructor(s){this.normalizedDispatchGroup=s,this.indicesHelpers=[]}guardAgainstOutOfBoundsWorkgroupSizes(s){return`if (global_idx >= ${typeof s=="number"?`${s}u`:s}) { return; }`}mainStart(s=c.WORKGROUP_SIZE){let a=typeof s=="number"?s:s[0],o=typeof s=="number"?1:s[1],n=typeof s=="number"?1:s[2],e=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1;return`@compute @workgroup_size(${a}, ${o}, ${n})
  fn main(${e?"@builtin(global_invocation_id) global_id : vec3<u32>":`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`}) {
    ${e?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${a*o*n}u + local_index;`}
  `}declareVariable(s,a){this.indicesHelpers.push(s);let o=s.usage==="input"?"read":"read_write",n=s.type.storage;return`@group(0) @binding(${a}) var<storage, ${o}> ${s.name}: array<${n}>;`}declareVariables(...s){let a=0;return s.filter(o=>m.ShapeUtil.size(o.shape)>0).map(o=>this.declareVariable(o,a++)).join(`
`)}get additionalImplementations(){return this.indicesHelpers.map(s=>s.impl()).join(`
`)}}c.createShaderHelper=u=>new p(u)},513:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseConcatAttributes=c.concat=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075);c.concat=(u,s)=>{(a=>{if(!a||a.length<1)throw new Error("too few inputs");let o=a[0].dataType,n=a[0].dims.length;for(let e of a){if(e.dataType!==o)throw new Error("input tensors should be one type");if(e.dims.length!==n)throw new Error("input tensors should have the same shape")}})(u.inputs),u.compute(((a,o)=>{let n=(e=a.length,t=o.cacheKey,{name:"Concat",inputTypes:Array(e).fill(h.GpuDataType.default),cacheHint:t});var e,t;return Object.assign(Object.assign({},n),{get:()=>((r,i,l)=>{let d=i[0].dims.slice();if(l>=d.length||l<-1*d.length)throw new Error("axis specified for concat doesn't match input dimensionality");let g=l<0?d.length+l:l,b=d.slice(0);for(let R=1;R<i.length;R++){let j=i[R].dims.slice();for(let A=0;A<d.length;A++)if(A===g)b[g]+=j[A];else if(d[A]!==j[A])throw new Error("non concat dimensions must match")}let v=m.ShapeUtil.size(b),w=new Array(i.length),x=new Array(i.length),T=i[0].dataType,O=0;for(let R=0;R<i.length;++R)O+=i[R].dims[g],w[R]=O,x[R]=(0,p.inputVariable)(`input${R}`,T,i[R].dims);let P=(0,p.outputVariable)("output",T,b),I=P.indicesGet("indices",g);return Object.assign(Object.assign({},r),{outputs:[{dims:b,dataType:i[0].dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:R=>{return`
  ${R.declareVariables(...x,P)}

  const sizeInConcatAxis = array<u32, ${w.length}>(${w.map(A=>`${A}u`).join(",")});
  ${j=w.length,`
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${j}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${j}u;
  }`}

  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes(v)}

    var indices = ${P.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${I});
    if (inputIndex != 0u) {
      ${I} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${((A,C)=>{let _=A.length,S=[];for(let E=0;E<_;++E){let z=C.setByOffset("global_idx",A[E].getByIndices("indices"));_===1?S.push(z):E===0?S.push(`if (inputIndex == ${E}u) { ${z} }`):E===_-1?S.push(`else { ${z} }`):S.push(`else if (inputIndex == ${E}) { ${z} }`)}return S.join(`
`)})(x,P)}
  }`;var j},dispatchGroup:()=>({x:Math.ceil(v/64)})})})(n,a,o.axis)})})(u.inputs,s))},c.parseConcatAttributes=u=>(0,f.createAttributeWithCacheKey)({axis:u.axis})},9192:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createGroupedConvProgramInfoLoader=void 0;let m=y(6952),f=y(1163),h=y(2075),p=y(9770),u=y(3997);c.createGroupedConvProgramInfoLoader=(s,a,o)=>{let n=(e=s.length>2,t=a.cacheKey,{name:"GroupedConv",inputTypes:e?[f.GpuDataType.default,f.GpuDataType.default,f.GpuDataType.default]:[f.GpuDataType.default,f.GpuDataType.default],cacheHint:t});var e,t;return Object.assign(Object.assign({},n),{get:()=>((r,i,l,d)=>{let g=r.length>2,b=g?"value += b[output_channel];":"",v=r[0].dims,w=r[1].dims,x=w[0]/l.group,{activationFunction:T,applyActivation:O}=(0,u.getActicationSnippet)(l),P=l.format==="NHWC",I=(0,p.calculateOutputShape)(v,w,l.dilations,l.pads,l.strides,P),R=m.ShapeUtil.size(I),j=(0,h.outputVariable)("output",r[0].dataType,I),A=(0,h.inputVariable)("x",r[0].dataType,v),C=(0,h.inputVariable)("w",r[1].dataType,w),_=[A,C];return g&&_.push((0,h.inputVariable)("b",r[2].dataType,r[2].dims)),Object.assign(Object.assign({},i),{outputs:[{dims:d?d(I):I,dataType:r[0].dataType,gpuDataType:f.GpuDataType.default}],getShaderSource:S=>`
  const strides: vec2<u32> = vec2(${l.strides[0]}u, ${l.strides[1]}u);
  const pads: vec2<u32> = vec2(${l.pads[0]}u, ${l.pads[1]}u);

  ${S.declareVariables(..._,j)}

  ${T}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(R)}

    let outputIndices = ${j.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${P?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${P?1:2}], outputIndices[${P?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${x}u;

    var value: ${j.type.value} = ${j.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${w[1]}u; wInChannel++) {
      let input_channel = group_id * ${w[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${w[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${l.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${v[P?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${w[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${l.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${v[P?2:3]}u) {
            continue;
          }

          let xVal = ${P?A.get("batch","xHeight","xWidth","input_channel"):A.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${C.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${b}
    ${O}
    ${j.setByOffset("global_idx","value")}
  }`,dispatchGroup:()=>({x:Math.ceil(R/64)})})})(s,n,a,o)})}},7640:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.convTranspose=c.parseConvTransposeAttributes=void 0;let m=y(387),f=y(1163),h=y(6514),p=y(3997),u=(n,e,t,r,i,l)=>(n-1)*e+t+(r-1)*i+1-l,s=(n,e,t,r,i)=>{let l=Math.floor(n/2);e==="SAME_UPPER"?(t[r]=l,t[i]=n-l):e==="SAME_LOWER"&&(t[r]=n-l,t[i]=l)},a=(n,e)=>{let t=n.kernelShape.slice();if(n.kernelShape.length===0||n.kernelShape.reduce((x,T)=>x*T,0)===0){t.length=0;for(let x=2;x<e[1].dims.length;++x)t.push(e[1].dims[x])}let r=n.format==="NHWC";t.splice(0,0,e[1].dims[0]),t.splice(r?3:1,0,e[1].dims[1]);let i=n.pads.slice(),l=n.outputShape.slice(),d=n.outputPadding.slice(),g=e[0].dims,b=n.dilations.slice();if(b.reduce((x,T)=>x+T,0)===0){let x=e[0].dims.length-2;b=new Array(x).fill(1)}let v=n.strides.slice();if(v.reduce((x,T)=>x+T,0)===0){let x=e[0].dims.length-2;v=new Array(x).fill(1)}((x,T,O,P,I,R,j,A,C,_)=>{let S=x.length-2,E=_.length===0;if(C.length===0)for(let Y=0;Y<S;++Y)C.push(0);let z=x[0],L=T[A?3:1]*I;for(let Y=0,X=x.length-S-(A?1:0);Y<S;++Y,++X){let te=x[X],ae=E?te*j[Y]:_[Y],se=u(te,j[Y],R[Y],T[X],O[Y],ae);s(se,P,R,Y,Y+S),E&&_.push(j[Y]*(te-1)+C[Y]+(T[X]-1)*O[Y]+1-R[Y]-R[Y+S])}_.splice(0,0,z),_.splice(A?3:1,0,L)})(g,t,b,n.autoPad,n.group,i,v,r,d,l);let w=Object.assign({},n);return Object.assign(w,{kernelShape:t,pads:i,outputPadding:d,outputShape:l,dilations:b,strides:v,cacheKey:n.cacheKey}),w};c.parseConvTransposeAttributes=n=>{let e=(0,p.parseInternalActivationAttributes)(n),t=n.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.autoPad===void 0?0:n.autoPad],i=n.dilations,l=n.group,d=n.kernelShape,g=n.pads,b=n.strides,v=n.wIsConst(),w=n.outputPadding,x=n.outputShape;return(0,m.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:t,dilations:i,group:l,kernelShape:d,outputPadding:w,outputShape:x,pads:g,strides:b,wIsConst:v},e))};let o=(n,e,t)=>{let r=(i=n.length===3,l=e.cacheKey,{name:"ConvTranspose2D",inputTypes:i?[f.GpuDataType.default,f.GpuDataType.default,f.GpuDataType.default]:[f.GpuDataType.default,f.GpuDataType.default],cacheHint:l});var i,l;return Object.assign(Object.assign({},r),{get:()=>(0,h.createConvTranspose2DProgramInfo)(n,r,e,t)})};c.convTranspose=(n,e)=>{((t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");if(t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1]!==t[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let i=t[1].dims[1]*r.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==i))throw new Error("invalid bias");let l=t[0].dims.length-2;if(r.dilations.reduce((d,g)=>d+g,0)>0&&r.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(r.strides.reduce((d,g)=>d+g,0)>0&&r.strides.length!==l)throw new Error(`strides should be ${l}D`);if(r.pads.reduce((d,g)=>d+g,0)>0&&r.pads.length!==2*l)throw new Error(`pads should be ${2*l}D`);if(r.outputPadding.length!==l&&r.outputPadding.length!==0)throw new Error(`output_padding should be ${l}D`);if(r.kernelShape.reduce((d,g)=>d+g,0)>0&&r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape");if(t[0].dataType!==1||t[1].dataType!==1)throw new Error("ConvTranspose input(X,W) should be float tensor");if(t.length===3&&t[2].dataType!==1)throw new Error("ConvTranspose input(bias) should be float tensor")})(n.inputs,e),n.inputs[0].dims.length===3?((t,r)=>{let i=r.format==="NHWC",l=[t.inputs[0].reshape(i?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];l.length===3&&l.push(t.inputs[2]);let d=r.kernelShape;d.length!==0&&d[0]!==0||(d=[t.inputs[1].dims[2]]);let g=r.dilations;g.length!==0&&g[0]!==0||(g=[1]);let b=r.strides;b.length!==0&&b[0]!==0||(b=[1]);let v=r.pads;v.length===0&&(v=[0,0]),v=[0,v[0],0,v[1]],b=[1].concat(b),g=[1].concat(g),d=[1].concat(d);let w=a(Object.assign(Object.assign({},r),{pads:v,strides:b,dilations:g,kernelShape:d}),l);t.compute(o(l,w,x=>i?[x[0],x[2],x[3]]:[x[0],x[1],x[3]]))})(n,e):((t,r,i)=>{let l=a(i,r);t.compute(o(r,l))})(n,n.inputs,e)}},9770:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.conv=c.parseConvAttributes=c.calculateOutputShape=void 0;let m=y(6952),f=y(387),h=y(9192),p=y(3822),u=y(3997),s=y(2625);c.calculateOutputShape=(n,e,t,r,i,l)=>{let d=n[0],g=n.slice(l?1:2,l?3:4),b=g.length,v=e[0],w=e.slice(2).map((T,O)=>T+(T-1)*(t[O]-1)),x=g.map((T,O)=>T+r[O]+r[O+b]).map((T,O)=>Math.floor((T-w[O]+i[O])/i[O]));return x.splice(0,0,d),x.splice(l?3:1,0,v),x};let a=(0,f.createAttributeWithCacheKey)({perm:[2,3,1,0]}),o=(n,e)=>{let t=n.kernelShape.slice();for(let l=2;l<e[1].dims.length;++l)t[l-2]===0&&(t[l-2]=e[1].dims[l]);let r=n.pads.slice();m.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims,n.strides,n.dilations,t,r,n.format==="NHWC",n.autoPad);let i=Object.assign({},n);return Object.assign(i,{kernelShape:t,pads:r,cacheKey:n.cacheKey}),i};c.parseConvAttributes=n=>{let e=(0,u.parseInternalActivationAttributes)(n),t=n.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],i=n.dilations,l=n.group,d=n.kernel_shape,g=n.pads,b=n.strides,v=n.w_is_const();return(0,f.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:t,dilations:i,group:l,kernelShape:d,pads:g,strides:b,wIsConst:v},e))},c.conv=(n,e)=>{((t,r)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");if(t[0].dims[r.format==="NHWC"?t[0].dims.length-1:1]!==t[1].dims[1]*r.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let i=t[0].dims.length-2;if(r.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(r.strides.length!==i)throw new Error(`strides should be ${i}D`);if(r.pads.length!==2*i)throw new Error(`pads should be ${2*i}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(t[0].dataType!==1||t[1].dataType!==1)throw new Error("Conv input(X,W) should be float tensor");if(t.length===3&&t[2].dataType!==1)throw new Error("Conv input(bias) should be float tensor")})(n.inputs,e),n.inputs[0].dims.length===3?((t,r)=>{let i=r.format==="NHWC",l=[t.inputs[0].reshape(i?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&l.push(t.inputs[2]);let d=[0,r.pads[0],0,r.pads[1]],g=[1].concat(r.strides),b=[1].concat(r.dilations),v=[1].concat(r.kernelShape),w=o(Object.assign(Object.assign({},r),{pads:d,strides:g,dilations:b,kernelShape:v}),l);t.compute((0,h.createGroupedConvProgramInfoLoader)(l,w,x=>i?[x[0],x[2],x[3]]:[]))})(n,e):((t,r,i)=>{var l;let d=o(i,r),g=r.length===3,b=i.format==="NHWC",v=r[0].dims[b?1:2],w=r[0].dims[b?2:3],x=r[0].dims[b?3:1],T=r[1].dims[2],O=r[1].dims[3],P=(0,c.calculateOutputShape)(r[0].dims,r[1].dims,i.dilations,d.pads,i.strides,b),I=P[b?1:2],R=P[b?2:3],j=P[b?3:1];if(b&&T===v&&O===w&&i.autoPad==="VALID"||T===1&&O===1&&i.dilations[0]===1&&i.dilations[1]===1&&i.strides[0]===1&&i.strides[1]===1&&(i.autoPad==="SAME_UPPER"||i.autoPad==="SAME_LOWER"||i.autoPad==="VALID")||!b||i.group!==1)return void t.compute((0,h.createGroupedConvProgramInfoLoader)(r,d));let A=b?I*R:j,C=b?j:I*R,_=T*O*x,S=(l=t.kernelCustomData.wT)!==null&&l!==void 0?l:t.compute(Object.assign(Object.assign({},s.transposeProgramMetadata),{cacheHint:a.cacheKey,get:()=>(0,s.createTransposeProgramInfo)(r[1],a.perm)}),{inputs:[1],outputs:[i.wIsConst?-2:-1]})[0];i.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=S);let E=[r[0],S];g&&(b||r[2].dims.length!==1?E.push(r[2]):E.push(r[2].reshape([r[2].dims[0],1,1]))),t.compute((0,p.createConv2DMatMulProgramInfoLoader)(E,d,P,A,C,_,g,!0),{inputs:E})})(n,n.inputs,e)}},3822:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.createConv2DMatMulProgramInfoLoader=void 0;let m=y(1163),f=y(9456);c.createConv2DMatMulProgramInfoLoader=(h,p,u,s,a,o,n,e)=>{let t=((r,i)=>({name:"Conv2DMatMul",inputTypes:r?[m.GpuDataType.default,m.GpuDataType.default,m.GpuDataType.default]:[m.GpuDataType.default,m.GpuDataType.default],cacheHint:i}))(n,p.cacheKey);return Object.assign(Object.assign({},t),{get:()=>(0,f.createConv2DMatMulProgramInfo)(h,t,p,u,s,a,o,n,e)})}},8856:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.expand=c.expandProgramMetadata=void 0;let m=y(6952),f=y(1163),h=y(2075);c.expandProgramMetadata={name:"Expand",inputTypes:[f.GpuDataType.default]};let p=(u,s)=>{let a=u.length-s.length,o=[];for(let n=0;n<a;++n)o.push(u[n]);for(let n=0;n<s.length;++n)o.push(s[n]===1?u[n+a]:s[n]);return o};c.expand=u=>{(a=>{if(!a||a.length!==2)throw new Error("Expand requires 2 input.");let o=a[0].dims,n=Array.from(a[1].getBigInt64Array(),Number),e=n.length<o.length?0:n.length-o.length,t=o.length<n.length?0:o.length-n.length;for(;e<n.length&&t<o.length;++e,++t)if(n[e]!==o[t]&&n[e]!==1&&o[t]!==1)throw new Error("Expand requires shape to be broadcastable to input")})(u.inputs);let s=Array.from(u.inputs[1].getBigInt64Array(),Number).toString();u.compute(Object.assign(Object.assign({},c.expandProgramMetadata),{cacheHint:s,get:()=>((a,o)=>{let n=o[0].dims,e=Array.from(o[1].getBigInt64Array(),Number),t=((g,b)=>g.length>b.length?p(g,b):p(b,g))(n,e),r=m.ShapeUtil.size(t),i=o[0].dataType,l=(0,h.inputVariable)("input",i,n),d=(0,h.outputVariable)("output",i,t);return Object.assign(Object.assign({},a),{getShaderSource:g=>`
  const inputShape = ${l.indices(...n)};
  ${g.declareVariables(l,d)}
  ${g.mainStart()}
  ${g.guardAgainstOutOfBoundsWorkgroupSizes(r)}
    let outputIndices = ${d.offsetToIndices("global_idx")};
    var inputIndices: ${l.type.indices};
    for (var i = 0; i < ${n.length}; i++) {
      if (${l.indicesGet("inputShape","i")} == 1) {
        ${l.indicesSet("inputIndices","i",0)}
      } else {
        ${l.indicesSet("inputIndices","i",d.indicesGet("outputIndices","i + "+(t.length-n.length)))}
      }
    }
    ${d.setByOffset("global_idx",l.getByIndices("inputIndices"))}
  }`,outputs:[{dims:t,dataType:o[0].dataType,gpuDataType:f.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(r/64)})})})(c.expandProgramMetadata,u.inputs)}),{inputs:[0]})}},3997:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseInternalActivationAttributes=c.getActicationSnippet=void 0;let m=y(6952);c.getActicationSnippet=f=>{switch(f.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${f.clipMin});const clip_max_=f32(${f.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},c.parseInternalActivationAttributes=f=>{let h=f?.activation||"";if(h==="Clip"){let[p,u]=f?.activation_params||[m.MIN_CLIP,m.MAX_CLIP];return{activation:h,clipMax:u,clipMin:p,activationCacheKey:`${h}:${p},${u}`}}return{activation:h,activationCacheKey:h}}},8405:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.gather=c.parseGatherAttributes=void 0;let m=y(6952),f=y(387),h=y(1163);c.parseGatherAttributes=p=>(0,f.createAttributeWithCacheKey)({axis:p.axis}),c.gather=(p,u)=>{(a=>{if(!a||a.length!==2)throw new Error("Gather requires 2 inputs.")})(p.inputs);let s={name:"Gather",inputTypes:[h.GpuDataType.default,h.GpuDataType.default],cacheHint:u.cacheKey};p.compute(((a,o,n)=>{let e=o[0].dims,t=o[1].dims,r=e.length,i=m.ShapeUtil.normalizeAxis(n.axis,r),l=e.slice(0);l.splice(i,1,...t);let d=o[0].dataType,g=m.ShapeUtil.sizeFromDimension(e,i+1),b=[7,13,11].includes(d)?2:1,v=o[1].dataType===7?2:1,w=b*g,x=m.ShapeUtil.sizeToDimension(e,i),T=m.ShapeUtil.size(t),O=m.ShapeUtil.sizeFromDimension(e,i)*b,P=T*g*b,I=e[i],R=m.ShapeUtil.size(e)*b,j=m.ShapeUtil.size(l)*b,A=x*T;return Object.assign(Object.assign({},a),{outputs:[{dims:l,dataType:o[0].dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:C=>`
  const N: u32 = ${T};
  const elementSize: u32 = ${b};
  const indicesElementSize: u32 = ${v};

  @group(0) @binding(0) var<storage, read> input : array<u32>;
  @group(0) @binding(1) var<storage, read> inputIndices : array<i32>;
  @group(0) @binding(2) var<storage, read_write> output: array<u32>;

  ${C.mainStart()}
    let batch: u32 = global_idx / N;
    let i: u32 = global_idx % N;

    let srcOffsetBatch: u32 = batch * ${O};
    let dstOffsetBatch: u32 = batch * ${P};
    var idx = inputIndices[i * indicesElementSize];
    if (idx < 0) {
        idx = idx + ${I};
    }

    let srcOffset = srcOffsetBatch + u32(idx) * ${w};
    let dstOffset = dstOffsetBatch + i * ${w};
    if (srcOffset >= ${R}) {
        return;
    }
    if (dstOffset >= ${j}) {
        return;
    }
    for (var j: u32 = 0; j < ${w}; j++) {
        output[dstOffset + j] = input[srcOffset + j];
    }
  }`,dispatchGroup:()=>({x:Math.ceil(A/64)})})})(s,p.inputs,u))}},4271:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseGemmAttributes=c.gemm=void 0;let m=y(6952),f=y(387),h=y(1163);c.gemm=(p,u)=>{(s=>{if(!s)throw new Error("Input is missing");if(s.length<2||s.length>3)throw new Error("Invaid input number.");if(s.length===3&&s[2].dims.length>2)throw new Error("Invalid input shape of C");if(s[0].dataType!==1||s[1].dataType!==1||s.length===3&&s[2].dataType!==1)throw new Error("Invalid input type.");if(s[0].dataType!==s[1].dataType||s.length===3&&s[0].dataType!==s[2].dataType)throw new Error("Input types are mismatched")})(p.inputs),p.compute(((s,a)=>{let o={name:"Gemm",inputTypes:s.length===3?[h.GpuDataType.default,h.GpuDataType.default,h.GpuDataType.default]:[h.GpuDataType.default,h.GpuDataType.default],cacheHint:a.cacheKey};return Object.assign(Object.assign({},o),{get:()=>((n,e,t)=>{let r=e[0].dims.slice(),i=e[1].dims.slice(),[l,d,g]=m.GemmUtil.getShapeOfGemmResult(r,t.transA,i,t.transB,e.length===3?e[2].dims:void 0),b=[l,d];if(!b)throw new Error("Can't use gemm on the given tensors");let v=m.ShapeUtil.size(b),w="";t.transA&&t.transB?w="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?w="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?w="value += a[m * K + k] * b[n * K + k];":t.transA||t.transB||(w="value += a[m * K + k] * b[k * N + n];");let x="f32",T=t.alpha===1?"":"value *= alpha;",O=e.length===3?`value += beta * c[${((I,R,j)=>{if(j.length===0)return"0u";let A=j.length===1&&I!==1||j.length===2&&j[0]!==I,C=j[j.length-1]!==R,_="0u";return A||(_+=`+ m * ${j[j.length-1]}u`),C||(_+="+n"),_})(l,d,e[2].dims)}];`:"",P=[`@group(0) @binding(0) var<storage, read> a : array<${x}>;`,`@group(0) @binding(1) var<storage, read> b : array<${x}>;`];return e.length===3&&P.push(`@group(0) @binding(2) var<storage, read> c : array<${x}>;`),Object.assign(Object.assign({},n),{outputs:[{dims:b,dataType:e[0].dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:I=>`
  const M: u32 = ${l}u;
  const N: u32 = ${d}u;
  const K: u32 = ${g}u;
  const alpha = ${x}(${t.alpha});
  const beta = ${x}(${t.beta});

  ${P.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${x}>;

  ${I.mainStart()}
    ${I.guardAgainstOutOfBoundsWorkgroupSizes(v)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${x}(0);
    for (var k: u32 = 0u; k<${g}u; k++) {
      ${w}
    }

    ${T}
    ${O}
    output[global_id.x] = value;

  }`,dispatchGroup:()=>({x:Math.ceil(v/64)})})})(o,s,a)})})(p.inputs,u))},c.parseGemmAttributes=p=>(0,f.createAttributeWithCacheKey)(p)},1798:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.instanceNorm=c.parseInstanceNormAttributes=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075);c.parseInstanceNormAttributes=u=>(0,f.createAttributeWithCacheKey)({epsilon:u.epsilon,format:u.format}),c.instanceNorm=(u,s)=>{(o=>{if(!o||o.length!==3)throw new Error("instanceNorm requires 3 inputs.");if(o[0].dataType!==1||o[1].dataType!==1)throw new Error("inputs should be float type")})(u.inputs);let a={name:"InstanceNormalization",inputTypes:[h.GpuDataType.default,h.GpuDataType.default,h.GpuDataType.default],cacheHint:s.cacheKey};s.format==="NHWC"?u.compute(((o,n,e)=>{let t=n[0].dims,r=t,i=m.ShapeUtil.size(r),l=t[0],d=t[t.length-1],g=m.ShapeUtil.sizeFromDimension(t,1)/d,b=(0,p.tensorTypeToWsglStorageType)(n[0].dataType),v=d*l;return Object.assign(Object.assign({},o),{outputs:[{dims:r,dataType:n[0].dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:w=>`
  const N: u32 = ${l};
  const H: u32 = ${g};
  const C: u32 = ${d};
  const normSizeTyped: ${b} = ${g};
  const imageSize: u32 = ${g*d};
  const epsilon: f32 = ${e.epsilon};

  @group(0) @binding(0) var<storage, read> x : array<${b}>;
  @group(0) @binding(1) var<storage, read> scale : array<${b}>;
  @group(0) @binding(2) var<storage, read> bias : array<${b}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${b}>;

  ${w.mainStart()}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;
    
    // offset is channel num * N
    let offset = currentImageNumber * imageSize;
    if (offset >= ${i}) { return; }
    var mean: ${b} = 0;

    for (var i: u32 = 0u; i < H; i++) {
        mean = mean + x[offset + i * C + currentChannelNumber];
    }
    mean = mean / normSizeTyped;

    var squaredNorm: ${b} = 0;
    for (var i: u32 = 0u; i < H; i++) {
        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;
        squaredNorm = squaredNorm + deviation * deviation;
    }
    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);
    let channelScale = invStdDev * scale[currentChannelNumber];
    let channelShift = bias[currentChannelNumber] - mean * channelScale;
    for (var i: u32 = 0u; i < H; i++) {
        let currentOffset = offset + i * C + currentChannelNumber;
        output[currentOffset] = x[currentOffset] * channelScale + channelShift;
    }
  }`,dispatchGroup:()=>({x:Math.ceil(v/64)})})})(a,u.inputs,s)):u.compute(((o,n,e)=>{let t=n[0].dims,r=n[1],i=n[2],l=t,d=m.ShapeUtil.size(l),g=m.ShapeUtil.sizeToDimension(t,2),b=m.ShapeUtil.sizeFromDimension(t,2),v=t[1],w=m.ShapeUtil.size(r.dims),x=i?m.ShapeUtil.size(i.dims):0;if(w!==b||i&&x!==b)throw new Error(`Size of X.shape()[axis:] == ${b}.
             Size of scale and bias (if provided) must match this. 
             Got scale size of ${w} and bias size of ${x}`);let T=(0,p.tensorTypeToWsglStorageType)(n[0].dataType);return Object.assign(Object.assign({},o),{outputs:[{dims:l,dataType:n[0].dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:O=>`
  const C: u32 = ${v};
  const normSize: u32 = ${b};
  const normSizeTyped: ${T} = ${b};
  const epsilon: f32 = ${e.epsilon};

  @group(0) @binding(0) var<storage, read> x : array<${T}>;
  @group(0) @binding(1) var<storage, read> scale : array<${T}>;
  @group(0) @binding(2) var<storage, read> bias : array<${T}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${T}>;

  ${O.mainStart()}
    let offset = global_idx * normSize;
    if (offset + normSize >= ${d}) { return; }
    var mean: ${T} = 0;

    for (var h: u32 = 0u; h < normSize; h++) {
        mean = mean + x[h + offset];
    }
    mean = mean / normSizeTyped;

    var squaredNorm: ${T} = 0;
    for (var h: u32 = 0u; h < normSize; h++) {
        let deviation: f32 = x[h + offset] - mean;
        squaredNorm = squaredNorm + deviation * deviation;
    }
    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);
    let channelScale = invStdDev * scale[global_idx % C];
    let channelShift = bias[global_idx % C] - mean * channelScale;
    for (var j: u32 = 0; j < normSize; j++) {
        output[j + offset] = x[j + offset] * channelScale + channelShift;
    }
  }`,dispatchGroup:()=>({x:Math.ceil(g/64)})})})(a,u.inputs,s))}},2915:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.layerNorm=c.parseLayerNormAttributes=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075);c.parseLayerNormAttributes=u=>(0,f.createAttributeWithCacheKey)({axis:u.axis,epsilon:u.epsilon}),c.layerNorm=(u,s)=>{(o=>{if(!o||o.length<2)throw new Error("layerNorm requires at least 2 inputs.");if(o[0].dataType!==1||o[1].dataType!==1)throw new Error("inputs should be float type")})(u.inputs);let a={name:"LayerNormalization",inputTypes:u.inputs.length===2?[h.GpuDataType.default,h.GpuDataType.default]:[h.GpuDataType.default,h.GpuDataType.default,h.GpuDataType.default],cacheHint:s.cacheKey+u.outputCount.toString(10)+u.inputs.length.toString(10)};u.compute(((o,n,e,t)=>{let r=n[0].dims,i=n[1],l=n[2],d=r,g=m.ShapeUtil.size(d),b=m.ShapeUtil.normalizeAxis(e.axis,r.length),v=m.ShapeUtil.sizeToDimension(r,b),w=m.ShapeUtil.sizeFromDimension(r,b),x=m.ShapeUtil.size(i.dims),T=l?m.ShapeUtil.size(l.dims):0;if(x!==w||l&&T!==w)throw new Error(`Size of X.shape()[axis:] == ${w}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${x} and bias size of ${T}`);let O=[];for(let C=0;C<r.length;++C)C<b?O.push(r[C]):O.push(1);let P=(0,p.tensorTypeToWsglStorageType)(n[0].dataType),I=t>1,R=t>2,j=0,A=[{dims:d,dataType:n[0].dataType,gpuDataType:h.GpuDataType.default}];return I&&A.push({dims:O,dataType:n[0].dataType,gpuDataType:h.GpuDataType.default}),R&&A.push({dims:O,dataType:n[0].dataType,gpuDataType:h.GpuDataType.default}),Object.assign(Object.assign({},o),{outputs:A,getShaderSource:C=>`
  const normSize: u32 = ${w};
  const normSizeTyped: ${P} = ${w};
  const epsilon: f32 = ${e.epsilon};

  @group(0) @binding(${j++}) var<storage, read> x : array<${P}>;
  @group(0) @binding(${j++}) var<storage, read> scale : array<${P}>;
  ${l?`@group(0) @binding(${j++}) var<storage, read> bias : array<${P}>;`:""}
  @group(0) @binding(${j++}) var<storage, read_write> output : array<${P}>;
  ${I?`@group(0) @binding(${j++}) var<storage, read_write> meanDataOutput : array<${P}>`:""};
  ${R?`@group(0) @binding(${j++}) var<storage, read_write> invStdOutput : array<${P}>`:""};

  ${C.mainStart()}
    let offset = global_idx * normSize;
    if (offset >= ${g}) { return; }
    var mean: ${P} = 0;
    var meanSquare: ${P} = 0;

    for (var h: u32 = 0u; h < normSize; h++) {
      mean = mean + x[h + offset];
      meanSquare = meanSquare + x[h + offset] * x[h + offset];
    }
    mean = mean / normSizeTyped;
    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSize; j++) {
      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${l?"+ bias[j]":""};
    }

    ${I?"meanDataOutput[global_idx] = mean":""};
    ${R?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,dispatchGroup:()=>({x:Math.ceil(v/64)})})})(a,u.inputs,s,u.outputCount))}},1522:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.matMul=c.createMatmulProgramInfoLoader=void 0;let m=y(6952),f=y(1163),h=y(3997);c.createMatmulProgramInfoLoader=(p,u)=>{let s=(a=p.length>2,o=u.activationCacheKey,{name:"MatMul",inputTypes:a?[f.GpuDataType.default,f.GpuDataType.default,f.GpuDataType.default]:[f.GpuDataType.default,f.GpuDataType.default],cacheHint:o});var a,o;return Object.assign(Object.assign({},s),{get:()=>((n,e,t)=>{let r=e[0].dims,i=e[1].dims,l=m.BroadcastUtil.calcShape(r,i,!0);if(!l)throw new Error("Can't use matmul on the given tensors");let d=m.ShapeUtil.size(l),g="f32",{activationFunction:b,applyActivation:v}=(0,h.getActicationSnippet)(t),w=l[l.length-2],x=r[r.length-1],T=l[l.length-1];return Object.assign(Object.assign({},n),{outputs:[{dims:l,dataType:e[0].dataType,gpuDataType:f.GpuDataType.default}],getShaderSource:O=>`
  const M: u32 = ${w}u;
  const N: u32 = ${T}u;
  const K: u32 = ${x}u;

  @group(0) @binding(0) var<storage, read> a : array<${g}>;
  @group(0) @binding(1) var<storage, read> b : array<${g}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${g}>;

  ${b}

  ${O.mainStart()}
    ${O.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${g}(0);
    for (var k: u32 = 0u; k<${x}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${v}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(s,p,u)})},c.matMul=p=>{(u=>{if(!u||u.length!==2)throw new Error("MatMul requires 2 inputs.");if(u[0].dims[u[0].dims.length-1]!==u[1].dims[u[1].dims.length-2])throw new Error("shared dimension does not match.");if(u[0].dataType!==1||u[1].dataType!==1)throw new Error("inputs should be float type")})(p.inputs),p.compute((0,c.createMatmulProgramInfoLoader)(p.inputs,{activation:"",activationCacheKey:""}))}},5262:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.globalMaxPool=c.parseGlobalMaxPoolAttributes=c.parseMaxPoolAttributes=c.maxPool=c.globalAveragePool=c.parseGlobalAveragePoolAttributes=c.averagePool=c.parseAveragePoolAttributes=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075),u=r=>{if(!r||r.length!==1)throw new Error("Pool ops requires 1 input.");if(r[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.");if(r[0].dataType!==1)throw new Error("Invalid input type.")},s=(r,i,l)=>{let d=i.format==="NHWC",g=d?[r.dims[0],r.dims[3],r.dims[1],r.dims[2]]:r.dims.slice(),b=Object.hasOwnProperty.call(i,"dilations"),v=i.kernelShape.slice(),w=i.strides.slice(),x=b?i.dilations.slice():[],T=i.pads.slice();m.PoolConvUtil.adjustPoolAttributes(l,g,v,w,x,T);let O=m.PoolConvUtil.computePoolOutputShape(l,g,w,x,v,T,i.autoPad),P=Object.assign({},i);return b?Object.assign(P,{kernelShape:v,strides:w,pads:T,dilations:x,cacheKey:i.cacheKey}):Object.assign(P,{kernelShape:v,strides:w,pads:T,cacheKey:i.cacheKey}),[P,d?[O[0],O[2],O[3],O[1]]:O]},a=(r,i,l,d,g,b,v)=>{let w=d.format==="NHWC",x=i.shape,T=i.type.value,O=x.length,P=m.ShapeUtil.size(l),I=(0,p.outputVariable)("output",i.type.tensor,l);if(d.kernelShape.length<=2){let R=d.kernelShape[d.kernelShape.length-1],j=d.strides[d.strides.length-1],A=d.pads[d.pads.length/2-1],C=O-(w?2:1),_="",S="",E="";if(_=A+d.pads[d.pads.length-1]!==0?`
              for (var i: u32 = 0u; i < ${R}u; i++) {
                xIndices[${C}] = indices[${C}] * ${j} - ${A} + i;
                if (xIndices[${C}] < 0 || xIndices[${C}] >= ${x[C]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${i.indicesToOffset("xIndices")}];
                ${g}
              }`:`
              for (var i: u32 = 0u; i < ${R}u; i++) {
                xIndices[${C}] = indices[${C}] * ${j} - ${A} + i;
                let x_val = x[${i.indicesToOffset("xIndices")}];
                ${g}
              }`,d.kernelShape.length===2){let z=d.kernelShape[d.kernelShape.length-2],L=d.strides[d.strides.length-2],Y=d.pads[d.pads.length/2-2],X=d.pads[d.pads.length-2],te=O-(w?3:2),ae=x[te];S=Y+X!==0?`
                for (var j: u32 = 0u; j < ${z}u; j++) {
                  xIndices[${te}] = indices[${te}] * ${L} - ${Y} + j;
                  if (xIndices[${te}] < 0 || xIndices[${te}] >= ${ae}) {
                    pad+= ${R};
                    continue;
                  }
              `:`
                for (var j: u32 = 0u; j < ${z}u; j++) {
                  xIndices[${te}] = indices[${te}] * ${L} - ${Y} + j;
                `,E=`
              }
            `}return`
            ${r.declareVariables(i,I)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(P)}

              let indices = ${I.offsetToIndices("global_idx")};
              var xIndices = ${I.offsetToIndices("global_idx")};

              var value: ${T} = ${T}(${v});
              var pad = 0;
              ${S}
              ${_}
              ${E}
              ${b}

              output[global_idx] = value;
            }`}{if(w)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let R=m.ShapeUtil.size(d.kernelShape),j=m.ShapeUtil.computeStrides(d.kernelShape),A=j.length,C=d.pads.length,_="";return _=d.pads.reduce((S,E)=>S+E)?`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${i.indicesToOffset("xIndices")}];
                ${g}
              }`:`
              }
              let x_val = x[${i.indicesToOffset("xIndices")}];
              ${g}
            `,`
            ${r.declareVariables(i,I)}

            const pads = array<u32, ${C}>(${d.pads.map(S=>`${S}u`).join(",")});
            const inputDims = array<u32, ${O}>(${x.map(S=>`${S}u`).join(",")});
            const kernelStrides = array<u32, ${A}>(${j.map(S=>`${S}u`).join(",")});
            const strides = array<u32, ${A}>(${d.strides.map(S=>`${S}u`).join(",")});

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(P)}

              let indices = ${I.offsetToIndices("global_idx")};
              let xIndices = ${I.offsetToIndices("global_idx")};

              var offsets: array<u32, ${A}>;

              var value = ${I.type.value}(${v});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${R}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${A-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${A-1}] = offset;

                isPad = false;
                for (var j = ${O-A}u; j < ${O}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${O-A}u]
                    + offsets[j - ${O-A}u] - pads[j - 2u];
                  ${_}
              }
              ${b}

              output[global_idx] = value;
            }`}},o=r=>({format:r.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],ceilMode:r.ceil_mode,kernelShape:r.kernel_shape,strides:r.strides,pads:r.pads}),n=(r,i,l,d)=>{let[g,b]=s(r,d,l),v=m.ShapeUtil.size(g.kernelShape),w=(0,p.inputVariable)("x",r.dataType,r.dims),x="";return g.countIncludePad?x+=`value /= f32(${v});`:x+=`value /= f32(${v} - pad);`,Object.assign(Object.assign({},i),{outputs:[{dims:b,dataType:r.dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:T=>a(T,w,b,g,"value += x_val;",x,"0.0"),dispatchGroup:()=>({x:Math.ceil(m.ShapeUtil.size(b)/64)})})};c.parseAveragePoolAttributes=r=>{let i=r.count_include_pad!==0,l=o(r);if(l.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,f.createAttributeWithCacheKey)(Object.assign({countIncludePad:i},l))},c.averagePool=(r,i)=>{u(r.inputs);let l={name:"AveragePool",inputTypes:[h.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},l),{get:()=>n(r.inputs[0],l,!1,i)}))};let e={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};c.parseGlobalAveragePoolAttributes=r=>{let i=r.format;return Object.assign(Object.assign({format:i},e),{cacheKey:i})},c.globalAveragePool=(r,i)=>{u(r.inputs);let l={name:"GlobalAveragePool",inputTypes:[h.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},l),{get:()=>n(r.inputs[0],l,!0,i)}))};let t=(r,i,l,d)=>{let[g,b]=s(r,d,l),v=(0,p.inputVariable)("x",r.dataType,r.dims);return Object.assign(Object.assign({},i),{outputs:[{dims:b,dataType:r.dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:w=>a(w,v,b,g,`
      value = max(x_val, value);
    `,"","-1e5"),dispatchGroup:()=>({x:Math.ceil(m.ShapeUtil.size(b)/64)})})};c.maxPool=(r,i)=>{u(r.inputs);let l={name:"MaxPool",inputTypes:[h.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},l),{get:()=>t(r.inputs[0],l,!1,i)}))},c.parseMaxPoolAttributes=r=>{let i=r.storage_order,l=r.dilations,d=o(r);if(i!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(d.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,f.createAttributeWithCacheKey)(Object.assign({storageOrder:i,dilations:l},d))},c.parseGlobalMaxPoolAttributes=r=>{let i=r.format;return Object.assign(Object.assign({format:i},e),{cacheKey:i})},c.globalMaxPool=(r,i)=>{u(r.inputs);let l={name:"GlobalMaxPool",inputTypes:[h.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},l),{get:()=>t(r.inputs[0],l,!0,i)}))}},6031:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseReduceAttributes=c.reduceSumSquare=c.reduceSum=c.reduceProd=c.reduceMin=c.reduceMean=c.reduceMax=c.reduceLogSumExp=c.reduceL2=c.reduceL1=c.reduceLogSum=c.createReduceProgramInfo=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075),u=o=>{if(!o||o.length===0||o.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(o.length===2&&o[1].dims.length!==1)throw new Error("Invalid axes input dims.");if(o[0].dataType!==1)throw new Error("Invalid input type.")},s=o=>["","",`var value = ${o.getByOffset("inputOffset")};`,""];c.createReduceProgramInfo=(o,n,e,t,r,i=!1,l=!1)=>{let d=[],g=n[0].dims,b=m.ShapeUtil.normalizeAxes(t,n[0].dims.length),v=!l&&b.length===0;g.forEach((_,S)=>{v||b.indexOf(S)>=0?i&&d.push(1):d.push(_)});let w=[],x=(0,p.inputVariable)("_A",n[0].dataType,g),T=(0,p.outputVariable)("output",r,d),O=e(x,T,b),P=`inputOffset = ${x.indicesToOffset("inputIndices")};`,I=`let ${P};`,R=`var ${P};`,j=O[1]===""?"":R,A=(O[1]===""?I:P)+`
`+O[2];for(let _=0,S=0;_<n[0].dims.length;_++)v||b.indexOf(_)>=0?(i&&S++,A=`for(var j${_}: u32 = 0; j${_} < ${n[0].dims[_]}; j${_}++) {
                ${O[2].includes("lastIndex")?`let lastIndex = j${_};`:""}
                ${x.indicesSet("inputIndices",_,`j${_}`)}
                ${A}
              }`):(w.push(`${x.indicesSet("inputIndices",_,T.indicesGet("outputIndices",S))};`),S++);let C=m.ShapeUtil.size(d);return Object.assign(Object.assign({},o),{getShaderSource:_=>`
        ${_.declareVariables(x,T)}

        ${_.mainStart()}
          ${_.guardAgainstOutOfBoundsWorkgroupSizes(C)}
          var inputIndices: ${x.type.indices};
          let outputIndices = ${T.offsetToIndices("global_idx")};

          ${w.join(`
`)}
          ${O[0]}       // init ops for reduce max/min
          ${j}
          ${O[1]}
          ${A}
          ${O[3]}
          ${O.length===4?T.setByOffset("global_idx","value"):O.slice(4).join(`
`)}
        }`,outputs:[{dims:d,dataType:r,gpuDataType:h.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(C/64)})})};let a=(o,n,e,t)=>{let r=o.length===1?e:((l,d)=>{let g=[];return l[1].dims[0]>0&&l[1].getBigInt64Array().forEach(b=>g.push(Number(b))),(0,f.createAttributeWithCacheKey)({axes:g,keepDims:d.keepDims,noopWithEmptyAxes:d.noopWithEmptyAxes})})(o,e),i={name:n,inputTypes:[h.GpuDataType.default],cacheHint:r.cacheKey+"_"+o[0].dims.map(l=>l.toString()).join(",")};return Object.assign(Object.assign({},i),{get:()=>(0,c.createReduceProgramInfo)(i,[o[0]],r.noopWithEmptyAxes&&r.axes.length===0?s:t,r.axes,o[0].dataType,r.keepDims,r.noopWithEmptyAxes)})};c.reduceLogSum=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceLogSum",n,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,"value = log(value);"]),{inputs:[0]})},c.reduceL1=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceL1",n,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByOffset("inputOffset")});`,""]),{inputs:[0]})},c.reduceL2=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceL2",n,(e,t)=>[`var t = f32(0); var value = ${t.type.storage}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"]),{inputs:[0]})},c.reduceLogSumExp=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceLogSumExp",n,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByOffset("inputOffset")});`,"value = log(value);"]),{inputs:[0]})},c.reduceMax=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceMax",n,(e,t,r)=>{let i=[];for(let l=0;l<e.shape.length;l++)(r.indexOf(l)>=0||r.length===0)&&i.push(e.indicesSet("inputIndices",l,0));return[`${i.join(`
`)}`,`var value = ${e.getByOffset("inputOffset")};`,`value = max(value, ${e.getByOffset("inputOffset")});`,""]}),{inputs:[0]})},c.reduceMean=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceMean",n,(e,t,r)=>{let i=1;for(let l=0;l<e.shape.length;l++)(r.indexOf(l)>=0||r.length===0)&&(i*=e.shape[l]);return[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,`value = value / ${i}.;`]}),{inputs:[0]})},c.reduceMin=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceMin",n,(e,t,r)=>{let i=[];for(let l=0;l<e.shape.length;l++)(r.indexOf(l)>=0||r.length===0)&&i.push(`inputIndices[${l}] = 0;`);return[`${i.join(`
`)}`,`var value = ${e.getByOffset("inputOffset")};`,`value = min(value, ${e.getByOffset("inputOffset")});`,""]}),{inputs:[0]})},c.reduceProd=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceProd",n,(e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByOffset("inputOffset")};`,""]),{inputs:[0]})},c.reduceSum=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceSum",n,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,""]),{inputs:[0]})},c.reduceSumSquare=(o,n)=>{u(o.inputs),o.compute(a(o.inputs,"ReduceSumSquare",n,(e,t)=>[`var t = f32(0); var value = ${t.type.storage}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += t * t;`,""]),{inputs:[0]})},c.parseReduceAttributes=o=>(0,f.createAttributeWithCacheKey)(o)},4566:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseResizeAttributes=c.resize=c.createResizeProgramInfoLoader=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075);c.createResizeProgramInfoLoader=(u,s,a,o,n,e)=>{let t={name:"Resize",inputTypes:[h.GpuDataType.default],cacheHint:s.cacheKey+a.toString()+(o.length>0?"_scales_"+o.toString():"")+(n.length>0?"_sizes_"+n.toString():"")};return Object.assign(Object.assign({},t),{get:()=>((r,i,l,d,g,b,v)=>{let w=i.dims,x=((C,_,S)=>{let E=new Array(S).fill(0).concat(new Array(S).fill(1)),z=C.length===0?E:C.slice();return _.length>0?(_.forEach((L,Y)=>{E[L]=z[Y],E[Y+S]=z[_.length+Y]}),E):z})(v,l.axes,w.length),T=((C,_,S,E)=>{let z=[];if(S.length>0)if(E.length>0){if(C.forEach(L=>z.push(L)),Math.max(...E)>C.length)throw new Error("axes is out of bound");E.forEach((L,Y)=>z[L]=S[Y])}else S.forEach(L=>z.push(L));else{if(_.length===0)throw new Error("Resize requires either scales or sizes.");z=C.map((L,Y)=>Math.round(L*_[Y]))}return z})(w,g,b,l.axes),O=g.slice();g.length===0&&(O=w.map((C,_)=>C===0?1:T[_]/C),l.keepAspectRatioPolicy!=="stretch"&&(T=((C,_,S,E)=>{let z=(()=>{switch(E.keepAspectRatioPolicy){case"not_larger":return E.axes.length>0?Math.min(...E.axes.map(Y=>S[Y]),Number.MAX_VALUE):Math.min(...S,Number.MAX_VALUE);case"not_smaller":return E.axes.length>0?Math.max(...E.axes.map(Y=>S[Y]),Number.MIN_VALUE):Math.max(...S,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${E.keepAspectRatioPolicy} is not supported`)}})();S.fill(1,0,S.length);let L=C.slice();return E.axes.length>0?(E.axes.forEach(Y=>S[Y]=z),E.axes.forEach(Y=>L[Y]=Math.round(C[Y]*S[Y]))):(S.fill(z,0,S.length),L.forEach((Y,X)=>L[X]=Math.round(Y*S[X]))),L})(w,0,O,l)));let P=(0,p.outputVariable)("output",i.dataType,T),I=(0,p.inputVariable)("input",i.dataType,w),R=m.ShapeUtil.size(T),j=w.length===T.length&&w.every((C,_)=>C===T[_]),A=l.coordinateTransformMode==="tf_crop_and_resize";return Object.assign(Object.assign({},r),{getShaderSource:C=>{return`
      ${_=l.coordinateTransformMode,"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(_){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${_} is not supported`)}})()+"}"};
      ${(()=>{switch(l.mode){case"nearest":return`
              ${((S,E)=>`
    fn checkInputIndices(inputIndices: ${S.type.indices}) -> bool {
      const inputShape = array<u32, ${E.length}>(${E.map(z=>`${z}u`).join(",")});
      for (var i:u32 = 0; i < ${E.length}; i++) {
        var inputIndex = ${E.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`)(I,w)};
              ${((S,E)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(S){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(E<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${S} is not supported`)}})()+"}")(l.nearestMode,d)};
              ${((S,E,z,L,Y,X,te)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${E.type.indices}) -> ${S.type.indices} {
        const inputShape = array<u32, ${z.length}>(${z.map(ae=>`${ae}u`).join(",")});
        const outputShape = array<u32, ${L.length}>(${L.map(ae=>`${ae}u`).join(",")});
        const scales = array<f32, ${Y.length}>(${Y.map(ae=>`${ae}f`).join(",")});
        const roi = array<f32, ${X.length}>(${X.map(ae=>`${ae}f`).join(",")});
        var inputIndices: ${S.type.indices};
        for (var i:u32 = 0; i < ${L.length}; i++) {
          var outputIndex = ${L.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${z.length}]);
            if (!${te} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${S.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`)(I,P,w,T,O,x,A)};
              `;case"linear":return`
              ${((S,E,z,L,Y)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${S.type.indices}) -> array<f32, ${z.length}> {
      const inputShape = array<u32, ${E.length}>(${E.map(X=>`${X}u`).join(",")});
      const outputShape = array<u32, ${z.length}>(${z.map(X=>`${X}u`).join(",")});
      const scales = array<f32, ${L.length}>(${L.map(X=>`${X}f`).join(",")});
      const roi = array<f32, ${Y.length}>(${Y.map(X=>`${X}f`).join(",")});
      var originalIndices: array<f32, ${z.length}>;
      for (var i:u32 = 0; i < ${z.length}; i++) {
        var outputIndex = ${z.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${E.length}]);
        }
      }
      return originalIndices;
    }`)(P,w,T,O,x)};
              ${((S,E,z,L,Y,X,te)=>{let[ae,se,pe,ge]=z.length===2?[-1,0,1,-1]:Y[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${S.type.indices};
      inputIndices[${se}] = max(0, min(row, ${z[se]} - 1));
      inputIndices[${pe}] = max(0, min(col, ${z[pe]} - 1));
      if (${z.length} > 2) {
        inputIndices[${ge}] = channel;
        inputIndices[${ae}] = batch;
      };
      return input[${S.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${E.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${se}];
      var col:f32 = originalIndices[${pe}];
      if (${X} && (row < 0 || row > (${z[se]} - 1) || col < 0 || col > ${z[pe]} - 1)) {
        return ${te};
      }
      row = max(0, min(row, ${z[se]} - 1));
      col = max(0, min(col, ${z[pe]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${z.length>2}) {
        channel = u32(originalIndices[${ge}]);
        batch = u32(originalIndices[${ae}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`})(I,P,w,0,O,A,l.extrapolationValue)};
              `;case"cubic":return`
            ${((S,E,z,L,Y,X,te,ae,se,pe)=>{let[ge,ve]=z.length===2?[0,1]:Y[1]===1?[2,3]:[1,2],Me=De=>{let je=De===ge?"row":"col";return`
      fn ${je}CubicInterpolation(inputIndices: ${S.type.indices}, outputIndices: ${E.type.indices}) -> f32 {
        var outputIndex = ${L.length===1?"outputIndices":`outputIndices[${De}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${Y[De]},
        f32(${L[De]}), f32(${z[De]}), ${X[De]}, ${X[De]} + ${z.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${ae} && (originalIdx < 0 || originalIdx > (${z[De]} - 1))) {
          return ${se};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${je}: f32 = originalIdx + f32(i);
          if (${je} < 0 || ${je} >= ${z[De]}) {
            if (${pe}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${ae}) {
              return ${se};
            } else {
              ${je} = max(0, min(${je}, ${z[De]} - 1));
            }
          }
          var inputIndicesCopy: ${S.type.indices} = inputIndices;
          inputIndicesCopy[${De}] = u32(${je});
          data[i + 1] = ${De===ge?`input[${S.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${Me(ge)};
    ${Me(ve)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${te} * onePlusAbsS - 5 * ${te}) * onePlusAbsS + 8 * ${te}) * onePlusAbsS - 4 * ${te};
    coeffs[1] = ((${te} + 2) * absS - (${te} + 3)) * absS * absS + 1;
    coeffs[2] = ((${te} + 2) * oneMinusAbsS - (${te} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${te} * twoMinusAbsS - 5 * ${te}) * twoMinusAbsS + 8 * ${te}) * twoMinusAbsS - 4 * ${te};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${E.type.indices}) -> f32 {
    var inputIndices: ${S.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `})(I,P,w,T,O,x,l.cubicCoeffA,A,l.extrapolationValue,l.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      ${C.declareVariables(I,P)}
      ${C.mainStart()}
        ${C.guardAgainstOutOfBoundsWorkgroupSizes(R)}
        if (${j}) {
          output[global_idx] = input[global_idx];
        } else {
          let outputIndices = ${P.offsetToIndices("global_idx")};
          var inputIndices: ${I.type.indices};
          ${(()=>{switch(l.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                  if (checkInputIndices(inputIndices)) {
                    output[global_idx] = input[${I.indicesToOffset("inputIndices")}];
                  } else {
                    output[global_idx] = ${l.extrapolationValue};
                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${l.mode}`)}})()};
        }
      }`;var _},outputs:[{dims:T,dataType:i.dataType,gpuDataType:h.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(R/64)})})})(t,u,s,a,o,n,e)})},c.resize=(u,s)=>{let a=[],o=[],n=[],e=(t=>{let r=t.customDataBuffer;return new Uint32Array(r,r.byteOffset,1)[0]})(u);((t,r,i,l,d,g)=>{let[b,v,w]=i>10?[1,2,3]:[-1,t.length>1?1:-1,-1],x=t[0].dims.length;if(b>0&&t.length>b&&t[b].dims.length>0)t[b].getFloat32Array().forEach(T=>g.push(T));else if(r.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(v>0&&t.length>v&&t[v].dims.length>0){if(t[v].getFloat32Array().forEach(T=>l.push(T)),l.length!==0&&l.length!==x&&i>=18&&l.length!==r.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");((T,O)=>{if(T.every(P=>P>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),T.length>0){if(O.mode==="linear"){if(!(T.length===2||T.length===4&&T[0]===1&&T[1]===1||T.length===4&&T[0]===1&&T[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(O.mode==="cubic"&&!(T.length===2||T.length===4&&T[0]===1&&T[1]===1||T.length===4&&T[0]===1&&T[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}})(l,r),r.axes.length>0&&((T,O,P)=>{O.every(R=>R>=0&&R<P||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let I=new Array(P).fill(1);return O.forEach((R,j)=>I[R]=T[j]),I})(l,r.axes,x).forEach((T,O)=>l[O]=T)}if(w>0&&t.length>w&&(t[w].getBigInt64Array().forEach(T=>d.push(Number(T))),d.length!==x||i>=18&&d.length===r.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(r.axes.length>0){if(l.length!==r.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(d.length!==r.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(l!==void 0&&d!==void 0&&l.length>0&&d.length>x)throw new Error("Resize requires only of scales or sizes to be specified")})(u.inputs,s,e,a,o,n),u.compute((0,c.createResizeProgramInfoLoader)(u.inputs[0],s,e,a,o,n),{inputs:[0]})},c.parseResizeAttributes=u=>{let s=u.antialias,a=u.axes,o=u.coordinateTransformMode,n=u.cubicCoeffA,e=u.excludeOutside!==0,t=u.extrapolationValue,r=u.keepAspectRatioPolicy,i=u.mode,l=u.nearestMode===""?"simple":u.nearestMode;return(0,f.createAttributeWithCacheKey)({antialias:s,axes:a,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:e,extrapolationValue:t,keepAspectRatioPolicy:r,mode:i,nearestMode:l})}},8906:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSkipLayerNormAttributes=c.skipLayerNorm=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075);c.skipLayerNorm=(u,s)=>{(o=>{if(!o||o.length<3)throw new Error("layerNorm requires at least 3 inputs.");if(o[0].dataType!==1||o[1].dataType!==1)throw new Error("inputs should be float type");let n=o[0],e=o[1],t=o[2];if(n.dataType!==e.dataType||n.dataType!==t.dataType)throw new Error("All inputs must have the same data type");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Input must be 2D or 3D");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Skip must be 2D or 3D");let r=n.dims[n.dims.length-1],i=n.dims[n.dims.length-2];if(e.dims[e.dims.length-1]!==r)throw new Error("Skip must have the same hidden size as input");if(e.dims[e.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(t.dims.length!==1)throw new Error("Gamma must be 1D");if(t.dims[t.dims.length-1]!==r)throw new Error("Gamma must have the same hidden size as input");if(o.length>3){let l=o[3];if(l.dims.length!==1)throw new Error("Beta must be 1D");if(l.dims[l.dims.length-1]!==r)throw new Error("Beta must have the same hidden size as input")}if(o.length>4){let l=o[4];if(l.dims.length!==1)throw new Error("Bias must be 1D");if(l.dims[l.dims.length-1]!==r)throw new Error("Bias must have the same hidden size as input")}})(u.inputs);let a=[0];u.outputCount>1&&a.push(-3),u.outputCount>2&&a.push(-3),u.outputCount>3&&a.push(3),u.compute(((o,n,e,t)=>{let r={name:"SkipLayerNormalization",inputTypes:new Array(o.length).fill(h.GpuDataType.default),cacheHint:n.cacheKey};return Object.assign(Object.assign({},r),{get:()=>((i,l,d,g,b)=>{let v=l[0].dims,w=v,x=m.ShapeUtil.size(v),T=v.slice(-1)[0],O=b?v.slice(0,-1).concat(1):[],P=l.length>3,I=l.length>4,R=(0,p.tensorTypeToWsglStorageType)(l[0].dataType),j=b&&g>1,A=b&&g>2,C=g>3,_=0,S=[{dims:w,dataType:l[0].dataType,gpuDataType:h.GpuDataType.default}];return g>1&&S.push({dims:O,dataType:l[0].dataType,gpuDataType:h.GpuDataType.default}),g>2&&S.push({dims:O,dataType:l[0].dataType,gpuDataType:h.GpuDataType.default}),g>3&&S.push({dims:v,dataType:l[0].dataType,gpuDataType:h.GpuDataType.default}),Object.assign(Object.assign({},i),{getShaderSource:E=>`
      const hiddenSize: u32 = ${T};
      const epsilon: f32 = ${d.epsilon};

      @group(0) @binding(${_++}) var<storage, read> x : array<${R}>;
      @group(0) @binding(${_++}) var<storage, read> skip : array<${R}>;
      @group(0) @binding(${_++}) var<storage, read> gamma : array<${R}>;
      ${P?`@group(0) @binding(${_++}) var<storage, read> beta : array<${R}>;`:""}
      ${I?`@group(0) @binding(${_++}) var<storage, read> bias : array<${R}>;`:""}
      @group(0) @binding(${_++}) var<storage, read_write> output : array<${R}>;
      ${j?`@group(0) @binding(${_++}) var<storage, read_write> meanOutput : array<${R}>;`:""}
      ${A?`@group(0) @binding(${_++}) var<storage, read_write> invStdOutput : array<${R}>;`:""}
      ${C?`@group(0) @binding(${_++}) var<storage, read_write> inputSkipBiasSum : array<${R}>;`:""}

      ${E.mainStart()}
        ${E.guardAgainstOutOfBoundsWorkgroupSizes(x/T)}
        let offset = global_idx * hiddenSize;
        var sum: f32 = 0.0;
        var squareSum: f32 = 0.0;
        for (var i: u32 = 0; i < hiddenSize; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${I?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${C?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          sum += value;
          squareSum += value * value;
        }
        let mean: f32 = sum / f32(hiddenSize);
        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);
        ${j?"meanOutput[global_idx] = mean;":""}
        ${A?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSize; i++) {
          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${P?"beta[i]":"0.0"};
        }
      }`,outputs:S,dispatchGroup:()=>({x:Math.ceil(x/T/64)})})})(r,o,n,e,t)})})(u.inputs,s,u.outputCount,!1),{outputs:a})},c.parseSkipLayerNormAttributes=u=>{let s=u.epsilon;return(0,f.createAttributeWithCacheKey)({epsilon:s})}},5101:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSliceAttributes=c.slice=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075),u=(a,o)=>{let n=[];if(a.length>o)if(a[o].dataType===7)a[o].getBigInt64Array().forEach(e=>n.push(Number(e)));else{if(a[o].dataType!==6)throw new Error(`Input ${o} must be an array of int32 or int64`);a[o].getInt32Array().forEach(e=>n.push(Number(e)))}return n},s=(a,o,n,e,t)=>{let r=a;return a<0&&(r+=n[e[o]]),t[o]<0?Math.max(0,Math.min(r,n[e[o]]-1)):Math.max(0,Math.min(r,n[e[o]]))};c.slice=(a,o)=>{((t,r)=>{if(!t||t.length<1)throw new Error("too few inputs");if(r.axes.length!==0){if(r.axes.length!==r.starts.length||r.axes.length!==r.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(r.starts.length!==r.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((i,l)=>{if(t[l+1].dataType!==6&&t[l+1].dataType!==7)throw new Error(`Input ${l} must be an array of int32 or int64`)})})(a.inputs,o);let n=((t,r)=>{let i=((d,g)=>{if(d.length>1){let b=u(d,1),v=u(d,2),w=u(d,3);return w.length===0&&(w=[...Array(d[0].dims.length).keys()]),(0,f.createAttributeWithCacheKey)({starts:b,ends:v,axes:w})}return g})(t,r),l={name:"Slice",inputTypes:[h.GpuDataType.default],cacheHint:i.cacheKey+(t.length>4?"steps_"+t[4].dims.toString():"")};return Object.assign(Object.assign({},l),{get:()=>((d,g,b)=>{let v=g[0].dims,w=m.ShapeUtil.size(v),x=b.axes.length>0?m.ShapeUtil.normalizeAxes(b.axes,v.length):[...Array(v.length).keys()],T=u(g,4);T.forEach(S=>S!==0||(()=>{throw new Error("step cannot be 0")})),T.length===0&&(T=Array(x.length).fill(1));let O=b.starts.map((S,E)=>s(S,E,v,x,T)),P=b.ends.map((S,E)=>s(S,E,v,x,T));if(x.length!==v.length)for(let S=0;S<v.length;++S)x.includes(S)||(O.splice(S,0,0),P.splice(S,0,v[S]),T.splice(S,0,1));let I=T.map(S=>Math.sign(S));T.forEach((S,E,z)=>{if(S<0){let L=(P[E]-O[E])/S,Y=O[E],X=Y+L*T[E];O[E]=X,P[E]=Y,z[E]=-S}});let R=v.slice(0);x.forEach((S,E)=>{R[S]=Math.ceil((P[S]-O[S])/T[S])});let j={dims:R,dataType:g[0].dataType,gpuDataType:h.GpuDataType.default},A=(0,p.outputVariable)("output",g[0].dataType,R),C=(0,p.inputVariable)("input",g[0].dataType,v),_=m.ShapeUtil.size(R);return Object.assign(Object.assign({},d),{getShaderSource:S=>`
      ${S.declareVariables(C,A)}
        const signs = array<i32, ${I.length}>(${I.map(E=>`${E}i`).join(",")});
        const starts = array<u32, ${O.length}>(${O.map(E=>`${E}u`).join(",")});
        const ends = array<u32, ${P.length}>(${P.map(E=>`${E}u`).join(",")});
        const steps = array<u32, ${T.length}>(${T.map(E=>`${E}u`).join(",")});
        const inputShape = array<u32, ${v.length}>(${v.map(E=>`${E}u`).join(",")});

        ${((E,z,L,Y)=>`fn calculateInputIndices(outputIndices: ${z.type.indices}) -> ${E.type.indices} {
          var inputIndices: ${E.type.indices};
          var carry = 0u;
          for (var i = ${L.length}; i >= 0; i--) {
            var outputIndex = ${Y.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${L.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`)(C,A,v,R)}
        ${S.mainStart()}
          ${S.guardAgainstOutOfBoundsWorkgroupSizes(_)}
          let outputIndices = ${A.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${A.setByOffset("global_idx",C.getByIndices("inputIndices"))}
      }`,outputs:[j],dispatchGroup:()=>({x:Math.ceil(w/64)})})})(l,t,i)})})(a.inputs,o),e=n.get();if(!(m.ShapeUtil.size(e.outputs[0].dims)>0))throw new Error("slice: output size is 0");a.compute(n,{inputs:[0]})},c.parseSliceAttributes=a=>{let o=a.starts,n=a.ends,e=a.axes;return(0,f.createAttributeWithCacheKey)({starts:o,ends:n,axes:e})}},6198:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSoftmaxAttributes=c.softmax=c.softmaxProgramMetadata=void 0;let m=y(6952),f=y(387),h=y(1163);c.softmaxProgramMetadata={name:"Softmax",inputTypes:[h.GpuDataType.default]},c.softmax=(p,u)=>{(s=>{if(!s||s.length!==1)throw new Error("Softmax op requires 1 input.");if(s[0].dataType!==1)throw new Error("Softmax input needs to be float.")})(p.inputs),p.compute(Object.assign(Object.assign({},c.softmaxProgramMetadata),{cacheHint:u.cacheKey,get:()=>((s,a)=>{let o="f32",n=s.dims,e=m.ShapeUtil.size(n),t=a.axis;if(t<0&&(t=n.length+t),t<n.length-1)throw new Error("softmax only supports last axis for now.");let r=n[t],i=e/r;return Object.assign(Object.assign({},c.softmaxProgramMetadata),{outputs:[{dims:n,dataType:s.dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:l=>`
      var<workgroup> rowMaxShared : ${o};
      var<workgroup> rowSumShared : ${o};
      var<workgroup> threadShared : array<${o}, 64>;

      @group(0) @binding(0) var<storage, read> x : array<${o}>;
      @group(0) @binding(1) var<storage, read_write> result : array<${o}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${o} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${o}) {
        let index = row * row_stride + col;
        result[index] = value;
      }

      @compute @workgroup_size(64, 1, 1)
      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = 64;
        let row = gindex / wg;
        let cols = ${r};
        let row_stride : i32 = ${r};

        // find the rows max
        var threadMax = -3.402823e+38f; // 6.2.4 in wgsl spec
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = threadShared[0];
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = 0.0;
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = threadShared[0];
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,dispatchGroup:()=>({x:i})})})(p.inputs[0],u)}))},c.parseSoftmaxAttributes=p=>(0,f.createAttributeWithCacheKey)({axis:p.axis})},2067:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseSplitAttributes=c.split=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075);c.split=(u,s)=>{(a=>{if(!a||a.length<1)throw new Error("too few inputs")})(u.inputs),u.compute(((a,o)=>{let n=a.length===1?o:((t,r)=>{let i=[],l=r.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(d=>i.push(Number(d))),l=i.length),(0,f.createAttributeWithCacheKey)({numOutputs:l,axis:r.axis,splitSizes:i})})(a,o),e={name:"Split",inputTypes:[h.GpuDataType.default],cacheHint:n.cacheKey};return Object.assign(Object.assign({},e),{get:()=>((t,r,i)=>{let l=r[0].dims,d=m.ShapeUtil.size(l),g=r[0].dataType,b=l.length,v=i.axis,w=v<0?l.length+v:v,x=new Array(i.numOutputs),T=(0,p.inputVariable)("input",g,l),O=new Array(i.numOutputs),P=[],I=[],R=0;for(let A=0;A<i.numOutputs;A++){R+=i.splitSizes[A],O[A]=R;let C=l.slice();C[i.axis]=i.splitSizes[A],I.push(C),x[A]=(0,p.outputVariable)(`output${A}`,g,I[A]),P.push({dims:I[A],dataType:r[0].dataType,gpuDataType:h.GpuDataType.default})}let j=b<2?"indices":`indices[${w}]`;return Object.assign(Object.assign({},t),{getShaderSource:A=>{return`
  ${A.declareVariables(T,...x)}
  const sizeInConcatAxis = array<u32, ${O.length}>(${O.map(_=>`${_}u`).join(",")});
  ${C=O.length,`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${C}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${C}u;
}`}
  ${(_=>{let S=_.length,E=[];for(let z=0;z<S;++z){let L=_[z].setByIndices("indices","input[global_idx]");S===1?E.push(L):z===0?E.push(`if (outputNumber == ${z}u) { ${L} }`):z===S-1?E.push(`else { ${L} }`):E.push(`else if (outputNumber == ${z}) { ${L} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${_[0].type.indices}, global_idx: u32) {
        ${E.join(`
`)}
      }`})(x)}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    var indices = ${T.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${j});
    if (outputNumber != 0) {
        ${j} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;var C},outputs:P,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(e,[a[0]],n)})})(u.inputs,s),{inputs:[0]})},c.parseSplitAttributes=u=>{let s=u.axis,a=u.splitSizes,o=u.numOutputs<0?a.length:u.numOutputs;if(o!==a.length)throw new Error("numOutputs and splitSizes lengh must be equal");return(0,f.createAttributeWithCacheKey)({axis:s,numOutputs:o,splitSizes:a})}},8699:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tile=c.createTileProgramInfo=c.tileProgramMetadata=void 0;let m=y(6952),f=y(1163),h=y(2075);c.tileProgramMetadata={name:"Tile",inputTypes:[f.GpuDataType.default]};let p=u=>Array.from(u.getBigInt64Array(),Number);c.createTileProgramInfo=(u,s)=>{let a=s[0].dims,o=p(s[1]),n=((l,d)=>{let g=[];for(let b=0;b<l.length;++b)g.push(l[b]*d[b]);return g})(a,o),e=m.ShapeUtil.size(n),t=s[0].dataType,r=(0,h.inputVariable)("input",t,a),i=(0,h.outputVariable)("output",t,n);return Object.assign(Object.assign({},u),{outputs:[{dims:n,dataType:s[0].dataType,gpuDataType:f.GpuDataType.default}],getShaderSource:l=>`
      const inputShape = ${r.indices(...a)};
      ${l.declareVariables(r,i)}
      ${l.mainStart()}
      ${l.guardAgainstOutOfBoundsWorkgroupSizes(e)}
      let outputIndices = ${i.offsetToIndices("global_idx")};
      var inputIndices: ${r.type.indices};
      for (var i = 0; i < ${a.length}; i++) {
        let inputDimValue = ${i.indicesGet("outputIndices","i")}  % ${r.indicesGet("inputShape","i")};

        ${r.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${i.setByOffset("global_idx",r.getByIndices("inputIndices"))}
    }`,dispatchGroup:()=>({x:Math.ceil(e/64)})})},c.tile=u=>{(a=>{if(!a||a.length!==2)throw new Error("Tile requires 2 inputs.");if(a[0].dataType!==1&&a[0].dataType!==6&&a[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(a[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(a[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(p(a[1]).length!==a[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")})(u.inputs);let s=p(u.inputs[1]).toString();u.compute(Object.assign(Object.assign({},c.tileProgramMetadata),{cacheHint:s,get:()=>(0,c.createTileProgramInfo)(c.tileProgramMetadata,u.inputs)}),{inputs:[0]})}},2625:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.parseTransposeAttributes=c.transpose=c.createTransposeProgramInfo=c.transposeProgramMetadata=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075);c.transposeProgramMetadata={name:"Transpose",inputTypes:[h.GpuDataType.default]};let u=(s,a)=>a&&a.length!==s.length?[...s.keys()].reverse():a;c.createTransposeProgramInfo=(s,a)=>{let o=s.dataType,n=s.dims,e=u(n,a),t=((g,b)=>m.ShapeUtil.sortBasedOnPerm(g,u(g,b)))(n,e),r=n.length,i=m.ShapeUtil.size(t),l=(0,p.outputVariable)("output",o,t),d=(0,p.inputVariable)("a",o,n);return Object.assign(Object.assign({},c.transposeProgramMetadata),{outputs:[{dims:t,dataType:s.dataType,gpuDataType:h.GpuDataType.default}],getShaderSource:g=>`
  ${g.declareVariables(d,l)}

  ${((b,v,w,x)=>{let T=[];T.push(`fn perm(i: ${x.type.indices}) -> ${w.type.indices} {
    var a: ${w.type.indices};`);for(let O=0;O<v;++O)T.push(w.indicesSet("a",b[O],`i[${O}]`));return T.push("return a;}"),T.join(`
`)})(e,r,d,l)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes(i)}

    let indices = ${l.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${l.setByOffset("global_idx",d.getByIndices("aIndices"))}
  }`,dispatchGroup:()=>({x:Math.ceil(i/64)})})},c.transpose=(s,a)=>{(o=>{if(!o||o.length!==1)throw new Error("Transpose requires 1 input.");if(o[0].dataType!==1&&o[0].dataType!==6&&o[0].dataType!==12)throw new Error("Transpose only support float, int32, and uint32 data types")})(s.inputs),s.compute(Object.assign(Object.assign({},c.transposeProgramMetadata),{cacheHint:a.cacheKey,get:()=>(0,c.createTransposeProgramInfo)(s.inputs[0],a.perm)}))},c.parseTransposeAttributes=s=>(0,f.createAttributeWithCacheKey)({perm:s.perm})},9302:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.log=c.thresholdedRelu=c.tanh=c.tan=c.sqrt=c.sinh=c.sin=c.sigmoid=c.relu=c.reciprocal=c.neg=c.leakyRelu=c.gelu=c.floor=c.exp=c.erf=c.erfImpl=c.elu=c.parseAlphaAttributes=c.cosh=c.cos=c.ceil=c.clip=c.clipV10=c.cast=c.parseCastAttributes=c.atanh=c.atan=c.asinh=c.asin=c.acosh=c.acos=c.abs=void 0;let m=y(6952),f=y(387),h=y(1163),p=y(2075),u=(s,a,o,n,e,t=s.dataType)=>{let r={name:a,inputTypes:[h.GpuDataType.default],cacheHint:e};return Object.assign(Object.assign({},r),{get:()=>((i,l,d,g,b)=>Object.assign(Object.assign({},i),{getShaderSource:v=>((w,x,T,O,P,I)=>{let R=Math.ceil(x/4),j="";j=typeof P=="string"?`${P}(a)`:P("a");let A=(0,p.inputVariable)("inputData",T,[R],4),C=(0,p.outputVariable)("outputData",O,[R],4);return`
  ${w.declareVariables(A,C)}

  ${I??""}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes(R)}

    let a = ${A.getByOffset("global_idx")};
    ${C.setByOffset("global_idx",j)}
  }`})(v,m.ShapeUtil.size(l.dims),l.dataType,d,g,b),outputs:[{dims:l.dims,dataType:d,gpuDataType:h.GpuDataType.default}],dispatchGroup:v=>({x:Math.ceil(m.ShapeUtil.size(v[0].dims)/64/4)})}))(r,s,t,o,n)})};c.abs=s=>{s.compute(u(s.inputs[0],"Abs","abs"))},c.acos=s=>{s.compute(u(s.inputs[0],"Acos","acos"))},c.acosh=s=>{s.compute(u(s.inputs[0],"Acosh","acosh"))},c.asin=s=>{s.compute(u(s.inputs[0],"Asin","asin"))},c.asinh=s=>{s.compute(u(s.inputs[0],"Asinh","asinh"))},c.atan=s=>{s.compute(u(s.inputs[0],"Atan","atan"))},c.atanh=s=>{s.compute(u(s.inputs[0],"Atanh","atanh"))},c.parseCastAttributes=s=>(0,f.createAttributeWithCacheKey)(s),c.cast=(s,a)=>{let o;switch(a.to){case 1:o="vec4<f32>";break;case 12:o="vec4<u32>";break;case 6:o="vec4<i32>";break;case 9:o="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${a.to}`)}s.compute(u(s.inputs[0],"Cast",o,void 0,a.cacheKey,a.to))},c.clipV10=(s,a)=>{s.compute(u(s.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<f32> = vec4(f32(${a.min}));
    const clip_max_: vec4<f32> = vec4(f32(${a.max}));
`,a.cacheKey),{inputs:[0]})},c.clip=s=>{let a=(o=>{let n=o.length>=2?o[1].getFloat32Array()[0]:m.MIN_CLIP,e=o.length>=3?o[2].getFloat32Array()[0]:m.MAX_CLIP;return(0,f.createAttributeWithCacheKey)({min:n,max:e})})(s.inputs);(0,c.clipV10)(s,a)},c.ceil=s=>{s.compute(u(s.inputs[0],"Ceil","ceil"))},c.cos=s=>{s.compute(u(s.inputs[0],"Cos","cos"))},c.cosh=s=>{s.compute(u(s.inputs[0],"Cosh","cosh"))},c.parseAlphaAttributes=s=>(0,f.createAttributeWithCacheKey)(s),c.elu=(s,a)=>{s.compute(u(s.inputs[0],"Elu",o=>`elu_vf32(${o})`,`
  const elu_alpha_: f32 = f32(${a.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,a.cacheKey))},c.erfImpl=s=>`
const r0: f32 = 0.3275911;
const r1: f32 = 0.254829592;
const r2: f32 = -0.284496736;
const r3: f32 = 1.421413741;
const r4: f32 = -1.453152027;
const r5: f32 = 1.061405429;

fn erf_vf32(v: ${s}) -> ${s} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,c.erf=s=>{s.compute(u(s.inputs[0],"Erf",a=>`erf_vf32(${a})`,(0,c.erfImpl)("vec4<f32>")))},c.exp=s=>{s.compute(u(s.inputs[0],"Exp","exp"))},c.floor=s=>{s.compute(u(s.inputs[0],"Floor","floor"))},c.gelu=s=>{s.compute(u(s.inputs[0],"Gelu",a=>`0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,(0,c.erfImpl)("vec4<f32>")))},c.leakyRelu=(s,a)=>{s.compute(u(s.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${a.alpha});`,a.cacheKey))},c.neg=s=>{s.compute(u(s.inputs[0],"Neg",a=>`-${a}`))},c.reciprocal=s=>{s.compute(u(s.inputs[0],"Reciprocal",a=>`1.0/${a}`))},c.relu=s=>{s.compute(u(s.inputs[0],"Relu",a=>`select(vec4<f32>(0.0), ${a}, ${a} > vec4<f32>(0.0))`))},c.sigmoid=s=>{s.compute(u(s.inputs[0],"Sigmoid",a=>`(1.0 / (1.0 + exp(-${a})))`))},c.sin=s=>{s.compute(u(s.inputs[0],"Sin","sin"))},c.sinh=s=>{s.compute(u(s.inputs[0],"Sinh","sinh"))},c.sqrt=s=>{s.compute(u(s.inputs[0],"Sqrt","sqrt"))},c.tan=s=>{s.compute(u(s.inputs[0],"Tan","tan"))},c.tanh=s=>{s.compute(u(s.inputs[0],"Tanh","tanh"))},c.thresholdedRelu=(s,a)=>(s.compute(u(s.inputs[0],"ThresholdedRelu",o=>`select(vec4<f32>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${a.alpha});`,a.cacheKey)),0),c.log=s=>{s.compute(u(s.inputs[0],"Log","log"))}},8305:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ProgramManager=void 0;let m=y(4955),f=y(2075);c.ProgramManager=class{constructor(h){this.backend=h,this.repo=new Map,this.attributesBound=!1}getArtifact(h){return this.repo.get(h)}setArtifact(h,p){this.repo.set(h,p)}run(h,p,u,s){let a=this.backend.device,o=this.backend.getComputePassEncoder(),n=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";n&&o.writeTimestamp(this.backend.profilingQuerySet,0),o.setPipeline(h.computePipeline);let e=[];for(let r of p)e.push({binding:e.length,resource:{buffer:r.buffer}});for(let r of u)e.push({binding:e.length,resource:{buffer:r.buffer}});let t=a.createBindGroup({layout:h.computePipeline.getBindGroupLayout(0),entries:e});if(o.setBindGroup(0,t),o.dispatchWorkgroups(...s),this.backend.pendingDispatchNumber++,n){o.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let r=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,r.buffer,0,16),this.backend.flush();let i=this.backend.currentKernelId,l=this.backend.kernels.get(i)[0];r.buffer.mapAsync(GPUMapMode.READ).then(()=>{let d=new BigUint64Array(r.buffer.getMappedRange()),g=d[0],b=d[1];r.buffer.unmap(),this.backend.profilingTimeBase===void 0&&(this.backend.profilingTimeBase=g);let v=Number(g-this.backend.profilingTimeBase),w=Number(b-this.backend.profilingTimeBase);if(!Number.isSafeInteger(v)||!Number.isSafeInteger(w))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(r.id),console.log(`[profiling] kernel "${i}|${l}" execution time: ${w-v} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(h,p){let u=this.backend.device,s=(0,f.createShaderHelper)(p),a=h.getShaderSource(s),o=`${s.additionalImplementations}
${a}`,n=u.createShaderModule({code:o});return(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] shader code: ${o}`),{programInfo:h,computePipeline:u.createComputePipeline({compute:{module:n,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(h){let p=typeof h=="number"?h:h.x,u=typeof h=="number"?1:h.y||1,s=typeof h=="number"?1:h.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(p<=a&&u<=a&&s<=a)return[p,u,s];let o=p*u*s,n=Math.ceil(Math.sqrt(o));if(n>a){if(n=Math.ceil(Math.cbrt(o)),n>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[n,n,n]}return[n,n,1]}}},1163:(M,c)=>{"use strict";var y;Object.defineProperty(c,"__esModule",{value:!0}),c.GpuDataType=void 0,(y=c.GpuDataType||(c.GpuDataType={}))[y.default=0]="default",y[y.upload=1]="upload",y[y.profile=2]="profile"},9544:function(M,c,y){"use strict";var m,f=this&&this.__createBinding||(Object.create?function(I,R,j,A){A===void 0&&(A=j);var C=Object.getOwnPropertyDescriptor(R,j);C&&!("get"in C?!R.__esModule:C.writable||C.configurable)||(C={enumerable:!0,get:function(){return R[j]}}),Object.defineProperty(I,A,C)}:function(I,R,j,A){A===void 0&&(A=j),I[A]=R[j]}),h=this&&this.__setModuleDefault||(Object.create?function(I,R){Object.defineProperty(I,"default",{enumerable:!0,value:R})}:function(I,R){I.default=R}),p=this&&this.__importStar||function(I){if(I&&I.__esModule)return I;var R={};if(I!=null)for(var j in I)j!=="default"&&Object.prototype.hasOwnProperty.call(I,j)&&f(R,I,j);return h(R,I),R};Object.defineProperty(c,"__esModule",{value:!0}),c.endProfiling=c.run=c.releaseSession=c.createSession=c.createSessionFinalize=c.createSessionAllocate=c.initializeRuntime=c.initializeWebAssemblyInstance=void 0;let u=y(2235),s=p(y(1259)),a=y(263),o=()=>!!u.env.wasm.proxy&&typeof document<"u",n,e,t,r=!1,i=!1,l=!1,d=[],g=[],b=[],v=[],w=[],x=[],T=()=>{if(r||!i||l||!n)throw new Error("worker not ready")},O=I=>{switch(I.data.type){case"init-wasm":r=!1,I.data.err?(l=!0,e[1](I.data.err)):(i=!0,e[0]());break;case"init-ort":I.data.err?t[1](I.data.err):t[0]();break;case"create_allocate":I.data.err?d.shift()[1](I.data.err):d.shift()[0](I.data.out);break;case"create_finalize":I.data.err?g.shift()[1](I.data.err):g.shift()[0](I.data.out);break;case"create":I.data.err?b.shift()[1](I.data.err):b.shift()[0](I.data.out);break;case"release":I.data.err?v.shift()[1](I.data.err):v.shift()[0]();break;case"run":I.data.err?w.shift()[1](I.data.err):w.shift()[0](I.data.out);break;case"end-profiling":I.data.err?x.shift()[1](I.data.err):x.shift()[0]()}},P=typeof document<"u"?(m=document?.currentScript)===null||m===void 0?void 0:m.src:void 0;c.initializeWebAssemblyInstance=async()=>{if(o()){if(i)return;if(r)throw new Error("multiple calls to 'initWasm()' detected.");if(l)throw new Error("previous call to 'initWasm()' failed.");return r=!0,u.env.wasm.wasmPaths===void 0&&P&&P.indexOf("blob:")!==0&&(u.env.wasm.wasmPaths=P.substr(0,+P.lastIndexOf("/")+1)),new Promise((I,R)=>{n?.terminate(),n=y(8050).Z(),n.onmessage=O,e=[I,R];let j={type:"init-wasm",in:u.env.wasm};n.postMessage(j)})}return(0,a.initializeWebAssembly)(u.env.wasm)},c.initializeRuntime=async I=>{if(o())return T(),new Promise((R,j)=>{t=[R,j];let A={type:"init-ort",in:I};n.postMessage(A)});await s.initRuntime(I)},c.createSessionAllocate=async I=>o()?(T(),new Promise((R,j)=>{d.push([R,j]);let A={type:"create_allocate",in:{model:I}};n.postMessage(A,[I.buffer])})):s.createSessionAllocate(I),c.createSessionFinalize=async(I,R)=>o()?(T(),new Promise((j,A)=>{g.push([j,A]);let C={type:"create_finalize",in:{modeldata:I,options:R}};n.postMessage(C)})):s.createSessionFinalize(I,R),c.createSession=async(I,R)=>o()?(T(),new Promise((j,A)=>{b.push([j,A]);let C={type:"create",in:{model:I,options:R}};n.postMessage(C,[I.buffer])})):s.createSession(I,R),c.releaseSession=async I=>{if(o())return T(),new Promise((R,j)=>{v.push([R,j]);let A={type:"release",in:I};n.postMessage(A)});s.releaseSession(I)},c.run=async(I,R,j,A,C)=>o()?(T(),new Promise((_,S)=>{w.push([_,S]);let E={type:"run",in:{sessionId:I,inputIndices:R,inputs:j,outputIndices:A,options:C}};n.postMessage(E,s.extractTransferableBuffers(j))})):s.run(I,R,j,A,C),c.endProfiling=async I=>{if(o())return T(),new Promise((R,j)=>{x.push([R,j]);let A={type:"end-profiling",in:I};n.postMessage(A)});s.endProfiling(I)}},7918:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.setRunOptions=void 0;let m=y(263),f=y(1497);c.setRunOptions=h=>{let p=(0,m.getInstance)(),u=0,s=[],a=h||{};try{if(h?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof h.logSeverityLevel!="number"||!Number.isInteger(h.logSeverityLevel)||h.logSeverityLevel<0||h.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${h.logSeverityLevel}`);if(h?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof h.logVerbosityLevel!="number"||!Number.isInteger(h.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${h.logVerbosityLevel}`);h?.terminate===void 0&&(a.terminate=!1);let o=0;return h?.tag!==void 0&&(o=(0,f.allocWasmString)(h.tag,s)),u=p._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,o),u===0&&(0,f.checkLastError)("Can't create run options."),h?.extra!==void 0&&(0,f.iterateExtraOptions)(h.extra,"",new WeakSet,(n,e)=>{let t=(0,f.allocWasmString)(n,s),r=(0,f.allocWasmString)(e,s);p._OrtAddRunConfigEntry(u,t,r)!==0&&(0,f.checkLastError)(`Can't set a run config entry: ${n} - ${e}.`)}),[u,s]}catch(o){throw u!==0&&p._OrtReleaseRunOptions(u),s.forEach(n=>p._free(n)),o}}},6640:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.OnnxruntimeWebAssemblySessionHandler=void 0;let m=y(2806),f=y(2235),h=y(2850),p=y(9544),u;c.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(s){let a=await fetch(s);if(a.status!==200)throw new Error(`failed to load model: ${s}`);let o=await a.arrayBuffer();return(0,p.createSessionAllocate)(new Uint8Array(o))}async loadModel(s,a){if(u||(await(0,p.initializeRuntime)(f.env),u=!0),typeof s=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let o=await(0,h.promisify)(m.readFile)(s);[this.sessionId,this.inputNames,this.outputNames]=await(0,p.createSession)(o,a)}else{let o=await this.createSessionAllocate(s);[this.sessionId,this.inputNames,this.outputNames]=await(0,p.createSessionFinalize)(o,a)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,p.createSession)(s,a)}async dispose(){return(0,p.releaseSession)(this.sessionId)}async run(s,a,o){let n=[],e=[];Object.entries(s).forEach(l=>{let d=l[0],g=l[1],b=this.inputNames.indexOf(d);if(b===-1)throw new Error(`invalid input '${d}'`);n.push(g),e.push(b)});let t=[];Object.entries(a).forEach(l=>{let d=l[0],g=this.outputNames.indexOf(d);if(g===-1)throw new Error(`invalid output '${d}'`);t.push(g)});let r=await(0,p.run)(this.sessionId,e,n.map(l=>[l.type,l.dims,l.data]),t,o),i={};for(let l=0;l<r.length;l++)i[this.outputNames[t[l]]]=new f.Tensor(r[l][0],r[l][2],r[l][1]);return i}startProfiling(){}endProfiling(){(0,p.endProfiling)(this.sessionId)}}},7622:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.setSessionOptions=void 0;let m=y(263),f=y(1497);c.setSessionOptions=h=>{var p,u,s,a;let o=(0,m.getInstance)(),n=0,e=[],t=h||{};(r=>{r.extra||(r.extra={}),r.extra.session||(r.extra.session={});let i=r.extra.session;i.use_ort_model_bytes_directly||(i.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(l=>(typeof l=="string"?l:l.name)==="webgpu")&&(r.enableMemPattern=!1)})(t);try{let r=(v=>{switch(v){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${v}`)}})((p=t.graphOptimizationLevel)!==null&&p!==void 0?p:"all"),i=(v=>{switch(v){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${v}`)}})((u=t.executionMode)!==null&&u!==void 0?u:"sequential"),l=typeof t.logId=="string"?(0,f.allocWasmString)(t.logId,e):0,d=(s=t.logSeverityLevel)!==null&&s!==void 0?s:2;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log serverity level is not valid: ${d}`);let g=(a=t.logVerbosityLevel)!==null&&a!==void 0?a:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);let b=typeof t.optimizedModelFilePath=="string"?(0,f.allocWasmString)(t.optimizedModelFilePath,e):0;return n=o._OrtCreateSessionOptions(r,!!t.enableCpuMemArena,!!t.enableMemPattern,i,!!t.enableProfiling,0,l,d,g,b),n===0&&(0,f.checkLastError)("Can't create session options."),t.executionProviders&&((v,w,x)=>{for(let T of w){let O=typeof T=="string"?T:T.name;switch(O){case"xnnpack":O="XNNPACK";break;case"webnn":if(O="WEBNN",typeof T!="string"){let I=T;if(I?.deviceType){let R=(0,f.allocWasmString)("deviceType",x),j=(0,f.allocWasmString)(I.deviceType,x);(0,m.getInstance)()._OrtAddSessionConfigEntry(v,R,j)!==0&&(0,f.checkLastError)(`Can't set a session config entry: 'deviceType' - ${I.deviceType}.`)}if(I?.powerPreference){let R=(0,f.allocWasmString)("powerPreference",x),j=(0,f.allocWasmString)(I.powerPreference,x);(0,m.getInstance)()._OrtAddSessionConfigEntry(v,R,j)!==0&&(0,f.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${I.powerPreference}.`)}}break;case"webgpu":O="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${O}`)}let P=(0,f.allocWasmString)(O,x);(0,m.getInstance)()._OrtAppendExecutionProvider(v,P)!==0&&(0,f.checkLastError)(`Can't append execution provider: ${O}.`)}})(n,t.executionProviders,e),t.extra!==void 0&&(0,f.iterateExtraOptions)(t.extra,"",new WeakSet,(v,w)=>{let x=(0,f.allocWasmString)(v,e),T=(0,f.allocWasmString)(w,e);o._OrtAddSessionConfigEntry(n,x,T)!==0&&(0,f.checkLastError)(`Can't set a session config entry: ${v} - ${w}.`)}),[n,e]}catch(r){throw n!==0&&o._OrtReleaseSessionOptions(n),e.forEach(i=>o._free(i)),r}}},7917:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.logLevelStringToEnum=c.tensorTypeToTypedArrayConstructor=c.getTensorElementSize=c.tensorDataTypeEnumToString=c.tensorDataTypeStringToEnum=void 0,c.tensorDataTypeStringToEnum=y=>{switch(y){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${y}`)}},c.tensorDataTypeEnumToString=y=>{switch(y){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${y}`)}},c.getTensorElementSize=y=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][y],c.tensorTypeToTypedArrayConstructor=y=>{switch(y){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${y}`)}},c.logLevelStringToEnum=y=>{switch(y){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${y}`)}}},1259:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.extractTransferableBuffers=c.endProfiling=c.run=c.releaseSession=c.createSession=c.createSessionFinalize=c.createSessionAllocate=c.initRuntime=void 0;let m=y(7918),f=y(7622),h=y(7917),p=y(263),u=y(1497);c.initRuntime=async a=>{var o,n;o=a.wasm.numThreads,n=(0,h.logLevelStringToEnum)(a.logLevel),(0,p.getInstance)()._OrtInit(o,n)!==0&&(0,u.checkLastError)("Can't initialize onnxruntime.");{let e=y(7675).S;await e((0,p.getInstance)(),a)}};let s=new Map;c.createSessionAllocate=a=>{let o=(0,p.getInstance)(),n=o._malloc(a.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${a.byteLength}.`);return o.HEAPU8.set(a,n),[n,a.byteLength]},c.createSessionFinalize=(a,o)=>{let n=(0,p.getInstance)(),e=0,t=0,r=[],i=[],l=[];try{[t,r]=(0,f.setSessionOptions)(o),e=n._OrtCreateSession(a[0],a[1],t),e===0&&(0,u.checkLastError)("Can't create a session.");let[d,g]=(w=>{let x=(0,p.getInstance)(),T=x.stackSave();try{let O=x.stackAlloc(8);return x._OrtGetInputOutputCount(w,O,O+4)!==0&&(0,u.checkLastError)("Can't get session input/output count."),[x.HEAP32[O/4],x.HEAP32[O/4+1]]}finally{x.stackRestore(T)}})(e),b=[],v=[];for(let w=0;w<d;w++){let x=n._OrtGetInputName(e,w);x===0&&(0,u.checkLastError)("Can't get an input name."),i.push(x),b.push(n.UTF8ToString(x))}for(let w=0;w<g;w++){let x=n._OrtGetOutputName(e,w);x===0&&(0,u.checkLastError)("Can't get an output name."),l.push(x),v.push(n.UTF8ToString(x))}return s.set(e,[e,i,l]),[e,b,v]}catch(d){throw i.forEach(g=>n._OrtFree(g)),l.forEach(g=>n._OrtFree(g)),e!==0&&n._OrtReleaseSession(e),d}finally{n._free(a[0]),t!==0&&n._OrtReleaseSessionOptions(t),r.forEach(d=>n._free(d))}},c.createSession=(a,o)=>{let n=(0,c.createSessionAllocate)(a);return(0,c.createSessionFinalize)(n,o)},c.releaseSession=a=>{let o=(0,p.getInstance)(),n=s.get(a);if(!n)throw new Error(`cannot release session. invalid session id: ${a}`);let[e,t,r]=n;t.forEach(i=>o._OrtFree(i)),r.forEach(i=>o._OrtFree(i)),o._OrtReleaseSession(e),s.delete(a)},c.run=async(a,o,n,e,t)=>{let r=(0,p.getInstance)(),i=s.get(a);if(!i)throw new Error(`cannot run inference. invalid session id: ${a}`);let[l,d,g]=i,b=o.length,v=e.length,w=0,x=[],T=[],O=[];try{[w,x]=(0,m.setRunOptions)(t);for(let C=0;C<b;C++){let _=n[C][0],S=n[C][1],E=n[C][2],z,L;if(Array.isArray(E)){L=4*E.length,z=r._malloc(L),O.push(z);let te=z/4;for(let ae=0;ae<E.length;ae++){if(typeof E[ae]!="string")throw new TypeError(`tensor data at index ${ae} is not a string`);r.HEAPU32[te++]=(0,u.allocWasmString)(E[ae],O)}}else L=E.byteLength,z=r._malloc(L),O.push(z),r.HEAPU8.set(new Uint8Array(E.buffer,E.byteOffset,L),z);let Y=r.stackSave(),X=r.stackAlloc(4*S.length);try{let te=X/4;S.forEach(se=>r.HEAP32[te++]=se);let ae=r._OrtCreateTensor((0,h.tensorDataTypeStringToEnum)(_),z,L,X,S.length);ae===0&&(0,u.checkLastError)(`Can't create tensor for input[${C}].`),T.push(ae)}finally{r.stackRestore(Y)}}let P=r.stackSave(),I=r.stackAlloc(4*b),R=r.stackAlloc(4*b),j=r.stackAlloc(4*v),A=r.stackAlloc(4*v);try{let C=I/4,_=R/4,S=j/4,E=A/4;for(let X=0;X<b;X++)r.HEAPU32[C++]=T[X],r.HEAPU32[_++]=d[o[X]];for(let X=0;X<v;X++)r.HEAPU32[S++]=0,r.HEAPU32[E++]=g[e[X]];let z=r._OrtRun(l,R,I,b,A,v,j,w),L=r.jsepRunPromise;L&&L.then!==void 0&&(z=await L);let Y=[];z!==0&&(0,u.checkLastError)("failed to call OrtRun().");for(let X=0;X<v;X++){let te=r.HEAPU32[j/4+X],ae=r.stackSave(),se=r.stackAlloc(16),pe,ge=0;try{z=r._OrtGetTensorData(te,se,se+4,se+8,se+12),z!==0&&(0,u.checkLastError)(`Can't access output tensor data on index ${X}.`);let ve=se/4,Me=r.HEAPU32[ve++];ge=r.HEAPU32[ve++];let De=r.HEAPU32[ve++],je=r.HEAPU32[ve++],_e=[];for(let Pe=0;Pe<je;Pe++)_e.push(r.HEAPU32[De/4+Pe]);r._OrtFree(De);let Be=_e.length===0?1:_e.reduce((Pe,Re)=>Pe*Re);if(pe=(0,h.tensorDataTypeEnumToString)(Me),pe==="string"){let Pe=[],Re=ge/4;for(let Ue=0;Ue<Be;Ue++){let He=r.HEAPU32[Re++],Ze=Ue===Be-1?void 0:r.HEAPU32[Re]-He;Pe.push(r.UTF8ToString(He,Ze))}Y.push([pe,_e,Pe])}else{let Pe=new((0,h.tensorTypeToTypedArrayConstructor)(pe))(Be);new Uint8Array(Pe.buffer,Pe.byteOffset,Pe.byteLength).set(r.HEAPU8.subarray(ge,ge+Pe.byteLength)),Y.push([pe,_e,Pe])}}finally{r.stackRestore(ae),pe==="string"&&ge&&r._free(ge),r._OrtReleaseTensor(te)}}return Y}finally{r.stackRestore(P)}}finally{T.forEach(P=>r._OrtReleaseTensor(P)),O.forEach(P=>r._free(P)),w!==0&&r._OrtReleaseRunOptions(w),x.forEach(P=>r._free(P))}},c.endProfiling=a=>{let o=(0,p.getInstance)(),n=s.get(a);if(!n)throw new Error("invalid session id");let e=n[0],t=o._OrtEndProfiling(e);t===0&&(0,u.checkLastError)("Can't get an profile file name."),o._OrtFree(t)},c.extractTransferableBuffers=a=>{let o=[];for(let n of a){let e=n[2];!Array.isArray(e)&&e.buffer&&o.push(e.buffer)}return o}},263:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(t,r,i,l){l===void 0&&(l=i);var d=Object.getOwnPropertyDescriptor(r,i);d&&!("get"in d?!r.__esModule:d.writable||d.configurable)||(d={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(t,l,d)}:function(t,r,i,l){l===void 0&&(l=i),t[l]=r[i]}),f=this&&this.__setModuleDefault||(Object.create?function(t,r){Object.defineProperty(t,"default",{enumerable:!0,value:r})}:function(t,r){t.default=r}),h=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var r={};if(t!=null)for(var i in t)i!=="default"&&Object.prototype.hasOwnProperty.call(t,i)&&m(r,t,i);return f(r,t),r};Object.defineProperty(c,"__esModule",{value:!0}),c.dispose=c.getInstance=c.initializeWebAssembly=void 0;let p=h(y(6449)),u=y(9377),s=y(5711),a,o=!1,n=!1,e=!1;c.initializeWebAssembly=async t=>{if(o)return Promise.resolve();if(n)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(e)throw new Error("previous call to 'initializeWebAssembly()' failed.");n=!0;let r=t.initTimeout,i=t.numThreads,l=t.simd,d=i>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),g=l&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),b=t.wasmPaths,v=typeof b=="string"?b:void 0,w=((P,I)=>I?P?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":P?"ort-wasm-simd.wasm":"ort-wasm.wasm")(g,d),x=typeof b=="object"?b[w]:void 0,T=!1,O=[];if(r>0&&O.push(new Promise(P=>{setTimeout(()=>{T=!0,P()},r)})),O.push(new Promise((P,I)=>{let R=d?s:u,j={locateFile:(A,C)=>{if(d&&A.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([y(4154)],{type:"text/javascript"}));if(A.endsWith(".wasm")){if(x)return x;let _=v??C;return w==="ort-wasm-simd.wasm"?_+"ort-wasm-simd.jsep.wasm":w==="ort-wasm-simd-threaded.wasm"?_+"ort-wasm-simd-threaded.jsep.wasm":_+w}return C+A}};if(d)if(typeof Blob>"u")j.mainScriptUrlOrBlob=p.join(__dirname,"ort-wasm-threaded.js");else{let A=`var ortWasmThreaded=(function(){var _scriptDir;return ${R.toString()}})();`;j.mainScriptUrlOrBlob=new Blob([A],{type:"text/javascript"})}R(j).then(A=>{n=!1,o=!0,a=A,P()},A=>{n=!1,e=!0,I(A)})})),await Promise.race(O),T)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},c.getInstance=()=>{if(o&&a)return a;throw new Error("WebAssembly is not initialized yet.")},c.dispose=()=>{var t;!o||n||e||(n=!0,(t=a.PThread)===null||t===void 0||t.terminateAllThreads(),a=void 0,n=!1,o=!1,e=!0)}},1497:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.checkLastError=c.iterateExtraOptions=c.allocWasmString=void 0;let m=y(263);c.allocWasmString=(f,h)=>{let p=(0,m.getInstance)(),u=p.lengthBytesUTF8(f)+1,s=p._malloc(u);return p.stringToUTF8(f,s,u),h.push(s),s},c.iterateExtraOptions=(f,h,p,u)=>{if(typeof f=="object"&&f!==null){if(p.has(f))throw new Error("Circular reference in options");p.add(f)}Object.entries(f).forEach(([s,a])=>{let o=h?h+s:s;if(typeof a=="object")(0,c.iterateExtraOptions)(a,o+".",p,u);else if(typeof a=="string"||typeof a=="number")u(o,a.toString());else{if(typeof a!="boolean")throw new Error("Can't handle extra config type: "+typeof a);u(o,a?"1":"0")}})},c.checkLastError=f=>{let h=(0,m.getInstance)(),p=h.stackSave();try{let u=h.stackAlloc(8);h._OrtGetLastError(u,u+4);let s=h.HEAP32[u/4],a=h.HEAPU32[u/4+1],o=a?h.UTF8ToString(a):"";throw new Error(`${f} ERROR_CODE: ${s}, ERROR_MESSAGE: ${o}`)}finally{h.stackRestore(p)}}},8050:(M,c,y)=>{"use strict";y.d(c,{Z:()=>h});var m=y(6614),f=y.n(m);function h(){return f()('/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={3838:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebGpuBackend=void 0;const r=n(4955),a=n(7771),i=n(8510),o=n(8305);t.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.supportTimestampQuery=!1}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const t=await navigator.gpu.requestAdapter();if(!t)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;const n={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ}};t.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,n.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await t.requestDevice(n),this.gpuDataManager=(0,a.createGpuDataManager)(this),this.programManager=new o.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,(0,r.configureLogger)(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(e,t,n,a,i){if(t.length!==e.inputTypes.length)throw new Error(`Input size must be equal to ${e.inputTypes.length}.`);const o=[];for(let e=0;e<t.length;++e){const n=this.gpuDataManager.get(t[e].data);if(!n)throw new Error(`no GPU data for input: ${t[e].data}`);o[e]=n}const s=((e,t)=>{const n=t.map((e=>`${e.dataType};${e.dims.join(",")}`)).join("|");let r=e.name;return e.cacheHint&&(r+="["+e.cacheHint+"]"),r+=":"+n,r})(e,t);let u=this.programManager.getArtifact(s);const l=u?u.programInfo:"function"==typeof e.get?e.get():e,c=0===n.length?l.outputs.map(((e,t)=>t)):n;if(c.length!==l.outputs.length)throw new Error(`Output size ${c.length} must be equal to ${l.outputs.length}.`);const d=[],p=[];for(let e=0;e<l.outputs.length;++e){if(!Number.isInteger(c[e])||c[e]<-3||c[e]>=l.outputs.length)throw new Error(`Invalid output index: ${c[e]}`);if(-3===c[e])continue;const t=-1===c[e],n=-2===c[e],r=t||n?i(l.outputs[e].dataType,l.outputs[e].dims):a(c[e],l.outputs[e].dataType,l.outputs[e].dims),o=this.gpuDataManager.get(r.data);if(!o)throw new Error(`no GPU data for output: ${r.data}`);if(t&&this.temporaryData.push(o),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(o)}d.push(r),p.push(o)}const f=this.programManager.normalizeDispatchGroupSize(l.dispatchGroup(t));return u||(u=this.programManager.build(l,f),this.programManager.setArtifact(s,u)),(0,r.LOG_DEBUG)("info",(()=>`[ProgramManager] run "${l.name}" (key=${s}) with ${f[0]}x${f[1]}x${f[2]}`)),this.programManager.run(u,o,p,f),d}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){const n=await this.gpuDataManager.download(e),r=t();r.set(new Uint8Array(n,0,r.byteLength))}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n){const r=i.WEBGPU_OP_RESOLVE_RULES.get(e);if(!r)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(t,[e,r[0],[r[1],n]])}releaseKernel(e){const t=this.kernelPersistentData.get(e);if(t){for(const e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t){const n=this.kernels.get(e);if(!n)throw new Error(`kernel not created: ${e}`);const[a,i,o]=n;if(null!==this.currentKernelId)throw new Error(`kernel "${a}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),(0,r.LOG_DEBUG)("info",(()=>`[WebGPU] Start to run kernel "${a}"...`)),this.temporaryData=[];try{return i(t,o[1]),0}catch(e){return(0,r.LOG_DEBUG)("warning",`[WebGPU] Kernel "${a}" failed. Error: ${e}`),1}finally{for(const e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(e,t,n)=>{"use strict";t.S=void 0;const r=n(7917),a=n(3838),i=n(4955),o=n(6952);class s{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");const e=o.ShapeUtil.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");const e=o.ShapeUtil.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");const e=o.ShapeUtil.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(o.ShapeUtil.size(e)!==o.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new s(this.module,this.dataType,this.data,e)}}class u{get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0;const r=e.HEAPU32;let a=n>>2;this.opKernelContext=r[a++];const i=r[a++];this.outputCount=r[a++],this.customDataOffset=r[a++],this.customDataSize=r[a++];const o=[];for(let t=0;t<i;t++){const t=r[a++],n=r[a++],i=r[a++],u=[];for(let e=0;e<i;e++)u.push(r[a++]);o.push(new s(e,t,n,u))}this.inputs=o}compute(e,t){var n,a,i;const u=null!==(a=null===(n=null==t?void 0:t.inputs)||void 0===n?void 0:n.map((e=>"number"==typeof e?this.inputs[e]:e)))&&void 0!==a?a:this.inputs,l=null!==(i=null==t?void 0:t.outputs)&&void 0!==i?i:[];return this.backend.run(e,u,l,((e,t,n)=>new s(this.module,t,this.output(e,n),n)),((e,t)=>{const n=(0,r.getTensorElementSize)(e);if(!n)throw new Error(`Unsupported data type: ${e}`);const a=n*o.ShapeUtil.size(t);return new s(this.module,e,this.backend.gpuDataManager.create(a).id,t)}))}output(e,t){const n=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+t.length));let r=n>>2;this.module.HEAPU32[r++]=t.length;for(let e=0;e<t.length;e++)this.module.HEAPU32[r++]=t[e];return this.module._JsepOutput(this.opKernelContext,e,n)}finally{this.module.stackRestore(n)}}}t.S=async(e,t)=>{const n=e.jsepInit;if(n&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");const r=new a.WebGpuBackend;await r.initialize(t),n({backend:r},(e=>r.alloc(e)),(e=>r.free(e)),((t,n,a,o=!1)=>{if(o)(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${t}, dst=${n}, size=${a}`)),r.memcpy(t,n);else{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${t}, gpuDataId=${n}, size=${a}`));const o=e.HEAPU8.subarray(t,t+a);r.upload(n,o)}}),(async(t,n,a)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${t}, dataOffset=${n}, size=${a}`)),await r.download(t,(()=>e.HEAPU8.subarray(n,n+a)))}),((e,t,n)=>r.createKernel(e,t,n)),(e=>r.releaseKernel(e)),((t,n)=>{(0,i.LOG_DEBUG)("verbose",(()=>`[WebGPU] jsepRun: kernel=${t}, contextDataOffset=${n}`));const a=new u(e,r,n);return r.computeKernel(t,a)}))}}},4955:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.LOG_DEBUG=t.LOG=t.configureLogger=void 0;const r=n(7917),a=["V","I","W","E","F"];let i,o;t.configureLogger=(e,t)=>{i=e,o=t},t.LOG=(e,t)=>{const n=(0,r.logLevelStringToEnum)(e);var o,s;n>=(0,r.logLevelStringToEnum)(i)&&(o=n,s="function"==typeof t?t():t,console.log(`[${a[o]},${(new Date).toISOString()}]${s}`))},t.LOG_DEBUG=(...e)=>{o&&(0,t.LOG)(...e)}},6952:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAX_CLIP=t.MIN_CLIP=t.GemmUtil=t.PoolConvUtil=t.ShapeUtil=t.BroadcastUtil=t.MatMulUtil=void 0;class n{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=n;class r{static calcShape(e,t,r=!1){const a=e.length,i=t.length;if(0===a)return t;if(0===i)return e;const o=Math.max(e.length,t.length),s=new Array(o);if(r){if(a<2||i<2)return;const r=n.calcMatMulShape([e[a-2],e[a-1]],[t[i-2],t[i-1]]);if(void 0===r)return;[s[o-2],s[o-1]]=r}for(let n=r?3:1;n<=o;n++){const r=a-n<0?1:e[a-n],u=i-n<0?1:t[i-n];if(r!==u&&r>1&&u>1)return;s[o-n]=Math.max(r,u)}return s}static isValidBroadcast(e,t){const n=e.length,r=t.length;if(n>r)return!1;for(let a=1;a<=n;a++)if(1!==e[n-a]&&e[n-a]!==t[r-a])return!1;return!0}}t.BroadcastUtil=r;class a{static size(e){return a.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return a.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let a=t;a<n;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=e[a]}return r}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((n=>this.normalizeAxis(n,null!=t?t:e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const n=e.length;return e.map(((e,r)=>e+t[r]+t[r+n]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,n)=>e===t[n]))}}t.ShapeUtil=a;class i{static adjustPoolAttributes(e,t,n,r,a,i){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*n.length;e++)if(e<i.length){if(i[e]<0)throw new Error("pad should be greater than or equal to 1")}else i.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(i[e]>=n[e]||i[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,n,r,a,o,s){if(s){if(a.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)i.adjustPadAndReturnShape(e[u+(o?1:2)],t[u],n[u],r[u],a,u,u+e.length-2,s)}}static computePoolOutputShape(e,t,n,r,a,o,s){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const u=[t[0],t[1]];return i.computeShapeHelper(e,t,u,n,r,a,o,s),u}static computeConvOutputShape(e,t,n,r,a,o,s){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const u=[e[0],t[0]];return i.computeShapeHelper(!1,e,u,n,r,a,o,s),u}static computeShapeHelper(e,t,n,r,a,o,s,u){if(e)for(let e=0;e<t.length-2;e++)n.push(1);else for(let e=0;e<t.length-2;e++)n.push(i.adjustPadAndReturnShape(t[e+2],r[e],a[e],o[e],s,e,e+t.length-2,u))}static adjustPadAndReturnShape(e,t,n,r,a,i,o,s){const u=n*(r-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[i]+a[o]-u)/t+1);switch(s){case"VALID":return a[i]=0,a[o]=0,Math.floor((e-u)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const n=((e+t-1)/t-1)*t+r-e;return a[i]="SAME_LOWER"===s?Math.floor((n+1)/2):Math.floor(n/2),a[o]=n-a[i],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=i,t.GemmUtil=class{static getShapeOfGemmResult(e,t,n,a,i){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let o,s,u;t?(o=e[1],s=e[0]):(o=e[0],s=e[1]);let l=-1;if(a?(u=n[0],l=1):(u=n[1],l=0),n[l]!==s)throw new Error("dimension mismatch");if(o<=0||u<=0||s<=0)throw new Error("invalid shape specified");if(i&&!r.isValidBroadcast(i,[o,u]))throw new Error("gemm: invalid bias shape for broadcast");return[o,u,s]}},t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22},387:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class n{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new n(e)},7771:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGpuDataManager=void 0;const r=n(4955),a=n(1163),i=e=>16*Math.ceil(e/16);let o=0;class s{constructor(e){this.backend=e,this.storageCache=new Map,this.downloadCache=new Map,this.freeBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(e,t){const n=t.buffer,a=t.byteOffset,o=t.byteLength,s=i(o),u=this.storageCache.get(e);if(!u)throw new Error("gpu data for uploading does not exist");if(u.originalSize!==o)throw new Error(`inconsistent data size. gpu data size=${u.originalSize}, data size=${o}`);const l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),c=l.getMappedRange();new Uint8Array(c).set(new Uint8Array(n,a,o)),l.unmap();const d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(l,0,u.gpuData.buffer,0,s),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`)),this.buffersForUploadingPending.push(l)}memcpy(e,t){const n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");const r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");const a=i(n.originalSize),o=this.backend.getCommandEncoder();this.backend.endComputePass(),o.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,a)}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const n=i(e);let s;if((t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let e=this.freeBuffers.get(n);e||(e=[],this.freeBuffers.set(n,e)),s=e.length>0?e.pop():this.backend.device.createBuffer({size:n,usage:t})}else s=this.backend.device.createBuffer({size:n,usage:t});const u={id:o++,type:a.GpuDataType.default,buffer:s};return this.storageCache.set(u.id,{gpuData:u,originalSize:e}),(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${u.id}`)),u}get(e){var t;return null===(t=this.storageCache.get(e))||void 0===t?void 0:t.gpuData}release(e){const t=this.storageCache.get(e);if(!t)throw new Error("releasing data does not exist");return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${t.gpuData.id}`)),this.storageCache.delete(e),this.buffersPending.push(t.gpuData.buffer),this.downloadCache.get(e)&&this.downloadCache.delete(e),t.originalSize}async download(e){const t=this.downloadCache.get(e);if(t)return t.data;const n=this.storageCache.get(e);if(!n)throw new Error("data does not exist");const r=this.backend.getCommandEncoder();this.backend.endComputePass();const a=i(n.originalSize),o=this.backend.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});r.copyBufferToBuffer(n.gpuData.buffer,0,o,0,a),this.backend.flush();const s=new Promise((e=>{o.mapAsync(GPUMapMode.READ).then((()=>{const t=o.getMappedRange().slice(0);o.destroy(),e(t)}))}));return this.downloadCache.set(e,{data:s}),s}refreshPendingBuffers(){for(const e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(const e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map,this.downloadCache=new Map,this.freeBuffers=new Map}}t.createGpuDataManager=(...e)=>new s(...e)},8510:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGPU_OP_RESOLVE_RULES=void 0;const o=n(1868),s=i(n(504)),u=n(513),l=n(9770),c=n(7640),d=n(8856),p=n(8405),f=n(4271),h=n(1798),g=n(6145),m=n(1522),y=i(n(5262)),b=n(6031),v=n(4566),w=n(8906),$=n(5101),x=n(6198),S=n(2067),_=n(8699),A=n(2625),C=i(n(9302));t.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[C.abs]],["Acos",[C.acos]],["Acosh",[C.acosh]],["Add",[s.add]],["ArgMax",[o.argMax,o.parseArgMinMaxAttributes]],["ArgMin",[o.argMin,o.parseArgMinMaxAttributes]],["Asin",[C.asin]],["Asinh",[C.asinh]],["Atan",[C.atan]],["Atanh",[C.atanh]],["AveragePool",[y.averagePool,y.parseAveragePoolAttributes]],["Cast",[C.cast,C.parseCastAttributes]],["Ceil",[C.ceil]],["ClipV10",[C.clipV10]],["Clip",[C.clip]],["Concat",[u.concat,u.parseConcatAttributes]],["Conv",[l.conv,l.parseConvAttributes]],["ConvTranspose",[c.convTranspose,c.parseConvTransposeAttributes]],["Cos",[C.cos]],["Cosh",[C.cosh]],["Div",[s.div]],["Elu",[C.elu,C.parseAlphaAttributes]],["Erf",[C.erf]],["Exp",[C.exp]],["Expand",[d.expand]],["Floor",[C.floor]],["Gather",[p.gather,p.parseGatherAttributes]],["Gelu",[C.gelu]],["Gemm",[f.gemm,f.parseGemmAttributes]],["GlobalAveragePool",[y.globalAveragePool,y.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[y.globalMaxPool,y.parseGlobalMaxPoolAttributes]],["InstanceNormalization",[h.instanceNorm,h.parseInstanceNormAttributes]],["LayerNormalization",[g.layerNorm,g.parseLayerNormAttributes]],["LeakyRelu",[C.leakyRelu,C.parseAlphaAttributes]],["Log",[C.log]],["MatMul",[m.matMul]],["MaxPool",[y.maxPool,y.parseMaxPoolAttributes]],["Mul",[s.mul]],["Neg",[C.neg]],["Pow",[s.pow]],["Reciprocal",[C.reciprocal]],["ReduceMin",[b.reduceMin,b.parseReduceAttributes]],["ReduceMean",[b.reduceMean,b.parseReduceAttributes]],["ReduceMax",[b.reduceMax,b.parseReduceAttributes]],["ReduceSum",[b.reduceSum,b.parseReduceAttributes]],["ReduceProd",[b.reduceProd,b.parseReduceAttributes]],["ReduceL1",[b.reduceL1,b.parseReduceAttributes]],["ReduceL2",[b.reduceL2,b.parseReduceAttributes]],["ReduceLogSum",[b.reduceLogSum,b.parseReduceAttributes]],["ReduceLogSumExp",[b.reduceLogSumExp,b.parseReduceAttributes]],["ReduceSumSquare",[b.reduceSumSquare,b.parseReduceAttributes]],["Relu",[C.relu]],["Resize",[v.resize,v.parseResizeAttributes]],["Sigmoid",[C.sigmoid]],["Sin",[C.sin]],["Sinh",[C.sinh]],["Slice",[$.slice,$.parseSliceAttributes]],["SkipLayerNormalization",[w.skipLayerNorm,w.parseSkipLayerNormAttributes]],["Split",[S.split,S.parseSplitAttributes]],["Sqrt",[C.sqrt]],["Softmax",[x.softmax,x.parseSoftmaxAttributes]],["Sub",[s.sub]],["Tan",[C.tan]],["Tanh",[C.tanh]],["ThresholdedRelu",[C.thresholdedRelu,C.parseAlphaAttributes]],["Tile",[_.tile]],["Transpose",[A.transpose,A.parseTransposeAttributes]]])},1427:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.biasActivationSnippet=t.activationFnSnippet=t.typeSnippet=void 0,t.typeSnippet=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}},t.activationFnSnippet=(e,t=!1,n=!1,r=3)=>"",t.biasActivationSnippet=(e,t)=>`\\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\\n      ${t?"value = activation(value, coords);":""}\\n      `},9456:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfo=void 0;const r=n(4955),a=n(6952),i=n(1163),o=n(1427),s=n(4085),u=n(158);t.createConv2DMatMulProgramInfo=(e,t,n,l,c,d,p,f,h)=>{const g="NHWC"===n.format,m=g?e[0].dims[3]:e[0].dims[1],y=l[0],b=g?l[2]:l[3],v=g?l[1]:l[2],w=g?l[3]:l[1],$=((m%4==0||m%3==0)&&g||b%4==0&&!g)&&w%4==0,x=g?w:b*v,S=g?b*v:w,_=$?[8,8,1]:[x<=4?4:16,x>4&&S<=4?4:16,1],A=$?[4,4,1]:[x<=4?1:2,x>4&&S<=4?1:2,1],C=[Math.ceil(x/_[0]/A[0]),Math.ceil(S/_[1]/A[1]),Math.ceil(y/_[2]/A[1])];(0,r.LOG_DEBUG)("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${C}`));const O=$?g&&m%4!=0?3:4:A[0],T=_[1]*A[1],I=_[0]*A[0],E=Math.max(_[0]*O,_[1]),P=c%T==0,M=d%I==0,R=p%E==0,k=$?[O,4,4]:[1,1,1],D=[`@group(0) @binding(0) var<storage, read> x: array<${$&&4===O?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?"vec4<f32>":"f32"}>;`];let z=`\\n      fn setOutputAtIndex(flatIndex : i32, value : ${$?"vec4<f32>":"f32"}) {\\n        result[flatIndex] = ${$?"vec4<f32>":"f32"}(value);\\n      }\\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?"vec4<f32>":"f32"}) {\\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\\n        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);\\n      }`;return f&&(D.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),z+=`\\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {\\n          return bias[coords.${g?"w":"y"}${$?"/ 4":""}];\\n        }`),Object.assign(Object.assign({},t),{outputs:[{dims:l,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:C[0],y:C[1],z:C[2]}),getShaderSource:()=>`\\n        ${s.utilFunctions}\\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\\n        ${D.join("")}\\n        @group(0) @binding(${D.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;\\n        //@group(0) @binding(${D.length+1}) var<uniform> uniforms: Uniforms;\\n\\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\\n        const outShape : vec4<i32> = vec4<i32>(${l.join(",")});\\n        const outShapeStrides : vec3<i32> = vec3<i32>(${a.ShapeUtil.computeStrides(l).slice(0,3).join(",")});\\n        const filterDims : vec2<i32> = vec2<i32>(${n.kernelShape[0]}, ${n.kernelShape[1]});\\n        const pad : vec2<i32> = vec2<i32>(${n.pads[0]}, ${n.pads[1]});\\n        const stride : vec2<i32> = vec2<i32>(${n.strides[0]}, ${n.strides[1]});\\n        const dilation : vec2<i32> = vec2<i32>(${n.dilations[0]}, ${n.dilations[1]});\\n        const dimAOuter : i32 = ${c};\\n        const dimBOuter : i32 = ${d};\\n        const dimInner : i32 = ${p};\\n        ${z}\\n        ${((e,t,n,r,a=!1,i,s=!1,u=4,l=4,c=4)=>{const d=e?"\\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\\n    ":"\\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\\n    ",p=e?"\\n    let coords = vec4<i32>(\\n      batch,\\n      row / outWidth,\\n      row % outWidth,\\n      col);\\n    ":"\\n    let coords = vec4<i32>(\\n      batch,\\n      row,\\n      col / outWidth,\\n      col % outWidth);\\n    ",f=e?"xShape[1]":"xShape[2]",h=e?"xShape[2]":"xShape[3]",g=e?"row":"col",m=e?"col":"row",y=`\\n    let inChannels = wShape[2];\\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\\n    let outRow = ${g} / outWidth;\\n    let outCol = ${g} % outWidth;\\n\\n    let WRow = ${m} / (filterDims[1] * inChannels);\\n    let WCol = ${m} / inChannels % filterDims[1];\\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\\n    let xCh = ${m} % inChannels;\\n    var resData = ${(0,o.typeSnippet)(u)}(0.0);\\n    // The bounds checking is always needed since we use it to pad zero for\\n    // the \'same\' padding type.\\n    if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {\\n      ${d}\\n      let xIndex = getIndexFromCoords4D(coord, xShape);\\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}\\n    }\\n    return resData;`,b=e?t&&r?`\\n    let col = colIn * ${u};\\n    ${y}`:`\\n    let col = colIn * ${u};\\n    if (row < dimAOuter && col < dimInner) {\\n      ${y}\\n    }\\n    return ${(0,o.typeSnippet)(u)}(0.0);`:r&&n?`\\n    let col = colIn * ${u};\\n    ${y}`:`\\n    let col = colIn * ${u};\\n    if (row < dimInner && col < dimBOuter) {\\n      ${y}\\n    }\\n    return ${(0,o.typeSnippet)(u)}(0.0);`,v=`${(e=>{switch(e){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(l)}`,w=(0,o.typeSnippet)(c),$=e?(0,o.typeSnippet)(u):(0,o.typeSnippet)(l),x=e?(0,o.typeSnippet)(l):(0,o.typeSnippet)(u);return`\\n    ${(0,o.activationFnSnippet)(i,s,4===c,4)}\\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${$} {\\n      ${e?b:v}\\n    }\\n\\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${x} {\\n      ${e?v:b}\\n    }\\n\\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\\n      let col = colIn * ${c};\\n      if (row < dimAOuter && col < dimBOuter)\\n      {\\n      var value = valueIn;\\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\\n      ${p}\\n      ${(0,o.biasActivationSnippet)(a,i)}\\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\\n      }\\n    }`})(g,P,M,R,f,void 0,!1,k[0],k[1],k[2])}\\n            ${$?(0,u.makeMatMulPackedVec4Source)(A,_,!g,E):(0,u.makeMatMulPackedSource)(A,_,!g,E,!1,void 0,h)}`})}},6514:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConvTranspose2DProgramInfo=void 0;const r=n(4955),a=n(6952),i=n(1163),o=n(2075);t.createConvTranspose2DProgramInfo=(e,t,n,s)=>{const u=e.length>2,l=n.outputShape,c=a.ShapeUtil.size(l),d=[Math.ceil(c/64),1,1];return(0,r.LOG_DEBUG)("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${d}`)),Object.assign(Object.assign({},t),{outputs:[{dims:s?s(l):l,dataType:e[0].dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:d[0],y:d[1],z:d[2]}),getShaderSource:t=>((e,t,n,r,i,s,u=!1)=>{const l="NHWC"===n.format,c=l?1:2,d=l?2:3,p=l?3:1,f=a.ShapeUtil.size(r),h=u?2:1,g=n.group,m=t[1].dims,y=m[0]/g,b=m[1];let v=`\\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?"vec4<f32>":"f32"}) {\\n    result[flatIndex] = ${u?"vec4<f32>":"f32"}(value);\\n  }`;i&&(v+=`\\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?"vec4<f32>":"f32"} {\\n      return bias[coords.${l?"w":"y"}${u?"/ 4":""}];\\n    }`);const w=u?4:1,$=(0,o.inputVariable)("W",t[1].dataType,t[1].dims,w),x=(0,o.inputVariable)("Dy",t[0].dataType,t[0].dims,w),S=[x,$];i&&S.push((0,o.inputVariable)("bias",t[2].dataType,[r[p]],w));const _=(0,o.outputVariable)("result",t[0].dataType,r,w),A=`{\\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${h};\\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\\n\\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        var dotProd: array<vec4<f32>, ${h}>;\\n        for (var i = 0; i < ${h}; i++) {\\n          dotProd[i] = vec4<f32>(0.0);\\n        }\\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\\n          var dyR = (f32(dyCorner.x) + f32(wR)) / f32(strides.x);\\n          let wRPerm = filterDims[0] - 1 - wR;\\n          if (dyR < 0.0 || dyR >= f32(outBackprop[1]) ||\\n              fract(dyR) > 0.0 || wRPerm < 0) {\\n            continue;\\n          }\\n          let idyR: u32 = u32(dyR);\\n\\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\\n            let dyC = (f32(dyCorner.y) + f32(wC)) / f32(strides.y);\\n            let dyC2 = (f32(dyCorner.y) + 1.0 + f32(wC)) / f32(strides.y);\\n            let wCPerm = filterDims[1] - 1 - wC;\\n            if (wCPerm < 0) {\\n              continue;\\n            }\\n            var bDyCVal = true;\\n            var bDyCVal2 = true;\\n            if (dyC < 0.0 || dyC >= f32(outBackprop[2]) ||\\n                fract(dyC) > 0.0) {\\n              bDyCVal = false;\\n            }\\n            if (dyC2 < 0.0 || dyC2 >= f32(outBackprop[2]) ||\\n                fract(dyC2) > 0.0) {\\n              bDyCVal2 = false;\\n            }\\n\\n            let idyC: u32 = u32(dyC);\\n            let idyC2: u32 = u32(dyC2);\\n            if (bDyCVal && bDyCVal2) {\\n              let d2Length = outBackprop[3];\\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\\n\\n                var xValue = ${x.get("batch","idyR","idyC","d2")};\\n                let tmpval = vec4<f32>(dot(xValue, wValue0),\\n                                      dot(xValue, wValue1),\\n                                      dot(xValue, wValue2),\\n                                      dot(xValue, wValue3));\\n                dotProd[0] = dotProd[0] + tmpval;\\n\\n                xValue =  ${x.get("batch","idyR","idyC2","d2")};\\n\\n                dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\\n                                                    dot(xValue, wValue1),\\n                                                    dot(xValue, wValue2),\\n                                                    dot(xValue, wValue3));\\n              }\\n            } else if (bDyCVal) {\\n              let d2Length = outBackprop[${p}];\\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\\n\\n                var xValue = ${x.get("batch","idyR","idyC","d2")};\\n                let tmpval = vec4<f32>(dot(xValue, wValue0),\\n                                      dot(xValue, wValue1),\\n                                      dot(xValue, wValue2),\\n                                      dot(xValue, wValue3));\\n                dotProd[0] = dotProd[0] + tmpval;\\n              }\\n            } else if (bDyCVal2) {\\n              let d2Length = outBackprop[3];\\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\\n                let wValue0 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\\n                let wValue1 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\\n                let wValue2 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\\n                let wValue3 = ${$.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\\n\\n                var xValue = ${x.get("batch","idyR","idyC2","d2")};\\n                let tmpval = vec4<f32>(dot(xValue, wValue0),\\n                                      dot(xValue, wValue1),\\n                                      dot(xValue, wValue2),\\n                                      dot(xValue, wValue3));\\n                dotProd[1] = dotProd[1] + tmpval;\\n              }\\n            }\\n          }\\n        }\\n\\n        for (var i: u32 = 0; i < ${h}; i = i + 1) {\\n          let value = dotProd[i] + ${i?"bias[c+i]":"0.0"};\\n          ${_.set("batch","r","c + i","d1","value")};\\n        }\\n      }`,C=`\\n          let outputIndices = ${_.offsetToIndices("global_idx")};\\n          let batch = ${_.indicesGet("outputIndices",0)};\\n          let d1 = ${_.indicesGet("outputIndices",p)};\\n          let r = ${_.indicesGet("outputIndices",c)};\\n          let c = ${_.indicesGet("outputIndices",d)};\\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\\n          let dyRCorner = dyCorner.x;\\n          let dyCCorner = dyCorner.y;\\n          let groupId = d1 / ${b};\\n          let wOutChannel = d1 - groupId * ${b};\\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n          // ? = to be determined. : = across all values in that axis.\\n          var dotProd = 0.0;\\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\\n            if (wR % dilations.x != 0) {\\n              continue;\\n            }\\n            let dyR = (f32(dyRCorner) + f32(wR)) / f32(strides[0]);\\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\\n            if (dyR < 0.0 || dyR >= f32(outBackprop[${c}]) || fract(dyR) > 0.0 ||\\n                wRPerm < 0) {\\n              continue;\\n            }\\n            let idyR: u32 = u32(dyR);\\n\\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\\n              if (wC % dilations.y != 0) {\\n                continue;\\n              }\\n              let dyC = (f32(dyCCorner) + f32(wC)) / f32(strides.y);\\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\\n              if (dyC < 0.0 || dyC >= f32(outBackprop[${d}]) ||\\n                  fract(dyC) > 0.0 || wCPerm < 0) {\\n                continue;\\n              }\\n              let idyC: u32 = u32(dyC);\\n\\n              for (var d2: u32 = 0; d2 < ${y}; d2 = d2 + 1) {\\n                let inputChannel = groupId * ${y} + d2;\\n                let xValue = ${l?x.get("batch","idyR","idyC","inputChannel"):x.get("batch","inputChannel","idyR","idyC")};\\n                let wValue = ${$.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\\n                dotProd = dotProd + xValue * wValue;\\n              }\\n            }\\n          }\\n          let value = dotProd + ${i?"bias[d1]":"0.0"};\\n          ${_.setByOffset("global_idx","value")};\\n        `;return`\\n  ${e.declareVariables(...S,_)}\\n  ${v}\\n  const outShape : vec4<u32> = vec4<u32>(${r.join(",")});\\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\\n  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});\\n  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[l?1:2]}, ${n.kernelShape[l?2:3]});\\n  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});\\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\\n          ${n.dilations[0]<=1?0:(n.kernelShape[l?1:2]-1)*(n.dilations[0]-1)},\\n          ${n.dilations[1]<=1?0:(n.kernelShape[l?2:3]-1)*(n.dilations[1]-1)});\\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,\\n                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);\\n    ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)};\\n  ${u?A:C}}`})(t,e,n,l,u,1===d[1]&&1===d[2])})}},4085:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.utilFunctions=void 0,t.utilFunctions="\\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n}\\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\\n}\\n"},158:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeMatMulPackedSource=t.makeMatMulPackedVec4Source=void 0,t.makeMatMulPackedVec4Source=(e,t,n=!1,r=32,a=!1,i=32,o=!1)=>{const s=t[1]*e[1],u=t[0]*e[0],l=n?s:r,c=n?r:s,d=l/t[0],p=r/t[1];if((!n||4!==d||4!==e[1])&&(n||3!==d&&4!==d)||l%t[0]!=0||r%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${n} is true, innerElementSize ${d} and workPerThread[1] ${e[1]} must be 4.\\n      Otherwise, innerElementSize ${d} must be 3 or 4.\\n  tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\\nvar<workgroup> mm_Asub : array<array<vec${d}<f32>, ${l/d}>, ${c}>;\\nvar<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/e[0]}>, ${r}>;\\n\\nconst rowPerThread = ${e[1]};\\nconst colPerThread = ${e[0]};\\nconst innerElementSize = ${d};\\nconst tileInner = ${r};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n  let localRow = i32(localId.y);\\n  let tileRow = ${o?"0":"localRow * rowPerThread"};\\n  let tileCol = i32(localId.x);\\n\\n  let globalRow = ${o?"0":"i32(globalId.y) * rowPerThread"};\\n  let globalCol = i32(globalId.x);\\n  let batch = ${a?"0":"i32(globalId.z)"};\\n  let globalRowStart = i32(workgroupId.y) * ${s};\\n\\n  let numTiles = ${a?`${Math.ceil(i/r)}`:"(dimInner - 1) / tileInner + 1"};\\n  var kStart = ${a?`i32(globalId.z) * ${i}`:"0"};\\n\\n  var acc: array<vec4<f32>, rowPerThread>;\\n\\n  // Loop over shared dimension.\\n  let tileRowB = localRow * ${p};\\n  for (var t = 0; t < numTiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let inputRow = tileRow + innerRow;\\n          let inputCol = tileCol;\\n          ${f=n,f?"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          kStart + inputRow,\\n          globalRowStart / innerElementSize + inputCol);\\n        ":"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          globalRow + innerRow,\\n          kStart / innerElementSize + inputCol);\\n        "}\\n      }\\n\\n      // Load one tile of B into local memory.\\n      for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\\n          let inputRow = tileRowB + innerRow;\\n          let inputCol = tileCol;\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\\n          ${3===d?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\\n\\n          ${((e,t)=>e?`\\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          acc[i] = BCached0 * ACached0[i] + acc[i];\\n          acc[i] = BCached1 * ACached1[i] + acc[i];\\n          acc[i] = BCached2 * ACached2[i] + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\\n        }`:`\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          let ACached = mm_Asub[tileRow + i][k];\\n          acc[i] = BCached0 * ACached.x + acc[i];\\n          acc[i] = BCached1 * ACached.y + acc[i];\\n          acc[i] = BCached2 * ACached.z + acc[i];\\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\\n        }`)(n,d)}\\n      }\\n\\n      workgroupBarrier();\\n  }\\n\\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\\n  }\\n}`;var f};const n=e=>e?"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              kStart + inputRow,\\n              globalRowStart + inputCol);\\n            ":"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              globalRowStart + inputRow,\\n              kStart + inputCol);\\n            ";t.makeMatMulPackedSource=(e,t,r=!1,a=32,i=!1,o=32,s=!1)=>{const u=e[1]*t[1],l=e[0]*t[0],c=r?u:a,d=r?a:u;if(d%t[1]!=0||c%t[0]!=0||a%t[1]!=0)throw new Error(`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);const p=d/t[1],f=c/t[0],h=a/t[1],g=s?`\\n    let localRow = i32(localId.y);\\n    let localCol = i32(localId.x);\\n    let globalRowStart = i32(workgroupId.y) * ${u};\\n    let globalColStart = i32(workgroupId.x) * ${l};\\n\\n    // Loop over shared dimension.\\n    for (var t = 0; t < numTiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {\\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\\n          ${n(r)}\\n        }\\n      }\\n      // Load one tile of B into local memory.\\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\\n            for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n            kStart + inputRow,\\n            globalColStart + inputCol);\\n        }\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      var BCached : array<f32, colPerThread>;\\n      for (var k = 0; k < tileInner; k = k + 1) {\\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\\n        }\\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\\n                ACached * BCached[innerCol];\\n          }\\n        }\\n      }\\n      workgroupBarrier();\\n    }\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\\n      }\\n    }\\n    `:`\\nlet tileRow = i32(localId.y) * rowPerThread;\\nlet tileCol = i32(localId.x) * colPerThread;\\n\\nlet globalRow = i32(globalId.y) * rowPerThread;\\nlet globalCol = i32(globalId.x) * colPerThread;\\nlet globalRowStart = i32(workgroupId.y) * ${u};\\n\\nlet tileRowA = i32(localId.y) * ${p};\\nlet tileColA = i32(localId.x) * ${f};\\nlet tileRowB = i32(localId.y) * ${h};\\n// Loop over shared dimension.\\nfor (var t = 0; t < numTiles; t = t + 1) {\\n  // Load one tile of A into local memory.\\n  for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\\n      let inputRow = tileRowA + innerRow;\\n      let inputCol = tileColA + innerCol;\\n      ${n(r)}\\n    }\\n  }\\n\\n  // Load one tile of B into local memory.\\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n      let inputRow = tileRowB + innerRow;\\n      let inputCol = tileCol + innerCol;\\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n        kStart + inputRow,\\n        globalCol + innerCol);\\n    }\\n  }\\n  kStart = kStart + tileInner;\\n  workgroupBarrier();\\n\\n  // Compute acc values for a single thread.\\n  var BCached : array<f32, colPerThread>;\\n  for (var k = 0; k < tileInner; k = k + 1) {\\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\\n    }\\n\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(r)}\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\\n      }\\n    }\\n  }\\n\\n  workgroupBarrier();\\n}\\n\\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\\n        acc[innerRow][innerCol]);\\n  }\\n}\\n`;return`\\n  var<workgroup> mm_Asub : array<array<f32, ${c}>, ${d}>;\\n  var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${a}>;\\n  const rowPerThread = ${e[1]};\\n  const colPerThread = ${e[0]};\\n  const tileInner = ${a};\\n\\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n    let batch = ${i?"0":"i32(globalId.z)"};\\n    let numTiles = ${i?`${Math.ceil(o/a)}`:"(dimInner - 1) / tileInner + 1"};\\n    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};\\n\\n    var acc : array<array<f32, colPerThread>, rowPerThread>;\\n\\n    // Without this initialization strange values show up in acc.\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = 0.0;\\n      }\\n    }\\n    ${g}\\n  }\\n`}},1868:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseArgMinMaxAttributes=t.argMax=t.argMin=void 0;const r=n(387),a=n(1163),i=n(6031),o=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},s=(e,t,n,o)=>{const s=1===e.length?n:((e,t)=>(0,r.createAttributeWithCacheKey)({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}))(0,n),u=s.cacheKey+e.map((e=>e.dims.toString())).join("_"),l={name:t,inputTypes:[a.GpuDataType.default],cacheHint:u};return Object.assign(Object.assign({},l),{get:()=>(0,i.createReduceProgramInfo)(l,[e[0]],o,[s.axis],7,s.keepDims)})};t.argMin=(e,t)=>{o(e.inputs),e.compute(s(e.inputs,"ArgMin",t,((e,n,r)=>{const a=[];for(let t=0;t<e.shape.length;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};\\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\\n         value = ${e.getByOffset("inputOffset")};\\n         bestIndex = i32(lastIndex);\\n       }`,"",n.setByOffset("global_idx","bestIndex")]})),{inputs:[0]})},t.argMax=(e,t)=>{o(e.inputs),e.compute(s(e.inputs,"argMax",t,((e,n,r)=>{const a=[];for(let t=0;t<e.shape.length;t++)(r.indexOf(t)>=0||0===r.length)&&a.push(`inputIndices[${t}] = 0;`);return[`${a.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};\\nvar bestIndex : i32 = 0;`,`if (${e.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\\n         value = ${e.getByOffset("inputOffset")};\\n         bestIndex = i32(lastIndex);\\n       }`,"",n.setByOffset("global_idx","bestIndex")]})),{inputs:[0]})},t.parseArgMinMaxAttributes=e=>(0,r.createAttributeWithCacheKey)(e)},504:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sub=t.pow=t.mul=t.div=t.add=void 0;const r=n(6952),a=n(1163),i=n(2075),o=(e,t,n,o,s)=>{const u={name:t,inputTypes:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},u),{get:()=>((e,t,n,o,s,u=t.dataType)=>{var l,c;const d=!r.ShapeUtil.areEqual(t.dims,n.dims);let p=t.dims,f=r.ShapeUtil.size(t.dims),h=!1;if(d){const e=r.BroadcastUtil.calcShape(t.dims,n.dims,!1);if(!e)throw new Error("Can\'t perform binary op on the given tensors");p=e,f=r.ShapeUtil.size(p);let a=1;for(let e=0;e<p.length;e++){const r=null!==(l=t.dims[t.dims.length-e])&&void 0!==l?l:1;if(r!==(null!==(c=n.dims[n.dims.length-e])&&void 0!==c?c:1))break;a*=r}a%4==0&&(h=!0)}else h=!0;return Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,a,o,s,u,l,c,d,p)=>{const f=r.ShapeUtil.size(a),h=Math.ceil(f/4);let g,m;"string"==typeof u?g=m=(e,t)=>`${u}((${e}),(${t}))`:"function"==typeof u?g=m=u:(g=u.scalar,m=u.vector);let y="";const b=(0,i.outputVariable)("outputData",d,a,4),v=(0,i.inputVariable)("aData",l,t,4),w=(0,i.inputVariable)("bData",c,n,4);if(s){const e=e=>{const t=r.ShapeUtil.computeStrides(e),n=[];for(let r=e.length-1;r>=0;r--){const i=0===a.length?"0u":1===a.length?"outputIndices":`outputIndices[${r+a.length-e.length}]`;n.push(`${t[r]}u * (${i} % ${e[r]}u)`)}return n.length>0?n.join("+"):"0u"};y=`\\n  fn calcOffsetA(outputIndices: ${b.type.indices}) -> u32 {\\n    return ${e(t)};\\n  }\\n\\n  fn calcOffsetB(outputIndices: ${b.type.indices}) -> u32 {\\n    return ${e(n)};\\n  }\\n  `}let $;if(o)$=s?`\\n      let outputIndices = ${b.offsetToIndices("global_idx * 4u")};\\n      let offsetA = calcOffsetA(outputIndices);\\n      let offsetB = calcOffsetB(outputIndices);\\n      ${b.setByOffset("global_idx",m(v.getByOffset("offsetA / 4u"),w.getByOffset("offsetB / 4u")))}`:b.setByOffset("global_idx",m(v.getByOffset("global_idx"),w.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const e=e=>{const t=`aData[indexA${e}][componentA${e}]`,n=`bData[indexB${e}][componentB${e}]`;return`\\n      let outputIndices${e} = ${b.offsetToIndices(`global_idx * 4u + ${e}u`)};\\n      let offsetA${e} = calcOffsetA(outputIndices${e});\\n      let offsetB${e} = calcOffsetB(outputIndices${e});\\n      let indexA${e} = offsetA${e} / 4u;\\n      let indexB${e} = offsetB${e} / 4u;\\n      let componentA${e} = offsetA${e} % 4u;\\n      let componentB${e} = offsetB${e} % 4u;\\n      outputData[global_idx][${e}] = ${g(t,n)};`};$=`\\n      ${e(0)}\\n      ${e(1)}\\n      ${e(2)}\\n      ${e(3)}`}return`\\n  ${e.declareVariables(v,w,b)}\\n\\n  ${null!=p?p:""}\\n  ${y}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(h)}\\n    ${$}\\n  }`})(e,t.dims,n.dims,p,h,d,o,t.dataType,n.dataType,u,s),outputs:[{dims:p,dataType:u,gpuDataType:a.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(f/64/(h?4:1))})})})(u,e[0],e[1],n,o)})};t.add=e=>{e.compute(o(e.inputs,"Add",((e,t)=>`${e}+${t}`)))},t.div=e=>{e.compute(o(e.inputs,"Div",((e,t)=>`${e}/${t}`)))},t.mul=e=>{e.compute(o(e.inputs,"Mul",((e,t)=>`${e}*${t}`)))},t.pow=e=>{const t=(0,i.inputVariable)("input",e.inputs[0].dataType,e.inputs[0].dims).type.value,n="i32"===t?"round":"";e.compute(o(e.inputs,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\\n      if (b == ${t}(0.0)) {\\n        return ${t}(1.0);\\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\\n        return ${t}(pow(f32(a), f32(b))); // NaN\\n      }\\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${n}(pow(f32(abs(a)), f32(b))));\\n    }\\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\\n      // TODO: implement vectorized pow\\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\\n    }\\n      `))},t.sub=e=>{e.compute(o(e.inputs,"Sub",((e,t)=>`${e}-${t}`)))}},2075:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createShaderHelper=t.outputVariable=t.inputVariable=t.tensorTypeToWsglStorageType=t.WORKGROUP_SIZE=void 0;const r=n(6952);t.WORKGROUP_SIZE=64;const a=(e,t)=>{switch(e){case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}};t.tensorTypeToWsglStorageType=(e,t=1)=>{const n=a(e,t);return"string"==typeof n?n:n[0]};const i=(e,t,n,i,o)=>{const s=n.length,u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,l=a(t,o),c="string"==typeof l?l:l[1],d="string"==typeof l?l:l[0],p={indices:u,value:c,storage:d,tensor:t},f=e=>"string"==typeof e?e:`${e}u`,h={offsetToIndices:!1,indicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},g=r.ShapeUtil.computeStrides(n);let m="";for(let e=0;e<s-1;e++)m+=`\\n    let dim${e} = current / ${g[e]}u;\\n    let rest${e} = current % ${g[e]}u;\\n    indices[${e}] = dim${e};\\n    current = rest${e};\\n    `;m+=`indices[${s-1}] = current;`;const y=s<2?"":`\\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\\n    var indices: ${p.indices};\\n    var current = offset;\\n    ${m}\\n    return indices;\\n  }`,b=[];if(s>=2)for(let e=s-1;e>=0;e--)b.push(`${g[e]}u * (indices[${e}])`);const v=s<2?"":`\\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\\n    return ${b.join("+")};\\n  }`,w=(...e)=>0===s?"0u":`${p.indices}(${e.map(f).join(",")})`,$=(t,n)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),x=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),S=s<2?"":`\\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${c} {\\n    return ${e}[i2o_${e}(indices)];\\n  }`,_=s<2?"":(()=>{const t=n.map(((e,t)=>`d${t}: u32`)).join(", "),r=n.map(((e,t)=>`d${t}`)).join(", ");return`\\n  fn get_${e}(${t}) -> ${c} {\\n    return get_${e}ByIndices(${w(r)});\\n  }`})(),A=s<2?"":`\\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${c}) {\\n    ${$(`i2o_${e}(indices)`,"value")}\\n  }`,C=s<2?"":(()=>{const t=n.map(((e,t)=>`d${t}: u32`)).join(", "),r=n.map(((e,t)=>`d${t}`)).join(", ");return`\\n  fn set_${e}(${t}, value: ${c}) {\\n    set_${e}ByIndices(${w(r)}, value);\\n  }`})();return{impl:()=>{const e=[];return h.offsetToIndices&&e.push(y),h.indicesToOffset&&e.push(v),h.set&&e.push(C),h.setByIndices&&e.push(A),h.get&&e.push(_),h.getByIndices&&e.push(S),e.join("\\n")},type:p,offsetToIndices:t=>(h.offsetToIndices=!0,s<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(h.indicesToOffset=!0,s<2?t:`i2o_${e}(${t})`),indices:w,indicesGet:(e,t)=>s<2?`${e}`:`${e}[${t}]`,indicesSet:(e,t,n)=>s<2?`${e}=${n};`:`${e}[${t}]=${n};`,set:(...t)=>{if(t.length!==s+1)throw new Error(`indices length must be ${s}`);const n=t[s];if("string"!=typeof n)throw new Error("value must be string");const r=t.slice(0,s).map(f).join(",");return 0===s?$("0u",n):1===s?$(r[0],n):(h.set=!0,h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:$,setByIndices:(t,n)=>s<2?$(t,n):(h.setByIndices=!0,h.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==s)throw new Error(`indices length must be ${s}`);const n=t.map(f).join(",");return 0===s?x("0u"):1===s?x(n[0]):(h.get=!0,h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:x,getByIndices:t=>s<2?x(t):(h.getByIndices=!0,h.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:i?"input":"output",name:e,shape:n}};t.inputVariable=(e,t,n,r=1)=>i(e,t,n,!0,r),t.outputVariable=(e,t,n,r=1)=>i(e,t,n,!1,r);class o{constructor(e){this.normalizedDispatchGroup=e,this.indicesHelpers=[]}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=t.WORKGROUP_SIZE){const n="number"==typeof e?e:e[0],r="number"==typeof e?1:e[1],a="number"==typeof e?1:e[2],i=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${n}, ${r}, ${a})\\n  fn main(${i?"@builtin(global_invocation_id) global_id : vec3<u32>":"@builtin(local_invocation_index) local_index : u32,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>"}) {\\n    ${i?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${n*r*a}u + local_index;`}\\n  `}declareVariable(e,t){this.indicesHelpers.push(e);const n="input"===e.usage?"read":"read_write",r=e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){let t=0;return e.filter((e=>r.ShapeUtil.size(e.shape)>0)).map((e=>this.declareVariable(e,t++))).join("\\n")}get additionalImplementations(){return this.indicesHelpers.map((e=>e.impl())).join("\\n")}}t.createShaderHelper=e=>new o(e)},513:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.concat=(e,t)=>{(e=>{if(!e||e.length<1)throw new Error("too few inputs");const t=e[0].dataType,n=e[0].dims.length;for(const r of e){if(r.dataType!==t)throw new Error("input tensors should be one type");if(r.dims.length!==n)throw new Error("input tensors should have the same shape")}})(e.inputs),e.compute(((e,t)=>{const n=(a=e.length,s=t.cacheKey,{name:"Concat",inputTypes:Array(a).fill(i.GpuDataType.default),cacheHint:s});var a,s;return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const a=t[0].dims.slice();if(n>=a.length||n<-1*a.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");const s=n<0?a.length+n:n,u=a.slice(0);for(let e=1;e<t.length;e++){const n=t[e].dims.slice();for(let e=0;e<a.length;e++)if(e===s)u[s]+=n[e];else if(a[e]!==n[e])throw new Error("non concat dimensions must match")}const l=r.ShapeUtil.size(u),c=new Array(t.length),d=new Array(t.length),p=t[0].dataType;let f=0;for(let e=0;e<t.length;++e)f+=t[e].dims[s],c[e]=f,d[e]=(0,o.inputVariable)(`input${e}`,p,t[e].dims);const h=(0,o.outputVariable)("output",p,u),g=h.indicesGet("indices",s);return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>{return`\\n  ${e.declareVariables(...d,h)}\\n\\n  const sizeInConcatAxis = array<u32, ${c.length}>(${c.map((e=>`${e}u`)).join(",")});\\n  ${t=c.length,`\\n  fn calculateInputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\\n      if (index < sizeInConcatAxis[i]) {\\n        return i;\\n      }\\n    }\\n    return ${t}u;\\n  }`}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n\\n    var indices = ${h.offsetToIndices("global_idx")};\\n\\n    let inputIndex = calculateInputIndex(${g});\\n    if (inputIndex != 0u) {\\n      ${g} -= sizeInConcatAxis[inputIndex - 1u];\\n    }\\n\\n    ${((e,t)=>{const n=e.length,r=[];for(let a=0;a<n;++a){const i=t.setByOffset("global_idx",e[a].getByIndices("indices"));1===n?r.push(i):0===a?r.push(`if (inputIndex == ${a}u) { ${i} }`):a===n-1?r.push(`else { ${i} }`):r.push(`else if (inputIndex == ${a}) { ${i} }`)}return r.join("\\n")})(d,h)}\\n  }`;var t},dispatchGroup:()=>({x:Math.ceil(l/64)})})})(n,e,t.axis)})})(e.inputs,t))},t.parseConcatAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis})},9192:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createGroupedConvProgramInfoLoader=void 0;const r=n(6952),a=n(1163),i=n(2075),o=n(9770),s=n(3997);t.createGroupedConvProgramInfoLoader=(e,t,n)=>{const u=(l=e.length>2,c=t.cacheKey,{name:"GroupedConv",inputTypes:l?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:c});var l,c;return Object.assign(Object.assign({},u),{get:()=>((e,t,n,u)=>{const l=e.length>2,c=l?"value += b[output_channel];":"",d=e[0].dims,p=e[1].dims,f=p[0]/n.group,{activationFunction:h,applyActivation:g}=(0,s.getActicationSnippet)(n),m="NHWC"===n.format,y=(0,o.calculateOutputShape)(d,p,n.dilations,n.pads,n.strides,m),b=r.ShapeUtil.size(y),v=(0,i.outputVariable)("output",e[0].dataType,y),w=(0,i.inputVariable)("x",e[0].dataType,d),$=(0,i.inputVariable)("w",e[1].dataType,p),x=[w,$];return l&&x.push((0,i.inputVariable)("b",e[2].dataType,e[2].dims)),Object.assign(Object.assign({},t),{outputs:[{dims:u?u(y):y,dataType:e[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\\n  const strides: vec2<u32> = vec2(${n.strides[0]}u, ${n.strides[1]}u);\\n  const pads: vec2<u32> = vec2(${n.pads[0]}u, ${n.pads[1]}u);\\n\\n  ${e.declareVariables(...x,v)}\\n\\n  ${h}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}\\n\\n    let outputIndices = ${v.offsetToIndices("global_idx")};\\n    let batch: u32 = outputIndices[0];\\n    let output_channel: u32 = outputIndices[${m?3:1}];\\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${m?1:2}], outputIndices[${m?2:3}]) * strides - pads;\\n    let group_id: u32 = output_channel / ${f}u;\\n\\n    var value: ${v.type.value} = ${v.type.value}(0);\\n    for (var wInChannel: u32 = 0u; wInChannel < ${p[1]}u; wInChannel++) {\\n      let input_channel = group_id * ${p[1]}u + wInChannel;\\n      for (var wHeight: u32 = 0u; wHeight < ${p[2]}u; wHeight++) {\\n        let xHeight = xRCCorner.x + wHeight * ${n.dilations[0]}u;\\n\\n        if (xHeight < 0u || xHeight >= ${d[m?1:2]}u) {\\n          continue;\\n        }\\n\\n        for (var wWidth: u32 = 0u; wWidth < ${p[3]}u; wWidth++) {\\n          let xWidth = xRCCorner.y + wWidth * ${n.dilations[1]}u;\\n          if (xWidth < 0u || xWidth >= ${d[m?2:3]}u) {\\n            continue;\\n          }\\n\\n          let xVal = ${m?w.get("batch","xHeight","xWidth","input_channel"):w.get("batch","input_channel","xHeight","xWidth")};\\n          let wVal = ${$.get("output_channel","wInChannel","wHeight","wWidth")};\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${c}\\n    ${g}\\n    ${v.setByOffset("global_idx","value")}\\n  }`,dispatchGroup:()=>({x:Math.ceil(b/64)})})})(e,u,t,n)})}},7640:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.convTranspose=t.parseConvTransposeAttributes=void 0;const r=n(387),a=n(1163),i=n(6514),o=n(3997),s=(e,t,n,r,a,i)=>(e-1)*t+n+(r-1)*a+1-i,u=(e,t,n,r,a)=>{const i=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=i,n[a]=e-i):"SAME_LOWER"===t&&(n[r]=e-i,n[a]=i)},l=(e,t)=>{const n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),0)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}const r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);const a=e.pads.slice(),i=e.outputShape.slice(),o=e.outputPadding.slice(),l=t[0].dims;let c=e.dilations.slice();if(0===c.reduce(((e,t)=>e+t),0)){const e=t[0].dims.length-2;c=new Array(e).fill(1)}let d=e.strides.slice();if(0===d.reduce(((e,t)=>e+t),0)){const e=t[0].dims.length-2;d=new Array(e).fill(1)}((e,t,n,r,a,i,o,l,c,d)=>{const p=e.length-2,f=0===d.length;if(0===c.length)for(let e=0;e<p;++e)c.push(0);const h=e[0],g=t[l?3:1]*a;for(let a=0,h=e.length-p-(l?1:0);a<p;++a,++h){const l=e[h],g=f?l*o[a]:d[a],m=s(l,o[a],i[a],t[h],n[a],g);u(m,r,i,a,a+p),f&&d.push(o[a]*(l-1)+c[a]+(t[h]-1)*n[a]+1-i[a]-i[a+p])}d.splice(0,0,h),d.splice(l?3:1,0,g)})(l,n,c,e.autoPad,e.group,a,d,r,o,i);const p=Object.assign({},e);return Object.assign(p,{kernelShape:n,pads:a,outputPadding:o,outputShape:i,dilations:c,strides:d,cacheKey:e.cacheKey}),p};t.parseConvTransposeAttributes=e=>{const t=(0,o.parseInternalActivationAttributes)(e),n=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][void 0===e.autoPad?0:e.autoPad],i=e.dilations,s=e.group,u=e.kernelShape,l=e.pads,c=e.strides,d=e.wIsConst(),p=e.outputPadding,f=e.outputShape;return(0,r.createAttributeWithCacheKey)(Object.assign({autoPad:a,format:n,dilations:i,group:s,kernelShape:u,outputPadding:p,outputShape:f,pads:l,strides:c,wIsConst:d},t))};const c=(e,t,n)=>{const r=(o=3===e.length,s=t.cacheKey,{name:"ConvTranspose2D",inputTypes:o?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s});var o,s;return Object.assign(Object.assign({},r),{get:()=>(0,i.createConvTranspose2DProgramInfo)(e,r,t,n)})};t.convTranspose=(e,t)=>{((e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");const r=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===e.length&&1!==e[2].dataType)throw new Error("ConvTranspose input(bias) should be float tensor")})(e.inputs,t),3===e.inputs[0].dims.length?((e,t)=>{const n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===r.length&&r.push(e.inputs[2]);let a=t.kernelShape;0!==a.length&&0!==a[0]||(a=[e.inputs[1].dims[2]]);let i=t.dilations;0!==i.length&&0!==i[0]||(i=[1]);let o=t.strides;0!==o.length&&0!==o[0]||(o=[1]);let s=t.pads;0===s.length&&(s=[0,0]),s=[0,s[0],0,s[1]],o=[1].concat(o),i=[1].concat(i),a=[1].concat(a);const u=l(Object.assign(Object.assign({},t),{pads:s,strides:o,dilations:i,kernelShape:a}),r);e.compute(c(r,u,(e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])))})(e,t):((e,t,n)=>{const r=l(n,t);e.compute(c(t,r))})(e,e.inputs,t)}},9770:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.conv=t.parseConvAttributes=t.calculateOutputShape=void 0;const r=n(6952),a=n(387),i=n(9192),o=n(3822),s=n(3997),u=n(2625);t.calculateOutputShape=(e,t,n,r,a,i)=>{const o=e[0],s=e.slice(i?1:2,i?3:4),u=s.length,l=t[0],c=t.slice(2).map(((e,t)=>e+(e-1)*(n[t]-1))),d=s.map(((e,t)=>e+r[t]+r[t+u])).map(((e,t)=>Math.floor((e-c[t]+a[t])/a[t])));return d.splice(0,0,o),d.splice(i?3:1,0,l),d};const l=(0,a.createAttributeWithCacheKey)({perm:[2,3,1,0]}),c=(e,t)=>{const n=e.kernelShape.slice();for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);const a=e.pads.slice();r.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,a,"NHWC"===e.format,e.autoPad);const i=Object.assign({},e);return Object.assign(i,{kernelShape:n,pads:a,cacheKey:e.cacheKey}),i};t.parseConvAttributes=e=>{const t=(0,s.parseInternalActivationAttributes)(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],i=e.dilations,o=e.group,u=e.kernel_shape,l=e.pads,c=e.strides,d=e.w_is_const();return(0,a.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:n,dilations:i,group:o,kernelShape:u,pads:l,strides:c,wIsConst:d},t))},t.conv=(e,n)=>{((e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&1!==e[2].dataType)throw new Error("Conv input(bias) should be float tensor")})(e.inputs,n),3===e.inputs[0].dims.length?((e,t)=>{const n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);const a=[0,t.pads[0],0,t.pads[1]],o=[1].concat(t.strides),s=[1].concat(t.dilations),u=[1].concat(t.kernelShape),l=c(Object.assign(Object.assign({},t),{pads:a,strides:o,dilations:s,kernelShape:u}),r);e.compute((0,i.createGroupedConvProgramInfoLoader)(r,l,(e=>n?[e[0],e[2],e[3]]:[])))})(e,n):((e,n,r)=>{var a;const s=c(r,n),d=3===n.length,p="NHWC"===r.format,f=n[0].dims[p?1:2],h=n[0].dims[p?2:3],g=n[0].dims[p?3:1],m=n[1].dims[2],y=n[1].dims[3],b=(0,t.calculateOutputShape)(n[0].dims,n[1].dims,r.dilations,s.pads,r.strides,p),v=b[p?1:2],w=b[p?2:3],$=b[p?3:1];if(p&&m===f&&y===h&&"VALID"===r.autoPad||1===m&&1===y&&1===r.dilations[0]&&1===r.dilations[1]&&1===r.strides[0]&&1===r.strides[1]&&("SAME_UPPER"===r.autoPad||"SAME_LOWER"===r.autoPad||"VALID"===r.autoPad))return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));if(!p||1!==r.group)return void e.compute((0,i.createGroupedConvProgramInfoLoader)(n,s));const x=p?v*w:$,S=p?$:v*w,_=m*y*g,A=null!==(a=e.kernelCustomData.wT)&&void 0!==a?a:e.compute(Object.assign(Object.assign({},u.transposeProgramMetadata),{cacheHint:l.cacheKey,get:()=>(0,u.createTransposeProgramInfo)(n[1],l.perm)}),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);const C=[n[0],A];d&&(p||1!==n[2].dims.length?C.push(n[2]):C.push(n[2].reshape([n[2].dims[0],1,1]))),e.compute((0,o.createConv2DMatMulProgramInfoLoader)(C,s,b,x,S,_,d,!0),{inputs:C})})(e,e.inputs,n)}},3822:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createConv2DMatMulProgramInfoLoader=void 0;const r=n(1163),a=n(9456);t.createConv2DMatMulProgramInfoLoader=(e,t,n,i,o,s,u,l)=>{const c=((e,t)=>({name:"Conv2DMatMul",inputTypes:e?[r.GpuDataType.default,r.GpuDataType.default,r.GpuDataType.default]:[r.GpuDataType.default,r.GpuDataType.default],cacheHint:t}))(u,t.cacheKey);return Object.assign(Object.assign({},c),{get:()=>(0,a.createConv2DMatMulProgramInfo)(e,c,t,n,i,o,s,u,l)})}},8856:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.expand=t.expandProgramMetadata=void 0;const r=n(6952),a=n(1163),i=n(2075);t.expandProgramMetadata={name:"Expand",inputTypes:[a.GpuDataType.default]};const o=(e,t)=>{const n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let a=0;a<t.length;++a)r.push(1===t[a]?e[a+n]:t[a]);return r};t.expand=e=>{(e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");const t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number);let r=n.length<t.length?0:n.length-t.length,a=t.length<n.length?0:t.length-n.length;for(;r<n.length&&a<t.length;++r,++a)if(n[r]!==t[a]&&1!==n[r]&&1!==t[a])throw new Error("Expand requires shape to be broadcastable to input")})(e.inputs);const n=Array.from(e.inputs[1].getBigInt64Array(),Number).toString();e.compute(Object.assign(Object.assign({},t.expandProgramMetadata),{cacheHint:n,get:()=>((e,t)=>{const n=t[0].dims,s=Array.from(t[1].getBigInt64Array(),Number),u=((e,t)=>e.length>t.length?o(e,t):o(t,e))(n,s),l=r.ShapeUtil.size(u),c=t[0].dataType,d=(0,i.inputVariable)("input",c,n),p=(0,i.outputVariable)("output",c,u);return Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n  const inputShape = ${d.indices(...n)};\\n  ${e.declareVariables(d,p)}\\n  ${e.mainStart()}\\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n    let outputIndices = ${p.offsetToIndices("global_idx")};\\n    var inputIndices: ${d.type.indices};\\n    for (var i = 0; i < ${n.length}; i++) {\\n      if (${d.indicesGet("inputShape","i")} == 1) {\\n        ${d.indicesSet("inputIndices","i",0)}\\n      } else {\\n        ${d.indicesSet("inputIndices","i",p.indicesGet("outputIndices","i + "+(u.length-n.length)))}\\n      }\\n    }\\n    ${p.setByOffset("global_idx",d.getByIndices("inputIndices"))}\\n  }`,outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:a.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(l/64)})})})(t.expandProgramMetadata,e.inputs)}),{inputs:[0]})}},3997:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActicationSnippet=void 0;const r=n(6952);t.getActicationSnippet=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},t.parseInternalActivationAttributes=e=>{const t=(null==e?void 0:e.activation)||"";if("Clip"===t){const[n,a]=(null==e?void 0:e.activation_params)||[r.MIN_CLIP,r.MAX_CLIP];return{activation:t,clipMax:a,clipMin:n,activationCacheKey:`${t}:${n},${a}`}}return{activation:t,activationCacheKey:t}}},8405:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.gather=t.parseGatherAttributes=void 0;const r=n(6952),a=n(387),i=n(1163);t.parseGatherAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis}),t.gather=(e,t)=>{(e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")})(e.inputs);const n={name:"Gather",inputTypes:[i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(((e,t,n)=>{const a=t[0].dims,o=t[1].dims,s=a.length,u=r.ShapeUtil.normalizeAxis(n.axis,s),l=a.slice(0);l.splice(u,1,...o);const c=t[0].dataType,d=r.ShapeUtil.sizeFromDimension(a,u+1),p=[7,13,11].includes(c)?2:1,f=7===t[1].dataType?2:1,h=p*d,g=r.ShapeUtil.sizeToDimension(a,u),m=r.ShapeUtil.size(o),y=r.ShapeUtil.sizeFromDimension(a,u)*p,b=m*d*p,v=a[u],w=r.ShapeUtil.size(a)*p,$=r.ShapeUtil.size(l)*p,x=g*m;return Object.assign(Object.assign({},e),{outputs:[{dims:l,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const N: u32 = ${m};\\n  const elementSize: u32 = ${p};\\n  const indicesElementSize: u32 = ${f};\\n\\n  @group(0) @binding(0) var<storage, read> input : array<u32>;\\n  @group(0) @binding(1) var<storage, read> inputIndices : array<i32>;\\n  @group(0) @binding(2) var<storage, read_write> output: array<u32>;\\n\\n  ${e.mainStart()}\\n    let batch: u32 = global_idx / N;\\n    let i: u32 = global_idx % N;\\n\\n    let srcOffsetBatch: u32 = batch * ${y};\\n    let dstOffsetBatch: u32 = batch * ${b};\\n    var idx = inputIndices[i * indicesElementSize];\\n    if (idx < 0) {\\n        idx = idx + ${v};\\n    }\\n\\n    let srcOffset = srcOffsetBatch + u32(idx) * ${h};\\n    let dstOffset = dstOffsetBatch + i * ${h};\\n    if (srcOffset >= ${w}) {\\n        return;\\n    }\\n    if (dstOffset >= ${$}) {\\n        return;\\n    }\\n    for (var j: u32 = 0; j < ${h}; j++) {\\n        output[dstOffset + j] = input[srcOffset + j];\\n    }\\n  }`,dispatchGroup:()=>({x:Math.ceil(x/64)})})})(n,e.inputs,t))}},4271:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributes=t.gemm=void 0;const r=n(6952),a=n(387),i=n(1163);t.gemm=(e,t)=>{(e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(1!==e[0].dataType||1!==e[1].dataType||3===e.length&&1!==e[2].dataType)throw new Error("Invalid input type.");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")})(e.inputs),e.compute(((e,t)=>{const n={name:"Gemm",inputTypes:3===e.length?[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default]:[i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const a=t[0].dims.slice(),o=t[1].dims.slice(),[s,u,l]=r.GemmUtil.getShapeOfGemmResult(a,n.transA,o,n.transB,3===t.length?t[2].dims:void 0),c=[s,u];if(!c)throw new Error("Can\'t use gemm on the given tensors");const d=r.ShapeUtil.size(c);let p="";n.transA&&n.transB?p="value += a[k * M + m] * b[n * K + k];":n.transA&&!n.transB?p="value += a[k * M + m] * b[k * N + n];":!n.transA&&n.transB?p="value += a[m * K + k] * b[n * K + k];":n.transA||n.transB||(p="value += a[m * K + k] * b[k * N + n];");const f="f32",h=1===n.alpha?"":"value *= alpha;",g=3===t.length?`value += beta * c[${((e,t,n)=>{if(0===n.length)return"0u";const r=1===n.length&&1!==e||2===n.length&&n[0]!==e,a=n[n.length-1]!==t;let i="0u";return r||(i+=`+ m * ${n[n.length-1]}u`),a||(i+="+n"),i})(s,u,t[2].dims)}];`:"",m=[`@group(0) @binding(0) var<storage, read> a : array<${f}>;`,`@group(0) @binding(1) var<storage, read> b : array<${f}>;`];return 3===t.length&&m.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`),Object.assign(Object.assign({},e),{outputs:[{dims:c,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const M: u32 = ${s}u;\\n  const N: u32 = ${u}u;\\n  const K: u32 = ${l}u;\\n  const alpha = ${f}(${n.alpha});\\n  const beta = ${f}(${n.beta});\\n\\n  ${m.join("\\n")}\\n  @group(0) @binding(${t.length}) var<storage, read_write> output : array<${f}>;\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(d)}\\n\\n    let m = global_id.x / N;\\n    let n = global_id.x % N;\\n\\n    var value = ${f}(0);\\n    for (var k: u32 = 0u; k<${l}u; k++) {\\n      ${p}\\n    }\\n\\n    ${h}\\n    ${g}\\n    output[global_id.x] = value;\\n\\n  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(n,e,t)})})(e.inputs,t))},t.parseGemmAttributes=e=>(0,a.createAttributeWithCacheKey)(e)},1798:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.instanceNorm=t.parseInstanceNormAttributes=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.parseInstanceNormAttributes=e=>(0,a.createAttributeWithCacheKey)({epsilon:e.epsilon,format:e.format}),t.instanceNorm=(e,t)=>{(e=>{if(!e||3!==e.length)throw new Error("instanceNorm requires 3 inputs.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs);const n={name:"InstanceNormalization",inputTypes:[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey};"NHWC"===t.format?e.compute(((e,t,n)=>{const a=t[0].dims,s=a,u=r.ShapeUtil.size(s),l=a[0],c=a[a.length-1],d=r.ShapeUtil.sizeFromDimension(a,1)/c,p=(0,o.tensorTypeToWsglStorageType)(t[0].dataType),f=c*l;return Object.assign(Object.assign({},e),{outputs:[{dims:s,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const N: u32 = ${l};\\n  const H: u32 = ${d};\\n  const C: u32 = ${c};\\n  const normSizeTyped: ${p} = ${d};\\n  const imageSize: u32 = ${d*c};\\n  const epsilon: f32 = ${n.epsilon};\\n\\n  @group(0) @binding(0) var<storage, read> x : array<${p}>;\\n  @group(0) @binding(1) var<storage, read> scale : array<${p}>;\\n  @group(0) @binding(2) var<storage, read> bias : array<${p}>;\\n  @group(0) @binding(3) var<storage, read_write> output : array<${p}>;\\n\\n  ${e.mainStart()}\\n    let currentImageNumber = global_idx / C;\\n    let currentChannelNumber = global_idx % C;\\n    \\n    // offset is channel num * N\\n    let offset = currentImageNumber * imageSize;\\n    if (offset >= ${u}) { return; }\\n    var mean: ${p} = 0;\\n\\n    for (var i: u32 = 0u; i < H; i++) {\\n        mean = mean + x[offset + i * C + currentChannelNumber];\\n    }\\n    mean = mean / normSizeTyped;\\n\\n    var squaredNorm: ${p} = 0;\\n    for (var i: u32 = 0u; i < H; i++) {\\n        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;\\n        squaredNorm = squaredNorm + deviation * deviation;\\n    }\\n    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);\\n    let channelScale = invStdDev * scale[currentChannelNumber];\\n    let channelShift = bias[currentChannelNumber] - mean * channelScale;\\n    for (var i: u32 = 0u; i < H; i++) {\\n        let currentOffset = offset + i * C + currentChannelNumber;\\n        output[currentOffset] = x[currentOffset] * channelScale + channelShift;\\n    }\\n  }`,dispatchGroup:()=>({x:Math.ceil(f/64)})})})(n,e.inputs,t)):e.compute(((e,t,n)=>{const a=t[0].dims,s=t[1],u=t[2],l=a,c=r.ShapeUtil.size(l),d=r.ShapeUtil.sizeToDimension(a,2),p=r.ShapeUtil.sizeFromDimension(a,2),f=a[1],h=r.ShapeUtil.size(s.dims),g=u?r.ShapeUtil.size(u.dims):0;if(h!==p||u&&g!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.\\n             Size of scale and bias (if provided) must match this. \\n             Got scale size of ${h} and bias size of ${g}`);const m=(0,o.tensorTypeToWsglStorageType)(t[0].dataType);return Object.assign(Object.assign({},e),{outputs:[{dims:l,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  const C: u32 = ${f};\\n  const normSize: u32 = ${p};\\n  const normSizeTyped: ${m} = ${p};\\n  const epsilon: f32 = ${n.epsilon};\\n\\n  @group(0) @binding(0) var<storage, read> x : array<${m}>;\\n  @group(0) @binding(1) var<storage, read> scale : array<${m}>;\\n  @group(0) @binding(2) var<storage, read> bias : array<${m}>;\\n  @group(0) @binding(3) var<storage, read_write> output : array<${m}>;\\n\\n  ${e.mainStart()}\\n    let offset = global_idx * normSize;\\n    if (offset + normSize >= ${c}) { return; }\\n    var mean: ${m} = 0;\\n\\n    for (var h: u32 = 0u; h < normSize; h++) {\\n        mean = mean + x[h + offset];\\n    }\\n    mean = mean / normSizeTyped;\\n\\n    var squaredNorm: ${m} = 0;\\n    for (var h: u32 = 0u; h < normSize; h++) {\\n        let deviation: f32 = x[h + offset] - mean;\\n        squaredNorm = squaredNorm + deviation * deviation;\\n    }\\n    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);\\n    let channelScale = invStdDev * scale[global_idx % C];\\n    let channelShift = bias[global_idx % C] - mean * channelScale;\\n    for (var j: u32 = 0; j < normSize; j++) {\\n        output[j + offset] = x[j + offset] * channelScale + channelShift;\\n    }\\n  }`,dispatchGroup:()=>({x:Math.ceil(d/64)})})})(n,e.inputs,t))}},6145:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.layerNorm=t.parseLayerNormAttributes=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.parseLayerNormAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis,epsilon:e.epsilon}),t.layerNorm=(e,t)=>{(e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs);const n={name:"LayerNormalization",inputTypes:2===e.inputs.length?[i.GpuDataType.default,i.GpuDataType.default]:[i.GpuDataType.default,i.GpuDataType.default,i.GpuDataType.default],cacheHint:t.cacheKey+e.outputCount.toString(10)+e.inputs.length.toString(10)};e.compute(((e,t,n,a)=>{const s=t[0].dims,u=t[1],l=t[2],c=s,d=r.ShapeUtil.size(c),p=r.ShapeUtil.normalizeAxis(n.axis,s.length),f=r.ShapeUtil.sizeToDimension(s,p),h=r.ShapeUtil.sizeFromDimension(s,p),g=r.ShapeUtil.size(u.dims),m=l?r.ShapeUtil.size(l.dims):0;if(g!==h||l&&m!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.\\n       Size of scale and bias (if provided) must match this.\\n       Got scale size of ${g} and bias size of ${m}`);const y=[];for(let e=0;e<s.length;++e)e<p?y.push(s[e]):y.push(1);const b=(0,o.tensorTypeToWsglStorageType)(t[0].dataType),v=a>1,w=a>2;let $=0;const x=[{dims:c,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}];return v&&x.push({dims:y,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),w&&x.push({dims:y,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),Object.assign(Object.assign({},e),{outputs:x,getShaderSource:e=>`\\n  const normSize: u32 = ${h};\\n  const normSizeTyped: ${b} = ${h};\\n  const epsilon: f32 = ${n.epsilon};\\n\\n  @group(0) @binding(${$++}) var<storage, read> x : array<${b}>;\\n  @group(0) @binding(${$++}) var<storage, read> scale : array<${b}>;\\n  ${l?`@group(0) @binding(${$++}) var<storage, read> bias : array<${b}>;`:""}\\n  @group(0) @binding(${$++}) var<storage, read_write> output : array<${b}>;\\n  ${v?`@group(0) @binding(${$++}) var<storage, read_write> meanDataOutput : array<${b}>`:""};\\n  ${w?`@group(0) @binding(${$++}) var<storage, read_write> invStdOutput : array<${b}>`:""};\\n\\n  ${e.mainStart()}\\n    let offset = global_idx * normSize;\\n    if (offset >= ${d}) { return; }\\n    var mean: ${b} = 0;\\n    var meanSquare: ${b} = 0;\\n\\n    for (var h: u32 = 0u; h < normSize; h++) {\\n      mean = mean + x[h + offset];\\n      meanSquare = meanSquare + x[h + offset] * x[h + offset];\\n    }\\n    mean = mean / normSizeTyped;\\n    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);\\n\\n    for (var j: u32 = 0; j < normSize; j++) {\\n      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${l?"+ bias[j]":""};\\n    }\\n\\n    ${v?"meanDataOutput[global_idx] = mean":""};\\n    ${w?"invStdOutput[global_idx] = 1 / meanSquare":""};\\n  }`,dispatchGroup:()=>({x:Math.ceil(f/64)})})})(n,e.inputs,t,e.outputCount))}},1522:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.matMul=t.createMatmulProgramInfoLoader=void 0;const r=n(6952),a=n(1163),i=n(3997);t.createMatmulProgramInfoLoader=(e,t)=>{const n=(o=e.length>2,s=t.activationCacheKey,{name:"MatMul",inputTypes:o?[a.GpuDataType.default,a.GpuDataType.default,a.GpuDataType.default]:[a.GpuDataType.default,a.GpuDataType.default],cacheHint:s});var o,s;return Object.assign(Object.assign({},n),{get:()=>((e,t,n)=>{const o=t[0].dims,s=t[1].dims,u=r.BroadcastUtil.calcShape(o,s,!0);if(!u)throw new Error("Can\'t use matmul on the given tensors");const l=r.ShapeUtil.size(u),c="f32",{activationFunction:d,applyActivation:p}=(0,i.getActicationSnippet)(n),f=u[u.length-2],h=o[o.length-1],g=u[u.length-1];return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\\n  const M: u32 = ${f}u;\\n  const N: u32 = ${g}u;\\n  const K: u32 = ${h}u;\\n\\n  @group(0) @binding(0) var<storage, read> a : array<${c}>;\\n  @group(0) @binding(1) var<storage, read> b : array<${c}>;\\n  @group(0) @binding(2) var<storage, read_write> output : array<${c}>;\\n\\n  ${d}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n\\n    let stack = global_idx / (M * N);\\n    let mn = global_idx % (M * N);\\n    let n = global_idx % N;\\n    let m = mn / N;\\n\\n    let offsetA = stack * (M * K);\\n    let offsetB = stack * (K * N);\\n\\n    var value = ${c}(0);\\n    for (var k: u32 = 0u; k<${h}u; k++) {\\n      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];\\n    }\\n    ${p}\\n    output[global_idx] = value;\\n  }`,dispatchGroup:()=>({x:Math.ceil(l/64)})})})(n,e,t)})},t.matMul=e=>{(e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type")})(e.inputs),e.compute((0,t.createMatmulProgramInfoLoader)(e.inputs,{activation:"",activationCacheKey:""}))}},5262:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseGlobalMaxPoolAttributes=t.parseMaxPoolAttributes=t.maxPool=t.globalAveragePool=t.parseGlobalAveragePoolAttributes=t.averagePool=t.parseAveragePoolAttributes=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if(4!==e[0].dims.length)throw new Error("Pool ops supports 2-D inputs only for now.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=(e,t,n)=>{const a="NHWC"===t.format,i=a?[e.dims[0],e.dims[3],e.dims[1],e.dims[2]]:e.dims.slice(),o=Object.hasOwnProperty.call(t,"dilations"),s=t.kernelShape.slice(),u=t.strides.slice(),l=o?t.dilations.slice():[],c=t.pads.slice();r.PoolConvUtil.adjustPoolAttributes(n,i,s,u,l,c);const d=r.PoolConvUtil.computePoolOutputShape(n,i,u,l,s,c,t.autoPad),p=Object.assign({},t);return o?Object.assign(p,{kernelShape:s,strides:u,pads:c,dilations:l,cacheKey:t.cacheKey}):Object.assign(p,{kernelShape:s,strides:u,pads:c,cacheKey:t.cacheKey}),[p,a?[d[0],d[2],d[3],d[1]]:d]},l=(e,t,n,a,i,s,u)=>{const l="NHWC"===a.format,c=t.shape,d=t.type.value,p=c.length,f=r.ShapeUtil.size(n),h=(0,o.outputVariable)("output",t.type.tensor,n);if(a.kernelShape.length<=2){const n=a.kernelShape[a.kernelShape.length-1],r=a.strides[a.strides.length-1],o=a.pads[a.pads.length/2-1],g=p-(l?2:1);let m="",y="",b="";if(m=o+a.pads[a.pads.length-1]!==0?`\\n              for (var i: u32 = 0u; i < ${n}u; i++) {\\n                xIndices[${g}] = indices[${g}] * ${r} - ${o} + i;\\n                if (xIndices[${g}] < 0 || xIndices[${g}] >= ${c[g]}) {\\n                  pad++;\\n                  continue;\\n                }\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`:`\\n              for (var i: u32 = 0u; i < ${n}u; i++) {\\n                xIndices[${g}] = indices[${g}] * ${r} - ${o} + i;\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`,2===a.kernelShape.length){const e=a.kernelShape[a.kernelShape.length-2],t=a.strides[a.strides.length-2],r=a.pads[a.pads.length/2-2],i=a.pads[a.pads.length-2],o=p-(l?3:2),s=c[o];y=r+i!==0?`\\n                for (var j: u32 = 0u; j < ${e}u; j++) {\\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\\n                  if (xIndices[${o}] < 0 || xIndices[${o}] >= ${s}) {\\n                    pad+= ${n};\\n                    continue;\\n                  }\\n              `:`\\n                for (var j: u32 = 0u; j < ${e}u; j++) {\\n                  xIndices[${o}] = indices[${o}] * ${t} - ${r} + j;\\n                `,b="\\n              }\\n            "}return`\\n            ${e.declareVariables(t,h)}\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\\n\\n              let indices = ${h.offsetToIndices("global_idx")};\\n              var xIndices = ${h.offsetToIndices("global_idx")};\\n\\n              var value: ${d} = ${d}(${u});\\n              var pad = 0;\\n              ${y}\\n              ${m}\\n              ${b}\\n              ${s}\\n\\n              output[global_idx] = value;\\n            }`}{if(l)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const n=r.ShapeUtil.size(a.kernelShape),o=r.ShapeUtil.computeStrides(a.kernelShape),d=o.length,g=a.pads.length;let m="";return m=a.pads.reduce(((e,t)=>e+t))?`\\n                if (xIndices[j] >= inputDims[j]) {\\n                  pad++;\\n                  isPad = true;\\n                  break;\\n                }\\n              }\\n              if (!isPad) {\\n                let x_val = x[${t.indicesToOffset("xIndices")}];\\n                ${i}\\n              }`:`\\n              }\\n              let x_val = x[${t.indicesToOffset("xIndices")}];\\n              ${i}\\n            `,`\\n            ${e.declareVariables(t,h)}\\n\\n            const pads = array<u32, ${g}>(${a.pads.map((e=>`${e}u`)).join(",")});\\n            const inputDims = array<u32, ${p}>(${c.map((e=>`${e}u`)).join(",")});\\n            const kernelStrides = array<u32, ${d}>(${o.map((e=>`${e}u`)).join(",")});\\n            const strides = array<u32, ${d}>(${a.strides.map((e=>`${e}u`)).join(",")});\\n\\n            ${e.mainStart()}\\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(f)}\\n\\n              let indices = ${h.offsetToIndices("global_idx")};\\n              let xIndices = ${h.offsetToIndices("global_idx")};\\n\\n              var offsets: array<u32, ${d}>;\\n\\n              var value = ${h.type.value}(${u});\\n              var pad = 0;\\n              var isPad = false;\\n\\n              for (var i: u32 = 0u; i < ${n}u; i++) {\\n                var offset = i;\\n                for (var j = 0u; j < ${d-1}u; j++) {\\n                  offsets[j] = offset / kernelStrides[j];\\n                  offset -= offsets[j] * kernelStrides[j];\\n                }\\n                offsets[${d-1}] = offset;\\n\\n                isPad = false;\\n                for (var j = ${p-d}u; j < ${p}u; j++) {\\n                  xIndices[j] = indices[j] * strides[j - ${p-d}u]\\n                    + offsets[j - ${p-d}u] - pads[j - 2u];\\n                  ${m}\\n              }\\n              ${s}\\n\\n              output[global_idx] = value;\\n            }`}},c=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),d=(e,t,n,a)=>{const[s,c]=u(e,a,n),d=r.ShapeUtil.size(s.kernelShape),p=(0,o.inputVariable)("x",e.dataType,e.dims);let f="";return s.countIncludePad?f+=`value /= f32(${d});`:f+=`value /= f32(${d} - pad);`,Object.assign(Object.assign({},t),{outputs:[{dims:c,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>l(e,p,c,s,"value += x_val;",f,"0.0"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(c)/64)})})};t.parseAveragePoolAttributes=e=>{const t=0!==e.count_include_pad,n=c(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,a.createAttributeWithCacheKey)(Object.assign({countIncludePad:t},n))},t.averagePool=(e,t)=>{s(e.inputs);const n={name:"AveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>d(e.inputs[0],n,!1,t)}))};const p={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};t.parseGlobalAveragePoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},p),{cacheKey:t})},t.globalAveragePool=(e,t)=>{s(e.inputs);const n={name:"GlobalAveragePool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>d(e.inputs[0],n,!0,t)}))};const f=(e,t,n,a)=>{const[s,c]=u(e,a,n),d=(0,o.inputVariable)("x",e.dataType,e.dims);return Object.assign(Object.assign({},t),{outputs:[{dims:c,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>l(e,d,c,s,"\\n      value = max(x_val, value);\\n    ","","-1e5"),dispatchGroup:()=>({x:Math.ceil(r.ShapeUtil.size(c)/64)})})};t.maxPool=(e,t)=>{s(e.inputs);const n={name:"MaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs[0],n,!1,t)}))},t.parseMaxPoolAttributes=e=>{const t=e.storage_order,n=e.dilations,r=c(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,a.createAttributeWithCacheKey)(Object.assign({storageOrder:t,dilations:n},r))},t.parseGlobalMaxPoolAttributes=e=>{const t=e.format;return Object.assign(Object.assign({format:t},p),{cacheKey:t})},t.globalMaxPool=(e,t)=>{s(e.inputs);const n={name:"GlobalMaxPool",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey};e.compute(Object.assign(Object.assign({},n),{get:()=>f(e.inputs[0],n,!0,t)}))}},6031:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseReduceAttributes=t.reduceSumSquare=t.reduceSum=t.reduceProd=t.reduceMin=t.reduceMean=t.reduceMax=t.reduceLogSumExp=t.reduceL2=t.reduceL1=t.reduceLogSum=t.createReduceProgramInfo=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},u=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""];t.createReduceProgramInfo=(e,t,n,a,s,u=!1,l=!1)=>{const c=[],d=t[0].dims,p=r.ShapeUtil.normalizeAxes(a,t[0].dims.length),f=!l&&0===p.length;d.forEach(((e,t)=>{f||p.indexOf(t)>=0?u&&c.push(1):c.push(e)}));const h=[],g=(0,o.inputVariable)("_A",t[0].dataType,d),m=(0,o.outputVariable)("output",s,c),y=n(g,m,p),b=`inputOffset = ${g.indicesToOffset("inputIndices")};`,v=`let ${b};`,w=`var ${b};`,$=""===y[1]?"":w;let x=(""===y[1]?v:b)+"\\n"+y[2];for(let e=0,n=0;e<t[0].dims.length;e++)f||p.indexOf(e)>=0?(u&&n++,x=`for(var j${e}: u32 = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\\n                ${y[2].includes("lastIndex")?`let lastIndex = j${e};`:""}\\n                ${g.indicesSet("inputIndices",e,`j${e}`)}\\n                ${x}\\n              }`):(h.push(`${g.indicesSet("inputIndices",e,m.indicesGet("outputIndices",n))};`),n++);const S=r.ShapeUtil.size(c);return Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n        ${e.declareVariables(g,m)}\\n\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(S)}\\n          var inputIndices: ${g.type.indices};\\n          let outputIndices = ${m.offsetToIndices("global_idx")};\\n\\n          ${h.join("\\n")}\\n          ${y[0]}       // init ops for reduce max/min\\n          ${$}\\n          ${y[1]}\\n          ${x}\\n          ${y[3]}\\n          ${4===y.length?m.setByOffset("global_idx","value"):y.slice(4).join("\\n")}\\n        }`,outputs:[{dims:c,dataType:s,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(S/64)})})};const l=(e,n,r,o)=>{const s=1===e.length?r:((e,t)=>{const n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),(0,a.createAttributeWithCacheKey)({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})})(e,r),l={name:n,inputTypes:[i.GpuDataType.default],cacheHint:s.cacheKey+"_"+e[0].dims.map((e=>e.toString())).join(",")};return Object.assign(Object.assign({},l),{get:()=>(0,t.createReduceProgramInfo)(l,[e[0]],s.noopWithEmptyAxes&&0===s.axes.length?u:o,s.axes,e[0].dataType,s.keepDims,s.noopWithEmptyAxes)})};t.reduceLogSum=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,"value = log(value);"])),{inputs:[0]})},t.reduceL1=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByOffset("inputOffset")});`,""])),{inputs:[0]})},t.reduceL2=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceL2",t,((e,t)=>[`var t = f32(0); var value = ${t.type.storage}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])),{inputs:[0]})},t.reduceLogSumExp=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByOffset("inputOffset")});`,"value = log(value);"])),{inputs:[0]})},t.reduceMax=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMax",t,((e,t,n)=>{const r=[];for(let t=0;t<e.shape.length;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("inputIndices",t,0));return[`${r.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = max(value, ${e.getByOffset("inputOffset")});`,""]})),{inputs:[0]})},t.reduceMean=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMean",t,((e,t,n)=>{let r=1;for(let t=0;t<e.shape.length;t++)(n.indexOf(t)>=0||0===n.length)&&(r*=e.shape[t]);return[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,`value = value / ${r}.;`]})),{inputs:[0]})},t.reduceMin=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceMin",t,((e,t,n)=>{const r=[];for(let t=0;t<e.shape.length;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`inputIndices[${t}] = 0;`);return[`${r.join("\\n")}`,`var value = ${e.getByOffset("inputOffset")};`,`value = min(value, ${e.getByOffset("inputOffset")});`,""]})),{inputs:[0]})},t.reduceProd=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByOffset("inputOffset")};`,""])),{inputs:[0]})},t.reduceSum=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByOffset("inputOffset")};`,""])),{inputs:[0]})},t.reduceSumSquare=(e,t)=>{s(e.inputs),e.compute(l(e.inputs,"ReduceSumSquare",t,((e,t)=>[`var t = f32(0); var value = ${t.type.storage}(0);`,"",`t = ${e.getByOffset("inputOffset")}; value += t * t;`,""])),{inputs:[0]})},t.parseReduceAttributes=e=>(0,a.createAttributeWithCacheKey)(e)},4566:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributes=t.resize=t.createResizeProgramInfoLoader=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.createResizeProgramInfoLoader=(e,t,n,a,s,u)=>{const l={name:"Resize",inputTypes:[i.GpuDataType.default],cacheHint:t.cacheKey+n.toString()+(a.length>0?"_scales_"+a.toString():"")+(s.length>0?"_sizes_"+s.toString():"")};return Object.assign(Object.assign({},l),{get:()=>((e,t,n,a,s,u,l)=>{const c=t.dims,d=((e,t,n)=>{const r=new Array(n).fill(0).concat(new Array(n).fill(1)),a=0===e.length?r:e.slice();return t.length>0?(t.forEach(((e,i)=>{r[e]=a[i],r[i+n]=a[t.length+i]})),r):a})(l,n.axes,c.length);let p=((e,t,n,r)=>{let a=[];if(n.length>0)if(r.length>0){if(e.forEach((e=>a.push(e))),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach(((e,t)=>a[e]=n[t]))}else n.forEach((e=>a.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");a=e.map(((e,n)=>Math.round(e*t[n])))}return a})(c,s,u,n.axes),f=s.slice();0===s.length&&(f=c.map(((e,t)=>0===e?1:p[t]/e)),"stretch"!==n.keepAspectRatioPolicy&&(p=((e,t,n,r)=>{const a=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map((e=>n[e])),Number.MAX_VALUE):Math.min(...n,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map((e=>n[e])),Number.MIN_VALUE):Math.max(...n,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();n.fill(1,0,n.length);const i=e.slice();return r.axes.length>0?(r.axes.forEach((e=>n[e]=a)),r.axes.forEach((t=>i[t]=Math.round(e[t]*n[t])))):(n.fill(a,0,n.length),i.forEach(((e,t)=>i[t]=Math.round(e*n[t])))),i})(c,0,f,n)));const h=(0,o.outputVariable)("output",t.dataType,p),g=(0,o.inputVariable)("input",t.dataType,c),m=r.ShapeUtil.size(p),y=c.length===p.length&&c.every(((e,t)=>e===p[t])),b="tf_crop_and_resize"===n.coordinateTransformMode;return Object.assign(Object.assign({},e),{getShaderSource:e=>{return`\\n      ${t=n.coordinateTransformMode,"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(t){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join("\\n");case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}"};\\n      ${(()=>{switch(n.mode){case"nearest":return`\\n              ${((e,t)=>`\\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\\n      for (var i:u32 = 0; i < ${t.length}; i++) {\\n        var inputIndex = ${1===t.length?"inputIndices":"inputIndices[i]"};\\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }`)(g,c)};\\n              ${((e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}")(n.nearestMode,a)};\\n              ${((e,t,n,r,a,i,o)=>`\\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\\n        const inputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\\n        const outputShape = array<u32, ${r.length}>(${r.map((e=>`${e}u`)).join(",")});\\n        const scales = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\\n        const roi = array<f32, ${i.length}>(${i.map((e=>`${e}f`)).join(",")});\\n        var inputIndices: ${e.type.indices};\\n        for (var i:u32 = 0; i < ${r.length}; i++) {\\n          var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\\n          var inputIndex: u32;\\n          if (scales[i] == 1.0) {\\n            inputIndex = outputIndex;\\n          } else {\\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${n.length}]);\\n            if (!${o} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\\n              if (original_idx < 0) {\\n                inputIndex = 0;\\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\\n                inputIndex = inputShape[i] - 1;\\n              } else {\\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\\n              }\\n            } else {\\n              inputIndex = u32(original_idx);\\n            }\\n          }\\n          ${e.indicesSet("inputIndices","i","inputIndex")}\\n        }\\n        return inputIndices;\\n    }`)(g,h,c,p,f,d,b)};\\n              `;case"linear":return`\\n              ${((e,t,n,r,a)=>`\\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${n.length}> {\\n      const inputShape = array<u32, ${t.length}>(${t.map((e=>`${e}u`)).join(",")});\\n      const outputShape = array<u32, ${n.length}>(${n.map((e=>`${e}u`)).join(",")});\\n      const scales = array<f32, ${r.length}>(${r.map((e=>`${e}f`)).join(",")});\\n      const roi = array<f32, ${a.length}>(${a.map((e=>`${e}f`)).join(",")});\\n      var originalIndices: array<f32, ${n.length}>;\\n      for (var i:u32 = 0; i < ${n.length}; i++) {\\n        var outputIndex = ${1===n.length?"outputIndices":"outputIndices[i]"};\\n        if (scales[i] == 1.0) {\\n          originalIndices[i] = f32(outputIndex);\\n        } else {\\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\\n        }\\n      }\\n      return originalIndices;\\n    }`)(h,c,p,f,d)};\\n              ${((e,t,n,r,a,i,o)=>{const[s,u,l,c]=2===n.length?[-1,0,1,-1]:1===a[1]?[0,2,3,1]:[0,1,2,3];return`\\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\\n      var inputIndices: ${e.type.indices};\\n      inputIndices[${u}] = max(0, min(row, ${n[u]} - 1));\\n      inputIndices[${l}] = max(0, min(col, ${n[l]} - 1));\\n      if (${n.length} > 2) {\\n        inputIndices[${c}] = channel;\\n        inputIndices[${s}] = batch;\\n      };\\n      return input[${e.indicesToOffset("inputIndices")}];\\n    }\\n\\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\\n      var row:f32 = originalIndices[${u}];\\n      var col:f32 = originalIndices[${l}];\\n      if (${i} && (row < 0 || row > (${n[u]} - 1) || col < 0 || col > ${n[l]} - 1)) {\\n        return ${o};\\n      }\\n      row = max(0, min(row, ${n[u]} - 1));\\n      col = max(0, min(col, ${n[l]} - 1));\\n      var row1: u32 = u32(row);\\n      var col1: u32 = u32(col);\\n      var row2: u32 = u32(row + 1);\\n      var col2: u32 = u32(col + 1);\\n      var channel: u32 = 0;\\n      var batch: u32 = 0;\\n      if (${n.length>2}) {\\n        channel = u32(originalIndices[${c}]);\\n        batch = u32(originalIndices[${s}]);\\n      }\\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\\n      var dx1: f32 = row - f32(row1);\\n      var dx2: f32 = f32(row2 ) - row;\\n      var dy1 = col - f32(col1);\\n      var dy2 = f32(col2) - col;\\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\\n    }`})(g,h,c,0,f,b,n.extrapolationValue)};\\n              `;case"cubic":return`\\n            ${((e,t,n,r,a,i,o,s,u,l)=>{const[c,d]=2===n.length?[0,1]:1===a[1]?[2,3]:[1,2],p=o=>{const d=o===c?"row":"col";return`\\n      fn ${d}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\\n        var outputIndex = ${1===r.length?"outputIndices":`outputIndices[${o}]`};\\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[o]},\\n        f32(${r[o]}), f32(${n[o]}), ${i[o]}, ${i[o]} + ${n.length});\\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\\n\\n        if (${s} && (originalIdx < 0 || originalIdx > (${n[o]} - 1))) {\\n          return ${u};\\n        }\\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\\n        for (var i: i32 = -1; i < 3; i++) {\\n          var ${d}: f32 = originalIdx + f32(i);\\n          if (${d} < 0 || ${d} >= ${n[o]}) {\\n            if (${l}) {\\n              coefs[i + 1] = 0.0;\\n              continue;\\n            } else if (${s}) {\\n              return ${u};\\n            } else {\\n              ${d} = max(0, min(${d}, ${n[o]} - 1));\\n            }\\n          }\\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\\n          inputIndicesCopy[${o}] = u32(${d});\\n          data[i + 1] = ${o===c?`input[${e.indicesToOffset("inputIndicesCopy")}];`:"\\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);"}\\n        }\\n        return cubicInterpolation1D(data, coefs);\\n      }`};return`\\n    ${p(c)};\\n    ${p(d)};\\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\\n    var absS = abs(s);\\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\\n    var oneMinusAbsS: f32 = 1.0 - absS;\\n    var twoMinusAbsS: f32 = 2.0 - absS;\\n    var onePlusAbsS: f32 = 1.0 + absS;\\n    coeffs[0] = ((${o} * onePlusAbsS - 5 * ${o}) * onePlusAbsS + 8 * ${o}) * onePlusAbsS - 4 * ${o};\\n    coeffs[1] = ((${o} + 2) * absS - (${o} + 3)) * absS * absS + 1;\\n    coeffs[2] = ((${o} + 2) * oneMinusAbsS - (${o} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\\n    coeffs[3] = ((${o} * twoMinusAbsS - 5 * ${o}) * twoMinusAbsS + 8 * ${o}) * twoMinusAbsS - 4 * ${o};\\n    return coeffs;\\n  }\\n\\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\\n  }\\n\\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\\n    var inputIndices: ${e.type.indices} = outputIndices;\\n    return colCubicInterpolation(inputIndices, outputIndices);\\n  }\\n    `})(g,h,c,p,f,d,n.cubicCoeffA,b,n.extrapolationValue,n.excludeOutside)};\\n            `;default:throw Error("Invalid resize mode")}})()};\\n      ${e.declareVariables(g,h)}\\n      ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(m)}\\n        if (${y}) {\\n          output[global_idx] = input[global_idx];\\n        } else {\\n          let outputIndices = ${h.offsetToIndices("global_idx")};\\n          var inputIndices: ${g.type.indices};\\n          ${(()=>{switch(n.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\\n                  if (checkInputIndices(inputIndices)) {\\n                    output[global_idx] = input[${g.indicesToOffset("inputIndices")}];\\n                  } else {\\n                    output[global_idx] = ${n.extrapolationValue};\\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${n.mode}`)}})()};\\n        }\\n      }`;var t},outputs:[{dims:p,dataType:t.dataType,gpuDataType:i.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(m/64)})})})(l,e,t,n,a,s,u)})},t.resize=(e,n)=>{const r=[],a=[],i=[],o=(e=>{const t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]})(e);((e,t,n,r,a,i)=>{const[o,s,u]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],l=e[0].dims.length;if(o>0&&e.length>o&&e[o].dims.length>0)e[o].getFloat32Array().forEach((e=>i.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(s>0&&e.length>s&&e[s].dims.length>0){if(e[s].getFloat32Array().forEach((e=>r.push(e))),0!==r.length&&r.length!==l&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");((e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")})(r,t),t.axes.length>0&&((e,t,n)=>{t.every((e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));const r=new Array(n).fill(1);return t.forEach(((t,n)=>r[t]=e[n])),r})(r,t.axes,l).forEach(((e,t)=>r[t]=e))}if(u>0&&e.length>u&&(e[u].getBigInt64Array().forEach((e=>a.push(Number(e)))),a.length!==l||n>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(r.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(a.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(void 0!==r&&void 0!==a&&r.length>0&&a.length>l)throw new Error("Resize requires only of scales or sizes to be specified")})(e.inputs,n,o,r,a,i),e.compute((0,t.createResizeProgramInfoLoader)(e.inputs[0],n,o,r,a,i),{inputs:[0]})},t.parseResizeAttributes=e=>{const t=e.antialias,n=e.axes,r=e.coordinateTransformMode,i=e.cubicCoeffA,o=0!==e.excludeOutside,s=e.extrapolationValue,u=e.keepAspectRatioPolicy,l=e.mode,c=""===e.nearestMode?"simple":e.nearestMode;return(0,a.createAttributeWithCacheKey)({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:i,excludeOutside:o,extrapolationValue:s,keepAspectRatioPolicy:u,mode:l,nearestMode:c})}},8906:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSkipLayerNormAttributes=t.skipLayerNorm=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.skipLayerNorm=(e,t)=>{(e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");if(1!==e[0].dataType||1!==e[1].dataType)throw new Error("inputs should be float type");const t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");const a=t.dims[t.dims.length-1],i=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){const t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){const t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}})(e.inputs);const n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(((e,t,n,a)=>{const s={name:"SkipLayerNormalization",inputTypes:new Array(e.length).fill(i.GpuDataType.default),cacheHint:t.cacheKey};return Object.assign(Object.assign({},s),{get:()=>((e,t,n,a,s)=>{const u=t[0].dims,l=u,c=r.ShapeUtil.size(u),d=u.slice(-1)[0],p=s?u.slice(0,-1).concat(1):[],f=t.length>3,h=t.length>4,g=(0,o.tensorTypeToWsglStorageType)(t[0].dataType),m=s&&a>1,y=s&&a>2,b=a>3;let v=0;const w=[{dims:l,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}];return a>1&&w.push({dims:p,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),a>2&&w.push({dims:p,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),a>3&&w.push({dims:u,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default}),Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n      const hiddenSize: u32 = ${d};\\n      const epsilon: f32 = ${n.epsilon};\\n\\n      @group(0) @binding(${v++}) var<storage, read> x : array<${g}>;\\n      @group(0) @binding(${v++}) var<storage, read> skip : array<${g}>;\\n      @group(0) @binding(${v++}) var<storage, read> gamma : array<${g}>;\\n      ${f?`@group(0) @binding(${v++}) var<storage, read> beta : array<${g}>;`:""}\\n      ${h?`@group(0) @binding(${v++}) var<storage, read> bias : array<${g}>;`:""}\\n      @group(0) @binding(${v++}) var<storage, read_write> output : array<${g}>;\\n      ${m?`@group(0) @binding(${v++}) var<storage, read_write> meanOutput : array<${g}>;`:""}\\n      ${y?`@group(0) @binding(${v++}) var<storage, read_write> invStdOutput : array<${g}>;`:""}\\n      ${b?`@group(0) @binding(${v++}) var<storage, read_write> inputSkipBiasSum : array<${g}>;`:""}\\n\\n      ${e.mainStart()}\\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(c/d)}\\n        let offset = global_idx * hiddenSize;\\n        var sum: f32 = 0.0;\\n        var squareSum: f32 = 0.0;\\n        for (var i: u32 = 0; i < hiddenSize; i++) {\\n          let skipValue = skip[offset + i];\\n          let biasValue = ${h?"bias[i]":"0.0"};\\n          let inputValue = x[offset + i];\\n          let value = inputValue + skipValue + biasValue;\\n          ${b?"inputSkipBiasSum[offset + i] = value;":""}\\n          output[offset + i] = value;\\n          sum += value;\\n          squareSum += value * value;\\n        }\\n        let mean: f32 = sum / f32(hiddenSize);\\n        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);\\n        ${m?"meanOutput[global_idx] = mean;":""}\\n        ${y?"invStdOutput[global_idx] = 1.0 / variance;":""}\\n        for (var i: u32 = 0; i < hiddenSize; i++) {\\n          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${f?"beta[i]":"0.0"};\\n        }\\n      }`,outputs:w,dispatchGroup:()=>({x:Math.ceil(c/d/64)})})})(s,e,t,n,a)})})(e.inputs,t,e.outputCount,!1),{outputs:n})},t.parseSkipLayerNormAttributes=e=>{const t=e.epsilon;return(0,a.createAttributeWithCacheKey)({epsilon:t})}},5101:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSliceAttributes=t.slice=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=(e,t)=>{const n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>n.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>n.push(Number(e))))}return n},u=(e,t,n,r,a)=>{let i=e;return e<0&&(i+=n[r[t]]),a[t]<0?Math.max(0,Math.min(i,n[r[t]]-1)):Math.max(0,Math.min(i,n[r[t]]))};t.slice=(e,t)=>{((e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)}))})(e.inputs,t);const n=((e,t)=>{const n=((e,t)=>{if(e.length>1){const t=s(e,1),n=s(e,2);let r=s(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),(0,a.createAttributeWithCacheKey)({starts:t,ends:n,axes:r})}return t})(e,t),l={name:"Slice",inputTypes:[i.GpuDataType.default],cacheHint:n.cacheKey+(e.length>4?"steps_"+e[4].dims.toString():"")};return Object.assign(Object.assign({},l),{get:()=>((e,t,n)=>{const a=t[0].dims,l=r.ShapeUtil.size(a),c=n.axes.length>0?r.ShapeUtil.normalizeAxes(n.axes,a.length):[...Array(a.length).keys()];let d=s(t,4);d.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===d.length&&(d=Array(c.length).fill(1));const p=n.starts.map(((e,t)=>u(e,t,a,c,d))),f=n.ends.map(((e,t)=>u(e,t,a,c,d)));if(c.length!==a.length)for(let e=0;e<a.length;++e)c.includes(e)||(p.splice(e,0,0),f.splice(e,0,a[e]),d.splice(e,0,1));const h=d.map((e=>Math.sign(e)));d.forEach(((e,t,n)=>{if(e<0){const r=(f[t]-p[t])/e,a=p[t],i=a+r*d[t];p[t]=i,f[t]=a,n[t]=-e}}));const g=a.slice(0);c.forEach(((e,t)=>{g[e]=Math.ceil((f[e]-p[e])/d[e])}));const m={dims:g,dataType:t[0].dataType,gpuDataType:i.GpuDataType.default},y=(0,o.outputVariable)("output",t[0].dataType,g),b=(0,o.inputVariable)("input",t[0].dataType,a),v=r.ShapeUtil.size(g);return Object.assign(Object.assign({},e),{getShaderSource:e=>`\\n      ${e.declareVariables(b,y)}\\n        const signs = array<i32, ${h.length}>(${h.map((e=>`${e}i`)).join(",")});\\n        const starts = array<u32, ${p.length}>(${p.map((e=>`${e}u`)).join(",")});\\n        const ends = array<u32, ${f.length}>(${f.map((e=>`${e}u`)).join(",")});\\n        const steps = array<u32, ${d.length}>(${d.map((e=>`${e}u`)).join(",")});\\n        const inputShape = array<u32, ${a.length}>(${a.map((e=>`${e}u`)).join(",")});\\n\\n        ${((e,t,n,r)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\\n          var inputIndices: ${e.type.indices};\\n          var carry = 0u;\\n          for (var i = ${n.length}; i >= 0; i--) {\\n            var outputIndex = ${1===r.length?"outputIndices":"outputIndices[i]"};\\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\\n            carry = inputIndex / inputShape[i];\\n            inputIndex = inputIndex % inputShape[i];\\n            if (signs[i] < 0) {\\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\\n            }\\n            ${1===n.length?"inputIndices":"inputIndices[i]"} = inputIndex;\\n          }\\n          return inputIndices;\\n      }`)(b,y,a,g)}\\n        ${e.mainStart()}\\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes(v)}\\n          let outputIndices = ${y.offsetToIndices("global_idx")};\\n          let inputIndices = calculateInputIndices(outputIndices);\\n          ${y.setByOffset("global_idx",b.getByIndices("inputIndices"))}\\n      }`,outputs:[m],dispatchGroup:()=>({x:Math.ceil(l/64)})})})(l,e,n)})})(e.inputs,t),l=n.get();if(!(r.ShapeUtil.size(l.outputs[0].dims)>0))throw new Error("slice: output size is 0");e.compute(n,{inputs:[0]})},t.parseSliceAttributes=e=>{const t=e.starts,n=e.ends,r=e.axes;return(0,a.createAttributeWithCacheKey)({starts:t,ends:n,axes:r})}},6198:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSoftmaxAttributes=t.softmax=t.softmaxProgramMetadata=void 0;const r=n(6952),a=n(387),i=n(1163);t.softmaxProgramMetadata={name:"Softmax",inputTypes:[i.GpuDataType.default]},t.softmax=(e,n)=>{(e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.");if(1!==e[0].dataType)throw new Error("Softmax input needs to be float.")})(e.inputs),e.compute(Object.assign(Object.assign({},t.softmaxProgramMetadata),{cacheHint:n.cacheKey,get:()=>((e,n)=>{const a="f32",o=e.dims,s=r.ShapeUtil.size(o);let u=n.axis;if(u<0&&(u=o.length+u),u<o.length-1)throw new Error("softmax only supports last axis for now.");const l=o[u],c=s/l;return Object.assign(Object.assign({},t.softmaxProgramMetadata),{outputs:[{dims:o,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n      var<workgroup> rowMaxShared : ${a};\\n      var<workgroup> rowSumShared : ${a};\\n      var<workgroup> threadShared : array<${a}, 64>;\\n\\n      @group(0) @binding(0) var<storage, read> x : array<${a}>;\\n      @group(0) @binding(1) var<storage, read_write> result : array<${a}>;\\n\\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${a} {\\n        let index = row * row_stride + col;\\n        return x[index];\\n      }\\n\\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${a}) {\\n        let index = row * row_stride + col;\\n        result[index] = value;\\n      }\\n\\n      @compute @workgroup_size(64, 1, 1)\\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\\n        let gindex = i32(global_id.x);\\n        let lindex = i32(local_id.x);\\n        const wg = 64;\\n        let row = gindex / wg;\\n        let cols = ${l};\\n        let row_stride : i32 = ${l};\\n\\n        // find the rows max\\n        var threadMax = -3.402823e+38f; // 6.2.4 in wgsl spec\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = getValue(row, col, row_stride);\\n          threadMax = max(threadMax, value);\\n        }\\n        if (lindex < cols) {\\n          threadShared[lindex] = threadMax;\\n        }\\n        workgroupBarrier();\\n\\n        var reduceSize = min(cols, wg);\\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\\n          reduceSize = currSize + (reduceSize & 1);\\n          if (lindex < currSize) {\\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowMaxShared = threadShared[0];\\n        }\\n        workgroupBarrier();\\n\\n        // find the rows sum\\n        var threadSum = 0.0;\\n        for (var col = lindex; col < cols; col += wg) {\\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\\n          threadSum += subExp;\\n        }\\n        threadShared[lindex] = threadSum;\\n        workgroupBarrier();\\n\\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\\n          if (lindex < currSize) {\\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowSumShared = threadShared[0];\\n        }\\n        workgroupBarrier();\\n\\n        // calculate final value for each element in the row\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\\n          setValue(row, col, row_stride, value);\\n        }\\n      }`,dispatchGroup:()=>({x:c})})})(e.inputs[0],n)}))},t.parseSoftmaxAttributes=e=>(0,a.createAttributeWithCacheKey)({axis:e.axis})},2067:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.split=(e,t)=>{(e=>{if(!e||e.length<1)throw new Error("too few inputs")})(e.inputs),e.compute(((e,t)=>{const n=1===e.length?t:((e,t)=>{const n=[];let r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>n.push(Number(e)))),r=n.length),(0,a.createAttributeWithCacheKey)({numOutputs:r,axis:t.axis,splitSizes:n})})(e,t),s={name:"Split",inputTypes:[i.GpuDataType.default],cacheHint:n.cacheKey};return Object.assign(Object.assign({},s),{get:()=>((e,t,n)=>{const a=t[0].dims,s=r.ShapeUtil.size(a),u=t[0].dataType,l=a.length,c=n.axis,d=c<0?a.length+c:c,p=new Array(n.numOutputs),f=(0,o.inputVariable)("input",u,a),h=new Array(n.numOutputs),g=[],m=[];let y=0;for(let e=0;e<n.numOutputs;e++){y+=n.splitSizes[e],h[e]=y;const r=a.slice();r[n.axis]=n.splitSizes[e],m.push(r),p[e]=(0,o.outputVariable)(`output${e}`,u,m[e]),g.push({dims:m[e],dataType:t[0].dataType,gpuDataType:i.GpuDataType.default})}const b=l<2?"indices":`indices[${d}]`;return Object.assign(Object.assign({},e),{getShaderSource:e=>{return`\\n  ${e.declareVariables(f,...p)}\\n  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map((e=>`${e}u`)).join(",")});\\n  ${t=h.length,`\\nfn calculateOutputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {\\n    if (index < sizeInConcatAxis[i]) {\\n        return i;\\n    }\\n    }\\n    return ${t}u;\\n}`}\\n  ${(e=>{const t=e.length,n=[];for(let r=0;r<t;++r){const a=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(a):0===r?n.push(`if (outputNumber == ${r}u) { ${a} }`):r===t-1?n.push(`else { ${a} }`):n.push(`else if (outputNumber == ${r}) { ${a} }`)}return`\\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\\n        ${n.join("\\n")}\\n      }`})(p)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(s)}\\n\\n    var indices = ${f.offsetToIndices("global_idx")};\\n    let outputNumber = calculateOutputIndex(${b});\\n    if (outputNumber != 0) {\\n        ${b} -= sizeInConcatAxis[outputNumber - 1u];\\n    }\\n    writeBufferData(outputNumber, indices, global_idx);\\n  }`;var t},outputs:g,dispatchGroup:()=>({x:Math.ceil(s/64)})})})(s,[e[0]],n)})})(e.inputs,t),{inputs:[0]})},t.parseSplitAttributes=e=>{const t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return(0,a.createAttributeWithCacheKey)({axis:t,numOutputs:r,splitSizes:n})}},8699:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.tile=t.createTileProgramInfo=t.tileProgramMetadata=void 0;const r=n(6952),a=n(1163),i=n(2075);t.tileProgramMetadata={name:"Tile",inputTypes:[a.GpuDataType.default]};const o=e=>Array.from(e.getBigInt64Array(),Number);t.createTileProgramInfo=(e,t)=>{const n=t[0].dims,s=o(t[1]),u=((e,t)=>{const n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n})(n,s),l=r.ShapeUtil.size(u),c=t[0].dataType,d=(0,i.inputVariable)("input",c,n),p=(0,i.outputVariable)("output",c,u);return Object.assign(Object.assign({},e),{outputs:[{dims:u,dataType:t[0].dataType,gpuDataType:a.GpuDataType.default}],getShaderSource:e=>`\\n      const inputShape = ${d.indices(...n)};\\n      ${e.declareVariables(d,p)}\\n      ${e.mainStart()}\\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\\n      let outputIndices = ${p.offsetToIndices("global_idx")};\\n      var inputIndices: ${d.type.indices};\\n      for (var i = 0; i < ${n.length}; i++) {\\n        let inputDimValue = ${p.indicesGet("outputIndices","i")}  % ${d.indicesGet("inputShape","i")};\\n\\n        ${d.indicesSet("inputIndices","i","inputDimValue")}\\n      }\\n      ${p.setByOffset("global_idx",d.getByIndices("inputIndices"))}\\n    }`,dispatchGroup:()=>({x:Math.ceil(l/64)})})},t.tile=e=>{(e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(o(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")})(e.inputs);const n=o(e.inputs[1]).toString();e.compute(Object.assign(Object.assign({},t.tileProgramMetadata),{cacheHint:n,get:()=>(0,t.createTileProgramInfo)(t.tileProgramMetadata,e.inputs)}),{inputs:[0]})}},2625:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=t.createTransposeProgramInfo=t.transposeProgramMetadata=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075);t.transposeProgramMetadata={name:"Transpose",inputTypes:[i.GpuDataType.default]};const s=(e,t)=>t&&t.length!==e.length?[...e.keys()].reverse():t;t.createTransposeProgramInfo=(e,n)=>{const a=e.dataType,u=e.dims,l=s(u,n),c=((e,t)=>r.ShapeUtil.sortBasedOnPerm(e,s(e,t)))(u,l),d=u.length,p=r.ShapeUtil.size(c),f=(0,o.outputVariable)("output",a,c),h=(0,o.inputVariable)("a",a,u);return Object.assign(Object.assign({},t.transposeProgramMetadata),{outputs:[{dims:c,dataType:e.dataType,gpuDataType:i.GpuDataType.default}],getShaderSource:e=>`\\n  ${e.declareVariables(h,f)}\\n\\n  ${((e,t,n,r)=>{const a=[];a.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)a.push(n.indicesSet("a",e[r],`i[${r}]`));return a.push("return a;}"),a.join("\\n")})(l,d,h,f)}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(p)}\\n\\n    let indices = ${f.offsetToIndices("global_idx")};\\n    let aIndices = perm(indices);\\n\\n    ${f.setByOffset("global_idx",h.getByIndices("aIndices"))}\\n  }`,dispatchGroup:()=>({x:Math.ceil(p/64)})})},t.transpose=(e,n)=>{(e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(1!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Transpose only support float, int32, and uint32 data types")})(e.inputs),e.compute(Object.assign(Object.assign({},t.transposeProgramMetadata),{cacheHint:n.cacheKey,get:()=>(0,t.createTransposeProgramInfo)(e.inputs[0],n.perm)}))},t.parseTransposeAttributes=e=>(0,a.createAttributeWithCacheKey)({perm:e.perm})},9302:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.log=t.thresholdedRelu=t.tanh=t.tan=t.sqrt=t.sinh=t.sin=t.sigmoid=t.relu=t.reciprocal=t.neg=t.leakyRelu=t.gelu=t.floor=t.exp=t.erf=t.erfImpl=t.elu=t.parseAlphaAttributes=t.cosh=t.cos=t.ceil=t.clip=t.clipV10=t.cast=t.parseCastAttributes=t.atanh=t.atan=t.asinh=t.asin=t.acosh=t.acos=t.abs=void 0;const r=n(6952),a=n(387),i=n(1163),o=n(2075),s=(e,t,n,a,s,u=e.dataType)=>{const l={name:t,inputTypes:[i.GpuDataType.default],cacheHint:s};return Object.assign(Object.assign({},l),{get:()=>((e,t,n,a,s)=>Object.assign(Object.assign({},e),{getShaderSource:e=>((e,t,n,r,a,i)=>{const s=Math.ceil(t/4);let u="";u="string"==typeof a?`${a}(a)`:a("a");const l=(0,o.inputVariable)("inputData",n,[s],4),c=(0,o.outputVariable)("outputData",r,[s],4);return`\\n  ${e.declareVariables(l,c)}\\n\\n  ${null!=i?i:""}\\n\\n  ${e.mainStart()}\\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(s)}\\n\\n    let a = ${l.getByOffset("global_idx")};\\n    ${c.setByOffset("global_idx",u)}\\n  }`})(e,r.ShapeUtil.size(t.dims),t.dataType,n,a,s),outputs:[{dims:t.dims,dataType:n,gpuDataType:i.GpuDataType.default}],dispatchGroup:e=>({x:Math.ceil(r.ShapeUtil.size(e[0].dims)/64/4)})}))(l,e,u,n,a)})};t.abs=e=>{e.compute(s(e.inputs[0],"Abs","abs"))},t.acos=e=>{e.compute(s(e.inputs[0],"Acos","acos"))},t.acosh=e=>{e.compute(s(e.inputs[0],"Acosh","acosh"))},t.asin=e=>{e.compute(s(e.inputs[0],"Asin","asin"))},t.asinh=e=>{e.compute(s(e.inputs[0],"Asinh","asinh"))},t.atan=e=>{e.compute(s(e.inputs[0],"Atan","atan"))},t.atanh=e=>{e.compute(s(e.inputs[0],"Atanh","atanh"))},t.parseCastAttributes=e=>(0,a.createAttributeWithCacheKey)(e),t.cast=(e,t)=>{let n;switch(t.to){case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(s(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},t.clipV10=(e,t)=>{e.compute(s(e.inputs[0],"Clip",(e=>`clamp(${e}, clip_min_, clip_max_)`),`\\n    const clip_min_: vec4<f32> = vec4(f32(${t.min}));\\n    const clip_max_: vec4<f32> = vec4(f32(${t.max}));\\n`,t.cacheKey),{inputs:[0]})},t.clip=e=>{const n=(e=>{const t=e.length>=2?e[1].getFloat32Array()[0]:r.MIN_CLIP,n=e.length>=3?e[2].getFloat32Array()[0]:r.MAX_CLIP;return(0,a.createAttributeWithCacheKey)({min:t,max:n})})(e.inputs);(0,t.clipV10)(e,n)},t.ceil=e=>{e.compute(s(e.inputs[0],"Ceil","ceil"))},t.cos=e=>{e.compute(s(e.inputs[0],"Cos","cos"))},t.cosh=e=>{e.compute(s(e.inputs[0],"Cosh","cosh"))},t.parseAlphaAttributes=e=>(0,a.createAttributeWithCacheKey)(e),t.elu=(e,t)=>{e.compute(s(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\\n  const elu_alpha_: f32 = f32(${t.alpha});\\n\\n  fn elu_f32(a: f32) -> f32 {\\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\\n  }\\n\\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\\n  }`,t.cacheKey))},t.erfImpl=e=>`\\nconst r0: f32 = 0.3275911;\\nconst r1: f32 = 0.254829592;\\nconst r2: f32 = -0.284496736;\\nconst r3: f32 = 1.421413741;\\nconst r4: f32 = -1.453152027;\\nconst r5: f32 = 1.061405429;\\n\\nfn erf_vf32(v: ${e}) -> ${e} {\\n  let absv = abs(v);\\n  let x = 1.0 / (1.0 + r0 * absv);\\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\\n}`,t.erf=e=>{e.compute(s(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),(0,t.erfImpl)("vec4<f32>")))},t.exp=e=>{e.compute(s(e.inputs[0],"Exp","exp"))},t.floor=e=>{e.compute(s(e.inputs[0],"Floor","floor"))},t.gelu=e=>{e.compute(s(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),(0,t.erfImpl)("vec4<f32>")))},t.leakyRelu=(e,t)=>{e.compute(s(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<f32>(0.0))`),`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},t.neg=e=>{e.compute(s(e.inputs[0],"Neg",(e=>`-${e}`)))},t.reciprocal=e=>{e.compute(s(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},t.relu=e=>{e.compute(s(e.inputs[0],"Relu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`)))},t.sigmoid=e=>{e.compute(s(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},t.sin=e=>{e.compute(s(e.inputs[0],"Sin","sin"))},t.sinh=e=>{e.compute(s(e.inputs[0],"Sinh","sinh"))},t.sqrt=e=>{e.compute(s(e.inputs[0],"Sqrt","sqrt"))},t.tan=e=>{e.compute(s(e.inputs[0],"Tan","tan"))},t.tanh=e=>{e.compute(s(e.inputs[0],"Tanh","tanh"))},t.thresholdedRelu=(e,t)=>(e.compute(s(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<f32>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),t.log=e=>{e.compute(s(e.inputs[0],"Log","log"))}},8305:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const r=n(4955),a=n(2075);t.ProgramManager=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r){const a=this.backend.device,i=this.backend.getComputePassEncoder(),o=this.backend.supportTimestampQuery&&"default"===this.backend.env.webgpu.profilingMode;o&&i.writeTimestamp(this.backend.profilingQuerySet,0),i.setPipeline(e.computePipeline);const s=[];for(const e of t)s.push({binding:s.length,resource:{buffer:e.buffer}});for(const e of n)s.push({binding:s.length,resource:{buffer:e.buffer}});const u=a.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:s});if(i.setBindGroup(0,u),i.dispatchWorkgroups(...r),this.backend.pendingDispatchNumber++,o){i.writeTimestamp(this.backend.profilingQuerySet,1),null==this.backend.profilingQueryData&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));const e=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,e.buffer,0,16),this.backend.flush();const t=this.backend.currentKernelId,n=this.backend.kernels.get(t)[0];e.buffer.mapAsync(GPUMapMode.READ).then((()=>{const r=new BigUint64Array(e.buffer.getMappedRange()),a=r[0],i=r[1];e.buffer.unmap(),void 0===this.backend.profilingTimeBase&&(this.backend.profilingTimeBase=a);const o=Number(a-this.backend.profilingTimeBase),s=Number(i-this.backend.profilingTimeBase);if(!Number.isSafeInteger(o)||!Number.isSafeInteger(s))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(e.id),console.log(`[profiling] kernel "${t}|${n}" execution time: ${s-o} ns`)}))}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,t){const n=this.backend.device,i=(0,a.createShaderHelper)(t),o=e.getShaderSource(i),s=`${i.additionalImplementations}\\n${o}`,u=n.createShaderModule({code:s});return(0,r.LOG_DEBUG)("verbose",(()=>`[WebGPU] shader code: ${s}`)),{programInfo:e,computePipeline:n.createComputePipeline({compute:{module:u,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(e){const t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&n<=a&&r<=a)return[t,n,r];const i=t*n*r;let o=Math.ceil(Math.sqrt(i));if(o>a){if(o=Math.ceil(Math.cbrt(i)),o>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[o,o,o]}return[o,o,1]}}},1163:(e,t)=>{"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0}),t.GpuDataType=void 0,(n=t.GpuDataType||(t.GpuDataType={}))[n.default=0]="default",n[n.upload=1]="upload",n[n.profile=2]="profile"},7918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(263),a=n(1497);t.setRunOptions=e=>{const t=(0,r.getInstance)();let n=0;const i=[],o=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(o.terminate=!1);let r=0;return void 0!==(null==e?void 0:e.tag)&&(r=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,r),0===n&&(0,a.checkLastError)("Can\'t create run options."),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);0!==t._OrtAddRunConfigEntry(n,o,s)&&(0,a.checkLastError)(`Can\'t set a run config entry: ${e} - ${r}.`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach((e=>t._free(e))),e}}},7622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(263),a=n(1497);t.setSessionOptions=e=>{var t,n,i,o;const s=(0,r.getInstance)();let u=0;const l=[],c=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(c);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=c.graphOptimizationLevel)&&void 0!==t?t:"all"),d=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=c.executionMode)&&void 0!==n?n:"sequential"),p="string"==typeof c.logId?(0,a.allocWasmString)(c.logId,l):0,f=null!==(i=c.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log serverity level is not valid: ${f}`);const h=null!==(o=c.logVerbosityLevel)&&void 0!==o?o:0;if(!Number.isInteger(h)||h<0||h>4)throw new Error(`log verbosity level is not valid: ${h}`);const g="string"==typeof c.optimizedModelFilePath?(0,a.allocWasmString)(c.optimizedModelFilePath,l):0;return u=s._OrtCreateSessionOptions(e,!!c.enableCpuMemArena,!!c.enableMemPattern,d,!!c.enableProfiling,0,p,f,h,g),0===u&&(0,a.checkLastError)("Can\'t create session options."),c.executionProviders&&((e,t,n)=>{for(const i of t){let t="string"==typeof i?i:i.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webnn":if(t="WEBNN","string"!=typeof i){const t=i;if(null==t?void 0:t.deviceType){const i=(0,a.allocWasmString)("deviceType",n),o=(0,a.allocWasmString)(t.deviceType,n);0!==(0,r.getInstance)()._OrtAddSessionConfigEntry(e,i,o)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'deviceType\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const i=(0,a.allocWasmString)("powerPreference",n),o=(0,a.allocWasmString)(t.powerPreference,n);0!==(0,r.getInstance)()._OrtAddSessionConfigEntry(e,i,o)&&(0,a.checkLastError)(`Can\'t set a session config entry: \'powerPreference\' - ${t.powerPreference}.`)}}break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}const o=(0,a.allocWasmString)(t,n);0!==(0,r.getInstance)()._OrtAppendExecutionProvider(e,o)&&(0,a.checkLastError)(`Can\'t append execution provider: ${t}.`)}})(u,c.executionProviders,l),void 0!==c.extra&&(0,a.iterateExtraOptions)(c.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);0!==s._OrtAddSessionConfigEntry(u,n,r)&&(0,a.checkLastError)(`Can\'t set a session config entry: ${e} - ${t}.`)})),[u,l]}catch(e){throw 0!==u&&s._OrtReleaseSessionOptions(u),l.forEach((e=>s._free(e))),e}}},7917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float16":case"uint16":return Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},1259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const r=n(7918),a=n(7622),i=n(7917),o=n(263),s=n(1497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,i.logLevelStringToEnum)(e.logLevel),0!==(0,o.getInstance)()._OrtInit(t,r)&&(0,s.checkLastError)("Can\'t initialize onnxruntime.");{const t=n(7675).S;await t((0,o.getInstance)(),e)}};const u=new Map;t.createSessionAllocate=e=>{const t=(0,o.getInstance)(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,o.getInstance)();let r=0,i=0,l=[];const c=[],d=[];try{[i,l]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],i),0===r&&(0,s.checkLastError)("Can\'t create a session.");const[p,f]=(e=>{const t=(0,o.getInstance)(),n=t.stackSave();try{const n=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,n,n+4)&&(0,s.checkLastError)("Can\'t get session input/output count."),[t.HEAP32[n/4],t.HEAP32[n/4+1]]}finally{t.stackRestore(n)}})(r),h=[],g=[];for(let e=0;e<p;e++){const t=n._OrtGetInputName(r,e);0===t&&(0,s.checkLastError)("Can\'t get an input name."),c.push(t),h.push(n.UTF8ToString(t))}for(let e=0;e<f;e++){const t=n._OrtGetOutputName(r,e);0===t&&(0,s.checkLastError)("Can\'t get an output name."),d.push(t),g.push(n.UTF8ToString(t))}return u.set(r,[r,c,d]),[r,h,g]}catch(e){throw c.forEach((e=>n._OrtFree(e))),d.forEach((e=>n._OrtFree(e))),0!==r&&n._OrtReleaseSession(r),e}finally{n._free(e[0]),0!==i&&n._OrtReleaseSessionOptions(i),l.forEach((e=>n._free(e)))}},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,o.getInstance)(),n=u.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);const[r,a,i]=n;a.forEach((e=>t._OrtFree(e))),i.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,l)=>{const c=(0,o.getInstance)(),d=u.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);const[p,f,h]=d,g=t.length,m=a.length;let y=0,b=[];const v=[],w=[];try{[y,b]=(0,r.setRunOptions)(l);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=c._malloc(u),w.push(o);let e=o/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);c.HEAPU32[e++]=(0,s.allocWasmString)(a[t],w)}}else u=a.byteLength,o=c._malloc(u),w.push(o),c.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const l=c.stackSave(),d=c.stackAlloc(4*r.length);try{let n=d/4;r.forEach((e=>c.HEAP32[n++]=e));const a=c._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),o,u,d,r.length);0===a&&(0,s.checkLastError)(`Can\'t create tensor for input[${e}].`),v.push(a)}finally{c.stackRestore(l)}}const e=c.stackSave(),o=c.stackAlloc(4*g),u=c.stackAlloc(4*g),d=c.stackAlloc(4*m),$=c.stackAlloc(4*m);try{let e=o/4,n=u/4,r=d/4,l=$/4;for(let r=0;r<g;r++)c.HEAPU32[e++]=v[r],c.HEAPU32[n++]=f[t[r]];for(let e=0;e<m;e++)c.HEAPU32[r++]=0,c.HEAPU32[l++]=h[a[e]];let b=c._OrtRun(p,u,o,g,$,m,d,y);const w=c.jsepRunPromise;w&&void 0!==w.then&&(b=await w);const x=[];0!==b&&(0,s.checkLastError)("failed to call OrtRun().");for(let e=0;e<m;e++){const t=c.HEAPU32[d/4+e],n=c.stackSave(),r=c.stackAlloc(16);let a,o=0;try{b=c._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==b&&(0,s.checkLastError)(`Can\'t access output tensor data on index ${e}.`);let n=r/4;const u=c.HEAPU32[n++];o=c.HEAPU32[n++];const l=c.HEAPU32[n++],d=c.HEAPU32[n++],p=[];for(let e=0;e<d;e++)p.push(c.HEAPU32[l/4+e]);c._OrtFree(l);const f=0===p.length?1:p.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(u),"string"===a){const e=[];let t=o/4;for(let n=0;n<f;n++){const r=c.HEAPU32[t++],a=n===f-1?void 0:c.HEAPU32[t]-r;e.push(c.UTF8ToString(r,a))}x.push([a,p,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(f);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(c.HEAPU8.subarray(o,o+e.byteLength)),x.push([a,p,e])}}finally{c.stackRestore(n),"string"===a&&o&&c._free(o),c._OrtReleaseTensor(t)}}return x}finally{c.stackRestore(e)}}finally{v.forEach((e=>c._OrtReleaseTensor(e))),w.forEach((e=>c._free(e))),0!==y&&c._OrtReleaseRunOptions(y),b.forEach((e=>c._free(e)))}},t.endProfiling=e=>{const t=(0,o.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);0===a&&(0,s.checkLastError)("Can\'t get an profile file name."),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const o=i(n(6449)),s=n(9377),u=n(5711);let l,c=!1,d=!1,p=!1;t.initializeWebAssembly=async e=>{if(c)return Promise.resolve();if(d)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");d=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),f=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),h=e.wasmPaths,g="string"==typeof h?h:void 0,m=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(f,i),y="object"==typeof h?h[m]:void 0;let b=!1;const v=[];if(t>0&&v.push(new Promise((e=>{setTimeout((()=>{b=!0,e()}),t)}))),v.push(new Promise(((e,t)=>{const r=i?u:s,a={locateFile:(e,t)=>{if(i&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob)return URL.createObjectURL(new Blob([n(4154)],{type:"text/javascript"}));if(e.endsWith(".wasm")){if(y)return y;const e=null!=g?g:t;return"ort-wasm-simd.wasm"===m?e+"ort-wasm-simd.jsep.wasm":"ort-wasm-simd-threaded.wasm"===m?e+"ort-wasm-simd-threaded.jsep.wasm":e+m}return t+e}};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=o.join(__dirname,"ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{d=!1,c=!0,l=t,e()}),(e=>{d=!1,p=!0,t(e)}))}))),await Promise.race(v),b)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(c&&l)return l;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!c||d||p||(d=!0,null===(e=l.PThread)||void 0===e||e.terminateAllThreads(),l=void 0,d=!1,c=!1,p=!0)}},1497:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,i=n._malloc(a);return n.stringToUTF8(e,i,a),t.push(i),i},t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,i])=>{const o=n?n+e:e;if("object"==typeof i)(0,t.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))},t.checkLastError=e=>{const t=(0,r.getInstance)(),n=t.stackSave();try{const n=t.stackAlloc(8);t._OrtGetLastError(n,n+4);const r=t.HEAP32[n/4],a=t.HEAPU32[n/4+1],i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}},5711:(e,t,n)=>{var _scriptDir,r=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return E.buffer!=k.buffer&&G(),k}function r(){return E.buffer!=k.buffer&&G(),D}function a(){return E.buffer!=k.buffer&&G(),z}function i(){return E.buffer!=k.buffer&&G(),j}function o(){return E.buffer!=k.buffer&&G(),B}var s,u,l=e;l.ready=new Promise(((e,t)=>{s=e,u=t})),l.jsepInit=function(e,t,n,r,a,i,o,s){l.Ib=e,l.ob=t,l.qb=n,l.ab=r,l.pb=a,l.xa=i,l.rb=o,l.sb=s};var c,d,p,f=Object.assign({},l),h="./this.program",g=(e,t)=>{throw t},m="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,v=l.ENVIRONMENT_IS_PTHREAD||!1,w="";function $(e){return l.locateFile?l.locateFile(e,w):w+e}if(b){var x=n(1384),S=n(908);let e;w=y?S.dirname(w)+"/":__dirname+"/",c=(e,t)=>(e=e.startsWith("file://")?new URL(e):S.normalize(e),x.readFileSync(e,t?void 0:"utf8")),p=e=>((e=c(e,!0)).buffer||(e=new Uint8Array(e)),e),d=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):S.normalize(e),x.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!l.thisProgram&&1<process.argv.length&&(h=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),g=(e,t)=>{throw process.exitCode=e,t},l.inspect=()=>"[Emscripten Module object]";try{e=n(9925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}global.Worker=e.Worker}else(m||y)&&(y?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",b||(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},y&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),d=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));b&&"undefined"==typeof performance&&(global.performance=n(6953).performance);var _=console.log.bind(console),A=console.error.bind(console);b&&(_=(...e)=>x.writeSync(1,e.join(" ")+"\\n"),A=(...e)=>x.writeSync(2,e.join(" ")+"\\n"));var C,O=l.print||_,T=l.printErr||A;Object.assign(l,f),f=null,l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit),l.wasmBinary&&(C=l.wasmBinary);var I=l.noExitRuntime||!0;"object"!=typeof WebAssembly&&Z("no native wasm support detected");var E,P,M,R,k,D,z,j,B,W=!1;function G(){var e=E.buffer;l.HEAP8=k=new Int8Array(e),l.HEAP16=new Int16Array(e),l.HEAP32=z=new Int32Array(e),l.HEAPU8=D=new Uint8Array(e),l.HEAPU16=new Uint16Array(e),l.HEAPU32=j=new Uint32Array(e),l.HEAPF32=new Float32Array(e),l.HEAPF64=B=new Float64Array(e)}var U=l.INITIAL_MEMORY||16777216;if(5242880<=U||Z("INITIAL_MEMORY should be larger than STACK_SIZE, was "+U+"! (STACK_SIZE=5242880)"),v)E=l.wasmMemory;else if(l.wasmMemory)E=l.wasmMemory;else if(!((E=new WebAssembly.Memory({initial:U/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw T("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&T("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");G(),U=E.buffer.byteLength;var N=[],L=[],H=[],F=0;function V(){return I||0<F}var K,q=0,Y=null,X=null;function J(){q++,l.monitorRunDependencies&&l.monitorRunDependencies(q)}function Q(){if(q--,l.monitorRunDependencies&&l.monitorRunDependencies(q),0==q&&(null!==Y&&(clearInterval(Y),Y=null),X)){var e=X;X=null,e()}}function Z(e){throw l.onAbort&&l.onAbort(e),T(e="Aborted("+e+")"),W=!0,R=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function ee(e){return e.startsWith("data:application/octet-stream;base64,")}function te(e){if(e==K&&C)return new Uint8Array(C);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}function ne(e,t,n){return function(e){if(!C&&(m||y)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>te(e)));if(d)return new Promise(((t,n)=>{d(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>te(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{T("failed to asynchronously prepare wasm: "+e),Z(e)}))}ee(K="ort-wasm-simd-threaded.wasm")||(K=$(K));var re,ae={898348:()=>{l.jsepRunPromise=new Promise((function(e){l.tb=e}))},898443:e=>{l.tb(e)},898481:e=>l.ob(e),898514:e=>l.qb(e),898546:(e,t,n)=>{l.ab(e,t,n,!0)},898585:(e,t,n)=>{l.ab(e,t,n)},898618:e=>{l.xa("Abs",e,void 0)},898669:e=>{l.xa("Neg",e,void 0)},898720:e=>{l.xa("Floor",e,void 0)},898773:e=>{l.xa("Ceil",e,void 0)},898825:e=>{l.xa("Reciprocal",e,void 0)},898883:e=>{l.xa("Sqrt",e,void 0)},898935:e=>{l.xa("Exp",e,void 0)},898986:e=>{l.xa("Erf",e,void 0)},899037:e=>{l.xa("Sigmoid",e,void 0)},899092:e=>{l.xa("Log",e,void 0)},899143:e=>{l.xa("Sin",e,void 0)},899194:e=>{l.xa("Cos",e,void 0)},899245:e=>{l.xa("Tan",e,void 0)},899296:e=>{l.xa("Asin",e,void 0)},899348:e=>{l.xa("Acos",e,void 0)},899400:e=>{l.xa("Atan",e,void 0)},899452:e=>{l.xa("Sinh",e,void 0)},899504:e=>{l.xa("Cosh",e,void 0)},899556:e=>{l.xa("Asinh",e,void 0)},899609:e=>{l.xa("Acosh",e,void 0)},899662:e=>{l.xa("Atanh",e,void 0)},899715:e=>{l.xa("Tanh",e,void 0)},899767:(e,t,n)=>{l.xa("ClipV10",e,{min:t,max:n})},899839:e=>{l.xa("Clip",e,void 0)},899891:(e,t)=>{l.xa("Elu",e,{alpha:t})},899949:e=>{l.xa("Relu",e,void 0)},900001:(e,t)=>{l.xa("LeakyRelu",e,{alpha:t})},900065:(e,t)=>{l.xa("ThresholdedRelu",e,{alpha:t})},900135:(e,t)=>{l.xa("Cast",e,{to:t})},900193:e=>{l.xa("Add",e,void 0)},900244:e=>{l.xa("Sub",e,void 0)},900295:e=>{l.xa("Mul",e,void 0)},900346:e=>{l.xa("Div",e,void 0)},900397:e=>{l.xa("Pow",e,void 0)},900448:(e,t,n,r,i)=>{l.xa("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},900612:(e,t,n,r,i)=>{l.xa("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},900775:(e,t,n,r,i)=>{l.xa("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},900938:(e,t,n,r,i)=>{l.xa("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901102:(e,t,n,r,i)=>{l.xa("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901265:(e,t,n,r,i)=>{l.xa("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901427:(e,t,n,r,i)=>{l.xa("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901589:(e,t,n,r,i)=>{l.xa("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901755:(e,t,n,r,i)=>{l.xa("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},901924:(e,t,n,r,i)=>{l.xa("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},902093:(e,t,n)=>{l.xa("Transpose",e,{perm:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[]})},902206:(e,n,r,a,i,o,s,u,c,d)=>{l.xa("Conv",e,{format:c?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:a,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!t()[d>>>0]})},902434:(e,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("Conv",e,{format:g?"NHWC":"NCHW",auto_pad:n,dilations:[r,a],group:i,kernel_shape:[o,s],pads:[u,c,d,p],strides:[f,h],w_is_const:()=>!!t()[m>>>0]})},902693:(e,n,r,a,i,o,s,u,c,d)=>{l.xa("Conv",e,{format:c?"NHWC":"NCHW",auto_pad:n,dilations:[r],group:a,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!t()[d>>>0]})},902921:(e,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("Conv",e,{format:g?"NHWC":"NCHW",auto_pad:n,dilations:[r,a],group:i,kernel_shape:[o,s],pads:[u,c,d,p],strides:[f,h],w_is_const:()=>!!t()[m>>>0]})},903180:(e,n,r,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[c],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:g?Array.from(a().subarray(m>>>0,m+g>>>0)):[]})},903560:(e,n,r,i,o,s,u,c,d,p,f,h,g)=>{l.xa("ConvTranspose",e,{format:c?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(g>>>0,g+h>>>0)):[]})},904083:(e,n,r,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:n,dilations:[r],group:i,kernel_shape:[o],pads:[s,u],strides:[c],wIsConst:()=>!!t()[p>>>0],outputPadding:f?Array.from(a().subarray(h>>>0,h+f>>>0)):[],outputShape:g?Array.from(a().subarray(m>>>0,m+g>>>0)):[]})},904463:(e,n,r,i,o,s,u,c,d,p,f,h,g)=>{l.xa("ConvTranspose",e,{format:c?"NHWC":"NCHW",autoPad:n,dilations:Array.from(a().subarray(r>>>0,r+2>>>0)),group:i,kernelShape:Array.from(a().subarray(o>>>0,o+2>>>0)),pads:Array.from(a().subarray(s>>>0,s+4>>>0)),strides:Array.from(a().subarray(u>>>0,u+2>>>0)),wIsConst:()=>!!t()[d>>>0],outputPadding:0<p?Array.from(a().subarray(f>>>0,f+p>>>0)):[],outputShape:0<h?Array.from(a().subarray(g>>>0,g+h>>>0)):[]})},904986:(e,t)=>{l.xa("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},905077:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},905361:(e,t)=>{l.xa("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},905452:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},905736:(e,t)=>{l.xa("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},905823:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},906103:(e,t)=>{l.xa("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},906190:(e,t,n,r,a,i,o,s,u,c,d,p,f,h,g,m)=>{l.xa("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:a,dilations:[i,o],kernel_shape:[s,u],pads:[c,d,p,f],strides:[h,g]})},906470:(e,t,n,r,a)=>{l.xa("Gemm",e,{alpha:t,beta:n,transA:r,transB:a})},906574:e=>{l.xa("MatMul",e,void 0)},906628:(e,t,n,r)=>{l.xa("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},906736:(e,t,n,r)=>{l.xa("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},906844:(e,t)=>{l.xa("Softmax",e,{axis:t})},906907:(e,t)=>{l.xa("Concat",e,{axis:t})},906967:(e,t,n,r,i)=>{l.xa("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[]})},907112:e=>{l.xa("Expand",e,void 0)},907166:(e,t)=>{l.xa("Gather",e,{axis:Number(t)})},907237:(e,t,n,r,i,o,s,u,c,d,p)=>{l.xa("Resize",e,{antialias:t,axes:n?Array.from(a().subarray(r>>>0,r+n>>>0)):[],coordinateTransformMode:de(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:de(c),mode:de(d),nearestMode:de(p)})},907588:(e,t,n,r,i,o,s)=>{l.xa("Slice",e,{starts:t?Array.from(a().subarray(n>>>0,n+t>>>0)):[],ends:r?Array.from(a().subarray(i>>>0,i+r>>>0)):[],axes:o?Array.from(a().subarray(s>>>0,s+o>>>0)):[]})},907819:e=>{l.xa("Tile",e,void 0)},907871:(e,t,n)=>{l.xa("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},907978:(e,t,n)=>{l.xa("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},908092:(e,t,n)=>{l.xa("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},908206:e=>{l.xa("Gelu",e,void 0)},908258:(e,t)=>{l.xa("SkipLayerNormalization",e,{epsilon:t})},908339:e=>{l.rb(e)},908373:(e,t)=>l.sb(e,t)};function ie(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}function oe(e){e.terminate(),e.onmessage=()=>{}}function se(e){(e=he.Ja[e])||Z(),he.xb(e)}function ue(e){var t=he.lb();if(!t)return 6;he.Ra.push(t),he.Ja[e.Qa]=t,t.Qa=e.Qa;var n={cmd:"run",start_routine:e.yb,arg:e.jb,pthread_ptr:e.Qa};return b&&t.unref(),t.postMessage(n,e.Eb),0}var le="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,ce=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&le)return le.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},de=(e,t)=>(e>>>=0)?ce(r(),e,t):"";function pe(e){if(v)return qe(1,1,e);R=e,V()||(he.zb(),l.onExit&&l.onExit(e),W=!0),g(e,new ie(e))}var fe=e=>{if(R=e,v)throw me(e),"unwind";pe(e)},he={Ua:[],Ra:[],eb:[],Ja:{},Xa:function(){v?he.nb():he.mb()},mb:function(){N.unshift((()=>{J(),he.ub((()=>Q()))}))},nb:function(){he.receiveObjectTransfer=he.wb,he.threadInitTLS=he.cb,he.setExitStatus=he.bb,I=!1},bb:function(e){R=e},Kb:["$terminateWorker"],zb:function(){for(var e of he.Ra)oe(e);for(e of he.Ua)oe(e);he.Ua=[],he.Ra=[],he.Ja=[]},xb:function(e){var t=e.Qa;delete he.Ja[t],he.Ua.push(e),he.Ra.splice(he.Ra.indexOf(e),1),e.Qa=0,It(t)},wb:function(){},cb:function(){he.eb.forEach((e=>e()))},vb:e=>new Promise((t=>{e.onmessage=n=>{var r=(n=n.data).cmd;if(n.targetThread&&n.targetThread!=St()){var a=he.Ja[n.Jb];a?a.postMessage(n,n.transferList):T(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"checkMailbox"===r?Be():"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=he.Ja[n],delete he.Ja[n],oe(r),It(n),he.Ra.splice(he.Ra.indexOf(r),1),r.Qa=0):"cancelThread"===r?he.Ja[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t(e)):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"callHandler"===r?l[n.handler](...n.args):r&&T("worker sent an unknown command "+r)},e.onerror=e=>{throw T("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},b&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})));var n,r=[];for(n of["onExit","onAbort","print","printErr"])l.hasOwnProperty(n)&&r.push(n);e.postMessage({cmd:"load",handlers:r,urlOrBlob:l.mainScriptUrlOrBlob||_scriptDir,wasmMemory:E,wasmModule:M})})),ub:function(e){e()},ib:function(){var e=$("ort-wasm-simd-threaded.worker.js");e=new Worker(e),he.Ua.push(e)},lb:function(){return 0==he.Ua.length&&(he.ib(),he.vb(he.Ua[0])),he.Ua.pop()}};l.PThread=he;var ge=e=>{for(;0<e.length;)e.shift()(l)};function me(e){if(v)return qe(2,0,e);fe(e)}function ye(e){this.$a=e-24,this.hb=function(e){i()[this.$a+4>>2>>>0]=e},this.gb=function(e){i()[this.$a+8>>2>>>0]=e},this.Xa=function(e,t){this.fb(),this.hb(e),this.gb(t)},this.fb=function(){i()[this.$a+16>>2>>>0]=0}}function be(e,t,n,r){return v?qe(3,1,e,t,n,r):ve(e,t,n,r)}function ve(e,t,n,r){if(e>>>=0,t>>>=0,n>>>=0,r>>>=0,"undefined"==typeof SharedArrayBuffer)return T("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return v&&0===a.length?be(e,t,n,r):(e={yb:n,Qa:e,jb:r,Eb:a},v?(e.Gb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return v?qe(4,1,e,t,n):0}function $e(e,t){if(v)return qe(5,1,e,t)}l.establishStackSpace=function(){var e=St(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],Rt(t,t-e),Dt(t)},l.invokeEntryPoint=function(e,t){e=jt.apply(null,[e,t]),V()?he.bb(e):Et(e)};var xe=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Se=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},_e=(e,t,n)=>Se(e,r(),t,n);function Ae(e,t){if(v)return qe(6,1,e,t)}function Ce(e,t,n){if(v)return qe(7,1,e,t,n)}function Oe(e,t,n){return v?qe(8,1,e,t,n):0}function Te(e,t){if(v)return qe(9,1,e,t)}function Ie(e,t,n){if(v)return qe(10,1,e,t,n)}function Ee(e,t,n,r){if(v)return qe(11,1,e,t,n,r)}function Pe(e,t,n,r){if(v)return qe(12,1,e,t,n,r)}function Me(e,t,n,r){if(v)return qe(13,1,e,t,n,r)}function Re(e){if(v)return qe(14,1,e)}function ke(e,t){if(v)return qe(15,1,e,t)}function De(e,t,n){if(v)return qe(16,1,e,t,n)}var ze=e=>{if(!W)try{if(e(),!V())try{v?Et(R):fe(R)}catch(e){e instanceof ie||"unwind"==e||g(1,e)}}catch(e){e instanceof ie||"unwind"==e||g(1,e)}};function je(e){e>>>=0,"function"==typeof Atomics.Fb&&(Atomics.Fb(a(),e>>2,e).value.then(Be),e+=128,Atomics.store(a(),e>>2,1))}function Be(){var e=St();e&&(je(e),ze((()=>Pt())))}l.__emscripten_thread_mailbox_await=je,l.checkMailbox=Be;var We=e=>0==e%4&&(0!=e%100||0==e%400),Ge=[0,31,60,91,121,152,182,213,244,274,305,335],Ue=[0,31,59,90,120,151,181,212,243,273,304,334];function Ne(e,t,n,r,a,i,o,s){return v?qe(17,1,e,t,n,r,a,i,o,s):-52}function Le(e,t,n,r,a,i,o){if(v)return qe(18,1,e,t,n,r,a,i,o)}var He=e=>{var t=xe(e)+1,n=_t(t);return n&&_e(e,n,t),n},Fe=[],Ve=(e,t)=>{var n;for(Fe.length=0,t>>=2;n=r()[e++>>>0];)t+=105!=n&t,Fe.push(105==n?a()[t>>>0]:o()[t++>>>1]),++t;return Fe},Ke=e=>{var t=kt();return e=e(),Dt(t),e};function qe(e,t){var n=arguments.length-2,r=arguments;return Ke((()=>{for(var a=zt(8*n),i=a>>3,s=0;s<n;s++){var u=r[2+s];o()[i+s>>>0]=u}return Tt(e,n,a,t)}))}var Ye,Xe=[],Je={},Qe=()=>{if(!Ye){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:h||"./this.program"};for(e in Je)void 0===Je[e]?delete t[e]:t[e]=Je[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Ye=n}return Ye};function Ze(e,n){if(v)return qe(19,1,e,n);e>>>=0,n>>>=0;var r=0;return Qe().forEach((function(a,o){var s=n+r;for(o=i()[e+4*o>>2>>>0]=s,s=0;s<a.length;++s)t()[o++>>0>>>0]=a.charCodeAt(s);t()[o>>0>>>0]=0,r+=a.length+1})),0}function et(e,t){if(v)return qe(20,1,e,t);e>>>=0,t>>>=0;var n=Qe();i()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),i()[t>>2>>>0]=r,0}function tt(e){return v?qe(21,1,e):52}function nt(e,t,n,r){return v?qe(22,1,e,t,n,r):52}function rt(e,t,n,r,a){return v?qe(23,1,e,t,n,r,a):70}var at=[null,[],[]];function it(e,t,n,a){if(v)return qe(24,1,e,t,n,a);t>>>=0,n>>>=0,a>>>=0;for(var o=0,s=0;s<n;s++){var u=i()[t>>2>>>0],l=i()[t+4>>2>>>0];t+=8;for(var c=0;c<l;c++){var d=r()[u+c>>>0],p=at[e];0===d||10===d?((1===e?O:T)(ce(p,0)),p.length=0):p.push(d)}o+=l}return i()[a>>2>>>0]=o,0}var ot=e=>(ot=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(b)try{var e=n(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}Z("initRandomDevice")})())(e),st=[31,29,31,30,31,30,31,31,30,31,30,31],ut=[31,28,31,30,31,30,31,31,30,31,30,31],lt=(e,n)=>{t().set(e,n>>>0)};function ct(e,t,n,r){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return i(e,t,"0")}function s(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Sa;for(e=new Date(new Date(e.Ta+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(We(e.getFullYear())?st:ut)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),n=u(n),0>=s(t,e)?0>=s(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0,r>>>=0;var c=a()[r+40>>2>>>0];for(var d in r={Cb:a()[r>>2>>>0],Bb:a()[r+4>>2>>>0],Va:a()[r+8>>2>>>0],Za:a()[r+12>>2>>>0],Wa:a()[r+16>>2>>>0],Ta:a()[r+20>>2>>>0],Pa:a()[r+24>>2>>>0],Sa:a()[r+28>>2>>>0],Lb:a()[r+32>>2>>>0],Ab:a()[r+36>>2>>>0],Db:c?de(c):""},n=de(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(d,"g"),c[d]);var p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),f="January February March April May June July August September October November December".split(" ");for(d in c={"%a":e=>p[e.Pa].substring(0,3),"%A":e=>p[e.Pa],"%b":e=>f[e.Wa].substring(0,3),"%B":e=>f[e.Wa],"%C":e=>o((e.Ta+1900)/100|0,2),"%d":e=>o(e.Za,2),"%e":e=>i(e.Za,2," "),"%g":e=>l(e).toString().substring(2),"%G":e=>l(e),"%H":e=>o(e.Va,2),"%I":e=>(0==(e=e.Va)?e=12:12<e&&(e-=12),o(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.Wa-1;t+=(We(e.Ta+1900)?st:ut)[n++]);return o(e.Za+t,3)},"%m":e=>o(e.Wa+1,2),"%M":e=>o(e.Bb,2),"%n":()=>"\\n","%p":e=>0<=e.Va&&12>e.Va?"AM":"PM","%S":e=>o(e.Cb,2),"%t":()=>"\\t","%u":e=>e.Pa||7,"%U":e=>o(Math.floor((e.Sa+7-e.Pa)/7),2),"%V":e=>{var t=Math.floor((e.Sa+7-(e.Pa+6)%7)/7);if(2>=(e.Pa+371-e.Sa-2)%7&&t++,t)53==t&&(4==(n=(e.Pa+371-e.Sa)%7)||3==n&&We(e.Ta)||(t=1));else{t=52;var n=(e.Pa+7-e.Sa-1)%7;(4==n||5==n&&We(e.Ta%400-1))&&t++}return o(t,2)},"%w":e=>e.Pa,"%W":e=>o(Math.floor((e.Sa+7-(e.Pa+6)%7)/7),2),"%y":e=>(e.Ta+1900).toString().substring(2),"%Y":e=>e.Ta+1900,"%z":e=>{var t=0<=(e=e.Ab);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.Db,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(d)&&(n=n.replace(new RegExp(d,"g"),c[d](r)));return d=function(e){var t=Array(xe(e)+1);return Se(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),d.length>t?0:(lt(d,e),d.length-1)}function dt(e){try{e()}catch(e){Z(e)}}var pt=0,ft=null,ht=0,gt=[],mt={},yt={},bt=0,vt=null,wt=[];he.Xa();var $t=[null,pe,me,be,we,$e,Ae,Ce,Oe,Te,Ie,Ee,Pe,Me,Re,ke,De,Ne,Le,Ze,et,tt,nt,rt,it],xt={r:function(e,t,n){return function(e){return function(e){if(!W){if(0===pt){var t=!1,n=!1;e(((e=0)=>{if(!W&&(ht=e,t=!0,n)){pt=2,dt((()=>Gt(ft))),"undefined"!=typeof Browser&&Browser.Ya.kb&&Browser.Ya.resume(),e=!1;try{var r=function(){var e=a()[ft+8>>2>>>0];return e=P[yt[e]],--F,e()}()}catch(t){r=t,e=!0}var i=!1;if(!ft){var o=vt;o&&(vt=null,(e?o.reject:o.resolve)(r),i=!0)}if(e&&!i)throw r}})),n=!0,t||(pt=1,ft=function(){var e=_t(65548),t=e+12;i()[e>>2>>>0]=t,i()[e+4>>2>>>0]=t+65536,t=gt[0];var n=mt[t];return void 0===n&&(n=bt++,mt[t]=n,yt[n]=t),t=n,a()[e+8>>2>>>0]=t,e}(),"undefined"!=typeof Browser&&Browser.Ya.kb&&Browser.Ya.pause(),dt((()=>Bt(ft))))}else 2===pt?(pt=0,dt(Ut),At(ft),ft=null,wt.forEach((e=>ze(e)))):Z(`invalid state: ${pt}`);return ht}}((t=>{e().then(t)}))}((async()=>{await l.pb(e,t,n)}))},b:function(e,t,n){throw new ye(e>>>=0).Xa(t>>>0,n>>>0),e},O:function(e){Ct(e>>>0,!y,1,!m,131072,!1),he.cb()},m:function(e){e>>>=0,v?postMessage({cmd:"cleanupThread",thread:e}):se(e)},J:ve,i:we,U:$e,G:Ae,I:Ce,V:Oe,S:Te,K:Ie,R:Ee,q:Pe,H:Me,E:Re,T:ke,F:De,Y:()=>!0,C:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>Be())):v?postMessage({targetThread:e,cmd:"checkMailbox"}):(e=he.Ja[e])&&e.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:je,X:function(e){b&&he.Ja[e>>>0].ref()},u:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getUTCSeconds(),a()[n+4>>2>>>0]=e.getUTCMinutes(),a()[n+8>>2>>>0]=e.getUTCHours(),a()[n+12>>2>>>0]=e.getUTCDate(),a()[n+16>>2>>>0]=e.getUTCMonth(),a()[n+20>>2>>>0]=e.getUTCFullYear()-1900,a()[n+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[n+28>>2>>>0]=e},v:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),a()[n>>2>>>0]=e.getSeconds(),a()[n+4>>2>>>0]=e.getMinutes(),a()[n+8>>2>>>0]=e.getHours(),a()[n+12>>2>>>0]=e.getDate(),a()[n+16>>2>>>0]=e.getMonth(),a()[n+20>>2>>>0]=e.getFullYear()-1900,a()[n+24>>2>>>0]=e.getDay(),t=(We(e.getFullYear())?Ge:Ue)[e.getMonth()]+e.getDate()-1|0,a()[n+28>>2>>>0]=t,a()[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t)),a()[n+32>>2>>>0]=e},w:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(o,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=o&&s==r):0<n!=(s==r)&&(i=Math.max(o,i),t.setTime(t.getTime()+6e4*((0<n?s:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(We(t.getFullYear())?Ge:Ue)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Mt((re=e,1<=+Math.abs(re)?0<re?+Math.floor(re/4294967296)>>>0:~~+Math.ceil((re-+(~~re>>>0))/4294967296)>>>0:0)),e>>>0},s:Ne,t:Le,A:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}e>>>=0,t>>>=0,n>>>=0;var o=(new Date).getFullYear(),s=new Date(o,0,1),u=new Date(o,6,1);o=s.getTimezoneOffset();var l=u.getTimezoneOffset(),c=Math.max(o,l);i()[e>>2>>>0]=60*c,a()[t>>2>>>0]=Number(o!=l),e=r(s),t=r(u),e=He(e),t=He(t),l<o?(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t):(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e)},d:()=>{Z("")},c:function(e,t,n){return e>>>=0,t=Ve(t>>>0,n>>>0),ae[e].apply(null,t)},l:function(e,t,n){return e>>>=0,t=Ve(t>>>0,n>>>0),ae[e].apply(null,t)},n:function(){},j:function(){return Date.now()},W:()=>{throw F+=1,"unwind"},D:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return b?n(3993).cpus().length:navigator.hardwareConcurrency},L:function(e,t,n,r){for(he.Hb=t>>>0,Xe.length=n,t=r>>>0>>3,r=0;r<n;r++)Xe[r]=o()[t+r>>>0];return(0>e?ae[-e-1]:$t[e]).apply(null,Xe)},z:function(e){e>>>=0;var t=r().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var i=Math;a=Math.max(e,a);e:{i=i.min.call(i,4294901760,a+(65536-a%65536)%65536)-E.buffer.byteLength+65535>>>16;try{E.grow(i),G();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},P:Ze,Q:et,k:fe,h:tt,p:nt,x:rt,o:it,y:function(e,t){return e>>>=0,t>>>=0,ot(r().subarray(e>>>0,e+t>>>0)),0},a:E||l.wasmMemory,B:ct,e:function(e,t,n,r){return ct(e>>>0,t>>>0,n>>>0,r>>>0)}};!function(){function e(e,t){return e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){gt.push(t);try{return r.apply(null,arguments)}finally{W||(gt.pop()===t||Z(),ft&&1===pt&&0===gt.length&&(pt=0,F+=1,dt(Wt),"undefined"!=typeof Fibers&&Fibers.Mb()))}}:r}(t);return n}(e=e.exports),P=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),he.eb.push(P.wa),L.unshift(P.Z),M=t,Q(),e}var t={a:xt};if(J(),l.instantiateWasm)try{return l.instantiateWasm(t,e)}catch(e){T("Module.instantiateWasm callback failed with error: "+e),u(e)}(function(e,t){var n=K;return C||"function"!=typeof WebAssembly.instantiateStreaming||ee(n)||n.startsWith("file://")||b||"function"!=typeof fetch?ne(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return T("wasm streaming compile failed: "+r),T("falling back to ArrayBuffer instantiation"),ne(n,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),l._OrtInit=(e,t)=>(l._OrtInit=P._)(e,t),l._OrtGetLastError=(e,t)=>(l._OrtGetLastError=P.$)(e,t),l._OrtCreateSessionOptions=(e,t,n,r,a,i,o,s,u,c)=>(l._OrtCreateSessionOptions=P.aa)(e,t,n,r,a,i,o,s,u,c),l._OrtAppendExecutionProvider=(e,t)=>(l._OrtAppendExecutionProvider=P.ba)(e,t),l._OrtAddSessionConfigEntry=(e,t,n)=>(l._OrtAddSessionConfigEntry=P.ca)(e,t,n),l._OrtReleaseSessionOptions=e=>(l._OrtReleaseSessionOptions=P.da)(e),l._OrtCreateSession=(e,t,n)=>(l._OrtCreateSession=P.ea)(e,t,n),l._OrtReleaseSession=e=>(l._OrtReleaseSession=P.fa)(e),l._OrtGetInputOutputCount=(e,t,n)=>(l._OrtGetInputOutputCount=P.ga)(e,t,n),l._OrtGetInputName=(e,t)=>(l._OrtGetInputName=P.ha)(e,t),l._OrtGetOutputName=(e,t)=>(l._OrtGetOutputName=P.ia)(e,t),l._OrtFree=e=>(l._OrtFree=P.ja)(e),l._OrtCreateTensor=(e,t,n,r,a)=>(l._OrtCreateTensor=P.ka)(e,t,n,r,a),l._OrtGetTensorData=(e,t,n,r,a)=>(l._OrtGetTensorData=P.la)(e,t,n,r,a),l._OrtReleaseTensor=e=>(l._OrtReleaseTensor=P.ma)(e),l._OrtCreateRunOptions=(e,t,n,r)=>(l._OrtCreateRunOptions=P.na)(e,t,n,r),l._OrtAddRunConfigEntry=(e,t,n)=>(l._OrtAddRunConfigEntry=P.oa)(e,t,n),l._OrtReleaseRunOptions=e=>(l._OrtReleaseRunOptions=P.pa)(e),l._OrtRun=(e,t,n,r,a,i,o,s)=>(l._OrtRun=P.qa)(e,t,n,r,a,i,o,s),l._OrtEndProfiling=e=>(l._OrtEndProfiling=P.ra)(e),l._JsepOutput=(e,t,n)=>(l._JsepOutput=P.sa)(e,t,n);var St=l._pthread_self=()=>(St=l._pthread_self=P.ta)(),_t=l._malloc=e=>(_t=l._malloc=P.ua)(e),At=l._free=e=>(At=l._free=P.va)(e);l.__emscripten_tls_init=()=>(l.__emscripten_tls_init=P.wa)();var Ct=l.__emscripten_thread_init=(e,t,n,r,a,i)=>(Ct=l.__emscripten_thread_init=P.ya)(e,t,n,r,a,i);l.__emscripten_thread_crashed=()=>(l.__emscripten_thread_crashed=P.za)();var Ot,Tt=(e,t,n,r)=>(Tt=P.Aa)(e,t,n,r),It=e=>(It=P.Ba)(e),Et=l.__emscripten_thread_exit=e=>(Et=l.__emscripten_thread_exit=P.Ca)(e),Pt=l.__emscripten_check_mailbox=()=>(Pt=l.__emscripten_check_mailbox=P.Da)(),Mt=e=>(Mt=P.Ea)(e),Rt=(e,t)=>(Rt=P.Fa)(e,t),kt=()=>(kt=P.Ga)(),Dt=e=>(Dt=P.Ha)(e),zt=e=>(zt=P.Ia)(e),jt=l.dynCall_ii=(e,t)=>(jt=l.dynCall_ii=P.Ka)(e,t),Bt=e=>(Bt=P.La)(e),Wt=()=>(Wt=P.Ma)(),Gt=e=>(Gt=P.Na)(e),Ut=()=>(Ut=P.Oa)();function Nt(){function e(){if(!Ot&&(Ot=!0,l.calledRun=!0,!W)&&(v||ge(L),s(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),!v)){if(l.postRun)for("function"==typeof l.postRun&&(l.postRun=[l.postRun]);l.postRun.length;){var e=l.postRun.shift();H.unshift(e)}ge(H)}}if(!(0<q))if(v)s(l),v||ge(L),startWorker(l);else{if(l.preRun)for("function"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)N.unshift(l.preRun.shift());ge(N),0<q||(l.setStatus?(l.setStatus("Running..."),setTimeout((function(){setTimeout((function(){l.setStatus("")}),1),e()}),1)):e())}}if(l.___start_em_js=908408,l.___stop_em_js=908569,l.keepRuntimeAlive=V,l.wasmMemory=E,l.stackAlloc=zt,l.stackSave=kt,l.stackRestore=Dt,l.UTF8ToString=de,l.stringToUTF8=_e,l.lengthBytesUTF8=xe,l.ExitStatus=ie,l.PThread=he,X=function e(){Ot||Nt(),Ot||(X=e)},l.preInit)for("function"==typeof l.preInit&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();return Nt(),e.ready});e.exports=r},9377:(e,t,n)=>{var _scriptDir,r=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,r,a=e;a.ready=new Promise(((e,n)=>{t=e,r=n})),a.jsepInit=function(e,t,n,r,i,o,s,u){a.Sa=e,a.Ea=t,a.Ga=n,a.Ca=r,a.Fa=i,a.la=o,a.Ha=s,a.Ia=u};var i,o,s,u=Object.assign({},a),l="./this.program",c=(e,t)=>{throw t},d="object"==typeof window,p="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(f){var g=n(1384),m=n(908);h=p?m.dirname(h)+"/":__dirname+"/",i=(e,t)=>(e=e.startsWith("file://")?new URL(e):m.normalize(e),g.readFileSync(e,t?void 0:"utf8")),s=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),o=(e,t,n,r=!0)=>{e=e.startsWith("file://")?new URL(e):m.normalize(e),g.readFile(e,r?void 0:"utf8",((e,a)=>{e?n(e):t(r?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),c=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>"[Emscripten Module object]"}else(d||p)&&(p?h=self.location.href:"undefined"!=typeof document&&document.currentScript&&(h=document.currentScript.src),_scriptDir&&(h=_scriptDir),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},p&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var y,b=a.print||console.log.bind(console),v=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(l=a.thisProgram),a.quit&&(c=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;"object"!=typeof WebAssembly&&W("no native wasm support detected");var $,x,S,_,A,C,O,T,I=!1;function E(){var e=$.buffer;a.HEAP8=_=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=C=new Int32Array(e),a.HEAPU8=A=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=O=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=T=new Float64Array(e)}var P=[],M=[],R=[];function k(){var e=a.preRun.shift();P.unshift(e)}var D,z=0,j=null,B=null;function W(e){throw a.onAbort&&a.onAbort(e),v(e="Aborted("+e+")"),I=!0,S=1,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),r(e),e}function G(e){return e.startsWith("data:application/octet-stream;base64,")}if(!G(D="ort-wasm-simd.wasm")){var U=D;D=a.locateFile?a.locateFile(U,h):h+U}function N(e){if(e==D&&y)return new Uint8Array(y);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}function L(e,t,n){return function(e){if(!y&&(d||p)){if("function"==typeof fetch&&!e.startsWith("file://"))return fetch(e,{credentials:"same-origin"}).then((t=>{if(!t.ok)throw"failed to load wasm binary file at \'"+e+"\'";return t.arrayBuffer()})).catch((()=>N(e)));if(o)return new Promise(((t,n)=>{o(e,(e=>t(new Uint8Array(e))),n)}))}return Promise.resolve().then((()=>N(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(n,(e=>{v("failed to asynchronously prepare wasm: "+e),W(e)}))}var H,F={894528:()=>{a.jsepRunPromise=new Promise((function(e){a.Ja=e}))},894623:e=>{a.Ja(e)},894661:e=>a.Ea(e),894694:e=>a.Ga(e),894726:(e,t,n)=>{a.Ca(e,t,n,!0)},894765:(e,t,n)=>{a.Ca(e,t,n)},894798:e=>{a.la("Abs",e,void 0)},894849:e=>{a.la("Neg",e,void 0)},894900:e=>{a.la("Floor",e,void 0)},894953:e=>{a.la("Ceil",e,void 0)},895005:e=>{a.la("Reciprocal",e,void 0)},895063:e=>{a.la("Sqrt",e,void 0)},895115:e=>{a.la("Exp",e,void 0)},895166:e=>{a.la("Erf",e,void 0)},895217:e=>{a.la("Sigmoid",e,void 0)},895272:e=>{a.la("Log",e,void 0)},895323:e=>{a.la("Sin",e,void 0)},895374:e=>{a.la("Cos",e,void 0)},895425:e=>{a.la("Tan",e,void 0)},895476:e=>{a.la("Asin",e,void 0)},895528:e=>{a.la("Acos",e,void 0)},895580:e=>{a.la("Atan",e,void 0)},895632:e=>{a.la("Sinh",e,void 0)},895684:e=>{a.la("Cosh",e,void 0)},895736:e=>{a.la("Asinh",e,void 0)},895789:e=>{a.la("Acosh",e,void 0)},895842:e=>{a.la("Atanh",e,void 0)},895895:e=>{a.la("Tanh",e,void 0)},895947:(e,t,n)=>{a.la("ClipV10",e,{min:t,max:n})},896019:e=>{a.la("Clip",e,void 0)},896071:(e,t)=>{a.la("Elu",e,{alpha:t})},896129:e=>{a.la("Relu",e,void 0)},896181:(e,t)=>{a.la("LeakyRelu",e,{alpha:t})},896245:(e,t)=>{a.la("ThresholdedRelu",e,{alpha:t})},896315:(e,t)=>{a.la("Cast",e,{to:t})},896373:e=>{a.la("Add",e,void 0)},896424:e=>{a.la("Sub",e,void 0)},896475:e=>{a.la("Mul",e,void 0)},896526:e=>{a.la("Div",e,void 0)},896577:e=>{a.la("Pow",e,void 0)},896628:(e,t,n,r,i)=>{a.la("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},896792:(e,t,n,r,i)=>{a.la("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},896955:(e,t,n,r,i)=>{a.la("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897118:(e,t,n,r,i)=>{a.la("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897282:(e,t,n,r,i)=>{a.la("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897445:(e,t,n,r,i)=>{a.la("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897607:(e,t,n,r,i)=>{a.la("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897769:(e,t,n,r,i)=>{a.la("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},897935:(e,t,n,r,i)=>{a.la("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},898104:(e,t,n,r,i)=>{a.la("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},898273:(e,t,n)=>{a.la("Transpose",e,{perm:t?Array.from(C.subarray(n>>>0,n+t>>>0)):[]})},898386:(e,t,n,r,i,o,s,u,l,c)=>{a.la("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!_[c>>>0]})},898614:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g)=>{a.la("Conv",e,{format:h?"NHWC":"NCHW",auto_pad:t,dilations:[n,r],group:i,kernel_shape:[o,s],pads:[u,l,c,d],strides:[p,f],w_is_const:()=>!!_[g>>>0]})},898873:(e,t,n,r,i,o,s,u,l,c)=>{a.la("Conv",e,{format:l?"NHWC":"NCHW",auto_pad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],w_is_const:()=>!!_[c>>>0]})},899101:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g)=>{a.la("Conv",e,{format:h?"NHWC":"NCHW",auto_pad:t,dilations:[n,r],group:i,kernel_shape:[o,s],pads:[u,l,c,d],strides:[p,f],w_is_const:()=>!!_[g>>>0]})},899360:(e,t,n,r,i,o,s,u,l,c,d,p,f,h)=>{a.la("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[c>>>0],outputPadding:d?Array.from(C.subarray(p>>>0,p+d>>>0)):[],outputShape:f?Array.from(C.subarray(h>>>0,h+f>>>0)):[]})},899740:(e,t,n,r,i,o,s,u,l,c,d,p,f)=>{a.la("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(C.subarray(n>>>0,n+2>>>0)),group:r,kernelShape:Array.from(C.subarray(i>>>0,i+2>>>0)),pads:Array.from(C.subarray(o>>>0,o+4>>>0)),strides:Array.from(C.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<c?Array.from(C.subarray(d>>>0,d+c>>>0)):[],outputShape:0<p?Array.from(C.subarray(f>>>0,f+p>>>0)):[]})},900263:(e,t,n,r,i,o,s,u,l,c,d,p,f,h)=>{a.la("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:[n],group:r,kernel_shape:[i],pads:[o,s],strides:[u],wIsConst:()=>!!_[c>>>0],outputPadding:d?Array.from(C.subarray(p>>>0,p+d>>>0)):[],outputShape:f?Array.from(C.subarray(h>>>0,h+f>>>0)):[]})},900643:(e,t,n,r,i,o,s,u,l,c,d,p,f)=>{a.la("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:Array.from(C.subarray(n>>>0,n+2>>>0)),group:r,kernelShape:Array.from(C.subarray(i>>>0,i+2>>>0)),pads:Array.from(C.subarray(o>>>0,o+4>>>0)),strides:Array.from(C.subarray(s>>>0,s+2>>>0)),wIsConst:()=>!!_[l>>>0],outputPadding:0<c?Array.from(C.subarray(d>>>0,d+c>>>0)):[],outputShape:0<p?Array.from(C.subarray(f>>>0,f+p>>>0)):[]})},901166:(e,t)=>{a.la("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},901257:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},901541:(e,t)=>{a.la("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},901632:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("AveragePool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},901916:(e,t)=>{a.la("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},902003:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},902283:(e,t)=>{a.la("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},902370:(e,t,n,r,i,o,s,u,l,c,d,p,f,h,g,m)=>{a.la("MaxPool",e,{format:m?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:r,storage_order:i,dilations:[o,s],kernel_shape:[u,l],pads:[c,d,p,f],strides:[h,g]})},902650:(e,t,n,r,i)=>{a.la("Gemm",e,{alpha:t,beta:n,transA:r,transB:i})},902754:e=>{a.la("MatMul",e,void 0)},902808:(e,t,n,r)=>{a.la("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},902916:(e,t,n,r)=>{a.la("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:r})},903024:(e,t)=>{a.la("Softmax",e,{axis:t})},903087:(e,t)=>{a.la("Concat",e,{axis:t})},903147:(e,t,n,r,i)=>{a.la("Split",e,{axis:t,numOutputs:n,splitSizes:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[]})},903292:e=>{a.la("Expand",e,void 0)},903346:(e,t)=>{a.la("Gather",e,{axis:Number(t)})},903417:(e,t,n,r,i,o,s,u,l,c,d)=>{a.la("Resize",e,{antialias:t,axes:n?Array.from(C.subarray(r>>>0,r+n>>>0)):[],coordinateTransformMode:Q(i),cubicCoeffA:o,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:Q(l),mode:Q(c),nearestMode:Q(d)})},903768:(e,t,n,r,i,o,s)=>{a.la("Slice",e,{starts:t?Array.from(C.subarray(n>>>0,n+t>>>0)):[],ends:r?Array.from(C.subarray(i>>>0,i+r>>>0)):[],axes:o?Array.from(C.subarray(s>>>0,s+o>>>0)):[]})},903999:e=>{a.la("Tile",e,void 0)},904051:(e,t,n)=>{a.la("LayerNormalization",e,{axis:Number(t),epsilon:Number(n)})},904158:(e,t,n)=>{a.la("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},904272:(e,t,n)=>{a.la("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},904386:e=>{a.la("Gelu",e,void 0)},904438:(e,t)=>{a.la("SkipLayerNormalization",e,{epsilon:t})},904519:e=>{a.Ha(e)},904553:(e,t)=>a.Ia(e,t)};function V(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var K=e=>{for(;0<e.length;)e.shift()(a)};function q(e){this.za=e-24,this.Ra=function(e){O[this.za+4>>2>>>0]=e},this.Qa=function(e){O[this.za+8>>2>>>0]=e},this.Ka=function(e,t){this.Pa(),this.Ra(e),this.Qa(t)},this.Pa=function(){O[this.za+16>>2>>>0]=0}}var Y,X="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,J=(e,t,n)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&X)return X.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var i=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r},Q=(e,t)=>(e>>>=0)?J(A,e,t):"",Z=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},ee=(e,t,n,r)=>{if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<e.length;++i){var o=e.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),127>=o){if(n>=r)break;t[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;t[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;t[n++>>>0]=224|o>>12}else{if(n+3>=r)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63}t[n++>>>0]=128|o>>6&63}t[n++>>>0]=128|63&o}}return t[n>>>0]=0,n-a},te=e=>0==e%4&&(0!=e%100||0==e%400),ne=[0,31,60,91,121,152,182,213,244,274,305,335],re=[0,31,59,90,120,151,181,212,243,273,304,334],ae=e=>{var t=Z(e)+1,n=Oe(t);return n&&ee(e,A,n,t),n},ie=[],oe=(e,t)=>{var n;for(ie.length=0,t>>=2;n=A[e++>>>0];)t+=105!=n&t,ie.push(105==n?C[t>>>0]:T[t++>>>1]),++t;return ie},se={},ue=()=>{if(!Y){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"};for(e in se)void 0===se[e]?delete t[e]:t[e]=se[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Y=n}return Y},le=e=>{S=e,w||(a.onExit&&a.onExit(e),I=!0),c(e,new V(e))},ce=[null,[],[]],de=e=>(de=(()=>{if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(f)try{var e=n(760);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W("initRandomDevice")})())(e),pe=[31,29,31,30,31,30,31,31,30,31,30,31],fe=[31,28,31,30,31,30,31,31,30,31,30,31];function he(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function i(e,t){return a(e,t,"0")}function o(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.va;for(e=new Date(new Date(e.wa+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?pe:fe)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=o(t,e)?0>=o(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,n>>>=0;var l=C[40+(r>>>=0)>>2>>>0];for(var c in r={Na:C[r>>2>>>0],Ma:C[r+4>>2>>>0],xa:C[r+8>>2>>>0],Ba:C[r+12>>2>>>0],ya:C[r+16>>2>>>0],wa:C[r+20>>2>>>0],qa:C[r+24>>2>>>0],va:C[r+28>>2>>>0],Ta:C[r+32>>2>>>0],La:C[r+36>>2>>>0],Oa:l?Q(l):""},n=Q(n),l={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(c,"g"),l[c]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(c in l={"%a":e=>d[e.qa].substring(0,3),"%A":e=>d[e.qa],"%b":e=>p[e.ya].substring(0,3),"%B":e=>p[e.ya],"%C":e=>i((e.wa+1900)/100|0,2),"%d":e=>i(e.Ba,2),"%e":e=>a(e.Ba,2," "),"%g":e=>u(e).toString().substring(2),"%G":e=>u(e),"%H":e=>i(e.xa,2),"%I":e=>(0==(e=e.xa)?e=12:12<e&&(e-=12),i(e,2)),"%j":e=>{for(var t=0,n=0;n<=e.ya-1;t+=(te(e.wa+1900)?pe:fe)[n++]);return i(e.Ba+t,3)},"%m":e=>i(e.ya+1,2),"%M":e=>i(e.Ma,2),"%n":()=>"\\n","%p":e=>0<=e.xa&&12>e.xa?"AM":"PM","%S":e=>i(e.Na,2),"%t":()=>"\\t","%u":e=>e.qa||7,"%U":e=>i(Math.floor((e.va+7-e.qa)/7),2),"%V":e=>{var t=Math.floor((e.va+7-(e.qa+6)%7)/7);if(2>=(e.qa+371-e.va-2)%7&&t++,t)53==t&&(4==(n=(e.qa+371-e.va)%7)||3==n&&te(e.wa)||(t=1));else{t=52;var n=(e.qa+7-e.va-1)%7;(4==n||5==n&&te(e.wa%400-1))&&t++}return i(t,2)},"%w":e=>e.qa,"%W":e=>i(Math.floor((e.va+7-(e.qa+6)%7)/7),2),"%y":e=>(e.wa+1900).toString().substring(2),"%Y":e=>e.wa+1900,"%z":e=>{var t=0<=(e=e.La);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":e=>e.Oa,"%%":()=>"%"},n=n.replace(/%%/g,"\\0\\0"),l)n.includes(c)&&(n=n.replace(new RegExp(c,"g"),l[c](r)));return c=function(e){var t=Array(Z(e)+1);return ee(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),c.length>t?0:(_.set(c,e>>>0),c.length-1)}function ge(e){try{e()}catch(e){W(e)}}var me=0,ye=null,be=0,ve=[],we={},$e={},xe=0,Se=null,_e=[];var Ae={o:function(e,t,n){return function(e){return function(e){if(!I){if(0===me){var t=!1,n=!1;e(((e=0)=>{if(!I&&(be=e,t=!0,n)){me=2,ge((()=>De(ye))),"undefined"!=typeof Browser&&Browser.Aa.Da&&Browser.Aa.resume(),e=!1;try{var r=(0,x[$e[C[ye+8>>2>>>0]]])()}catch(t){r=t,e=!0}var a=!1;if(!ye){var i=Se;i&&(Se=null,(e?i.reject:i.resolve)(r),a=!0)}if(e&&!a)throw r}})),n=!0,t||(me=1,ye=function(){var e=Oe(65548),t=e+12;O[e>>2>>>0]=t,O[e+4>>2>>>0]=t+65536,t=ve[0];var n=we[t];return void 0===n&&(n=xe++,we[t]=n,$e[n]=t),C[e+8>>2>>>0]=n,e}(),"undefined"!=typeof Browser&&Browser.Aa.Da&&Browser.Aa.pause(),ge((()=>Re(ye))))}else 2===me?(me=0,ge(ze),Te(ye),ye=null,_e.forEach((e=>{if(!I)try{if(e(),!w)try{S=e=S,le(e)}catch(e){e instanceof V||"unwind"==e||c(1,e)}}catch(e){e instanceof V||"unwind"==e||c(1,e)}}))):W(`invalid state: ${me}`);return be}}((t=>{e().then(t)}))}((async()=>{await a.Fa(e,t,n)}))},a:function(e,t,n){throw new q(e>>>=0).Ka(t>>>0,n>>>0),e},g:function(){return 0},L:function(){},C:function(){},E:function(){},N:function(){return 0},J:function(){},F:function(){},I:function(){},l:function(){},D:function(){},A:function(){},K:function(){},B:function(){},m:()=>!0,r:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),C[n>>2>>>0]=e.getUTCSeconds(),C[n+4>>2>>>0]=e.getUTCMinutes(),C[n+8>>2>>>0]=e.getUTCHours(),C[n+12>>2>>>0]=e.getUTCDate(),C[n+16>>2>>>0]=e.getUTCMonth(),C[n+20>>2>>>0]=e.getUTCFullYear()-1900,C[n+24>>2>>>0]=e.getUTCDay(),C[n+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},s:function(e,t,n){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,n>>>=0,e=new Date(1e3*e),C[n>>2>>>0]=e.getSeconds(),C[n+4>>2>>>0]=e.getMinutes(),C[n+8>>2>>>0]=e.getHours(),C[n+12>>2>>>0]=e.getDate(),C[n+16>>2>>>0]=e.getMonth(),C[n+20>>2>>>0]=e.getFullYear()-1900,C[n+24>>2>>>0]=e.getDay(),C[n+28>>2>>>0]=(te(e.getFullYear())?ne:re)[e.getMonth()]+e.getDate()-1|0,C[n+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();C[n+32>>2>>>0]=0|(t!=r&&e.getTimezoneOffset()==Math.min(r,t))},t:function(e){e>>>=0;var t=new Date(C[e+20>>2>>>0]+1900,C[e+16>>2>>>0],C[e+12>>2>>>0],C[e+8>>2>>>0],C[e+4>>2>>>0],C[e>>2>>>0],0),n=C[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=new Date(t.getFullYear(),0,1).getTimezoneOffset(),o=Math.min(i,a);return 0>n?C[e+32>>2>>>0]=Number(a!=i&&o==r):0<n!=(o==r)&&(a=Math.max(i,a),t.setTime(t.getTime()+6e4*((0<n?o:a)-r))),C[e+24>>2>>>0]=t.getDay(),C[e+28>>2>>>0]=(te(t.getFullYear())?ne:re)[t.getMonth()]+t.getDate()-1|0,C[e>>2>>>0]=t.getSeconds(),C[e+4>>2>>>0]=t.getMinutes(),C[e+8>>2>>>0]=t.getHours(),C[e+12>>2>>>0]=t.getDate(),C[e+16>>2>>>0]=t.getMonth(),C[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,Ie((H=e,1<=+Math.abs(H)?0<H?+Math.floor(H/4294967296)>>>0:~~+Math.ceil((H-+(~~H>>>0))/4294967296)>>>0:0)),e>>>0},p:function(){return-52},q:function(){},x:function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}n>>>=0;var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var s=o.getTimezoneOffset();O[e>>>0>>2>>>0]=60*Math.max(a,s),C[t>>>0>>2>>>0]=Number(a!=s),e=r(i),t=r(o),e=ae(e),t=ae(t),s<a?(O[n>>2>>>0]=e,O[n+4>>2>>>0]=t):(O[n>>2>>>0]=t,O[n+4>>2>>>0]=e)},e:()=>{W("")},b:function(e,t,n){return e>>>=0,t=oe(t>>>0,n>>>0),F[e].apply(null,t)},i:function(e,t,n){return e>>>=0,t=oe(t>>>0,n>>>0),F[e].apply(null,t)},h:function(){return Date.now()},z:function(){return 4294901760},d:()=>performance.now(),M:function(e,t,n){return t>>>=0,A.copyWithin(e>>>0>>>0,t>>>0,t+(n>>>0)>>>0)},w:function(e){e>>>=0;var t=A.length;if(4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r);e:{a=a.min.call(a,4294901760,r+(65536-r%65536)%65536)-$.buffer.byteLength+65535>>>16;try{$.grow(a),E();var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},G:function(e,t){e>>>=0,t>>>=0;var n=0;return ue().forEach((function(r,a){var i=t+n;for(a=O[e+4*a>>2>>>0]=i,i=0;i<r.length;++i)_[a++>>0>>>0]=r.charCodeAt(i);_[a>>0>>>0]=0,n+=r.length+1})),0},H:function(e,t){e>>>=0,t>>>=0;var n=ue();O[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),O[t>>2>>>0]=r,0},n:e=>{S=e,le(e)},f:()=>52,k:function(){return 52},u:function(){return 70},j:function(e,t,n,r){t>>>=0,n>>>=0,r>>>=0;for(var a=0,i=0;i<n;i++){var o=O[t>>2>>>0],s=O[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var l=A[o+u>>>0],c=ce[e];0===l||10===l?((1===e?b:v)(J(c,0)),c.length=0):c.push(l)}a+=s}return O[r>>2>>>0]=a,0},v:function(e,t){return e>>>=0,de(A.subarray(e>>>0,e+(t>>>0)>>>0)),0},y:he,c:function(e,t,n,r){return he(e>>>0,t>>>0,n>>>0,r>>>0)}};!function(){function e(e){if(e=function(e){var t,n={};for(t in e)!function(t){var r=e[t];n[t]="function"==typeof r?function(){ve.push(t);try{return r.apply(null,arguments)}finally{I||(ve.pop()===t||W(),ye&&1===me&&0===ve.length&&(me=0,ge(ke),"undefined"!=typeof Fibers&&Fibers.Ua()))}}:r}(t);return n}(e=e.exports),x=e=function(e){var t=e=>()=>e()>>>0,n=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=n(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=n(e.stackAlloc),e}(e),$=x.O,E(),M.unshift(x.P),z--,a.monitorRunDependencies&&a.monitorRunDependencies(z),0==z&&(null!==j&&(clearInterval(j),j=null),B)){var t=B;B=null,t()}return e}var t={a:Ae};if(z++,a.monitorRunDependencies&&a.monitorRunDependencies(z),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){v("Module.instantiateWasm callback failed with error: "+e),r(e)}(function(e,t){var n=D;return y||"function"!=typeof WebAssembly.instantiateStreaming||G(n)||n.startsWith("file://")||f||"function"!=typeof fetch?L(n,e,t):fetch(n,{credentials:"same-origin"}).then((r=>WebAssembly.instantiateStreaming(r,e).then(t,(function(r){return v("wasm streaming compile failed: "+r),v("falling back to ArrayBuffer instantiation"),L(n,e,t)}))))})(t,(function(t){e(t.instance)})).catch(r)}(),a._OrtInit=(e,t)=>(a._OrtInit=x.Q)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=x.R)(e,t),a._OrtCreateSessionOptions=(e,t,n,r,i,o,s,u,l,c)=>(a._OrtCreateSessionOptions=x.S)(e,t,n,r,i,o,s,u,l,c),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=x.T)(e,t),a._OrtAddSessionConfigEntry=(e,t,n)=>(a._OrtAddSessionConfigEntry=x.U)(e,t,n),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=x.V)(e),a._OrtCreateSession=(e,t,n)=>(a._OrtCreateSession=x.W)(e,t,n),a._OrtReleaseSession=e=>(a._OrtReleaseSession=x.X)(e),a._OrtGetInputOutputCount=(e,t,n)=>(a._OrtGetInputOutputCount=x.Y)(e,t,n),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=x.Z)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=x._)(e,t),a._OrtFree=e=>(a._OrtFree=x.$)(e),a._OrtCreateTensor=(e,t,n,r,i)=>(a._OrtCreateTensor=x.aa)(e,t,n,r,i),a._OrtGetTensorData=(e,t,n,r,i)=>(a._OrtGetTensorData=x.ba)(e,t,n,r,i),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=x.ca)(e),a._OrtCreateRunOptions=(e,t,n,r)=>(a._OrtCreateRunOptions=x.da)(e,t,n,r),a._OrtAddRunConfigEntry=(e,t,n)=>(a._OrtAddRunConfigEntry=x.ea)(e,t,n),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=x.fa)(e),a._OrtRun=(e,t,n,r,i,o,s,u)=>(a._OrtRun=x.ga)(e,t,n,r,i,o,s,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=x.ha)(e),a._JsepOutput=(e,t,n)=>(a._JsepOutput=x.ia)(e,t,n);var Ce,Oe=a._malloc=e=>(Oe=a._malloc=x.ja)(e),Te=a._free=e=>(Te=a._free=x.ka)(e),Ie=e=>(Ie=x.ma)(e),Ee=()=>(Ee=x.na)(),Pe=e=>(Pe=x.oa)(e),Me=e=>(Me=x.pa)(e),Re=e=>(Re=x.ra)(e),ke=()=>(ke=x.sa)(),De=e=>(De=x.ta)(e),ze=()=>(ze=x.ua)();function je(){function e(){if(!Ce&&(Ce=!0,a.calledRun=!0,!I)){if(K(M),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for("function"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();R.unshift(e)}K(R)}}if(!(0<z)){if(a.preRun)for("function"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)k();K(P),0<z||(a.setStatus?(a.setStatus("Running..."),setTimeout((function(){setTimeout((function(){a.setStatus("")}),1),e()}),1)):e())}}if(a.___start_em_js=904588,a.___stop_em_js=904749,a.stackAlloc=Me,a.stackSave=Ee,a.stackRestore=Pe,a.UTF8ToString=Q,a.stringToUTF8=(e,t,n)=>ee(e,A,t,n),a.lengthBytesUTF8=Z,B=function e(){Ce||je(),Ce||(B=e)},a.preInit)for("function"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return je(),e.ready});e.exports=r},4154:e=>{"use strict";e.exports=\'"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n\'},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},6449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var i=t[r]={exports:{}};return e[r].call(i.exports,i,i.exports,n),i.exports}(()=>{"use strict";const e=n(1259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":try{(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})))}catch(e){postMessage({type:"init-wasm",err:e})}break;case"init-ort":try{(0,e.initRuntime)(n.data.in).then((()=>postMessage({type:"init-ort"})),(e=>postMessage({type:"init-ort",err:e}))),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in;(0,e.run)(t,r,a,i,o).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:M=>{"use strict";M.exports=function(c,y,m,f){var h=self||window;try{try{var p;try{p=new h.Blob([c])}catch{(p=new(h.BlobBuilder||h.WebKitBlobBuilder||h.MozBlobBuilder||h.MSBlobBuilder)).append(c),p=p.getBlob()}var u=h.URL||h.webkitURL,s=u.createObjectURL(p),a=new h[y](s,m);return u.revokeObjectURL(s),a}catch{return new h[y]("data:application/javascript,".concat(encodeURIComponent(c)),m)}}catch{if(!f)throw Error("Inline worker is not supported");return new h[y](f,m)}}},2446:(M,c,y)=>{"use strict";var m,f,h,p=y(2100),u=p.Reader,s=p.Writer,a=p.util,o=p.roots.default||(p.roots.default={});o.onnx=((h={}).Version=(m={},(f=Object.create(m))[m[0]="_START_VERSION"]=0,f[m[1]="IR_VERSION_2017_10_10"]=1,f[m[2]="IR_VERSION_2017_10_30"]=2,f[m[3]="IR_VERSION_2017_11_3"]=3,f[m[4]="IR_VERSION_2019_1_22"]=4,f[m[5]="IR_VERSION_2019_3_18"]=5,f[m[6]="IR_VERSION_2019_9_19"]=6,f[m[7]="IR_VERSION_2020_5_8"]=7,f[m[8]="IR_VERSION_2021_7_30"]=8,f[m[9]="IR_VERSION"]=9,f),h.AttributeProto=function(){function n(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.name="",n.prototype.refAttrName="",n.prototype.docString="",n.prototype.type=0,n.prototype.f=0,n.prototype.i=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.s=a.newBuffer([]),n.prototype.t=null,n.prototype.g=null,n.prototype.sparseTensor=null,n.prototype.tp=null,n.prototype.floats=a.emptyArray,n.prototype.ints=a.emptyArray,n.prototype.strings=a.emptyArray,n.prototype.tensors=a.emptyArray,n.prototype.graphs=a.emptyArray,n.prototype.sparseTensors=a.emptyArray,n.prototype.typeProtos=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(10).string(e.name),e.f!=null&&Object.hasOwnProperty.call(e,"f")&&t.uint32(21).float(e.f),e.i!=null&&Object.hasOwnProperty.call(e,"i")&&t.uint32(24).int64(e.i),e.s!=null&&Object.hasOwnProperty.call(e,"s")&&t.uint32(34).bytes(e.s),e.t!=null&&Object.hasOwnProperty.call(e,"t")&&o.onnx.TensorProto.encode(e.t,t.uint32(42).fork()).ldelim(),e.g!=null&&Object.hasOwnProperty.call(e,"g")&&o.onnx.GraphProto.encode(e.g,t.uint32(50).fork()).ldelim(),e.floats!=null&&e.floats.length){t.uint32(58).fork();for(var r=0;r<e.floats.length;++r)t.float(e.floats[r]);t.ldelim()}if(e.ints!=null&&e.ints.length){for(t.uint32(66).fork(),r=0;r<e.ints.length;++r)t.int64(e.ints[r]);t.ldelim()}if(e.strings!=null&&e.strings.length)for(r=0;r<e.strings.length;++r)t.uint32(74).bytes(e.strings[r]);if(e.tensors!=null&&e.tensors.length)for(r=0;r<e.tensors.length;++r)o.onnx.TensorProto.encode(e.tensors[r],t.uint32(82).fork()).ldelim();if(e.graphs!=null&&e.graphs.length)for(r=0;r<e.graphs.length;++r)o.onnx.GraphProto.encode(e.graphs[r],t.uint32(90).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(106).string(e.docString),e.tp!=null&&Object.hasOwnProperty.call(e,"tp")&&o.onnx.TypeProto.encode(e.tp,t.uint32(114).fork()).ldelim(),e.typeProtos!=null&&e.typeProtos.length)for(r=0;r<e.typeProtos.length;++r)o.onnx.TypeProto.encode(e.typeProtos[r],t.uint32(122).fork()).ldelim();if(e.type!=null&&Object.hasOwnProperty.call(e,"type")&&t.uint32(160).int32(e.type),e.refAttrName!=null&&Object.hasOwnProperty.call(e,"refAttrName")&&t.uint32(170).string(e.refAttrName),e.sparseTensor!=null&&Object.hasOwnProperty.call(e,"sparseTensor")&&o.onnx.SparseTensorProto.encode(e.sparseTensor,t.uint32(178).fork()).ldelim(),e.sparseTensors!=null&&e.sparseTensors.length)for(r=0;r<e.sparseTensors.length;++r)o.onnx.SparseTensorProto.encode(e.sparseTensors[r],t.uint32(186).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.AttributeProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.name=e.string();break;case 21:i.refAttrName=e.string();break;case 13:i.docString=e.string();break;case 20:i.type=e.int32();break;case 2:i.f=e.float();break;case 3:i.i=e.int64();break;case 4:i.s=e.bytes();break;case 5:i.t=o.onnx.TensorProto.decode(e,e.uint32());break;case 6:i.g=o.onnx.GraphProto.decode(e,e.uint32());break;case 22:i.sparseTensor=o.onnx.SparseTensorProto.decode(e,e.uint32());break;case 14:i.tp=o.onnx.TypeProto.decode(e,e.uint32());break;case 7:if(i.floats&&i.floats.length||(i.floats=[]),(7&l)==2)for(var d=e.uint32()+e.pos;e.pos<d;)i.floats.push(e.float());else i.floats.push(e.float());break;case 8:if(i.ints&&i.ints.length||(i.ints=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.ints.push(e.int64());else i.ints.push(e.int64());break;case 9:i.strings&&i.strings.length||(i.strings=[]),i.strings.push(e.bytes());break;case 10:i.tensors&&i.tensors.length||(i.tensors=[]),i.tensors.push(o.onnx.TensorProto.decode(e,e.uint32()));break;case 11:i.graphs&&i.graphs.length||(i.graphs=[]),i.graphs.push(o.onnx.GraphProto.decode(e,e.uint32()));break;case 23:i.sparseTensors&&i.sparseTensors.length||(i.sparseTensors=[]),i.sparseTensors.push(o.onnx.SparseTensorProto.decode(e,e.uint32()));break;case 15:i.typeProtos&&i.typeProtos.length||(i.typeProtos=[]),i.typeProtos.push(o.onnx.TypeProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&!a.isString(e.refAttrName))return"refAttrName: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.type!=null&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:}if(e.f!=null&&e.hasOwnProperty("f")&&typeof e.f!="number")return"f: number expected";if(e.i!=null&&e.hasOwnProperty("i")&&!(a.isInteger(e.i)||e.i&&a.isInteger(e.i.low)&&a.isInteger(e.i.high)))return"i: integer|Long expected";if(e.s!=null&&e.hasOwnProperty("s")&&!(e.s&&typeof e.s.length=="number"||a.isString(e.s)))return"s: buffer expected";if(e.t!=null&&e.hasOwnProperty("t")&&(r=o.onnx.TensorProto.verify(e.t)))return"t."+r;if(e.g!=null&&e.hasOwnProperty("g")&&(r=o.onnx.GraphProto.verify(e.g)))return"g."+r;if(e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")&&(r=o.onnx.SparseTensorProto.verify(e.sparseTensor)))return"sparseTensor."+r;if(e.tp!=null&&e.hasOwnProperty("tp")&&(r=o.onnx.TypeProto.verify(e.tp)))return"tp."+r;if(e.floats!=null&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var t=0;t<e.floats.length;++t)if(typeof e.floats[t]!="number")return"floats: number[] expected"}if(e.ints!=null&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(t=0;t<e.ints.length;++t)if(!(a.isInteger(e.ints[t])||e.ints[t]&&a.isInteger(e.ints[t].low)&&a.isInteger(e.ints[t].high)))return"ints: integer|Long[] expected"}if(e.strings!=null&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(t=0;t<e.strings.length;++t)if(!(e.strings[t]&&typeof e.strings[t].length=="number"||a.isString(e.strings[t])))return"strings: buffer[] expected"}if(e.tensors!=null&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(t=0;t<e.tensors.length;++t)if(r=o.onnx.TensorProto.verify(e.tensors[t]))return"tensors."+r}if(e.graphs!=null&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(t=0;t<e.graphs.length;++t)if(r=o.onnx.GraphProto.verify(e.graphs[t]))return"graphs."+r}if(e.sparseTensors!=null&&e.hasOwnProperty("sparseTensors")){if(!Array.isArray(e.sparseTensors))return"sparseTensors: array expected";for(t=0;t<e.sparseTensors.length;++t)if(r=o.onnx.SparseTensorProto.verify(e.sparseTensors[t]))return"sparseTensors."+r}if(e.typeProtos!=null&&e.hasOwnProperty("typeProtos")){if(!Array.isArray(e.typeProtos))return"typeProtos: array expected";for(t=0;t<e.typeProtos.length;++t){var r;if(r=o.onnx.TypeProto.verify(e.typeProtos[t]))return"typeProtos."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.AttributeProto)return e;var t=new o.onnx.AttributeProto;switch(e.name!=null&&(t.name=String(e.name)),e.refAttrName!=null&&(t.refAttrName=String(e.refAttrName)),e.docString!=null&&(t.docString=String(e.docString)),e.type){default:if(typeof e.type=="number"){t.type=e.type;break}break;case"UNDEFINED":case 0:t.type=0;break;case"FLOAT":case 1:t.type=1;break;case"INT":case 2:t.type=2;break;case"STRING":case 3:t.type=3;break;case"TENSOR":case 4:t.type=4;break;case"GRAPH":case 5:t.type=5;break;case"SPARSE_TENSOR":case 11:t.type=11;break;case"TYPE_PROTO":case 13:t.type=13;break;case"FLOATS":case 6:t.type=6;break;case"INTS":case 7:t.type=7;break;case"STRINGS":case 8:t.type=8;break;case"TENSORS":case 9:t.type=9;break;case"GRAPHS":case 10:t.type=10;break;case"SPARSE_TENSORS":case 12:t.type=12;break;case"TYPE_PROTOS":case 14:t.type=14}if(e.f!=null&&(t.f=Number(e.f)),e.i!=null&&(a.Long?(t.i=a.Long.fromValue(e.i)).unsigned=!1:typeof e.i=="string"?t.i=parseInt(e.i,10):typeof e.i=="number"?t.i=e.i:typeof e.i=="object"&&(t.i=new a.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),e.s!=null&&(typeof e.s=="string"?a.base64.decode(e.s,t.s=a.newBuffer(a.base64.length(e.s)),0):e.s.length>=0&&(t.s=e.s)),e.t!=null){if(typeof e.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");t.t=o.onnx.TensorProto.fromObject(e.t)}if(e.g!=null){if(typeof e.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");t.g=o.onnx.GraphProto.fromObject(e.g)}if(e.sparseTensor!=null){if(typeof e.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");t.sparseTensor=o.onnx.SparseTensorProto.fromObject(e.sparseTensor)}if(e.tp!=null){if(typeof e.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");t.tp=o.onnx.TypeProto.fromObject(e.tp)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");t.floats=[];for(var r=0;r<e.floats.length;++r)t.floats[r]=Number(e.floats[r])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(t.ints=[],r=0;r<e.ints.length;++r)a.Long?(t.ints[r]=a.Long.fromValue(e.ints[r])).unsigned=!1:typeof e.ints[r]=="string"?t.ints[r]=parseInt(e.ints[r],10):typeof e.ints[r]=="number"?t.ints[r]=e.ints[r]:typeof e.ints[r]=="object"&&(t.ints[r]=new a.LongBits(e.ints[r].low>>>0,e.ints[r].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(t.strings=[],r=0;r<e.strings.length;++r)typeof e.strings[r]=="string"?a.base64.decode(e.strings[r],t.strings[r]=a.newBuffer(a.base64.length(e.strings[r])),0):e.strings[r].length>=0&&(t.strings[r]=e.strings[r])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(t.tensors=[],r=0;r<e.tensors.length;++r){if(typeof e.tensors[r]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");t.tensors[r]=o.onnx.TensorProto.fromObject(e.tensors[r])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(t.graphs=[],r=0;r<e.graphs.length;++r){if(typeof e.graphs[r]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");t.graphs[r]=o.onnx.GraphProto.fromObject(e.graphs[r])}}if(e.sparseTensors){if(!Array.isArray(e.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");for(t.sparseTensors=[],r=0;r<e.sparseTensors.length;++r){if(typeof e.sparseTensors[r]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");t.sparseTensors[r]=o.onnx.SparseTensorProto.fromObject(e.sparseTensors[r])}}if(e.typeProtos){if(!Array.isArray(e.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");for(t.typeProtos=[],r=0;r<e.typeProtos.length;++r){if(typeof e.typeProtos[r]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");t.typeProtos[r]=o.onnx.TypeProto.fromObject(e.typeProtos[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.floats=[],r.ints=[],r.strings=[],r.tensors=[],r.graphs=[],r.typeProtos=[],r.sparseTensors=[]),t.defaults){if(r.name="",r.f=0,a.Long){var i=new a.Long(0,0,!1);r.i=t.longs===String?i.toString():t.longs===Number?i.toNumber():i}else r.i=t.longs===String?"0":0;t.bytes===String?r.s="":(r.s=[],t.bytes!==Array&&(r.s=a.newBuffer(r.s))),r.t=null,r.g=null,r.docString="",r.tp=null,r.type=t.enums===String?"UNDEFINED":0,r.refAttrName="",r.sparseTensor=null}if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.f!=null&&e.hasOwnProperty("f")&&(r.f=t.json&&!isFinite(e.f)?String(e.f):e.f),e.i!=null&&e.hasOwnProperty("i")&&(typeof e.i=="number"?r.i=t.longs===String?String(e.i):e.i:r.i=t.longs===String?a.Long.prototype.toString.call(e.i):t.longs===Number?new a.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),e.s!=null&&e.hasOwnProperty("s")&&(r.s=t.bytes===String?a.base64.encode(e.s,0,e.s.length):t.bytes===Array?Array.prototype.slice.call(e.s):e.s),e.t!=null&&e.hasOwnProperty("t")&&(r.t=o.onnx.TensorProto.toObject(e.t,t)),e.g!=null&&e.hasOwnProperty("g")&&(r.g=o.onnx.GraphProto.toObject(e.g,t)),e.floats&&e.floats.length){r.floats=[];for(var l=0;l<e.floats.length;++l)r.floats[l]=t.json&&!isFinite(e.floats[l])?String(e.floats[l]):e.floats[l]}if(e.ints&&e.ints.length)for(r.ints=[],l=0;l<e.ints.length;++l)typeof e.ints[l]=="number"?r.ints[l]=t.longs===String?String(e.ints[l]):e.ints[l]:r.ints[l]=t.longs===String?a.Long.prototype.toString.call(e.ints[l]):t.longs===Number?new a.LongBits(e.ints[l].low>>>0,e.ints[l].high>>>0).toNumber():e.ints[l];if(e.strings&&e.strings.length)for(r.strings=[],l=0;l<e.strings.length;++l)r.strings[l]=t.bytes===String?a.base64.encode(e.strings[l],0,e.strings[l].length):t.bytes===Array?Array.prototype.slice.call(e.strings[l]):e.strings[l];if(e.tensors&&e.tensors.length)for(r.tensors=[],l=0;l<e.tensors.length;++l)r.tensors[l]=o.onnx.TensorProto.toObject(e.tensors[l],t);if(e.graphs&&e.graphs.length)for(r.graphs=[],l=0;l<e.graphs.length;++l)r.graphs[l]=o.onnx.GraphProto.toObject(e.graphs[l],t);if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.tp!=null&&e.hasOwnProperty("tp")&&(r.tp=o.onnx.TypeProto.toObject(e.tp,t)),e.typeProtos&&e.typeProtos.length)for(r.typeProtos=[],l=0;l<e.typeProtos.length;++l)r.typeProtos[l]=o.onnx.TypeProto.toObject(e.typeProtos[l],t);if(e.type!=null&&e.hasOwnProperty("type")&&(r.type=t.enums===String?o.onnx.AttributeProto.AttributeType[e.type]===void 0?e.type:o.onnx.AttributeProto.AttributeType[e.type]:e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&(r.refAttrName=e.refAttrName),e.sparseTensor!=null&&e.hasOwnProperty("sparseTensor")&&(r.sparseTensor=o.onnx.SparseTensorProto.toObject(e.sparseTensor,t)),e.sparseTensors&&e.sparseTensors.length)for(r.sparseTensors=[],l=0;l<e.sparseTensors.length;++l)r.sparseTensors[l]=o.onnx.SparseTensorProto.toObject(e.sparseTensors[l],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.AttributeProto"},n.AttributeType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="INT"]=2,t[e[3]="STRING"]=3,t[e[4]="TENSOR"]=4,t[e[5]="GRAPH"]=5,t[e[11]="SPARSE_TENSOR"]=11,t[e[13]="TYPE_PROTO"]=13,t[e[6]="FLOATS"]=6,t[e[7]="INTS"]=7,t[e[8]="STRINGS"]=8,t[e[9]="TENSORS"]=9,t[e[10]="GRAPHS"]=10,t[e[12]="SPARSE_TENSORS"]=12,t[e[14]="TYPE_PROTOS"]=14,t}(),n}(),h.ValueInfoProto=function(){function n(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.name="",n.prototype.type=null,n.prototype.docString="",n.create=function(e){return new n(e)},n.encode=function(e,t){return t||(t=s.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(10).string(e.name),e.type!=null&&Object.hasOwnProperty.call(e,"type")&&o.onnx.TypeProto.encode(e.type,t.uint32(18).fork()).ldelim(),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(26).string(e.docString),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.ValueInfoProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.name=e.string();break;case 2:i.type=o.onnx.TypeProto.decode(e,e.uint32());break;case 3:i.docString=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.type!=null&&e.hasOwnProperty("type")){var t=o.onnx.TypeProto.verify(e.type);if(t)return"type."+t}return e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString)?"docString: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.ValueInfoProto)return e;var t=new o.onnx.ValueInfoProto;if(e.name!=null&&(t.name=String(e.name)),e.type!=null){if(typeof e.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");t.type=o.onnx.TypeProto.fromObject(e.type)}return e.docString!=null&&(t.docString=String(e.docString)),t},n.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.name="",r.type=null,r.docString=""),e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.type!=null&&e.hasOwnProperty("type")&&(r.type=o.onnx.TypeProto.toObject(e.type,t)),e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ValueInfoProto"},n}(),h.NodeProto=function(){function n(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.name="",n.prototype.opType="",n.prototype.domain="",n.prototype.attribute=a.emptyArray,n.prototype.docString="",n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.input!=null&&e.input.length)for(var r=0;r<e.input.length;++r)t.uint32(10).string(e.input[r]);if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)t.uint32(18).string(e.output[r]);if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(26).string(e.name),e.opType!=null&&Object.hasOwnProperty.call(e,"opType")&&t.uint32(34).string(e.opType),e.attribute!=null&&e.attribute.length)for(r=0;r<e.attribute.length;++r)o.onnx.AttributeProto.encode(e.attribute[r],t.uint32(42).fork()).ldelim();return e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(50).string(e.docString),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(58).string(e.domain),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.NodeProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.input&&i.input.length||(i.input=[]),i.input.push(e.string());break;case 2:i.output&&i.output.length||(i.output=[]),i.output.push(e.string());break;case 3:i.name=e.string();break;case 4:i.opType=e.string();break;case 7:i.domain=e.string();break;case 5:i.attribute&&i.attribute.length||(i.attribute=[]),i.attribute.push(o.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:i.docString=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!a.isString(e.input[t]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!a.isString(e.output[t]))return"output: string[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.opType!=null&&e.hasOwnProperty("opType")&&!a.isString(e.opType))return"opType: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain))return"domain: string expected";if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t){var r=o.onnx.AttributeProto.verify(e.attribute[t]);if(r)return"attribute."+r}}return e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString)?"docString: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.NodeProto)return e;var t=new o.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");t.input=[];for(var r=0;r<e.input.length;++r)t.input[r]=String(e.input[r])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r)t.output[r]=String(e.output[r])}if(e.name!=null&&(t.name=String(e.name)),e.opType!=null&&(t.opType=String(e.opType)),e.domain!=null&&(t.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(t.attribute=[],r=0;r<e.attribute.length;++r){if(typeof e.attribute[r]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");t.attribute[r]=o.onnx.AttributeProto.fromObject(e.attribute[r])}}return e.docString!=null&&(t.docString=String(e.docString)),t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.input=[],r.output=[],r.attribute=[]),t.defaults&&(r.name="",r.opType="",r.docString="",r.domain=""),e.input&&e.input.length){r.input=[];for(var i=0;i<e.input.length;++i)r.input[i]=e.input[i]}if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=e.output[i];if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.opType!=null&&e.hasOwnProperty("opType")&&(r.opType=e.opType),e.attribute&&e.attribute.length)for(r.attribute=[],i=0;i<e.attribute.length;++i)r.attribute[i]=o.onnx.AttributeProto.toObject(e.attribute[i],t);return e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.NodeProto"},n}(),h.TrainingInfoProto=function(){function n(e){if(this.initializationBinding=[],this.updateBinding=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.initialization=null,n.prototype.algorithm=null,n.prototype.initializationBinding=a.emptyArray,n.prototype.updateBinding=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.initialization!=null&&Object.hasOwnProperty.call(e,"initialization")&&o.onnx.GraphProto.encode(e.initialization,t.uint32(10).fork()).ldelim(),e.algorithm!=null&&Object.hasOwnProperty.call(e,"algorithm")&&o.onnx.GraphProto.encode(e.algorithm,t.uint32(18).fork()).ldelim(),e.initializationBinding!=null&&e.initializationBinding.length)for(var r=0;r<e.initializationBinding.length;++r)o.onnx.StringStringEntryProto.encode(e.initializationBinding[r],t.uint32(26).fork()).ldelim();if(e.updateBinding!=null&&e.updateBinding.length)for(r=0;r<e.updateBinding.length;++r)o.onnx.StringStringEntryProto.encode(e.updateBinding[r],t.uint32(34).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TrainingInfoProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.initialization=o.onnx.GraphProto.decode(e,e.uint32());break;case 2:i.algorithm=o.onnx.GraphProto.decode(e,e.uint32());break;case 3:i.initializationBinding&&i.initializationBinding.length||(i.initializationBinding=[]),i.initializationBinding.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 4:i.updateBinding&&i.updateBinding.length||(i.updateBinding=[]),i.updateBinding.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.initialization!=null&&e.hasOwnProperty("initialization")&&(r=o.onnx.GraphProto.verify(e.initialization)))return"initialization."+r;if(e.algorithm!=null&&e.hasOwnProperty("algorithm")&&(r=o.onnx.GraphProto.verify(e.algorithm)))return"algorithm."+r;if(e.initializationBinding!=null&&e.hasOwnProperty("initializationBinding")){if(!Array.isArray(e.initializationBinding))return"initializationBinding: array expected";for(var t=0;t<e.initializationBinding.length;++t)if(r=o.onnx.StringStringEntryProto.verify(e.initializationBinding[t]))return"initializationBinding."+r}if(e.updateBinding!=null&&e.hasOwnProperty("updateBinding")){if(!Array.isArray(e.updateBinding))return"updateBinding: array expected";for(t=0;t<e.updateBinding.length;++t){var r;if(r=o.onnx.StringStringEntryProto.verify(e.updateBinding[t]))return"updateBinding."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.TrainingInfoProto)return e;var t=new o.onnx.TrainingInfoProto;if(e.initialization!=null){if(typeof e.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");t.initialization=o.onnx.GraphProto.fromObject(e.initialization)}if(e.algorithm!=null){if(typeof e.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");t.algorithm=o.onnx.GraphProto.fromObject(e.algorithm)}if(e.initializationBinding){if(!Array.isArray(e.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");t.initializationBinding=[];for(var r=0;r<e.initializationBinding.length;++r){if(typeof e.initializationBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");t.initializationBinding[r]=o.onnx.StringStringEntryProto.fromObject(e.initializationBinding[r])}}if(e.updateBinding){if(!Array.isArray(e.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");for(t.updateBinding=[],r=0;r<e.updateBinding.length;++r){if(typeof e.updateBinding[r]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");t.updateBinding[r]=o.onnx.StringStringEntryProto.fromObject(e.updateBinding[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.initializationBinding=[],r.updateBinding=[]),t.defaults&&(r.initialization=null,r.algorithm=null),e.initialization!=null&&e.hasOwnProperty("initialization")&&(r.initialization=o.onnx.GraphProto.toObject(e.initialization,t)),e.algorithm!=null&&e.hasOwnProperty("algorithm")&&(r.algorithm=o.onnx.GraphProto.toObject(e.algorithm,t)),e.initializationBinding&&e.initializationBinding.length){r.initializationBinding=[];for(var i=0;i<e.initializationBinding.length;++i)r.initializationBinding[i]=o.onnx.StringStringEntryProto.toObject(e.initializationBinding[i],t)}if(e.updateBinding&&e.updateBinding.length)for(r.updateBinding=[],i=0;i<e.updateBinding.length;++i)r.updateBinding[i]=o.onnx.StringStringEntryProto.toObject(e.updateBinding[i],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TrainingInfoProto"},n}(),h.ModelProto=function(){function n(e){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.irVersion=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.opsetImport=a.emptyArray,n.prototype.producerName="",n.prototype.producerVersion="",n.prototype.domain="",n.prototype.modelVersion=a.Long?a.Long.fromBits(0,0,!1):0,n.prototype.docString="",n.prototype.graph=null,n.prototype.metadataProps=a.emptyArray,n.prototype.trainingInfo=a.emptyArray,n.prototype.functions=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.irVersion!=null&&Object.hasOwnProperty.call(e,"irVersion")&&t.uint32(8).int64(e.irVersion),e.producerName!=null&&Object.hasOwnProperty.call(e,"producerName")&&t.uint32(18).string(e.producerName),e.producerVersion!=null&&Object.hasOwnProperty.call(e,"producerVersion")&&t.uint32(26).string(e.producerVersion),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(34).string(e.domain),e.modelVersion!=null&&Object.hasOwnProperty.call(e,"modelVersion")&&t.uint32(40).int64(e.modelVersion),e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(50).string(e.docString),e.graph!=null&&Object.hasOwnProperty.call(e,"graph")&&o.onnx.GraphProto.encode(e.graph,t.uint32(58).fork()).ldelim(),e.opsetImport!=null&&e.opsetImport.length)for(var r=0;r<e.opsetImport.length;++r)o.onnx.OperatorSetIdProto.encode(e.opsetImport[r],t.uint32(66).fork()).ldelim();if(e.metadataProps!=null&&e.metadataProps.length)for(r=0;r<e.metadataProps.length;++r)o.onnx.StringStringEntryProto.encode(e.metadataProps[r],t.uint32(114).fork()).ldelim();if(e.trainingInfo!=null&&e.trainingInfo.length)for(r=0;r<e.trainingInfo.length;++r)o.onnx.TrainingInfoProto.encode(e.trainingInfo[r],t.uint32(162).fork()).ldelim();if(e.functions!=null&&e.functions.length)for(r=0;r<e.functions.length;++r)o.onnx.FunctionProto.encode(e.functions[r],t.uint32(202).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.ModelProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.irVersion=e.int64();break;case 8:i.opsetImport&&i.opsetImport.length||(i.opsetImport=[]),i.opsetImport.push(o.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:i.producerName=e.string();break;case 3:i.producerVersion=e.string();break;case 4:i.domain=e.string();break;case 5:i.modelVersion=e.int64();break;case 6:i.docString=e.string();break;case 7:i.graph=o.onnx.GraphProto.decode(e,e.uint32());break;case 14:i.metadataProps&&i.metadataProps.length||(i.metadataProps=[]),i.metadataProps.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 20:i.trainingInfo&&i.trainingInfo.length||(i.trainingInfo=[]),i.trainingInfo.push(o.onnx.TrainingInfoProto.decode(e,e.uint32()));break;case 25:i.functions&&i.functions.length||(i.functions=[]),i.functions.push(o.onnx.FunctionProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&!(a.isInteger(e.irVersion)||e.irVersion&&a.isInteger(e.irVersion.low)&&a.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var t=0;t<e.opsetImport.length;++t)if(r=o.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+r}if(e.producerName!=null&&e.hasOwnProperty("producerName")&&!a.isString(e.producerName))return"producerName: string expected";if(e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&!a.isString(e.producerVersion))return"producerVersion: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain))return"domain: string expected";if(e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&!(a.isInteger(e.modelVersion)||e.modelVersion&&a.isInteger(e.modelVersion.low)&&a.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.graph!=null&&e.hasOwnProperty("graph")&&(r=o.onnx.GraphProto.verify(e.graph)))return"graph."+r;if(e.metadataProps!=null&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(t=0;t<e.metadataProps.length;++t)if(r=o.onnx.StringStringEntryProto.verify(e.metadataProps[t]))return"metadataProps."+r}if(e.trainingInfo!=null&&e.hasOwnProperty("trainingInfo")){if(!Array.isArray(e.trainingInfo))return"trainingInfo: array expected";for(t=0;t<e.trainingInfo.length;++t)if(r=o.onnx.TrainingInfoProto.verify(e.trainingInfo[t]))return"trainingInfo."+r}if(e.functions!=null&&e.hasOwnProperty("functions")){if(!Array.isArray(e.functions))return"functions: array expected";for(t=0;t<e.functions.length;++t){var r;if(r=o.onnx.FunctionProto.verify(e.functions[t]))return"functions."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.ModelProto)return e;var t=new o.onnx.ModelProto;if(e.irVersion!=null&&(a.Long?(t.irVersion=a.Long.fromValue(e.irVersion)).unsigned=!1:typeof e.irVersion=="string"?t.irVersion=parseInt(e.irVersion,10):typeof e.irVersion=="number"?t.irVersion=e.irVersion:typeof e.irVersion=="object"&&(t.irVersion=new a.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");t.opsetImport=[];for(var r=0;r<e.opsetImport.length;++r){if(typeof e.opsetImport[r]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");t.opsetImport[r]=o.onnx.OperatorSetIdProto.fromObject(e.opsetImport[r])}}if(e.producerName!=null&&(t.producerName=String(e.producerName)),e.producerVersion!=null&&(t.producerVersion=String(e.producerVersion)),e.domain!=null&&(t.domain=String(e.domain)),e.modelVersion!=null&&(a.Long?(t.modelVersion=a.Long.fromValue(e.modelVersion)).unsigned=!1:typeof e.modelVersion=="string"?t.modelVersion=parseInt(e.modelVersion,10):typeof e.modelVersion=="number"?t.modelVersion=e.modelVersion:typeof e.modelVersion=="object"&&(t.modelVersion=new a.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),e.docString!=null&&(t.docString=String(e.docString)),e.graph!=null){if(typeof e.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");t.graph=o.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(t.metadataProps=[],r=0;r<e.metadataProps.length;++r){if(typeof e.metadataProps[r]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");t.metadataProps[r]=o.onnx.StringStringEntryProto.fromObject(e.metadataProps[r])}}if(e.trainingInfo){if(!Array.isArray(e.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");for(t.trainingInfo=[],r=0;r<e.trainingInfo.length;++r){if(typeof e.trainingInfo[r]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");t.trainingInfo[r]=o.onnx.TrainingInfoProto.fromObject(e.trainingInfo[r])}}if(e.functions){if(!Array.isArray(e.functions))throw TypeError(".onnx.ModelProto.functions: array expected");for(t.functions=[],r=0;r<e.functions.length;++r){if(typeof e.functions[r]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");t.functions[r]=o.onnx.FunctionProto.fromObject(e.functions[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.opsetImport=[],r.metadataProps=[],r.trainingInfo=[],r.functions=[]),t.defaults){if(a.Long){var i=new a.Long(0,0,!1);r.irVersion=t.longs===String?i.toString():t.longs===Number?i.toNumber():i}else r.irVersion=t.longs===String?"0":0;r.producerName="",r.producerVersion="",r.domain="",a.Long?(i=new a.Long(0,0,!1),r.modelVersion=t.longs===String?i.toString():t.longs===Number?i.toNumber():i):r.modelVersion=t.longs===String?"0":0,r.docString="",r.graph=null}if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&(typeof e.irVersion=="number"?r.irVersion=t.longs===String?String(e.irVersion):e.irVersion:r.irVersion=t.longs===String?a.Long.prototype.toString.call(e.irVersion):t.longs===Number?new a.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&(r.producerName=e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&(r.producerVersion=e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&(typeof e.modelVersion=="number"?r.modelVersion=t.longs===String?String(e.modelVersion):e.modelVersion:r.modelVersion=t.longs===String?a.Long.prototype.toString.call(e.modelVersion):t.longs===Number?new a.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&(r.graph=o.onnx.GraphProto.toObject(e.graph,t)),e.opsetImport&&e.opsetImport.length){r.opsetImport=[];for(var l=0;l<e.opsetImport.length;++l)r.opsetImport[l]=o.onnx.OperatorSetIdProto.toObject(e.opsetImport[l],t)}if(e.metadataProps&&e.metadataProps.length)for(r.metadataProps=[],l=0;l<e.metadataProps.length;++l)r.metadataProps[l]=o.onnx.StringStringEntryProto.toObject(e.metadataProps[l],t);if(e.trainingInfo&&e.trainingInfo.length)for(r.trainingInfo=[],l=0;l<e.trainingInfo.length;++l)r.trainingInfo[l]=o.onnx.TrainingInfoProto.toObject(e.trainingInfo[l],t);if(e.functions&&e.functions.length)for(r.functions=[],l=0;l<e.functions.length;++l)r.functions[l]=o.onnx.FunctionProto.toObject(e.functions[l],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.ModelProto"},n}(),h.StringStringEntryProto=function(){function n(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.key="",n.prototype.value="",n.create=function(e){return new n(e)},n.encode=function(e,t){return t||(t=s.create()),e.key!=null&&Object.hasOwnProperty.call(e,"key")&&t.uint32(10).string(e.key),e.value!=null&&Object.hasOwnProperty.call(e,"value")&&t.uint32(18).string(e.value),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.StringStringEntryProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.key=e.string();break;case 2:i.value=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){return typeof e!="object"||e===null?"object expected":e.key!=null&&e.hasOwnProperty("key")&&!a.isString(e.key)?"key: string expected":e.value!=null&&e.hasOwnProperty("value")&&!a.isString(e.value)?"value: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.StringStringEntryProto)return e;var t=new o.onnx.StringStringEntryProto;return e.key!=null&&(t.key=String(e.key)),e.value!=null&&(t.value=String(e.value)),t},n.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.key="",r.value=""),e.key!=null&&e.hasOwnProperty("key")&&(r.key=e.key),e.value!=null&&e.hasOwnProperty("value")&&(r.value=e.value),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.StringStringEntryProto"},n}(),h.TensorAnnotation=function(){function n(e){if(this.quantParameterTensorNames=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.tensorName="",n.prototype.quantParameterTensorNames=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.tensorName!=null&&Object.hasOwnProperty.call(e,"tensorName")&&t.uint32(10).string(e.tensorName),e.quantParameterTensorNames!=null&&e.quantParameterTensorNames.length)for(var r=0;r<e.quantParameterTensorNames.length;++r)o.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[r],t.uint32(18).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TensorAnnotation;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.tensorName=e.string();break;case 2:i.quantParameterTensorNames&&i.quantParameterTensorNames.length||(i.quantParameterTensorNames=[]),i.quantParameterTensorNames.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.tensorName!=null&&e.hasOwnProperty("tensorName")&&!a.isString(e.tensorName))return"tensorName: string expected";if(e.quantParameterTensorNames!=null&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var t=0;t<e.quantParameterTensorNames.length;++t){var r=o.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);if(r)return"quantParameterTensorNames."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.TensorAnnotation)return e;var t=new o.onnx.TensorAnnotation;if(e.tensorName!=null&&(t.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");t.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r){if(typeof e.quantParameterTensorNames[r]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");t.quantParameterTensorNames[r]=o.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.quantParameterTensorNames=[]),t.defaults&&(r.tensorName=""),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&(r.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){r.quantParameterTensorNames=[];for(var i=0;i<e.quantParameterTensorNames.length;++i)r.quantParameterTensorNames[i]=o.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[i],t)}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorAnnotation"},n}(),h.GraphProto=function(){function n(e){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.node=a.emptyArray,n.prototype.name="",n.prototype.initializer=a.emptyArray,n.prototype.sparseInitializer=a.emptyArray,n.prototype.docString="",n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.valueInfo=a.emptyArray,n.prototype.quantizationAnnotation=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.node!=null&&e.node.length)for(var r=0;r<e.node.length;++r)o.onnx.NodeProto.encode(e.node[r],t.uint32(10).fork()).ldelim();if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(18).string(e.name),e.initializer!=null&&e.initializer.length)for(r=0;r<e.initializer.length;++r)o.onnx.TensorProto.encode(e.initializer[r],t.uint32(42).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(82).string(e.docString),e.input!=null&&e.input.length)for(r=0;r<e.input.length;++r)o.onnx.ValueInfoProto.encode(e.input[r],t.uint32(90).fork()).ldelim();if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)o.onnx.ValueInfoProto.encode(e.output[r],t.uint32(98).fork()).ldelim();if(e.valueInfo!=null&&e.valueInfo.length)for(r=0;r<e.valueInfo.length;++r)o.onnx.ValueInfoProto.encode(e.valueInfo[r],t.uint32(106).fork()).ldelim();if(e.quantizationAnnotation!=null&&e.quantizationAnnotation.length)for(r=0;r<e.quantizationAnnotation.length;++r)o.onnx.TensorAnnotation.encode(e.quantizationAnnotation[r],t.uint32(114).fork()).ldelim();if(e.sparseInitializer!=null&&e.sparseInitializer.length)for(r=0;r<e.sparseInitializer.length;++r)o.onnx.SparseTensorProto.encode(e.sparseInitializer[r],t.uint32(122).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.GraphProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.node&&i.node.length||(i.node=[]),i.node.push(o.onnx.NodeProto.decode(e,e.uint32()));break;case 2:i.name=e.string();break;case 5:i.initializer&&i.initializer.length||(i.initializer=[]),i.initializer.push(o.onnx.TensorProto.decode(e,e.uint32()));break;case 15:i.sparseInitializer&&i.sparseInitializer.length||(i.sparseInitializer=[]),i.sparseInitializer.push(o.onnx.SparseTensorProto.decode(e,e.uint32()));break;case 10:i.docString=e.string();break;case 11:i.input&&i.input.length||(i.input=[]),i.input.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:i.output&&i.output.length||(i.output=[]),i.output.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:i.valueInfo&&i.valueInfo.length||(i.valueInfo=[]),i.valueInfo.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:i.quantizationAnnotation&&i.quantizationAnnotation.length||(i.quantizationAnnotation=[]),i.quantizationAnnotation.push(o.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var t=0;t<e.node.length;++t)if(r=o.onnx.NodeProto.verify(e.node[t]))return"node."+r}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.initializer!=null&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(t=0;t<e.initializer.length;++t)if(r=o.onnx.TensorProto.verify(e.initializer[t]))return"initializer."+r}if(e.sparseInitializer!=null&&e.hasOwnProperty("sparseInitializer")){if(!Array.isArray(e.sparseInitializer))return"sparseInitializer: array expected";for(t=0;t<e.sparseInitializer.length;++t)if(r=o.onnx.SparseTensorProto.verify(e.sparseInitializer[t]))return"sparseInitializer."+r}if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(t=0;t<e.input.length;++t)if(r=o.onnx.ValueInfoProto.verify(e.input[t]))return"input."+r}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(r=o.onnx.ValueInfoProto.verify(e.output[t]))return"output."+r}if(e.valueInfo!=null&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(t=0;t<e.valueInfo.length;++t)if(r=o.onnx.ValueInfoProto.verify(e.valueInfo[t]))return"valueInfo."+r}if(e.quantizationAnnotation!=null&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(t=0;t<e.quantizationAnnotation.length;++t){var r;if(r=o.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t]))return"quantizationAnnotation."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.GraphProto)return e;var t=new o.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");t.node=[];for(var r=0;r<e.node.length;++r){if(typeof e.node[r]!="object")throw TypeError(".onnx.GraphProto.node: object expected");t.node[r]=o.onnx.NodeProto.fromObject(e.node[r])}}if(e.name!=null&&(t.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(t.initializer=[],r=0;r<e.initializer.length;++r){if(typeof e.initializer[r]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");t.initializer[r]=o.onnx.TensorProto.fromObject(e.initializer[r])}}if(e.sparseInitializer){if(!Array.isArray(e.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");for(t.sparseInitializer=[],r=0;r<e.sparseInitializer.length;++r){if(typeof e.sparseInitializer[r]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");t.sparseInitializer[r]=o.onnx.SparseTensorProto.fromObject(e.sparseInitializer[r])}}if(e.docString!=null&&(t.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(t.input=[],r=0;r<e.input.length;++r){if(typeof e.input[r]!="object")throw TypeError(".onnx.GraphProto.input: object expected");t.input[r]=o.onnx.ValueInfoProto.fromObject(e.input[r])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r){if(typeof e.output[r]!="object")throw TypeError(".onnx.GraphProto.output: object expected");t.output[r]=o.onnx.ValueInfoProto.fromObject(e.output[r])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(t.valueInfo=[],r=0;r<e.valueInfo.length;++r){if(typeof e.valueInfo[r]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");t.valueInfo[r]=o.onnx.ValueInfoProto.fromObject(e.valueInfo[r])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(t.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r){if(typeof e.quantizationAnnotation[r]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");t.quantizationAnnotation[r]=o.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.node=[],r.initializer=[],r.input=[],r.output=[],r.valueInfo=[],r.quantizationAnnotation=[],r.sparseInitializer=[]),t.defaults&&(r.name="",r.docString=""),e.node&&e.node.length){r.node=[];for(var i=0;i<e.node.length;++i)r.node[i]=o.onnx.NodeProto.toObject(e.node[i],t)}if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.initializer&&e.initializer.length)for(r.initializer=[],i=0;i<e.initializer.length;++i)r.initializer[i]=o.onnx.TensorProto.toObject(e.initializer[i],t);if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.input&&e.input.length)for(r.input=[],i=0;i<e.input.length;++i)r.input[i]=o.onnx.ValueInfoProto.toObject(e.input[i],t);if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=o.onnx.ValueInfoProto.toObject(e.output[i],t);if(e.valueInfo&&e.valueInfo.length)for(r.valueInfo=[],i=0;i<e.valueInfo.length;++i)r.valueInfo[i]=o.onnx.ValueInfoProto.toObject(e.valueInfo[i],t);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(r.quantizationAnnotation=[],i=0;i<e.quantizationAnnotation.length;++i)r.quantizationAnnotation[i]=o.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[i],t);if(e.sparseInitializer&&e.sparseInitializer.length)for(r.sparseInitializer=[],i=0;i<e.sparseInitializer.length;++i)r.sparseInitializer[i]=o.onnx.SparseTensorProto.toObject(e.sparseInitializer[i],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.GraphProto"},n}(),h.TensorProto=function(){function n(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.dims=a.emptyArray,n.prototype.dataType=0,n.prototype.segment=null,n.prototype.floatData=a.emptyArray,n.prototype.int32Data=a.emptyArray,n.prototype.stringData=a.emptyArray,n.prototype.int64Data=a.emptyArray,n.prototype.name="",n.prototype.docString="",n.prototype.rawData=a.newBuffer([]),n.prototype.externalData=a.emptyArray,n.prototype.dataLocation=0,n.prototype.doubleData=a.emptyArray,n.prototype.uint64Data=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.dims!=null&&e.dims.length){t.uint32(10).fork();for(var r=0;r<e.dims.length;++r)t.int64(e.dims[r]);t.ldelim()}if(e.dataType!=null&&Object.hasOwnProperty.call(e,"dataType")&&t.uint32(16).int32(e.dataType),e.segment!=null&&Object.hasOwnProperty.call(e,"segment")&&o.onnx.TensorProto.Segment.encode(e.segment,t.uint32(26).fork()).ldelim(),e.floatData!=null&&e.floatData.length){for(t.uint32(34).fork(),r=0;r<e.floatData.length;++r)t.float(e.floatData[r]);t.ldelim()}if(e.int32Data!=null&&e.int32Data.length){for(t.uint32(42).fork(),r=0;r<e.int32Data.length;++r)t.int32(e.int32Data[r]);t.ldelim()}if(e.stringData!=null&&e.stringData.length)for(r=0;r<e.stringData.length;++r)t.uint32(50).bytes(e.stringData[r]);if(e.int64Data!=null&&e.int64Data.length){for(t.uint32(58).fork(),r=0;r<e.int64Data.length;++r)t.int64(e.int64Data[r]);t.ldelim()}if(e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(66).string(e.name),e.rawData!=null&&Object.hasOwnProperty.call(e,"rawData")&&t.uint32(74).bytes(e.rawData),e.doubleData!=null&&e.doubleData.length){for(t.uint32(82).fork(),r=0;r<e.doubleData.length;++r)t.double(e.doubleData[r]);t.ldelim()}if(e.uint64Data!=null&&e.uint64Data.length){for(t.uint32(90).fork(),r=0;r<e.uint64Data.length;++r)t.uint64(e.uint64Data[r]);t.ldelim()}if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(98).string(e.docString),e.externalData!=null&&e.externalData.length)for(r=0;r<e.externalData.length;++r)o.onnx.StringStringEntryProto.encode(e.externalData[r],t.uint32(106).fork()).ldelim();return e.dataLocation!=null&&Object.hasOwnProperty.call(e,"dataLocation")&&t.uint32(112).int32(e.dataLocation),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TensorProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:if(i.dims&&i.dims.length||(i.dims=[]),(7&l)==2)for(var d=e.uint32()+e.pos;e.pos<d;)i.dims.push(e.int64());else i.dims.push(e.int64());break;case 2:i.dataType=e.int32();break;case 3:i.segment=o.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(i.floatData&&i.floatData.length||(i.floatData=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.floatData.push(e.float());else i.floatData.push(e.float());break;case 5:if(i.int32Data&&i.int32Data.length||(i.int32Data=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.int32Data.push(e.int32());else i.int32Data.push(e.int32());break;case 6:i.stringData&&i.stringData.length||(i.stringData=[]),i.stringData.push(e.bytes());break;case 7:if(i.int64Data&&i.int64Data.length||(i.int64Data=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.int64Data.push(e.int64());else i.int64Data.push(e.int64());break;case 8:i.name=e.string();break;case 12:i.docString=e.string();break;case 9:i.rawData=e.bytes();break;case 13:i.externalData&&i.externalData.length||(i.externalData=[]),i.externalData.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:i.dataLocation=e.int32();break;case 10:if(i.doubleData&&i.doubleData.length||(i.doubleData=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.doubleData.push(e.double());else i.doubleData.push(e.double());break;case 11:if(i.uint64Data&&i.uint64Data.length||(i.uint64Data=[]),(7&l)==2)for(d=e.uint32()+e.pos;e.pos<d;)i.uint64Data.push(e.uint64());else i.uint64Data.push(e.uint64());break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var t=0;t<e.dims.length;++t)if(!(a.isInteger(e.dims[t])||e.dims[t]&&a.isInteger(e.dims[t].low)&&a.isInteger(e.dims[t].high)))return"dims: integer|Long[] expected"}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&!a.isInteger(e.dataType))return"dataType: integer expected";if(e.segment!=null&&e.hasOwnProperty("segment")&&(r=o.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+r;if(e.floatData!=null&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(t=0;t<e.floatData.length;++t)if(typeof e.floatData[t]!="number")return"floatData: number[] expected"}if(e.int32Data!=null&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(t=0;t<e.int32Data.length;++t)if(!a.isInteger(e.int32Data[t]))return"int32Data: integer[] expected"}if(e.stringData!=null&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(t=0;t<e.stringData.length;++t)if(!(e.stringData[t]&&typeof e.stringData[t].length=="number"||a.isString(e.stringData[t])))return"stringData: buffer[] expected"}if(e.int64Data!=null&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(t=0;t<e.int64Data.length;++t)if(!(a.isInteger(e.int64Data[t])||e.int64Data[t]&&a.isInteger(e.int64Data[t].low)&&a.isInteger(e.int64Data[t].high)))return"int64Data: integer|Long[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.rawData!=null&&e.hasOwnProperty("rawData")&&!(e.rawData&&typeof e.rawData.length=="number"||a.isString(e.rawData)))return"rawData: buffer expected";if(e.externalData!=null&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(t=0;t<e.externalData.length;++t){var r;if(r=o.onnx.StringStringEntryProto.verify(e.externalData[t]))return"externalData."+r}}if(e.dataLocation!=null&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(e.doubleData!=null&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(t=0;t<e.doubleData.length;++t)if(typeof e.doubleData[t]!="number")return"doubleData: number[] expected"}if(e.uint64Data!=null&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(t=0;t<e.uint64Data.length;++t)if(!(a.isInteger(e.uint64Data[t])||e.uint64Data[t]&&a.isInteger(e.uint64Data[t].low)&&a.isInteger(e.uint64Data[t].high)))return"uint64Data: integer|Long[] expected"}return null},n.fromObject=function(e){if(e instanceof o.onnx.TensorProto)return e;var t=new o.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");t.dims=[];for(var r=0;r<e.dims.length;++r)a.Long?(t.dims[r]=a.Long.fromValue(e.dims[r])).unsigned=!1:typeof e.dims[r]=="string"?t.dims[r]=parseInt(e.dims[r],10):typeof e.dims[r]=="number"?t.dims[r]=e.dims[r]:typeof e.dims[r]=="object"&&(t.dims[r]=new a.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber())}if(e.dataType!=null&&(t.dataType=0|e.dataType),e.segment!=null){if(typeof e.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");t.segment=o.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(t.floatData=[],r=0;r<e.floatData.length;++r)t.floatData[r]=Number(e.floatData[r])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(t.int32Data=[],r=0;r<e.int32Data.length;++r)t.int32Data[r]=0|e.int32Data[r]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(t.stringData=[],r=0;r<e.stringData.length;++r)typeof e.stringData[r]=="string"?a.base64.decode(e.stringData[r],t.stringData[r]=a.newBuffer(a.base64.length(e.stringData[r])),0):e.stringData[r].length>=0&&(t.stringData[r]=e.stringData[r])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(t.int64Data=[],r=0;r<e.int64Data.length;++r)a.Long?(t.int64Data[r]=a.Long.fromValue(e.int64Data[r])).unsigned=!1:typeof e.int64Data[r]=="string"?t.int64Data[r]=parseInt(e.int64Data[r],10):typeof e.int64Data[r]=="number"?t.int64Data[r]=e.int64Data[r]:typeof e.int64Data[r]=="object"&&(t.int64Data[r]=new a.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber())}if(e.name!=null&&(t.name=String(e.name)),e.docString!=null&&(t.docString=String(e.docString)),e.rawData!=null&&(typeof e.rawData=="string"?a.base64.decode(e.rawData,t.rawData=a.newBuffer(a.base64.length(e.rawData)),0):e.rawData.length>=0&&(t.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(t.externalData=[],r=0;r<e.externalData.length;++r){if(typeof e.externalData[r]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");t.externalData[r]=o.onnx.StringStringEntryProto.fromObject(e.externalData[r])}}switch(e.dataLocation){default:if(typeof e.dataLocation=="number"){t.dataLocation=e.dataLocation;break}break;case"DEFAULT":case 0:t.dataLocation=0;break;case"EXTERNAL":case 1:t.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(t.doubleData=[],r=0;r<e.doubleData.length;++r)t.doubleData[r]=Number(e.doubleData[r])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(t.uint64Data=[],r=0;r<e.uint64Data.length;++r)a.Long?(t.uint64Data[r]=a.Long.fromValue(e.uint64Data[r])).unsigned=!0:typeof e.uint64Data[r]=="string"?t.uint64Data[r]=parseInt(e.uint64Data[r],10):typeof e.uint64Data[r]=="number"?t.uint64Data[r]=e.uint64Data[r]:typeof e.uint64Data[r]=="object"&&(t.uint64Data[r]=new a.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0))}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dims=[],r.floatData=[],r.int32Data=[],r.stringData=[],r.int64Data=[],r.doubleData=[],r.uint64Data=[],r.externalData=[]),t.defaults&&(r.dataType=0,r.segment=null,r.name="",t.bytes===String?r.rawData="":(r.rawData=[],t.bytes!==Array&&(r.rawData=a.newBuffer(r.rawData))),r.docString="",r.dataLocation=t.enums===String?"DEFAULT":0),e.dims&&e.dims.length){r.dims=[];for(var i=0;i<e.dims.length;++i)typeof e.dims[i]=="number"?r.dims[i]=t.longs===String?String(e.dims[i]):e.dims[i]:r.dims[i]=t.longs===String?a.Long.prototype.toString.call(e.dims[i]):t.longs===Number?new a.LongBits(e.dims[i].low>>>0,e.dims[i].high>>>0).toNumber():e.dims[i]}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&(r.dataType=e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&(r.segment=o.onnx.TensorProto.Segment.toObject(e.segment,t)),e.floatData&&e.floatData.length)for(r.floatData=[],i=0;i<e.floatData.length;++i)r.floatData[i]=t.json&&!isFinite(e.floatData[i])?String(e.floatData[i]):e.floatData[i];if(e.int32Data&&e.int32Data.length)for(r.int32Data=[],i=0;i<e.int32Data.length;++i)r.int32Data[i]=e.int32Data[i];if(e.stringData&&e.stringData.length)for(r.stringData=[],i=0;i<e.stringData.length;++i)r.stringData[i]=t.bytes===String?a.base64.encode(e.stringData[i],0,e.stringData[i].length):t.bytes===Array?Array.prototype.slice.call(e.stringData[i]):e.stringData[i];if(e.int64Data&&e.int64Data.length)for(r.int64Data=[],i=0;i<e.int64Data.length;++i)typeof e.int64Data[i]=="number"?r.int64Data[i]=t.longs===String?String(e.int64Data[i]):e.int64Data[i]:r.int64Data[i]=t.longs===String?a.Long.prototype.toString.call(e.int64Data[i]):t.longs===Number?new a.LongBits(e.int64Data[i].low>>>0,e.int64Data[i].high>>>0).toNumber():e.int64Data[i];if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&(r.rawData=t.bytes===String?a.base64.encode(e.rawData,0,e.rawData.length):t.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(r.doubleData=[],i=0;i<e.doubleData.length;++i)r.doubleData[i]=t.json&&!isFinite(e.doubleData[i])?String(e.doubleData[i]):e.doubleData[i];if(e.uint64Data&&e.uint64Data.length)for(r.uint64Data=[],i=0;i<e.uint64Data.length;++i)typeof e.uint64Data[i]=="number"?r.uint64Data[i]=t.longs===String?String(e.uint64Data[i]):e.uint64Data[i]:r.uint64Data[i]=t.longs===String?a.Long.prototype.toString.call(e.uint64Data[i]):t.longs===Number?new a.LongBits(e.uint64Data[i].low>>>0,e.uint64Data[i].high>>>0).toNumber(!0):e.uint64Data[i];if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.externalData&&e.externalData.length)for(r.externalData=[],i=0;i<e.externalData.length;++i)r.externalData[i]=o.onnx.StringStringEntryProto.toObject(e.externalData[i],t);return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&(r.dataLocation=t.enums===String?o.onnx.TensorProto.DataLocation[e.dataLocation]===void 0?e.dataLocation:o.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorProto"},n.DataType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="UINT8"]=2,t[e[3]="INT8"]=3,t[e[4]="UINT16"]=4,t[e[5]="INT16"]=5,t[e[6]="INT32"]=6,t[e[7]="INT64"]=7,t[e[8]="STRING"]=8,t[e[9]="BOOL"]=9,t[e[10]="FLOAT16"]=10,t[e[11]="DOUBLE"]=11,t[e[12]="UINT32"]=12,t[e[13]="UINT64"]=13,t[e[14]="COMPLEX64"]=14,t[e[15]="COMPLEX128"]=15,t[e[16]="BFLOAT16"]=16,t[e[17]="FLOAT8E4M3FN"]=17,t[e[18]="FLOAT8E4M3FNUZ"]=18,t[e[19]="FLOAT8E5M2"]=19,t[e[20]="FLOAT8E5M2FNUZ"]=20,t}(),n.Segment=function(){function e(t){if(t)for(var r=Object.keys(t),i=0;i<r.length;++i)t[r[i]]!=null&&(this[r[i]]=t[r[i]])}return e.prototype.begin=a.Long?a.Long.fromBits(0,0,!1):0,e.prototype.end=a.Long?a.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,r){return r||(r=s.create()),t.begin!=null&&Object.hasOwnProperty.call(t,"begin")&&r.uint32(8).int64(t.begin),t.end!=null&&Object.hasOwnProperty.call(t,"end")&&r.uint32(16).int64(t.end),r},e.encodeDelimited=function(t,r){return this.encode(t,r).ldelim()},e.decode=function(t,r){t instanceof u||(t=u.create(t));for(var i=r===void 0?t.len:t.pos+r,l=new o.onnx.TensorProto.Segment;t.pos<i;){var d=t.uint32();switch(d>>>3){case 1:l.begin=t.int64();break;case 2:l.end=t.int64();break;default:t.skipType(7&d)}}return l},e.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.begin!=null&&t.hasOwnProperty("begin")&&!(a.isInteger(t.begin)||t.begin&&a.isInteger(t.begin.low)&&a.isInteger(t.begin.high))?"begin: integer|Long expected":t.end!=null&&t.hasOwnProperty("end")&&!(a.isInteger(t.end)||t.end&&a.isInteger(t.end.low)&&a.isInteger(t.end.high))?"end: integer|Long expected":null},e.fromObject=function(t){if(t instanceof o.onnx.TensorProto.Segment)return t;var r=new o.onnx.TensorProto.Segment;return t.begin!=null&&(a.Long?(r.begin=a.Long.fromValue(t.begin)).unsigned=!1:typeof t.begin=="string"?r.begin=parseInt(t.begin,10):typeof t.begin=="number"?r.begin=t.begin:typeof t.begin=="object"&&(r.begin=new a.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber())),t.end!=null&&(a.Long?(r.end=a.Long.fromValue(t.end)).unsigned=!1:typeof t.end=="string"?r.end=parseInt(t.end,10):typeof t.end=="number"?r.end=t.end:typeof t.end=="object"&&(r.end=new a.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber())),r},e.toObject=function(t,r){r||(r={});var i={};if(r.defaults){if(a.Long){var l=new a.Long(0,0,!1);i.begin=r.longs===String?l.toString():r.longs===Number?l.toNumber():l}else i.begin=r.longs===String?"0":0;a.Long?(l=new a.Long(0,0,!1),i.end=r.longs===String?l.toString():r.longs===Number?l.toNumber():l):i.end=r.longs===String?"0":0}return t.begin!=null&&t.hasOwnProperty("begin")&&(typeof t.begin=="number"?i.begin=r.longs===String?String(t.begin):t.begin:i.begin=r.longs===String?a.Long.prototype.toString.call(t.begin):r.longs===Number?new a.LongBits(t.begin.low>>>0,t.begin.high>>>0).toNumber():t.begin),t.end!=null&&t.hasOwnProperty("end")&&(typeof t.end=="number"?i.end=r.longs===String?String(t.end):t.end:i.end=r.longs===String?a.Long.prototype.toString.call(t.end):r.longs===Number?new a.LongBits(t.end.low>>>0,t.end.high>>>0).toNumber():t.end),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto.Segment"},e}(),n.DataLocation=function(){var e={},t=Object.create(e);return t[e[0]="DEFAULT"]=0,t[e[1]="EXTERNAL"]=1,t}(),n}(),h.SparseTensorProto=function(){function n(e){if(this.dims=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.values=null,n.prototype.indices=null,n.prototype.dims=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.values!=null&&Object.hasOwnProperty.call(e,"values")&&o.onnx.TensorProto.encode(e.values,t.uint32(10).fork()).ldelim(),e.indices!=null&&Object.hasOwnProperty.call(e,"indices")&&o.onnx.TensorProto.encode(e.indices,t.uint32(18).fork()).ldelim(),e.dims!=null&&e.dims.length){t.uint32(26).fork();for(var r=0;r<e.dims.length;++r)t.int64(e.dims[r]);t.ldelim()}return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.SparseTensorProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.values=o.onnx.TensorProto.decode(e,e.uint32());break;case 2:i.indices=o.onnx.TensorProto.decode(e,e.uint32());break;case 3:if(i.dims&&i.dims.length||(i.dims=[]),(7&l)==2)for(var d=e.uint32()+e.pos;e.pos<d;)i.dims.push(e.int64());else i.dims.push(e.int64());break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";var t;if(e.values!=null&&e.hasOwnProperty("values")&&(t=o.onnx.TensorProto.verify(e.values)))return"values."+t;if(e.indices!=null&&e.hasOwnProperty("indices")&&(t=o.onnx.TensorProto.verify(e.indices)))return"indices."+t;if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var r=0;r<e.dims.length;++r)if(!(a.isInteger(e.dims[r])||e.dims[r]&&a.isInteger(e.dims[r].low)&&a.isInteger(e.dims[r].high)))return"dims: integer|Long[] expected"}return null},n.fromObject=function(e){if(e instanceof o.onnx.SparseTensorProto)return e;var t=new o.onnx.SparseTensorProto;if(e.values!=null){if(typeof e.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");t.values=o.onnx.TensorProto.fromObject(e.values)}if(e.indices!=null){if(typeof e.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");t.indices=o.onnx.TensorProto.fromObject(e.indices)}if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");t.dims=[];for(var r=0;r<e.dims.length;++r)a.Long?(t.dims[r]=a.Long.fromValue(e.dims[r])).unsigned=!1:typeof e.dims[r]=="string"?t.dims[r]=parseInt(e.dims[r],10):typeof e.dims[r]=="number"?t.dims[r]=e.dims[r]:typeof e.dims[r]=="object"&&(t.dims[r]=new a.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber())}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dims=[]),t.defaults&&(r.values=null,r.indices=null),e.values!=null&&e.hasOwnProperty("values")&&(r.values=o.onnx.TensorProto.toObject(e.values,t)),e.indices!=null&&e.hasOwnProperty("indices")&&(r.indices=o.onnx.TensorProto.toObject(e.indices,t)),e.dims&&e.dims.length){r.dims=[];for(var i=0;i<e.dims.length;++i)typeof e.dims[i]=="number"?r.dims[i]=t.longs===String?String(e.dims[i]):e.dims[i]:r.dims[i]=t.longs===String?a.Long.prototype.toString.call(e.dims[i]):t.longs===Number?new a.LongBits(e.dims[i].low>>>0,e.dims[i].high>>>0).toNumber():e.dims[i]}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.SparseTensorProto"},n}(),h.TensorShapeProto=function(){function n(e){if(this.dim=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.dim=a.emptyArray,n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.dim!=null&&e.dim.length)for(var r=0;r<e.dim.length;++r)o.onnx.TensorShapeProto.Dimension.encode(e.dim[r],t.uint32(10).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.TensorShapeProto;e.pos<r;){var l=e.uint32();l>>>3==1?(i.dim&&i.dim.length||(i.dim=[]),i.dim.push(o.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&l)}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dim!=null&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var t=0;t<e.dim.length;++t){var r=o.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);if(r)return"dim."+r}}return null},n.fromObject=function(e){if(e instanceof o.onnx.TensorShapeProto)return e;var t=new o.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");t.dim=[];for(var r=0;r<e.dim.length;++r){if(typeof e.dim[r]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");t.dim[r]=o.onnx.TensorShapeProto.Dimension.fromObject(e.dim[r])}}return t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dim=[]),e.dim&&e.dim.length){r.dim=[];for(var i=0;i<e.dim.length;++i)r.dim[i]=o.onnx.TensorShapeProto.Dimension.toObject(e.dim[i],t)}return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.TensorShapeProto"},n.Dimension=function(){function e(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}var t;return e.prototype.dimValue=null,e.prototype.dimParam=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:a.oneOfGetter(t=["dimValue","dimParam"]),set:a.oneOfSetter(t)}),e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=s.create()),r.dimValue!=null&&Object.hasOwnProperty.call(r,"dimValue")&&i.uint32(8).int64(r.dimValue),r.dimParam!=null&&Object.hasOwnProperty.call(r,"dimParam")&&i.uint32(18).string(r.dimParam),r.denotation!=null&&Object.hasOwnProperty.call(r,"denotation")&&i.uint32(26).string(r.denotation),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TensorShapeProto.Dimension;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.dimValue=r.int64();break;case 2:d.dimParam=r.string();break;case 3:d.denotation=r.string();break;default:r.skipType(7&g)}}return d},e.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";var i={};if(r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(i.value=1,!(a.isInteger(r.dimValue)||r.dimValue&&a.isInteger(r.dimValue.low)&&a.isInteger(r.dimValue.high))))return"dimValue: integer|Long expected";if(r.dimParam!=null&&r.hasOwnProperty("dimParam")){if(i.value===1)return"value: multiple values";if(i.value=1,!a.isString(r.dimParam))return"dimParam: string expected"}return r.denotation!=null&&r.hasOwnProperty("denotation")&&!a.isString(r.denotation)?"denotation: string expected":null},e.fromObject=function(r){if(r instanceof o.onnx.TensorShapeProto.Dimension)return r;var i=new o.onnx.TensorShapeProto.Dimension;return r.dimValue!=null&&(a.Long?(i.dimValue=a.Long.fromValue(r.dimValue)).unsigned=!1:typeof r.dimValue=="string"?i.dimValue=parseInt(r.dimValue,10):typeof r.dimValue=="number"?i.dimValue=r.dimValue:typeof r.dimValue=="object"&&(i.dimValue=new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber())),r.dimParam!=null&&(i.dimParam=String(r.dimParam)),r.denotation!=null&&(i.denotation=String(r.denotation)),i},e.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.denotation=""),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(typeof r.dimValue=="number"?l.dimValue=i.longs===String?String(r.dimValue):r.dimValue:l.dimValue=i.longs===String?a.Long.prototype.toString.call(r.dimValue):i.longs===Number?new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber():r.dimValue,i.oneofs&&(l.value="dimValue")),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&(l.dimParam=r.dimParam,i.oneofs&&(l.value="dimParam")),r.denotation!=null&&r.hasOwnProperty("denotation")&&(l.denotation=r.denotation),l},e.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TensorShapeProto.Dimension"},e}(),n}(),h.TypeProto=function(){function n(t){if(t)for(var r=Object.keys(t),i=0;i<r.length;++i)t[r[i]]!=null&&(this[r[i]]=t[r[i]])}var e;return n.prototype.tensorType=null,n.prototype.sequenceType=null,n.prototype.mapType=null,n.prototype.optionalType=null,n.prototype.sparseTensorType=null,n.prototype.denotation="",Object.defineProperty(n.prototype,"value",{get:a.oneOfGetter(e=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:a.oneOfSetter(e)}),n.create=function(t){return new n(t)},n.encode=function(t,r){return r||(r=s.create()),t.tensorType!=null&&Object.hasOwnProperty.call(t,"tensorType")&&o.onnx.TypeProto.Tensor.encode(t.tensorType,r.uint32(10).fork()).ldelim(),t.sequenceType!=null&&Object.hasOwnProperty.call(t,"sequenceType")&&o.onnx.TypeProto.Sequence.encode(t.sequenceType,r.uint32(34).fork()).ldelim(),t.mapType!=null&&Object.hasOwnProperty.call(t,"mapType")&&o.onnx.TypeProto.Map.encode(t.mapType,r.uint32(42).fork()).ldelim(),t.denotation!=null&&Object.hasOwnProperty.call(t,"denotation")&&r.uint32(50).string(t.denotation),t.sparseTensorType!=null&&Object.hasOwnProperty.call(t,"sparseTensorType")&&o.onnx.TypeProto.SparseTensor.encode(t.sparseTensorType,r.uint32(66).fork()).ldelim(),t.optionalType!=null&&Object.hasOwnProperty.call(t,"optionalType")&&o.onnx.TypeProto.Optional.encode(t.optionalType,r.uint32(74).fork()).ldelim(),r},n.encodeDelimited=function(t,r){return this.encode(t,r).ldelim()},n.decode=function(t,r){t instanceof u||(t=u.create(t));for(var i=r===void 0?t.len:t.pos+r,l=new o.onnx.TypeProto;t.pos<i;){var d=t.uint32();switch(d>>>3){case 1:l.tensorType=o.onnx.TypeProto.Tensor.decode(t,t.uint32());break;case 4:l.sequenceType=o.onnx.TypeProto.Sequence.decode(t,t.uint32());break;case 5:l.mapType=o.onnx.TypeProto.Map.decode(t,t.uint32());break;case 9:l.optionalType=o.onnx.TypeProto.Optional.decode(t,t.uint32());break;case 8:l.sparseTensorType=o.onnx.TypeProto.SparseTensor.decode(t,t.uint32());break;case 6:l.denotation=t.string();break;default:t.skipType(7&d)}}return l},n.decodeDelimited=function(t){return t instanceof u||(t=new u(t)),this.decode(t,t.uint32())},n.verify=function(t){if(typeof t!="object"||t===null)return"object expected";var r={};if(t.tensorType!=null&&t.hasOwnProperty("tensorType")&&(r.value=1,i=o.onnx.TypeProto.Tensor.verify(t.tensorType)))return"tensorType."+i;if(t.sequenceType!=null&&t.hasOwnProperty("sequenceType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Sequence.verify(t.sequenceType))return"sequenceType."+i}if(t.mapType!=null&&t.hasOwnProperty("mapType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Map.verify(t.mapType))return"mapType."+i}if(t.optionalType!=null&&t.hasOwnProperty("optionalType")){if(r.value===1)return"value: multiple values";if(r.value=1,i=o.onnx.TypeProto.Optional.verify(t.optionalType))return"optionalType."+i}if(t.sparseTensorType!=null&&t.hasOwnProperty("sparseTensorType")){if(r.value===1)return"value: multiple values";var i;if(r.value=1,i=o.onnx.TypeProto.SparseTensor.verify(t.sparseTensorType))return"sparseTensorType."+i}return t.denotation!=null&&t.hasOwnProperty("denotation")&&!a.isString(t.denotation)?"denotation: string expected":null},n.fromObject=function(t){if(t instanceof o.onnx.TypeProto)return t;var r=new o.onnx.TypeProto;if(t.tensorType!=null){if(typeof t.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");r.tensorType=o.onnx.TypeProto.Tensor.fromObject(t.tensorType)}if(t.sequenceType!=null){if(typeof t.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");r.sequenceType=o.onnx.TypeProto.Sequence.fromObject(t.sequenceType)}if(t.mapType!=null){if(typeof t.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");r.mapType=o.onnx.TypeProto.Map.fromObject(t.mapType)}if(t.optionalType!=null){if(typeof t.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");r.optionalType=o.onnx.TypeProto.Optional.fromObject(t.optionalType)}if(t.sparseTensorType!=null){if(typeof t.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");r.sparseTensorType=o.onnx.TypeProto.SparseTensor.fromObject(t.sparseTensorType)}return t.denotation!=null&&(r.denotation=String(t.denotation)),r},n.toObject=function(t,r){r||(r={});var i={};return r.defaults&&(i.denotation=""),t.tensorType!=null&&t.hasOwnProperty("tensorType")&&(i.tensorType=o.onnx.TypeProto.Tensor.toObject(t.tensorType,r),r.oneofs&&(i.value="tensorType")),t.sequenceType!=null&&t.hasOwnProperty("sequenceType")&&(i.sequenceType=o.onnx.TypeProto.Sequence.toObject(t.sequenceType,r),r.oneofs&&(i.value="sequenceType")),t.mapType!=null&&t.hasOwnProperty("mapType")&&(i.mapType=o.onnx.TypeProto.Map.toObject(t.mapType,r),r.oneofs&&(i.value="mapType")),t.denotation!=null&&t.hasOwnProperty("denotation")&&(i.denotation=t.denotation),t.sparseTensorType!=null&&t.hasOwnProperty("sparseTensorType")&&(i.sparseTensorType=o.onnx.TypeProto.SparseTensor.toObject(t.sparseTensorType,r),r.oneofs&&(i.value="sparseTensorType")),t.optionalType!=null&&t.hasOwnProperty("optionalType")&&(i.optionalType=o.onnx.TypeProto.Optional.toObject(t.optionalType,r),r.oneofs&&(i.value="optionalType")),i},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TypeProto"},n.Tensor=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&i.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&o.onnx.TensorShapeProto.encode(r.shape,i.uint32(18).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Tensor;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.elemType=r.int32();break;case 2:d.shape=o.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var i=o.onnx.TensorShapeProto.verify(r.shape);if(i)return"shape."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Tensor)return r;var i=new o.onnx.TypeProto.Tensor;if(r.elemType!=null&&(i.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");i.shape=o.onnx.TensorShapeProto.fromObject(r.shape)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=0,l.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(l.shape=o.onnx.TensorShapeProto.toObject(r.shape,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Tensor"},t}(),n.Sequence=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&o.onnx.TypeProto.encode(r.elemType,i.uint32(10).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Sequence;r.pos<l;){var g=r.uint32();g>>>3==1?d.elemType=o.onnx.TypeProto.decode(r,r.uint32()):r.skipType(7&g)}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var i=o.onnx.TypeProto.verify(r.elemType);if(i)return"elemType."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Sequence)return r;var i=new o.onnx.TypeProto.Sequence;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");i.elemType=o.onnx.TypeProto.fromObject(r.elemType)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=o.onnx.TypeProto.toObject(r.elemType,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Sequence"},t}(),n.Map=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.keyType!=null&&Object.hasOwnProperty.call(r,"keyType")&&i.uint32(8).int32(r.keyType),r.valueType!=null&&Object.hasOwnProperty.call(r,"valueType")&&o.onnx.TypeProto.encode(r.valueType,i.uint32(18).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Map;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.keyType=r.int32();break;case 2:d.valueType=o.onnx.TypeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.keyType!=null&&r.hasOwnProperty("keyType")&&!a.isInteger(r.keyType))return"keyType: integer expected";if(r.valueType!=null&&r.hasOwnProperty("valueType")){var i=o.onnx.TypeProto.verify(r.valueType);if(i)return"valueType."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Map)return r;var i=new o.onnx.TypeProto.Map;if(r.keyType!=null&&(i.keyType=0|r.keyType),r.valueType!=null){if(typeof r.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");i.valueType=o.onnx.TypeProto.fromObject(r.valueType)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.keyType=0,l.valueType=null),r.keyType!=null&&r.hasOwnProperty("keyType")&&(l.keyType=r.keyType),r.valueType!=null&&r.hasOwnProperty("valueType")&&(l.valueType=o.onnx.TypeProto.toObject(r.valueType,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Map"},t}(),n.Optional=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&o.onnx.TypeProto.encode(r.elemType,i.uint32(10).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.Optional;r.pos<l;){var g=r.uint32();g>>>3==1?d.elemType=o.onnx.TypeProto.decode(r,r.uint32()):r.skipType(7&g)}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")){var i=o.onnx.TypeProto.verify(r.elemType);if(i)return"elemType."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Optional)return r;var i=new o.onnx.TypeProto.Optional;if(r.elemType!=null){if(typeof r.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");i.elemType=o.onnx.TypeProto.fromObject(r.elemType)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=o.onnx.TypeProto.toObject(r.elemType,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.Optional"},t}(),n.SparseTensor=function(){function t(r){if(r)for(var i=Object.keys(r),l=0;l<i.length;++l)r[i[l]]!=null&&(this[i[l]]=r[i[l]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(r){return new t(r)},t.encode=function(r,i){return i||(i=s.create()),r.elemType!=null&&Object.hasOwnProperty.call(r,"elemType")&&i.uint32(8).int32(r.elemType),r.shape!=null&&Object.hasOwnProperty.call(r,"shape")&&o.onnx.TensorShapeProto.encode(r.shape,i.uint32(18).fork()).ldelim(),i},t.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},t.decode=function(r,i){r instanceof u||(r=u.create(r));for(var l=i===void 0?r.len:r.pos+i,d=new o.onnx.TypeProto.SparseTensor;r.pos<l;){var g=r.uint32();switch(g>>>3){case 1:d.elemType=r.int32();break;case 2:d.shape=o.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&g)}}return d},t.decodeDelimited=function(r){return r instanceof u||(r=new u(r)),this.decode(r,r.uint32())},t.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var i=o.onnx.TensorShapeProto.verify(r.shape);if(i)return"shape."+i}return null},t.fromObject=function(r){if(r instanceof o.onnx.TypeProto.SparseTensor)return r;var i=new o.onnx.TypeProto.SparseTensor;if(r.elemType!=null&&(i.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");i.shape=o.onnx.TensorShapeProto.fromObject(r.shape)}return i},t.toObject=function(r,i){i||(i={});var l={};return i.defaults&&(l.elemType=0,l.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(l.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(l.shape=o.onnx.TensorShapeProto.toObject(r.shape,i)),l},t.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},t.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TypeProto.SparseTensor"},t}(),n}(),h.OperatorSetIdProto=function(){function n(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.domain="",n.prototype.version=a.Long?a.Long.fromBits(0,0,!1):0,n.create=function(e){return new n(e)},n.encode=function(e,t){return t||(t=s.create()),e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(10).string(e.domain),e.version!=null&&Object.hasOwnProperty.call(e,"version")&&t.uint32(16).int64(e.version),t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.OperatorSetIdProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.domain=e.string();break;case 2:i.version=e.int64();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){return typeof e!="object"||e===null?"object expected":e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain)?"domain: string expected":e.version!=null&&e.hasOwnProperty("version")&&!(a.isInteger(e.version)||e.version&&a.isInteger(e.version.low)&&a.isInteger(e.version.high))?"version: integer|Long expected":null},n.fromObject=function(e){if(e instanceof o.onnx.OperatorSetIdProto)return e;var t=new o.onnx.OperatorSetIdProto;return e.domain!=null&&(t.domain=String(e.domain)),e.version!=null&&(a.Long?(t.version=a.Long.fromValue(e.version)).unsigned=!1:typeof e.version=="string"?t.version=parseInt(e.version,10):typeof e.version=="number"?t.version=e.version:typeof e.version=="object"&&(t.version=new a.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),t},n.toObject=function(e,t){t||(t={});var r={};if(t.defaults)if(r.domain="",a.Long){var i=new a.Long(0,0,!1);r.version=t.longs===String?i.toString():t.longs===Number?i.toNumber():i}else r.version=t.longs===String?"0":0;return e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.version!=null&&e.hasOwnProperty("version")&&(typeof e.version=="number"?r.version=t.longs===String?String(e.version):e.version:r.version=t.longs===String?a.Long.prototype.toString.call(e.version):t.longs===Number?new a.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.OperatorSetIdProto"},n}(),h.OperatorStatus=function(){var n={},e=Object.create(n);return e[n[0]="EXPERIMENTAL"]=0,e[n[1]="STABLE"]=1,e}(),h.FunctionProto=function(){function n(e){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return n.prototype.name="",n.prototype.input=a.emptyArray,n.prototype.output=a.emptyArray,n.prototype.attribute=a.emptyArray,n.prototype.attributeProto=a.emptyArray,n.prototype.node=a.emptyArray,n.prototype.docString="",n.prototype.opsetImport=a.emptyArray,n.prototype.domain="",n.create=function(e){return new n(e)},n.encode=function(e,t){if(t||(t=s.create()),e.name!=null&&Object.hasOwnProperty.call(e,"name")&&t.uint32(10).string(e.name),e.input!=null&&e.input.length)for(var r=0;r<e.input.length;++r)t.uint32(34).string(e.input[r]);if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)t.uint32(42).string(e.output[r]);if(e.attribute!=null&&e.attribute.length)for(r=0;r<e.attribute.length;++r)t.uint32(50).string(e.attribute[r]);if(e.node!=null&&e.node.length)for(r=0;r<e.node.length;++r)o.onnx.NodeProto.encode(e.node[r],t.uint32(58).fork()).ldelim();if(e.docString!=null&&Object.hasOwnProperty.call(e,"docString")&&t.uint32(66).string(e.docString),e.opsetImport!=null&&e.opsetImport.length)for(r=0;r<e.opsetImport.length;++r)o.onnx.OperatorSetIdProto.encode(e.opsetImport[r],t.uint32(74).fork()).ldelim();if(e.domain!=null&&Object.hasOwnProperty.call(e,"domain")&&t.uint32(82).string(e.domain),e.attributeProto!=null&&e.attributeProto.length)for(r=0;r<e.attributeProto.length;++r)o.onnx.AttributeProto.encode(e.attributeProto[r],t.uint32(90).fork()).ldelim();return t},n.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},n.decode=function(e,t){e instanceof u||(e=u.create(e));for(var r=t===void 0?e.len:e.pos+t,i=new o.onnx.FunctionProto;e.pos<r;){var l=e.uint32();switch(l>>>3){case 1:i.name=e.string();break;case 4:i.input&&i.input.length||(i.input=[]),i.input.push(e.string());break;case 5:i.output&&i.output.length||(i.output=[]),i.output.push(e.string());break;case 6:i.attribute&&i.attribute.length||(i.attribute=[]),i.attribute.push(e.string());break;case 11:i.attributeProto&&i.attributeProto.length||(i.attributeProto=[]),i.attributeProto.push(o.onnx.AttributeProto.decode(e,e.uint32()));break;case 7:i.node&&i.node.length||(i.node=[]),i.node.push(o.onnx.NodeProto.decode(e,e.uint32()));break;case 8:i.docString=e.string();break;case 9:i.opsetImport&&i.opsetImport.length||(i.opsetImport=[]),i.opsetImport.push(o.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 10:i.domain=e.string();break;default:e.skipType(7&l)}}return i},n.decodeDelimited=function(e){return e instanceof u||(e=new u(e)),this.decode(e,e.uint32())},n.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!a.isString(e.input[t]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!a.isString(e.output[t]))return"output: string[] expected"}if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t)if(!a.isString(e.attribute[t]))return"attribute: string[] expected"}if(e.attributeProto!=null&&e.hasOwnProperty("attributeProto")){if(!Array.isArray(e.attributeProto))return"attributeProto: array expected";for(t=0;t<e.attributeProto.length;++t)if(r=o.onnx.AttributeProto.verify(e.attributeProto[t]))return"attributeProto."+r}if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(t=0;t<e.node.length;++t)if(r=o.onnx.NodeProto.verify(e.node[t]))return"node."+r}if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(t=0;t<e.opsetImport.length;++t){var r;if(r=o.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+r}}return e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain)?"domain: string expected":null},n.fromObject=function(e){if(e instanceof o.onnx.FunctionProto)return e;var t=new o.onnx.FunctionProto;if(e.name!=null&&(t.name=String(e.name)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.FunctionProto.input: array expected");t.input=[];for(var r=0;r<e.input.length;++r)t.input[r]=String(e.input[r])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.FunctionProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r)t.output[r]=String(e.output[r])}if(e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");for(t.attribute=[],r=0;r<e.attribute.length;++r)t.attribute[r]=String(e.attribute[r])}if(e.attributeProto){if(!Array.isArray(e.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");for(t.attributeProto=[],r=0;r<e.attributeProto.length;++r){if(typeof e.attributeProto[r]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");t.attributeProto[r]=o.onnx.AttributeProto.fromObject(e.attributeProto[r])}}if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.FunctionProto.node: array expected");for(t.node=[],r=0;r<e.node.length;++r){if(typeof e.node[r]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");t.node[r]=o.onnx.NodeProto.fromObject(e.node[r])}}if(e.docString!=null&&(t.docString=String(e.docString)),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");for(t.opsetImport=[],r=0;r<e.opsetImport.length;++r){if(typeof e.opsetImport[r]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");t.opsetImport[r]=o.onnx.OperatorSetIdProto.fromObject(e.opsetImport[r])}}return e.domain!=null&&(t.domain=String(e.domain)),t},n.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.input=[],r.output=[],r.attribute=[],r.node=[],r.opsetImport=[],r.attributeProto=[]),t.defaults&&(r.name="",r.docString="",r.domain=""),e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.input&&e.input.length){r.input=[];for(var i=0;i<e.input.length;++i)r.input[i]=e.input[i]}if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=e.output[i];if(e.attribute&&e.attribute.length)for(r.attribute=[],i=0;i<e.attribute.length;++i)r.attribute[i]=e.attribute[i];if(e.node&&e.node.length)for(r.node=[],i=0;i<e.node.length;++i)r.node[i]=o.onnx.NodeProto.toObject(e.node[i],t);if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.opsetImport&&e.opsetImport.length)for(r.opsetImport=[],i=0;i<e.opsetImport.length;++i)r.opsetImport[i]=o.onnx.OperatorSetIdProto.toObject(e.opsetImport[i],t);if(e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.attributeProto&&e.attributeProto.length)for(r.attributeProto=[],i=0;i<e.attributeProto.length;++i)r.attributeProto[i]=o.onnx.AttributeProto.toObject(e.attributeProto[i],t);return r},n.prototype.toJSON=function(){return this.constructor.toObject(this,p.util.toJSONOptions)},n.getTypeUrl=function(e){return e===void 0&&(e="type.googleapis.com"),e+"/onnx.FunctionProto"},n}(),h),M.exports=o},5711:(M,c,y)=>{var m,f=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(m=m||__filename),function(h={}){function p(){return z.buffer!=te.buffer&&Me(),te}function u(){return z.buffer!=te.buffer&&Me(),ae}function s(){return z.buffer!=te.buffer&&Me(),se}function a(){return z.buffer!=te.buffer&&Me(),pe}function o(){return z.buffer!=te.buffer&&Me(),ge}var n,e,t=h;t.ready=new Promise(($,N)=>{n=$,e=N}),t.jsepInit=function($,N,B,W,q,ce,he,Oe){t.Ib=$,t.ob=N,t.qb=B,t.ab=W,t.pb=q,t.xa=ce,t.rb=he,t.sb=Oe};var r,i,l,d=Object.assign({},t),g="./this.program",b=($,N)=>{throw N},v=typeof window=="object",w=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=t.ENVIRONMENT_IS_PTHREAD||!1,O="";function P($){return t.locateFile?t.locateFile($,O):O+$}if(x){var I=y(1384),R=y(908);let $;O=w?R.dirname(O)+"/":__dirname+"/",r=(N,B)=>(N=N.startsWith("file://")?new URL(N):R.normalize(N),I.readFileSync(N,B?void 0:"utf8")),l=N=>((N=r(N,!0)).buffer||(N=new Uint8Array(N)),N),i=(N,B,W,q=!0)=>{N=N.startsWith("file://")?new URL(N):R.normalize(N),I.readFile(N,q?void 0:"utf8",(ce,he)=>{ce?W(ce):B(q?he.buffer:he)})},!t.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),b=(N,B)=>{throw process.exitCode=N,B},t.inspect=()=>"[Emscripten Module object]";try{$=y(9925)}catch(N){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),N}global.Worker=$.Worker}else(v||w)&&(w?O=self.location.href:typeof document<"u"&&document.currentScript&&(O=document.currentScript.src),m&&(O=m),O=O.indexOf("blob:")!==0?O.substr(0,O.replace(/[?#].*/,"").lastIndexOf("/")+1):"",x||(r=$=>{var N=new XMLHttpRequest;return N.open("GET",$,!1),N.send(null),N.responseText},w&&(l=$=>{var N=new XMLHttpRequest;return N.open("GET",$,!1),N.responseType="arraybuffer",N.send(null),new Uint8Array(N.response)}),i=($,N,B)=>{var W=new XMLHttpRequest;W.open("GET",$,!0),W.responseType="arraybuffer",W.onload=()=>{W.status==200||W.status==0&&W.response?N(W.response):B()},W.onerror=B,W.send(null)}));x&&typeof performance>"u"&&(global.performance=y(6953).performance);var j=console.log.bind(console),A=console.error.bind(console);x&&(j=(...$)=>I.writeSync(1,$.join(" ")+`
`),A=(...$)=>I.writeSync(2,$.join(" ")+`
`));var C,_=t.print||j,S=t.printErr||A;Object.assign(t,d),d=null,t.thisProgram&&(g=t.thisProgram),t.quit&&(b=t.quit),t.wasmBinary&&(C=t.wasmBinary);var E=t.noExitRuntime||!0;typeof WebAssembly!="object"&&Qe("no native wasm support detected");var z,L,Y,X,te,ae,se,pe,ge,ve=!1;function Me(){var $=z.buffer;t.HEAP8=te=new Int8Array($),t.HEAP16=new Int16Array($),t.HEAP32=se=new Int32Array($),t.HEAPU8=ae=new Uint8Array($),t.HEAPU16=new Uint16Array($),t.HEAPU32=pe=new Uint32Array($),t.HEAPF32=new Float32Array($),t.HEAPF64=ge=new Float64Array($)}var De=t.INITIAL_MEMORY||16777216;if(5242880<=De||Qe("INITIAL_MEMORY should be larger than STACK_SIZE, was "+De+"! (STACK_SIZE=5242880)"),T)z=t.wasmMemory;else if(t.wasmMemory)z=t.wasmMemory;else if(!((z=new WebAssembly.Memory({initial:De/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw S("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&S("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Me(),De=z.buffer.byteLength;var je=[],_e=[],Be=[],Pe=0;function Re(){return E||0<Pe}var Ue,He=0,Ze=null,et=null;function ct(){He++,t.monitorRunDependencies&&t.monitorRunDependencies(He)}function qe(){if(He--,t.monitorRunDependencies&&t.monitorRunDependencies(He),He==0&&(Ze!==null&&(clearInterval(Ze),Ze=null),et)){var $=et;et=null,$()}}function Qe($){throw t.onAbort&&t.onAbort($),S($="Aborted("+$+")"),ve=!0,X=1,$=new WebAssembly.RuntimeError($+". Build with -sASSERTIONS for more info."),e($),$}function tt($){return $.startsWith("data:application/octet-stream;base64,")}function Ye($){if($==Ue&&C)return new Uint8Array(C);if(l)return l($);throw"both async and sync fetching of the wasm failed"}function wt($,N,B){return function(W){if(!C&&(v||w)){if(typeof fetch=="function"&&!W.startsWith("file://"))return fetch(W,{credentials:"same-origin"}).then(q=>{if(!q.ok)throw"failed to load wasm binary file at '"+W+"'";return q.arrayBuffer()}).catch(()=>Ye(W));if(i)return new Promise((q,ce)=>{i(W,he=>q(new Uint8Array(he)),ce)})}return Promise.resolve().then(()=>Ye(W))}($).then(W=>WebAssembly.instantiate(W,N)).then(W=>W).then(B,W=>{S("failed to asynchronously prepare wasm: "+W),Qe(W)})}tt(Ue="ort-wasm-simd-threaded.wasm")||(Ue=P(Ue));var ft,ht={898348:()=>{t.jsepRunPromise=new Promise(function($){t.tb=$})},898443:$=>{t.tb($)},898481:$=>t.ob($),898514:$=>t.qb($),898546:($,N,B)=>{t.ab($,N,B,!0)},898585:($,N,B)=>{t.ab($,N,B)},898618:$=>{t.xa("Abs",$,void 0)},898669:$=>{t.xa("Neg",$,void 0)},898720:$=>{t.xa("Floor",$,void 0)},898773:$=>{t.xa("Ceil",$,void 0)},898825:$=>{t.xa("Reciprocal",$,void 0)},898883:$=>{t.xa("Sqrt",$,void 0)},898935:$=>{t.xa("Exp",$,void 0)},898986:$=>{t.xa("Erf",$,void 0)},899037:$=>{t.xa("Sigmoid",$,void 0)},899092:$=>{t.xa("Log",$,void 0)},899143:$=>{t.xa("Sin",$,void 0)},899194:$=>{t.xa("Cos",$,void 0)},899245:$=>{t.xa("Tan",$,void 0)},899296:$=>{t.xa("Asin",$,void 0)},899348:$=>{t.xa("Acos",$,void 0)},899400:$=>{t.xa("Atan",$,void 0)},899452:$=>{t.xa("Sinh",$,void 0)},899504:$=>{t.xa("Cosh",$,void 0)},899556:$=>{t.xa("Asinh",$,void 0)},899609:$=>{t.xa("Acosh",$,void 0)},899662:$=>{t.xa("Atanh",$,void 0)},899715:$=>{t.xa("Tanh",$,void 0)},899767:($,N,B)=>{t.xa("ClipV10",$,{min:N,max:B})},899839:$=>{t.xa("Clip",$,void 0)},899891:($,N)=>{t.xa("Elu",$,{alpha:N})},899949:$=>{t.xa("Relu",$,void 0)},900001:($,N)=>{t.xa("LeakyRelu",$,{alpha:N})},900065:($,N)=>{t.xa("ThresholdedRelu",$,{alpha:N})},900135:($,N)=>{t.xa("Cast",$,{to:N})},900193:$=>{t.xa("Add",$,void 0)},900244:$=>{t.xa("Sub",$,void 0)},900295:$=>{t.xa("Mul",$,void 0)},900346:$=>{t.xa("Div",$,void 0)},900397:$=>{t.xa("Pow",$,void 0)},900448:($,N,B,W,q)=>{t.xa("ReduceMean",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},900612:($,N,B,W,q)=>{t.xa("ReduceMax",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},900775:($,N,B,W,q)=>{t.xa("ReduceMin",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},900938:($,N,B,W,q)=>{t.xa("ReduceProd",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},901102:($,N,B,W,q)=>{t.xa("ReduceSum",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},901265:($,N,B,W,q)=>{t.xa("ReduceL1",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},901427:($,N,B,W,q)=>{t.xa("ReduceL2",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},901589:($,N,B,W,q)=>{t.xa("ReduceLogSum",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},901755:($,N,B,W,q)=>{t.xa("ReduceSumSquare",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},901924:($,N,B,W,q)=>{t.xa("ReduceLogSumExp",$,{keepDims:!!N,noopWithEmptyAxes:!!B,axes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},902093:($,N,B)=>{t.xa("Transpose",$,{perm:N?Array.from(s().subarray(B>>>0,B+N>>>0)):[]})},902206:($,N,B,W,q,ce,he,Oe,Ie,Ee)=>{t.xa("Conv",$,{format:Ie?"NHWC":"NCHW",auto_pad:N,dilations:[B],group:W,kernel_shape:[q],pads:[ce,he],strides:[Oe],w_is_const:()=>!!p()[Ee>>>0]})},902434:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re,Le)=>{t.xa("Conv",$,{format:re?"NHWC":"NCHW",auto_pad:N,dilations:[B,W],group:q,kernel_shape:[ce,he],pads:[Oe,Ie,Ee,Ne],strides:[Ke,nt],w_is_const:()=>!!p()[Le>>>0]})},902693:($,N,B,W,q,ce,he,Oe,Ie,Ee)=>{t.xa("Conv",$,{format:Ie?"NHWC":"NCHW",auto_pad:N,dilations:[B],group:W,kernel_shape:[q],pads:[ce,he],strides:[Oe],w_is_const:()=>!!p()[Ee>>>0]})},902921:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re,Le)=>{t.xa("Conv",$,{format:re?"NHWC":"NCHW",auto_pad:N,dilations:[B,W],group:q,kernel_shape:[ce,he],pads:[Oe,Ie,Ee,Ne],strides:[Ke,nt],w_is_const:()=>!!p()[Le>>>0]})},903180:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re)=>{t.xa("ConvTranspose",$,{format:Ie?"NHWC":"NCHW",autoPad:N,dilations:[B],group:W,kernel_shape:[q],pads:[ce,he],strides:[Oe],wIsConst:()=>!!p()[Ee>>>0],outputPadding:Ne?Array.from(s().subarray(Ke>>>0,Ke+Ne>>>0)):[],outputShape:nt?Array.from(s().subarray(re>>>0,re+nt>>>0)):[]})},903560:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt)=>{t.xa("ConvTranspose",$,{format:Oe?"NHWC":"NCHW",autoPad:N,dilations:Array.from(s().subarray(B>>>0,B+2>>>0)),group:W,kernelShape:Array.from(s().subarray(q>>>0,q+2>>>0)),pads:Array.from(s().subarray(ce>>>0,ce+4>>>0)),strides:Array.from(s().subarray(he>>>0,he+2>>>0)),wIsConst:()=>!!p()[Ie>>>0],outputPadding:0<Ee?Array.from(s().subarray(Ne>>>0,Ne+Ee>>>0)):[],outputShape:0<Ke?Array.from(s().subarray(nt>>>0,nt+Ke>>>0)):[]})},904083:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re)=>{t.xa("ConvTranspose",$,{format:Ie?"NHWC":"NCHW",autoPad:N,dilations:[B],group:W,kernel_shape:[q],pads:[ce,he],strides:[Oe],wIsConst:()=>!!p()[Ee>>>0],outputPadding:Ne?Array.from(s().subarray(Ke>>>0,Ke+Ne>>>0)):[],outputShape:nt?Array.from(s().subarray(re>>>0,re+nt>>>0)):[]})},904463:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt)=>{t.xa("ConvTranspose",$,{format:Oe?"NHWC":"NCHW",autoPad:N,dilations:Array.from(s().subarray(B>>>0,B+2>>>0)),group:W,kernelShape:Array.from(s().subarray(q>>>0,q+2>>>0)),pads:Array.from(s().subarray(ce>>>0,ce+4>>>0)),strides:Array.from(s().subarray(he>>>0,he+2>>>0)),wIsConst:()=>!!p()[Ie>>>0],outputPadding:0<Ee?Array.from(s().subarray(Ne>>>0,Ne+Ee>>>0)):[],outputShape:0<Ke?Array.from(s().subarray(nt>>>0,nt+Ke>>>0)):[]})},904986:($,N)=>{t.xa("GlobalAveragePool",$,{format:N?"NHWC":"NCHW"})},905077:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re,Le,Je)=>{t.xa("AveragePool",$,{format:Je?"NHWC":"NCHW",auto_pad:N,ceil_mode:B,count_include_pad:W,storage_order:q,dilations:[ce,he],kernel_shape:[Oe,Ie],pads:[Ee,Ne,Ke,nt],strides:[re,Le]})},905361:($,N)=>{t.xa("GlobalAveragePool",$,{format:N?"NHWC":"NCHW"})},905452:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re,Le,Je)=>{t.xa("AveragePool",$,{format:Je?"NHWC":"NCHW",auto_pad:N,ceil_mode:B,count_include_pad:W,storage_order:q,dilations:[ce,he],kernel_shape:[Oe,Ie],pads:[Ee,Ne,Ke,nt],strides:[re,Le]})},905736:($,N)=>{t.xa("GlobalMaxPool",$,{format:N?"NHWC":"NCHW"})},905823:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re,Le,Je)=>{t.xa("MaxPool",$,{format:Je?"NHWC":"NCHW",auto_pad:N,ceil_mode:B,count_include_pad:W,storage_order:q,dilations:[ce,he],kernel_shape:[Oe,Ie],pads:[Ee,Ne,Ke,nt],strides:[re,Le]})},906103:($,N)=>{t.xa("GlobalMaxPool",$,{format:N?"NHWC":"NCHW"})},906190:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne,Ke,nt,re,Le,Je)=>{t.xa("MaxPool",$,{format:Je?"NHWC":"NCHW",auto_pad:N,ceil_mode:B,count_include_pad:W,storage_order:q,dilations:[ce,he],kernel_shape:[Oe,Ie],pads:[Ee,Ne,Ke,nt],strides:[re,Le]})},906470:($,N,B,W,q)=>{t.xa("Gemm",$,{alpha:N,beta:B,transA:W,transB:q})},906574:$=>{t.xa("MatMul",$,void 0)},906628:($,N,B,W)=>{t.xa("ArgMax",$,{keepDims:!!N,selectLastIndex:!!B,axis:W})},906736:($,N,B,W)=>{t.xa("ArgMin",$,{keepDims:!!N,selectLastIndex:!!B,axis:W})},906844:($,N)=>{t.xa("Softmax",$,{axis:N})},906907:($,N)=>{t.xa("Concat",$,{axis:N})},906967:($,N,B,W,q)=>{t.xa("Split",$,{axis:N,numOutputs:B,splitSizes:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[]})},907112:$=>{t.xa("Expand",$,void 0)},907166:($,N)=>{t.xa("Gather",$,{axis:Number(N)})},907237:($,N,B,W,q,ce,he,Oe,Ie,Ee,Ne)=>{t.xa("Resize",$,{antialias:N,axes:B?Array.from(s().subarray(W>>>0,W+B>>>0)):[],coordinateTransformMode:pt(q),cubicCoeffA:ce,excludeOutside:he,extrapolationValue:Oe,keepAspectRatioPolicy:pt(Ie),mode:pt(Ee),nearestMode:pt(Ne)})},907588:($,N,B,W,q,ce,he)=>{t.xa("Slice",$,{starts:N?Array.from(s().subarray(B>>>0,B+N>>>0)):[],ends:W?Array.from(s().subarray(q>>>0,q+W>>>0)):[],axes:ce?Array.from(s().subarray(he>>>0,he+ce>>>0)):[]})},907819:$=>{t.xa("Tile",$,void 0)},907871:($,N,B)=>{t.xa("LayerNormalization",$,{axis:Number(N),epsilon:Number(B)})},907978:($,N,B)=>{t.xa("InstanceNormalization",$,{epsilon:N,format:B?"NHWC":"NCHW"})},908092:($,N,B)=>{t.xa("InstanceNormalization",$,{epsilon:N,format:B?"NHWC":"NCHW"})},908206:$=>{t.xa("Gelu",$,void 0)},908258:($,N)=>{t.xa("SkipLayerNormalization",$,{epsilon:N})},908339:$=>{t.rb($)},908373:($,N)=>t.sb($,N)};function bt($){this.name="ExitStatus",this.message=`Program terminated with exit(${$})`,this.status=$}function xt($){$.terminate(),$.onmessage=()=>{}}function Ot($){($=de.Ja[$])||Qe(),de.xb($)}function At($){var N=de.lb();if(!N)return 6;de.Ra.push(N),de.Ja[$.Qa]=N,N.Qa=$.Qa;var B={cmd:"run",start_routine:$.yb,arg:$.jb,pthread_ptr:$.Qa};return x&&N.unref(),N.postMessage(B,$.Eb),0}var Ct=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,kt=($,N,B)=>{var W=(N>>>=0)+B;for(B=N;$[B]&&!(B>=W);)++B;if(16<B-N&&$.buffer&&Ct)return Ct.decode($.buffer instanceof SharedArrayBuffer?$.slice(N,B):$.subarray(N,B));for(W="";N<B;){var q=$[N++];if(128&q){var ce=63&$[N++];if((224&q)==192)W+=String.fromCharCode((31&q)<<6|ce);else{var he=63&$[N++];65536>(q=(240&q)==224?(15&q)<<12|ce<<6|he:(7&q)<<18|ce<<12|he<<6|63&$[N++])?W+=String.fromCharCode(q):(q-=65536,W+=String.fromCharCode(55296|q>>10,56320|1023&q))}}else W+=String.fromCharCode(q)}return W},pt=($,N)=>($>>>=0)?kt(u(),$,N):"";function $t($){if(T)return Te(1,1,$);X=$,Re()||(de.zb(),t.onExit&&t.onExit($),ve=!0),b($,new bt($))}var Tt=$=>{if(X=$,T)throw mt($),"unwind";$t($)},de={Ua:[],Ra:[],eb:[],Ja:{},Xa:function(){T?de.nb():de.mb()},mb:function(){je.unshift(()=>{ct(),de.ub(()=>qe())})},nb:function(){de.receiveObjectTransfer=de.wb,de.threadInitTLS=de.cb,de.setExitStatus=de.bb,E=!1},bb:function($){X=$},Kb:["$terminateWorker"],zb:function(){for(var $ of de.Ra)xt($);for($ of de.Ua)xt($);de.Ua=[],de.Ra=[],de.Ja=[]},xb:function($){var N=$.Qa;delete de.Ja[N],de.Ua.push($),de.Ra.splice(de.Ra.indexOf($),1),$.Qa=0,Q(N)},wb:function(){},cb:function(){de.eb.forEach($=>$())},vb:$=>new Promise(N=>{$.onmessage=q=>{var ce=(q=q.data).cmd;if(q.targetThread&&q.targetThread!=jt()){var he=de.Ja[q.Jb];he?he.postMessage(q,q.transferList):S('Internal error! Worker sent a message "'+ce+'" to target pthread '+q.targetThread+", but that thread no longer exists!")}else ce==="checkMailbox"?D():ce==="spawnThread"?At(q):ce==="cleanupThread"?Ot(q.thread):ce==="killThread"?(q=q.thread,ce=de.Ja[q],delete de.Ja[q],xt(ce),Q(q),de.Ra.splice(de.Ra.indexOf(ce),1),ce.Qa=0):ce==="cancelThread"?de.Ja[q.thread].postMessage({cmd:"cancel"}):ce==="loaded"?($.loaded=!0,N($)):ce==="alert"?alert("Thread "+q.threadId+": "+q.text):q.target==="setimmediate"?$.postMessage(q):ce==="callHandler"?t[q.handler](...q.args):ce&&S("worker sent an unknown command "+ce)},$.onerror=q=>{throw S("worker sent an error! "+q.filename+":"+q.lineno+": "+q.message),q},x&&($.on("message",function(q){$.onmessage({data:q})}),$.on("error",function(q){$.onerror(q)}));var B,W=[];for(B of["onExit","onAbort","print","printErr"])t.hasOwnProperty(B)&&W.push(B);$.postMessage({cmd:"load",handlers:W,urlOrBlob:t.mainScriptUrlOrBlob||m,wasmMemory:z,wasmModule:Y})}),ub:function($){$()},ib:function(){var $=P("ort-wasm-simd-threaded.worker.js");$=new Worker($),de.Ua.push($)},lb:function(){return de.Ua.length==0&&(de.ib(),de.vb(de.Ua[0])),de.Ua.pop()}};t.PThread=de;var gt=$=>{for(;0<$.length;)$.shift()(t)};function mt($){if(T)return Te(2,0,$);Tt($)}function U($){this.$a=$-24,this.hb=function(N){a()[this.$a+4>>2>>>0]=N},this.gb=function(N){a()[this.$a+8>>2>>>0]=N},this.Xa=function(N,B){this.fb(),this.hb(N),this.gb(B)},this.fb=function(){a()[this.$a+16>>2>>>0]=0}}function J($,N,B,W){return T?Te(3,1,$,N,B,W):ee($,N,B,W)}function ee($,N,B,W){if($>>>=0,N>>>=0,B>>>=0,W>>>=0,typeof SharedArrayBuffer>"u")return S("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var q=[];return T&&q.length===0?J($,N,B,W):($={yb:B,Qa:$,jb:W,Eb:q},T?($.Gb="spawnThread",postMessage($,q),0):At($))}function le($,N,B){return T?Te(4,1,$,N,B):0}function me($,N){if(T)return Te(5,1,$,N)}t.establishStackSpace=function(){var $=jt(),N=s()[$+52>>2>>>0];$=s()[$+56>>2>>>0],at(N,N-$),lt(N)},t.invokeEntryPoint=function($,N){$=nn.apply(null,[$,N]),Re()?de.bb($):ie($)};var Ae=$=>{for(var N=0,B=0;B<$.length;++B){var W=$.charCodeAt(B);127>=W?N++:2047>=W?N+=2:55296<=W&&57343>=W?(N+=4,++B):N+=3}return N},Ce=($,N,B,W)=>{if(!(0<W))return 0;var q=B>>>=0;W=B+W-1;for(var ce=0;ce<$.length;++ce){var he=$.charCodeAt(ce);if(55296<=he&&57343>=he&&(he=65536+((1023&he)<<10)|1023&$.charCodeAt(++ce)),127>=he){if(B>=W)break;N[B++>>>0]=he}else{if(2047>=he){if(B+1>=W)break;N[B++>>>0]=192|he>>6}else{if(65535>=he){if(B+2>=W)break;N[B++>>>0]=224|he>>12}else{if(B+3>=W)break;N[B++>>>0]=240|he>>18,N[B++>>>0]=128|he>>12&63}N[B++>>>0]=128|he>>6&63}N[B++>>>0]=128|63&he}}return N[B>>>0]=0,B-q},rt=($,N,B)=>Ce($,u(),N,B);function ut($,N){if(T)return Te(6,1,$,N)}function ot($,N,B){if(T)return Te(7,1,$,N,B)}function it($,N,B){return T?Te(8,1,$,N,B):0}function Pt($,N){if(T)return Te(9,1,$,N)}function It($,N,B){if(T)return Te(10,1,$,N,B)}function oe($,N,B,W){if(T)return Te(11,1,$,N,B,W)}function Fe($,N,B,W){if(T)return Te(12,1,$,N,B,W)}function Xe($,N,B,W){if(T)return Te(13,1,$,N,B,W)}function yt($){if(T)return Te(14,1,$)}function Et($,N){if(T)return Te(15,1,$,N)}function Nt($,N,B){if(T)return Te(16,1,$,N,B)}var Lt=$=>{if(!ve)try{if($(),!Re())try{T?ie(X):Tt(X)}catch(N){N instanceof bt||N=="unwind"||b(1,N)}}catch(N){N instanceof bt||N=="unwind"||b(1,N)}};function Ft($){$>>>=0,typeof Atomics.Fb=="function"&&(Atomics.Fb(s(),$>>2,$).value.then(D),$+=128,Atomics.store(s(),$>>2,1))}function D(){var $=jt();$&&(Ft($),Lt(()=>ye()))}t.__emscripten_thread_mailbox_await=Ft,t.checkMailbox=D;var F=$=>$%4==0&&($%100!=0||$%400==0),V=[0,31,60,91,121,152,182,213,244,274,305,335],K=[0,31,59,90,120,151,181,212,243,273,304,334];function Z($,N,B,W,q,ce,he,Oe){return T?Te(17,1,$,N,B,W,q,ce,he,Oe):-52}function fe($,N,B,W,q,ce,he){if(T)return Te(18,1,$,N,B,W,q,ce,he)}var be=$=>{var N=Ae($)+1,B=zt(N);return B&&rt($,B,N),B},xe=[],Se=($,N)=>{var B;for(xe.length=0,N>>=2;B=u()[$++>>>0];)N+=B!=105&N,xe.push(B==105?s()[N>>>0]:o()[N++>>>1]),++N;return xe},we=$=>{var N=vt();return $=$(),lt(N),$};function Te($,N){var B=arguments.length-2,W=arguments;return we(()=>{for(var q=dt(8*B),ce=q>>3,he=0;he<B;he++){var Oe=W[2+he];o()[ce+he>>>0]=Oe}return H($,B,q,N)})}var ze,Ve=[],ne={},ke=()=>{if(!ze){var $,N={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for($ in ne)ne[$]===void 0?delete N[$]:N[$]=ne[$];var B=[];for($ in N)B.push(`${$}=${N[$]}`);ze=B}return ze};function Ge($,N){if(T)return Te(19,1,$,N);$>>>=0,N>>>=0;var B=0;return ke().forEach(function(W,q){var ce=N+B;for(q=a()[$+4*q>>2>>>0]=ce,ce=0;ce<W.length;++ce)p()[q++>>0>>>0]=W.charCodeAt(ce);p()[q>>0>>>0]=0,B+=W.length+1}),0}function _t($,N){if(T)return Te(20,1,$,N);$>>>=0,N>>>=0;var B=ke();a()[$>>2>>>0]=B.length;var W=0;return B.forEach(function(q){W+=q.length+1}),a()[N>>2>>>0]=W,0}function Bt($){return T?Te(21,1,$):52}function Ht($,N,B,W){return T?Te(22,1,$,N,B,W):52}function on($,N,B,W,q){return T?Te(23,1,$,N,B,W,q):70}var an=[null,[],[]];function qt($,N,B,W){if(T)return Te(24,1,$,N,B,W);N>>>=0,B>>>=0,W>>>=0;for(var q=0,ce=0;ce<B;ce++){var he=a()[N>>2>>>0],Oe=a()[N+4>>2>>>0];N+=8;for(var Ie=0;Ie<Oe;Ie++){var Ee=u()[he+Ie>>>0],Ne=an[$];Ee===0||Ee===10?(($===1?_:S)(kt(Ne,0)),Ne.length=0):Ne.push(Ee)}q+=Oe}return a()[W>>2>>>0]=q,0}var Kt=$=>(Kt=(()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return W=>(W.set(crypto.getRandomValues(new Uint8Array(W.byteLength))),W);if(x)try{var N=y(760);if(N.randomFillSync)return W=>N.randomFillSync(W);var B=N.randomBytes;return W=>(W.set(B(W.byteLength)),W)}catch{}Qe("initRandomDevice")})())($),Xt=[31,29,31,30,31,30,31,31,30,31,30,31],sn=[31,28,31,30,31,30,31,31,30,31,30,31],un=($,N)=>{p().set($,N>>>0)};function ln($,N,B,W){function q(re,Le,Je){for(re=typeof re=="number"?re.toString():re||"";re.length<Le;)re=Je[0]+re;return re}function ce(re,Le){return q(re,Le,"0")}function he(re,Le){function Je(hn){return 0>hn?-1:0<hn?1:0}var Ut;return(Ut=Je(re.getFullYear()-Le.getFullYear()))===0&&(Ut=Je(re.getMonth()-Le.getMonth()))===0&&(Ut=Je(re.getDate()-Le.getDate())),Ut}function Oe(re){switch(re.getDay()){case 0:return new Date(re.getFullYear()-1,11,29);case 1:return re;case 2:return new Date(re.getFullYear(),0,3);case 3:return new Date(re.getFullYear(),0,2);case 4:return new Date(re.getFullYear(),0,1);case 5:return new Date(re.getFullYear()-1,11,31);case 6:return new Date(re.getFullYear()-1,11,30)}}function Ie(re){var Le=re.Sa;for(re=new Date(new Date(re.Ta+1900,0,1).getTime());0<Le;){var Je=re.getMonth(),Ut=(F(re.getFullYear())?Xt:sn)[Je];if(!(Le>Ut-re.getDate())){re.setDate(re.getDate()+Le);break}Le-=Ut-re.getDate()+1,re.setDate(1),11>Je?re.setMonth(Je+1):(re.setMonth(0),re.setFullYear(re.getFullYear()+1))}return Je=new Date(re.getFullYear()+1,0,4),Le=Oe(new Date(re.getFullYear(),0,4)),Je=Oe(Je),0>=he(Le,re)?0>=he(Je,re)?re.getFullYear()+1:re.getFullYear():re.getFullYear()-1}$>>>=0,N>>>=0,B>>>=0,W>>>=0;var Ee=s()[W+40>>2>>>0];for(var Ne in W={Cb:s()[W>>2>>>0],Bb:s()[W+4>>2>>>0],Va:s()[W+8>>2>>>0],Za:s()[W+12>>2>>>0],Wa:s()[W+16>>2>>>0],Ta:s()[W+20>>2>>>0],Pa:s()[W+24>>2>>>0],Sa:s()[W+28>>2>>>0],Lb:s()[W+32>>2>>>0],Ab:s()[W+36>>2>>>0],Db:Ee?pt(Ee):""},B=pt(B),Ee={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})B=B.replace(new RegExp(Ne,"g"),Ee[Ne]);var Ke="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),nt="January February March April May June July August September October November December".split(" ");for(Ne in Ee={"%a":re=>Ke[re.Pa].substring(0,3),"%A":re=>Ke[re.Pa],"%b":re=>nt[re.Wa].substring(0,3),"%B":re=>nt[re.Wa],"%C":re=>ce((re.Ta+1900)/100|0,2),"%d":re=>ce(re.Za,2),"%e":re=>q(re.Za,2," "),"%g":re=>Ie(re).toString().substring(2),"%G":re=>Ie(re),"%H":re=>ce(re.Va,2),"%I":re=>((re=re.Va)==0?re=12:12<re&&(re-=12),ce(re,2)),"%j":re=>{for(var Le=0,Je=0;Je<=re.Wa-1;Le+=(F(re.Ta+1900)?Xt:sn)[Je++]);return ce(re.Za+Le,3)},"%m":re=>ce(re.Wa+1,2),"%M":re=>ce(re.Bb,2),"%n":()=>`
`,"%p":re=>0<=re.Va&&12>re.Va?"AM":"PM","%S":re=>ce(re.Cb,2),"%t":()=>"	","%u":re=>re.Pa||7,"%U":re=>ce(Math.floor((re.Sa+7-re.Pa)/7),2),"%V":re=>{var Le=Math.floor((re.Sa+7-(re.Pa+6)%7)/7);if(2>=(re.Pa+371-re.Sa-2)%7&&Le++,Le)Le==53&&((Je=(re.Pa+371-re.Sa)%7)==4||Je==3&&F(re.Ta)||(Le=1));else{Le=52;var Je=(re.Pa+7-re.Sa-1)%7;(Je==4||Je==5&&F(re.Ta%400-1))&&Le++}return ce(Le,2)},"%w":re=>re.Pa,"%W":re=>ce(Math.floor((re.Sa+7-(re.Pa+6)%7)/7),2),"%y":re=>(re.Ta+1900).toString().substring(2),"%Y":re=>re.Ta+1900,"%z":re=>{var Le=0<=(re=re.Ab);return re=Math.abs(re)/60,(Le?"+":"-")+("0000"+(re/60*100+re%60)).slice(-4)},"%Z":re=>re.Db,"%%":()=>"%"},B=B.replace(/%%/g,"\0\0"),Ee)B.includes(Ne)&&(B=B.replace(new RegExp(Ne,"g"),Ee[Ne](W)));return Ne=function(re){var Le=Array(Ae(re)+1);return Ce(re,Le,0,Le.length),Le}(B=B.replace(/\0\0/g,"%")),Ne.length>N?0:(un(Ne,$),Ne.length-1)}function Vt($){try{$()}catch(N){Qe(N)}}var St=0,Dt=null,Yt=0,Mt=[],Jt={},Wt={},Zt=0,Qt=null,cn=[];de.Xa();var pn=[null,$t,mt,J,le,me,ut,ot,it,Pt,It,oe,Fe,Xe,yt,Et,Nt,Z,fe,Ge,_t,Bt,Ht,on,qt],en={r:function($,N,B){return function(W){return function(q){if(!ve){if(St===0){var ce=!1,he=!1;q((Oe=0)=>{if(!ve&&(Yt=Oe,ce=!0,he)){St=2,Vt(()=>We(Dt)),typeof Browser<"u"&&Browser.Ya.kb&&Browser.Ya.resume(),Oe=!1;try{var Ie=function(){var Ke=s()[Dt+8>>2>>>0];return Ke=L[Wt[Ke]],--Pe,Ke()}()}catch(Ke){Ie=Ke,Oe=!0}var Ee=!1;if(!Dt){var Ne=Qt;Ne&&(Qt=null,(Oe?Ne.reject:Ne.resolve)(Ie),Ee=!0)}if(Oe&&!Ee)throw Ie}}),he=!0,ce||(St=1,Dt=function(){var Oe=zt(65548),Ie=Oe+12;a()[Oe>>2>>>0]=Ie,a()[Oe+4>>2>>>0]=Ie+65536,Ie=Mt[0];var Ee=Jt[Ie];return Ee===void 0&&(Ee=Zt++,Jt[Ie]=Ee,Wt[Ee]=Ie),Ie=Ee,s()[Oe+8>>2>>>0]=Ie,Oe}(),typeof Browser<"u"&&Browser.Ya.kb&&Browser.Ya.pause(),Vt(()=>rn(Dt)))}else St===2?(St=0,Vt(st),tn(Dt),Dt=null,cn.forEach(Oe=>Lt(Oe))):Qe(`invalid state: ${St}`);return Yt}}(q=>{W().then(q)})}(async()=>{await t.pb($,N,B)})},b:function($,N,B){throw new U($>>>=0).Xa(N>>>0,B>>>0),$},O:function($){k($>>>0,!w,1,!v,131072,!1),de.cb()},m:function($){$>>>=0,T?postMessage({cmd:"cleanupThread",thread:$}):Ot($)},J:ee,i:le,U:me,G:ut,I:ot,V:it,S:Pt,K:It,R:oe,q:Fe,H:Xe,E:yt,T:Et,F:Nt,Y:()=>!0,C:function($,N){($>>>=0)==N>>>0?setTimeout(()=>D()):T?postMessage({targetThread:$,cmd:"checkMailbox"}):($=de.Ja[$])&&$.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Ft,X:function($){x&&de.Ja[$>>>0].ref()},u:function($,N,B){$=N+2097152>>>0<4194305-!!$?($>>>0)+4294967296*N:NaN,B>>>=0,$=new Date(1e3*$),s()[B>>2>>>0]=$.getUTCSeconds(),s()[B+4>>2>>>0]=$.getUTCMinutes(),s()[B+8>>2>>>0]=$.getUTCHours(),s()[B+12>>2>>>0]=$.getUTCDate(),s()[B+16>>2>>>0]=$.getUTCMonth(),s()[B+20>>2>>>0]=$.getUTCFullYear()-1900,s()[B+24>>2>>>0]=$.getUTCDay(),$=($.getTime()-Date.UTC($.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,s()[B+28>>2>>>0]=$},v:function($,N,B){$=N+2097152>>>0<4194305-!!$?($>>>0)+4294967296*N:NaN,B>>>=0,$=new Date(1e3*$),s()[B>>2>>>0]=$.getSeconds(),s()[B+4>>2>>>0]=$.getMinutes(),s()[B+8>>2>>>0]=$.getHours(),s()[B+12>>2>>>0]=$.getDate(),s()[B+16>>2>>>0]=$.getMonth(),s()[B+20>>2>>>0]=$.getFullYear()-1900,s()[B+24>>2>>>0]=$.getDay(),N=(F($.getFullYear())?V:K)[$.getMonth()]+$.getDate()-1|0,s()[B+28>>2>>>0]=N,s()[B+36>>2>>>0]=-60*$.getTimezoneOffset(),N=new Date($.getFullYear(),6,1).getTimezoneOffset();var W=new Date($.getFullYear(),0,1).getTimezoneOffset();$=0|(N!=W&&$.getTimezoneOffset()==Math.min(W,N)),s()[B+32>>2>>>0]=$},w:function($){$>>>=0;var N=new Date(s()[$+20>>2>>>0]+1900,s()[$+16>>2>>>0],s()[$+12>>2>>>0],s()[$+8>>2>>>0],s()[$+4>>2>>>0],s()[$>>2>>>0],0),B=s()[$+32>>2>>>0],W=N.getTimezoneOffset(),q=new Date(N.getFullYear(),6,1).getTimezoneOffset(),ce=new Date(N.getFullYear(),0,1).getTimezoneOffset(),he=Math.min(ce,q);return 0>B?s()[$+32>>2>>>0]=+(q!=ce&&he==W):0<B!=(he==W)&&(q=Math.max(ce,q),N.setTime(N.getTime()+6e4*((0<B?he:q)-W))),s()[$+24>>2>>>0]=N.getDay(),B=(F(N.getFullYear())?V:K)[N.getMonth()]+N.getDate()-1|0,s()[$+28>>2>>>0]=B,s()[$>>2>>>0]=N.getSeconds(),s()[$+4>>2>>>0]=N.getMinutes(),s()[$+8>>2>>>0]=N.getHours(),s()[$+12>>2>>>0]=N.getDate(),s()[$+16>>2>>>0]=N.getMonth(),s()[$+20>>2>>>0]=N.getYear(),$=N.getTime()/1e3,$e((ft=$,1<=+Math.abs(ft)?0<ft?+Math.floor(ft/4294967296)>>>0:~~+Math.ceil((ft-+(~~ft>>>0))/4294967296)>>>0:0)),$>>>0},s:Z,t:fe,A:function($,N,B){function W(Ee){return(Ee=Ee.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Ee[1]:"GMT"}$>>>=0,N>>>=0,B>>>=0;var q=new Date().getFullYear(),ce=new Date(q,0,1),he=new Date(q,6,1);q=ce.getTimezoneOffset();var Oe=he.getTimezoneOffset(),Ie=Math.max(q,Oe);a()[$>>2>>>0]=60*Ie,s()[N>>2>>>0]=+(q!=Oe),$=W(ce),N=W(he),$=be($),N=be(N),Oe<q?(a()[B>>2>>>0]=$,a()[B+4>>2>>>0]=N):(a()[B>>2>>>0]=N,a()[B+4>>2>>>0]=$)},d:()=>{Qe("")},c:function($,N,B){return $>>>=0,N=Se(N>>>0,B>>>0),ht[$].apply(null,N)},l:function($,N,B){return $>>>=0,N=Se(N>>>0,B>>>0),ht[$].apply(null,N)},n:function(){},j:function(){return Date.now()},W:()=>{throw Pe+=1,"unwind"},D:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return x?y(3993).cpus().length:navigator.hardwareConcurrency},L:function($,N,B,W){for(de.Hb=N>>>0,Ve.length=B,N=W>>>0>>3,W=0;W<B;W++)Ve[W]=o()[N+W>>>0];return(0>$?ht[-$-1]:pn[$]).apply(null,Ve)},z:function($){$>>>=0;var N=u().length;if($<=N||4294901760<$)return!1;for(var B=1;4>=B;B*=2){var W=N*(1+.2/B);W=Math.min(W,$+100663296);var q=Math;W=Math.max($,W);e:{q=q.min.call(q,4294901760,W+(65536-W%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(q),Me();var ce=1;break e}catch{}ce=void 0}if(ce)return!0}return!1},P:Ge,Q:_t,k:Tt,h:Bt,p:Ht,x:on,o:qt,y:function($,N){return $>>>=0,N>>>=0,Kt(u().subarray($>>>0,$+N>>>0)),0},a:z||t.wasmMemory,B:ln,e:function($,N,B,W){return ln($>>>0,N>>>0,B>>>0,W>>>0)}};(function(){function $(B,W){return B=function(q){var ce,he={};for(ce in q)(function(Oe){var Ie=q[Oe];he[Oe]=typeof Ie=="function"?function(){Mt.push(Oe);try{return Ie.apply(null,arguments)}finally{ve||(Mt.pop()===Oe||Qe(),Dt&&St===1&&Mt.length===0&&(St=0,Pe+=1,Vt(ue),typeof Fibers<"u"&&Fibers.Mb()))}}:Ie})(ce);return he}(B=B.exports),L=B=function(q){var ce=Oe=>()=>Oe()>>>0,he=Oe=>Ie=>Oe(Ie)>>>0;return(q=Object.assign({},q)).__errno_location=ce(q.__errno_location),q.pthread_self=ce(q.pthread_self),q.malloc=he(q.malloc),q.stackSave=ce(q.stackSave),q.stackAlloc=he(q.stackAlloc),q}(B),de.eb.push(L.wa),_e.unshift(L.Z),Y=W,qe(),B}var N={a:en};if(ct(),t.instantiateWasm)try{return t.instantiateWasm(N,$)}catch(B){S("Module.instantiateWasm callback failed with error: "+B),e(B)}(function(B,W){var q=Ue;return C||typeof WebAssembly.instantiateStreaming!="function"||tt(q)||q.startsWith("file://")||x||typeof fetch!="function"?wt(q,B,W):fetch(q,{credentials:"same-origin"}).then(ce=>WebAssembly.instantiateStreaming(ce,B).then(W,function(he){return S("wasm streaming compile failed: "+he),S("falling back to ArrayBuffer instantiation"),wt(q,B,W)}))})(N,function(B){$(B.instance,B.module)}).catch(e)})(),t._OrtInit=($,N)=>(t._OrtInit=L._)($,N),t._OrtGetLastError=($,N)=>(t._OrtGetLastError=L.$)($,N),t._OrtCreateSessionOptions=($,N,B,W,q,ce,he,Oe,Ie,Ee)=>(t._OrtCreateSessionOptions=L.aa)($,N,B,W,q,ce,he,Oe,Ie,Ee),t._OrtAppendExecutionProvider=($,N)=>(t._OrtAppendExecutionProvider=L.ba)($,N),t._OrtAddSessionConfigEntry=($,N,B)=>(t._OrtAddSessionConfigEntry=L.ca)($,N,B),t._OrtReleaseSessionOptions=$=>(t._OrtReleaseSessionOptions=L.da)($),t._OrtCreateSession=($,N,B)=>(t._OrtCreateSession=L.ea)($,N,B),t._OrtReleaseSession=$=>(t._OrtReleaseSession=L.fa)($),t._OrtGetInputOutputCount=($,N,B)=>(t._OrtGetInputOutputCount=L.ga)($,N,B),t._OrtGetInputName=($,N)=>(t._OrtGetInputName=L.ha)($,N),t._OrtGetOutputName=($,N)=>(t._OrtGetOutputName=L.ia)($,N),t._OrtFree=$=>(t._OrtFree=L.ja)($),t._OrtCreateTensor=($,N,B,W,q)=>(t._OrtCreateTensor=L.ka)($,N,B,W,q),t._OrtGetTensorData=($,N,B,W,q)=>(t._OrtGetTensorData=L.la)($,N,B,W,q),t._OrtReleaseTensor=$=>(t._OrtReleaseTensor=L.ma)($),t._OrtCreateRunOptions=($,N,B,W)=>(t._OrtCreateRunOptions=L.na)($,N,B,W),t._OrtAddRunConfigEntry=($,N,B)=>(t._OrtAddRunConfigEntry=L.oa)($,N,B),t._OrtReleaseRunOptions=$=>(t._OrtReleaseRunOptions=L.pa)($),t._OrtRun=($,N,B,W,q,ce,he,Oe)=>(t._OrtRun=L.qa)($,N,B,W,q,ce,he,Oe),t._OrtEndProfiling=$=>(t._OrtEndProfiling=L.ra)($),t._JsepOutput=($,N,B)=>(t._JsepOutput=L.sa)($,N,B);var jt=t._pthread_self=()=>(jt=t._pthread_self=L.ta)(),zt=t._malloc=$=>(zt=t._malloc=L.ua)($),tn=t._free=$=>(tn=t._free=L.va)($);t.__emscripten_tls_init=()=>(t.__emscripten_tls_init=L.wa)();var k=t.__emscripten_thread_init=($,N,B,W,q,ce)=>(k=t.__emscripten_thread_init=L.ya)($,N,B,W,q,ce);t.__emscripten_thread_crashed=()=>(t.__emscripten_thread_crashed=L.za)();var G,H=($,N,B,W)=>(H=L.Aa)($,N,B,W),Q=$=>(Q=L.Ba)($),ie=t.__emscripten_thread_exit=$=>(ie=t.__emscripten_thread_exit=L.Ca)($),ye=t.__emscripten_check_mailbox=()=>(ye=t.__emscripten_check_mailbox=L.Da)(),$e=$=>($e=L.Ea)($),at=($,N)=>(at=L.Fa)($,N),vt=()=>(vt=L.Ga)(),lt=$=>(lt=L.Ha)($),dt=$=>(dt=L.Ia)($),nn=t.dynCall_ii=($,N)=>(nn=t.dynCall_ii=L.Ka)($,N),rn=$=>(rn=L.La)($),ue=()=>(ue=L.Ma)(),We=$=>(We=L.Na)($),st=()=>(st=L.Oa)();function Rt(){function $(){if(!G&&(G=!0,t.calledRun=!0,!ve)&&(T||gt(_e),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),!T)){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;){var N=t.postRun.shift();Be.unshift(N)}gt(Be)}}if(!(0<He))if(T)n(t),T||gt(_e),startWorker(t);else{if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)je.unshift(t.preRun.shift());gt(je),0<He||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),$()},1)):$())}}if(t.___start_em_js=908408,t.___stop_em_js=908569,t.keepRuntimeAlive=Re,t.wasmMemory=z,t.stackAlloc=dt,t.stackSave=vt,t.stackRestore=lt,t.UTF8ToString=pt,t.stringToUTF8=rt,t.lengthBytesUTF8=Ae,t.ExitStatus=bt,t.PThread=de,et=function $(){G||Rt(),G||(et=$)},t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return Rt(),h.ready});M.exports=f},9377:(M,c,y)=>{var m,f=(m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(m=m||__filename),function(h={}){var p,u,s=h;s.ready=new Promise((D,F)=>{p=D,u=F}),s.jsepInit=function(D,F,V,K,Z,fe,be,xe){s.Sa=D,s.Ea=F,s.Ga=V,s.Ca=K,s.Fa=Z,s.la=fe,s.Ha=be,s.Ia=xe};var a,o,n,e=Object.assign({},s),t="./this.program",r=(D,F)=>{throw F},i=typeof window=="object",l=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";if(d){var b=y(1384),v=y(908);g=l?v.dirname(g)+"/":__dirname+"/",a=(D,F)=>(D=D.startsWith("file://")?new URL(D):v.normalize(D),b.readFileSync(D,F?void 0:"utf8")),n=D=>((D=a(D,!0)).buffer||(D=new Uint8Array(D)),D),o=(D,F,V,K=!0)=>{D=D.startsWith("file://")?new URL(D):v.normalize(D),b.readFile(D,K?void 0:"utf8",(Z,fe)=>{Z?V(Z):F(K?fe.buffer:fe)})},!s.thisProgram&&1<process.argv.length&&(t=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),r=(D,F)=>{throw process.exitCode=D,F},s.inspect=()=>"[Emscripten Module object]"}else(i||l)&&(l?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),m&&(g=m),g=g.indexOf("blob:")!==0?g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=D=>{var F=new XMLHttpRequest;return F.open("GET",D,!1),F.send(null),F.responseText},l&&(n=D=>{var F=new XMLHttpRequest;return F.open("GET",D,!1),F.responseType="arraybuffer",F.send(null),new Uint8Array(F.response)}),o=(D,F,V)=>{var K=new XMLHttpRequest;K.open("GET",D,!0),K.responseType="arraybuffer",K.onload=()=>{K.status==200||K.status==0&&K.response?F(K.response):V()},K.onerror=V,K.send(null)});var w,x=s.print||console.log.bind(console),T=s.printErr||console.error.bind(console);Object.assign(s,e),e=null,s.thisProgram&&(t=s.thisProgram),s.quit&&(r=s.quit),s.wasmBinary&&(w=s.wasmBinary);var O=s.noExitRuntime||!0;typeof WebAssembly!="object"&&ve("no native wasm support detected");var P,I,R,j,A,C,_,S,E=!1;function z(){var D=P.buffer;s.HEAP8=j=new Int8Array(D),s.HEAP16=new Int16Array(D),s.HEAP32=C=new Int32Array(D),s.HEAPU8=A=new Uint8Array(D),s.HEAPU16=new Uint16Array(D),s.HEAPU32=_=new Uint32Array(D),s.HEAPF32=new Float32Array(D),s.HEAPF64=S=new Float64Array(D)}var L=[],Y=[],X=[];function te(){var D=s.preRun.shift();L.unshift(D)}var ae,se=0,pe=null,ge=null;function ve(D){throw s.onAbort&&s.onAbort(D),T(D="Aborted("+D+")"),E=!0,R=1,D=new WebAssembly.RuntimeError(D+". Build with -sASSERTIONS for more info."),u(D),D}function Me(D){return D.startsWith("data:application/octet-stream;base64,")}if(!Me(ae="ort-wasm-simd.wasm")){var De=ae;ae=s.locateFile?s.locateFile(De,g):g+De}function je(D){if(D==ae&&w)return new Uint8Array(w);if(n)return n(D);throw"both async and sync fetching of the wasm failed"}function _e(D,F,V){return function(K){if(!w&&(i||l)){if(typeof fetch=="function"&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then(Z=>{if(!Z.ok)throw"failed to load wasm binary file at '"+K+"'";return Z.arrayBuffer()}).catch(()=>je(K));if(o)return new Promise((Z,fe)=>{o(K,be=>Z(new Uint8Array(be)),fe)})}return Promise.resolve().then(()=>je(K))}(D).then(K=>WebAssembly.instantiate(K,F)).then(K=>K).then(V,K=>{T("failed to asynchronously prepare wasm: "+K),ve(K)})}var Be,Pe={894528:()=>{s.jsepRunPromise=new Promise(function(D){s.Ja=D})},894623:D=>{s.Ja(D)},894661:D=>s.Ea(D),894694:D=>s.Ga(D),894726:(D,F,V)=>{s.Ca(D,F,V,!0)},894765:(D,F,V)=>{s.Ca(D,F,V)},894798:D=>{s.la("Abs",D,void 0)},894849:D=>{s.la("Neg",D,void 0)},894900:D=>{s.la("Floor",D,void 0)},894953:D=>{s.la("Ceil",D,void 0)},895005:D=>{s.la("Reciprocal",D,void 0)},895063:D=>{s.la("Sqrt",D,void 0)},895115:D=>{s.la("Exp",D,void 0)},895166:D=>{s.la("Erf",D,void 0)},895217:D=>{s.la("Sigmoid",D,void 0)},895272:D=>{s.la("Log",D,void 0)},895323:D=>{s.la("Sin",D,void 0)},895374:D=>{s.la("Cos",D,void 0)},895425:D=>{s.la("Tan",D,void 0)},895476:D=>{s.la("Asin",D,void 0)},895528:D=>{s.la("Acos",D,void 0)},895580:D=>{s.la("Atan",D,void 0)},895632:D=>{s.la("Sinh",D,void 0)},895684:D=>{s.la("Cosh",D,void 0)},895736:D=>{s.la("Asinh",D,void 0)},895789:D=>{s.la("Acosh",D,void 0)},895842:D=>{s.la("Atanh",D,void 0)},895895:D=>{s.la("Tanh",D,void 0)},895947:(D,F,V)=>{s.la("ClipV10",D,{min:F,max:V})},896019:D=>{s.la("Clip",D,void 0)},896071:(D,F)=>{s.la("Elu",D,{alpha:F})},896129:D=>{s.la("Relu",D,void 0)},896181:(D,F)=>{s.la("LeakyRelu",D,{alpha:F})},896245:(D,F)=>{s.la("ThresholdedRelu",D,{alpha:F})},896315:(D,F)=>{s.la("Cast",D,{to:F})},896373:D=>{s.la("Add",D,void 0)},896424:D=>{s.la("Sub",D,void 0)},896475:D=>{s.la("Mul",D,void 0)},896526:D=>{s.la("Div",D,void 0)},896577:D=>{s.la("Pow",D,void 0)},896628:(D,F,V,K,Z)=>{s.la("ReduceMean",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},896792:(D,F,V,K,Z)=>{s.la("ReduceMax",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},896955:(D,F,V,K,Z)=>{s.la("ReduceMin",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},897118:(D,F,V,K,Z)=>{s.la("ReduceProd",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},897282:(D,F,V,K,Z)=>{s.la("ReduceSum",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},897445:(D,F,V,K,Z)=>{s.la("ReduceL1",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},897607:(D,F,V,K,Z)=>{s.la("ReduceL2",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},897769:(D,F,V,K,Z)=>{s.la("ReduceLogSum",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},897935:(D,F,V,K,Z)=>{s.la("ReduceSumSquare",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},898104:(D,F,V,K,Z)=>{s.la("ReduceLogSumExp",D,{keepDims:!!F,noopWithEmptyAxes:!!V,axes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},898273:(D,F,V)=>{s.la("Transpose",D,{perm:F?Array.from(C.subarray(V>>>0,V+F>>>0)):[]})},898386:(D,F,V,K,Z,fe,be,xe,Se,we)=>{s.la("Conv",D,{format:Se?"NHWC":"NCHW",auto_pad:F,dilations:[V],group:K,kernel_shape:[Z],pads:[fe,be],strides:[xe],w_is_const:()=>!!j[we>>>0]})},898614:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne,ke)=>{s.la("Conv",D,{format:ne?"NHWC":"NCHW",auto_pad:F,dilations:[V,K],group:Z,kernel_shape:[fe,be],pads:[xe,Se,we,Te],strides:[ze,Ve],w_is_const:()=>!!j[ke>>>0]})},898873:(D,F,V,K,Z,fe,be,xe,Se,we)=>{s.la("Conv",D,{format:Se?"NHWC":"NCHW",auto_pad:F,dilations:[V],group:K,kernel_shape:[Z],pads:[fe,be],strides:[xe],w_is_const:()=>!!j[we>>>0]})},899101:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne,ke)=>{s.la("Conv",D,{format:ne?"NHWC":"NCHW",auto_pad:F,dilations:[V,K],group:Z,kernel_shape:[fe,be],pads:[xe,Se,we,Te],strides:[ze,Ve],w_is_const:()=>!!j[ke>>>0]})},899360:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne)=>{s.la("ConvTranspose",D,{format:Se?"NHWC":"NCHW",autoPad:F,dilations:[V],group:K,kernel_shape:[Z],pads:[fe,be],strides:[xe],wIsConst:()=>!!j[we>>>0],outputPadding:Te?Array.from(C.subarray(ze>>>0,ze+Te>>>0)):[],outputShape:Ve?Array.from(C.subarray(ne>>>0,ne+Ve>>>0)):[]})},899740:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve)=>{s.la("ConvTranspose",D,{format:xe?"NHWC":"NCHW",autoPad:F,dilations:Array.from(C.subarray(V>>>0,V+2>>>0)),group:K,kernelShape:Array.from(C.subarray(Z>>>0,Z+2>>>0)),pads:Array.from(C.subarray(fe>>>0,fe+4>>>0)),strides:Array.from(C.subarray(be>>>0,be+2>>>0)),wIsConst:()=>!!j[Se>>>0],outputPadding:0<we?Array.from(C.subarray(Te>>>0,Te+we>>>0)):[],outputShape:0<ze?Array.from(C.subarray(Ve>>>0,Ve+ze>>>0)):[]})},900263:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne)=>{s.la("ConvTranspose",D,{format:Se?"NHWC":"NCHW",autoPad:F,dilations:[V],group:K,kernel_shape:[Z],pads:[fe,be],strides:[xe],wIsConst:()=>!!j[we>>>0],outputPadding:Te?Array.from(C.subarray(ze>>>0,ze+Te>>>0)):[],outputShape:Ve?Array.from(C.subarray(ne>>>0,ne+Ve>>>0)):[]})},900643:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve)=>{s.la("ConvTranspose",D,{format:xe?"NHWC":"NCHW",autoPad:F,dilations:Array.from(C.subarray(V>>>0,V+2>>>0)),group:K,kernelShape:Array.from(C.subarray(Z>>>0,Z+2>>>0)),pads:Array.from(C.subarray(fe>>>0,fe+4>>>0)),strides:Array.from(C.subarray(be>>>0,be+2>>>0)),wIsConst:()=>!!j[Se>>>0],outputPadding:0<we?Array.from(C.subarray(Te>>>0,Te+we>>>0)):[],outputShape:0<ze?Array.from(C.subarray(Ve>>>0,Ve+ze>>>0)):[]})},901166:(D,F)=>{s.la("GlobalAveragePool",D,{format:F?"NHWC":"NCHW"})},901257:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne,ke,Ge)=>{s.la("AveragePool",D,{format:Ge?"NHWC":"NCHW",auto_pad:F,ceil_mode:V,count_include_pad:K,storage_order:Z,dilations:[fe,be],kernel_shape:[xe,Se],pads:[we,Te,ze,Ve],strides:[ne,ke]})},901541:(D,F)=>{s.la("GlobalAveragePool",D,{format:F?"NHWC":"NCHW"})},901632:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne,ke,Ge)=>{s.la("AveragePool",D,{format:Ge?"NHWC":"NCHW",auto_pad:F,ceil_mode:V,count_include_pad:K,storage_order:Z,dilations:[fe,be],kernel_shape:[xe,Se],pads:[we,Te,ze,Ve],strides:[ne,ke]})},901916:(D,F)=>{s.la("GlobalMaxPool",D,{format:F?"NHWC":"NCHW"})},902003:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne,ke,Ge)=>{s.la("MaxPool",D,{format:Ge?"NHWC":"NCHW",auto_pad:F,ceil_mode:V,count_include_pad:K,storage_order:Z,dilations:[fe,be],kernel_shape:[xe,Se],pads:[we,Te,ze,Ve],strides:[ne,ke]})},902283:(D,F)=>{s.la("GlobalMaxPool",D,{format:F?"NHWC":"NCHW"})},902370:(D,F,V,K,Z,fe,be,xe,Se,we,Te,ze,Ve,ne,ke,Ge)=>{s.la("MaxPool",D,{format:Ge?"NHWC":"NCHW",auto_pad:F,ceil_mode:V,count_include_pad:K,storage_order:Z,dilations:[fe,be],kernel_shape:[xe,Se],pads:[we,Te,ze,Ve],strides:[ne,ke]})},902650:(D,F,V,K,Z)=>{s.la("Gemm",D,{alpha:F,beta:V,transA:K,transB:Z})},902754:D=>{s.la("MatMul",D,void 0)},902808:(D,F,V,K)=>{s.la("ArgMax",D,{keepDims:!!F,selectLastIndex:!!V,axis:K})},902916:(D,F,V,K)=>{s.la("ArgMin",D,{keepDims:!!F,selectLastIndex:!!V,axis:K})},903024:(D,F)=>{s.la("Softmax",D,{axis:F})},903087:(D,F)=>{s.la("Concat",D,{axis:F})},903147:(D,F,V,K,Z)=>{s.la("Split",D,{axis:F,numOutputs:V,splitSizes:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[]})},903292:D=>{s.la("Expand",D,void 0)},903346:(D,F)=>{s.la("Gather",D,{axis:Number(F)})},903417:(D,F,V,K,Z,fe,be,xe,Se,we,Te)=>{s.la("Resize",D,{antialias:F,axes:V?Array.from(C.subarray(K>>>0,K+V>>>0)):[],coordinateTransformMode:qe(Z),cubicCoeffA:fe,excludeOutside:be,extrapolationValue:xe,keepAspectRatioPolicy:qe(Se),mode:qe(we),nearestMode:qe(Te)})},903768:(D,F,V,K,Z,fe,be)=>{s.la("Slice",D,{starts:F?Array.from(C.subarray(V>>>0,V+F>>>0)):[],ends:K?Array.from(C.subarray(Z>>>0,Z+K>>>0)):[],axes:fe?Array.from(C.subarray(be>>>0,be+fe>>>0)):[]})},903999:D=>{s.la("Tile",D,void 0)},904051:(D,F,V)=>{s.la("LayerNormalization",D,{axis:Number(F),epsilon:Number(V)})},904158:(D,F,V)=>{s.la("InstanceNormalization",D,{epsilon:F,format:V?"NHWC":"NCHW"})},904272:(D,F,V)=>{s.la("InstanceNormalization",D,{epsilon:F,format:V?"NHWC":"NCHW"})},904386:D=>{s.la("Gelu",D,void 0)},904438:(D,F)=>{s.la("SkipLayerNormalization",D,{epsilon:F})},904519:D=>{s.Ha(D)},904553:(D,F)=>s.Ia(D,F)};function Re(D){this.name="ExitStatus",this.message=`Program terminated with exit(${D})`,this.status=D}var Ue=D=>{for(;0<D.length;)D.shift()(s)};function He(D){this.za=D-24,this.Ra=function(F){_[this.za+4>>2>>>0]=F},this.Qa=function(F){_[this.za+8>>2>>>0]=F},this.Ka=function(F,V){this.Pa(),this.Ra(F),this.Qa(V)},this.Pa=function(){_[this.za+16>>2>>>0]=0}}var Ze,et=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,ct=(D,F,V)=>{var K=(F>>>=0)+V;for(V=F;D[V]&&!(V>=K);)++V;if(16<V-F&&D.buffer&&et)return et.decode(D.subarray(F,V));for(K="";F<V;){var Z=D[F++];if(128&Z){var fe=63&D[F++];if((224&Z)==192)K+=String.fromCharCode((31&Z)<<6|fe);else{var be=63&D[F++];65536>(Z=(240&Z)==224?(15&Z)<<12|fe<<6|be:(7&Z)<<18|fe<<12|be<<6|63&D[F++])?K+=String.fromCharCode(Z):(Z-=65536,K+=String.fromCharCode(55296|Z>>10,56320|1023&Z))}}else K+=String.fromCharCode(Z)}return K},qe=(D,F)=>(D>>>=0)?ct(A,D,F):"",Qe=D=>{for(var F=0,V=0;V<D.length;++V){var K=D.charCodeAt(V);127>=K?F++:2047>=K?F+=2:55296<=K&&57343>=K?(F+=4,++V):F+=3}return F},tt=(D,F,V,K)=>{if(!(0<K))return 0;var Z=V>>>=0;K=V+K-1;for(var fe=0;fe<D.length;++fe){var be=D.charCodeAt(fe);if(55296<=be&&57343>=be&&(be=65536+((1023&be)<<10)|1023&D.charCodeAt(++fe)),127>=be){if(V>=K)break;F[V++>>>0]=be}else{if(2047>=be){if(V+1>=K)break;F[V++>>>0]=192|be>>6}else{if(65535>=be){if(V+2>=K)break;F[V++>>>0]=224|be>>12}else{if(V+3>=K)break;F[V++>>>0]=240|be>>18,F[V++>>>0]=128|be>>12&63}F[V++>>>0]=128|be>>6&63}F[V++>>>0]=128|63&be}}return F[V>>>0]=0,V-Z},Ye=D=>D%4==0&&(D%100!=0||D%400==0),wt=[0,31,60,91,121,152,182,213,244,274,305,335],ft=[0,31,59,90,120,151,181,212,243,273,304,334],ht=D=>{var F=Qe(D)+1,V=it(F);return V&&tt(D,A,V,F),V},bt=[],xt=(D,F)=>{var V;for(bt.length=0,F>>=2;V=A[D++>>>0];)F+=V!=105&F,bt.push(V==105?C[F>>>0]:S[F++>>>1]),++F;return bt},Ot={},At=()=>{if(!Ze){var D,F={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:t||"./this.program"};for(D in Ot)Ot[D]===void 0?delete F[D]:F[D]=Ot[D];var V=[];for(D in F)V.push(`${D}=${F[D]}`);Ze=V}return Ze},Ct=D=>{R=D,O||(s.onExit&&s.onExit(D),E=!0),r(D,new Re(D))},kt=[null,[],[]],pt=D=>(pt=(()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return K=>crypto.getRandomValues(K);if(d)try{var F=y(760);if(F.randomFillSync)return K=>F.randomFillSync(K);var V=F.randomBytes;return K=>(K.set(V(K.byteLength)),K)}catch{}ve("initRandomDevice")})())(D),$t=[31,29,31,30,31,30,31,31,30,31,30,31],Tt=[31,28,31,30,31,30,31,31,30,31,30,31];function de(D,F,V,K){function Z(ne,ke,Ge){for(ne=typeof ne=="number"?ne.toString():ne||"";ne.length<ke;)ne=Ge[0]+ne;return ne}function fe(ne,ke){return Z(ne,ke,"0")}function be(ne,ke){function Ge(Bt){return 0>Bt?-1:0<Bt?1:0}var _t;return(_t=Ge(ne.getFullYear()-ke.getFullYear()))===0&&(_t=Ge(ne.getMonth()-ke.getMonth()))===0&&(_t=Ge(ne.getDate()-ke.getDate())),_t}function xe(ne){switch(ne.getDay()){case 0:return new Date(ne.getFullYear()-1,11,29);case 1:return ne;case 2:return new Date(ne.getFullYear(),0,3);case 3:return new Date(ne.getFullYear(),0,2);case 4:return new Date(ne.getFullYear(),0,1);case 5:return new Date(ne.getFullYear()-1,11,31);case 6:return new Date(ne.getFullYear()-1,11,30)}}function Se(ne){var ke=ne.va;for(ne=new Date(new Date(ne.wa+1900,0,1).getTime());0<ke;){var Ge=ne.getMonth(),_t=(Ye(ne.getFullYear())?$t:Tt)[Ge];if(!(ke>_t-ne.getDate())){ne.setDate(ne.getDate()+ke);break}ke-=_t-ne.getDate()+1,ne.setDate(1),11>Ge?ne.setMonth(Ge+1):(ne.setMonth(0),ne.setFullYear(ne.getFullYear()+1))}return Ge=new Date(ne.getFullYear()+1,0,4),ke=xe(new Date(ne.getFullYear(),0,4)),Ge=xe(Ge),0>=be(ke,ne)?0>=be(Ge,ne)?ne.getFullYear()+1:ne.getFullYear():ne.getFullYear()-1}D>>>=0,F>>>=0,V>>>=0;var we=C[40+(K>>>=0)>>2>>>0];for(var Te in K={Na:C[K>>2>>>0],Ma:C[K+4>>2>>>0],xa:C[K+8>>2>>>0],Ba:C[K+12>>2>>>0],ya:C[K+16>>2>>>0],wa:C[K+20>>2>>>0],qa:C[K+24>>2>>>0],va:C[K+28>>2>>>0],Ta:C[K+32>>2>>>0],La:C[K+36>>2>>>0],Oa:we?qe(we):""},V=qe(V),we={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})V=V.replace(new RegExp(Te,"g"),we[Te]);var ze="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ve="January February March April May June July August September October November December".split(" ");for(Te in we={"%a":ne=>ze[ne.qa].substring(0,3),"%A":ne=>ze[ne.qa],"%b":ne=>Ve[ne.ya].substring(0,3),"%B":ne=>Ve[ne.ya],"%C":ne=>fe((ne.wa+1900)/100|0,2),"%d":ne=>fe(ne.Ba,2),"%e":ne=>Z(ne.Ba,2," "),"%g":ne=>Se(ne).toString().substring(2),"%G":ne=>Se(ne),"%H":ne=>fe(ne.xa,2),"%I":ne=>((ne=ne.xa)==0?ne=12:12<ne&&(ne-=12),fe(ne,2)),"%j":ne=>{for(var ke=0,Ge=0;Ge<=ne.ya-1;ke+=(Ye(ne.wa+1900)?$t:Tt)[Ge++]);return fe(ne.Ba+ke,3)},"%m":ne=>fe(ne.ya+1,2),"%M":ne=>fe(ne.Ma,2),"%n":()=>`
`,"%p":ne=>0<=ne.xa&&12>ne.xa?"AM":"PM","%S":ne=>fe(ne.Na,2),"%t":()=>"	","%u":ne=>ne.qa||7,"%U":ne=>fe(Math.floor((ne.va+7-ne.qa)/7),2),"%V":ne=>{var ke=Math.floor((ne.va+7-(ne.qa+6)%7)/7);if(2>=(ne.qa+371-ne.va-2)%7&&ke++,ke)ke==53&&((Ge=(ne.qa+371-ne.va)%7)==4||Ge==3&&Ye(ne.wa)||(ke=1));else{ke=52;var Ge=(ne.qa+7-ne.va-1)%7;(Ge==4||Ge==5&&Ye(ne.wa%400-1))&&ke++}return fe(ke,2)},"%w":ne=>ne.qa,"%W":ne=>fe(Math.floor((ne.va+7-(ne.qa+6)%7)/7),2),"%y":ne=>(ne.wa+1900).toString().substring(2),"%Y":ne=>ne.wa+1900,"%z":ne=>{var ke=0<=(ne=ne.La);return ne=Math.abs(ne)/60,(ke?"+":"-")+("0000"+(ne/60*100+ne%60)).slice(-4)},"%Z":ne=>ne.Oa,"%%":()=>"%"},V=V.replace(/%%/g,"\0\0"),we)V.includes(Te)&&(V=V.replace(new RegExp(Te,"g"),we[Te](K)));return Te=function(ne){var ke=Array(Qe(ne)+1);return tt(ne,ke,0,ke.length),ke}(V=V.replace(/\0\0/g,"%")),Te.length>F?0:(j.set(Te,D>>>0),Te.length-1)}function gt(D){try{D()}catch(F){ve(F)}}var mt=0,U=null,J=0,ee=[],le={},me={},Ae=0,Ce=null,rt=[],ut={o:function(D,F,V){return function(K){return function(Z){if(!E){if(mt===0){var fe=!1,be=!1;Z((xe=0)=>{if(!E&&(J=xe,fe=!0,be)){mt=2,gt(()=>Nt(U)),typeof Browser<"u"&&Browser.Aa.Da&&Browser.Aa.resume(),xe=!1;try{var Se=(0,I[me[C[U+8>>2>>>0]]])()}catch(ze){Se=ze,xe=!0}var we=!1;if(!U){var Te=Ce;Te&&(Ce=null,(xe?Te.reject:Te.resolve)(Se),we=!0)}if(xe&&!we)throw Se}}),be=!0,fe||(mt=1,U=function(){var xe=it(65548),Se=xe+12;_[xe>>2>>>0]=Se,_[xe+4>>2>>>0]=Se+65536,Se=ee[0];var we=le[Se];return we===void 0&&(we=Ae++,le[Se]=we,me[we]=Se),C[xe+8>>2>>>0]=we,xe}(),typeof Browser<"u"&&Browser.Aa.Da&&Browser.Aa.pause(),gt(()=>yt(U)))}else mt===2?(mt=0,gt(Lt),Pt(U),U=null,rt.forEach(xe=>{if(!E)try{if(xe(),!O)try{R=xe=R,Ct(xe)}catch(Se){Se instanceof Re||Se=="unwind"||r(1,Se)}}catch(Se){Se instanceof Re||Se=="unwind"||r(1,Se)}})):ve(`invalid state: ${mt}`);return J}}(Z=>{K().then(Z)})}(async()=>{await s.Fa(D,F,V)})},a:function(D,F,V){throw new He(D>>>=0).Ka(F>>>0,V>>>0),D},g:function(){return 0},L:function(){},C:function(){},E:function(){},N:function(){return 0},J:function(){},F:function(){},I:function(){},l:function(){},D:function(){},A:function(){},K:function(){},B:function(){},m:()=>!0,r:function(D,F,V){D=F+2097152>>>0<4194305-!!D?(D>>>0)+4294967296*F:NaN,V>>>=0,D=new Date(1e3*D),C[V>>2>>>0]=D.getUTCSeconds(),C[V+4>>2>>>0]=D.getUTCMinutes(),C[V+8>>2>>>0]=D.getUTCHours(),C[V+12>>2>>>0]=D.getUTCDate(),C[V+16>>2>>>0]=D.getUTCMonth(),C[V+20>>2>>>0]=D.getUTCFullYear()-1900,C[V+24>>2>>>0]=D.getUTCDay(),C[V+28>>2>>>0]=(D.getTime()-Date.UTC(D.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},s:function(D,F,V){D=F+2097152>>>0<4194305-!!D?(D>>>0)+4294967296*F:NaN,V>>>=0,D=new Date(1e3*D),C[V>>2>>>0]=D.getSeconds(),C[V+4>>2>>>0]=D.getMinutes(),C[V+8>>2>>>0]=D.getHours(),C[V+12>>2>>>0]=D.getDate(),C[V+16>>2>>>0]=D.getMonth(),C[V+20>>2>>>0]=D.getFullYear()-1900,C[V+24>>2>>>0]=D.getDay(),C[V+28>>2>>>0]=(Ye(D.getFullYear())?wt:ft)[D.getMonth()]+D.getDate()-1|0,C[V+36>>2>>>0]=-60*D.getTimezoneOffset(),F=new Date(D.getFullYear(),6,1).getTimezoneOffset();var K=new Date(D.getFullYear(),0,1).getTimezoneOffset();C[V+32>>2>>>0]=0|(F!=K&&D.getTimezoneOffset()==Math.min(K,F))},t:function(D){D>>>=0;var F=new Date(C[D+20>>2>>>0]+1900,C[D+16>>2>>>0],C[D+12>>2>>>0],C[D+8>>2>>>0],C[D+4>>2>>>0],C[D>>2>>>0],0),V=C[D+32>>2>>>0],K=F.getTimezoneOffset(),Z=new Date(F.getFullYear(),6,1).getTimezoneOffset(),fe=new Date(F.getFullYear(),0,1).getTimezoneOffset(),be=Math.min(fe,Z);return 0>V?C[D+32>>2>>>0]=+(Z!=fe&&be==K):0<V!=(be==K)&&(Z=Math.max(fe,Z),F.setTime(F.getTime()+6e4*((0<V?be:Z)-K))),C[D+24>>2>>>0]=F.getDay(),C[D+28>>2>>>0]=(Ye(F.getFullYear())?wt:ft)[F.getMonth()]+F.getDate()-1|0,C[D>>2>>>0]=F.getSeconds(),C[D+4>>2>>>0]=F.getMinutes(),C[D+8>>2>>>0]=F.getHours(),C[D+12>>2>>>0]=F.getDate(),C[D+16>>2>>>0]=F.getMonth(),C[D+20>>2>>>0]=F.getYear(),D=F.getTime()/1e3,It((Be=D,1<=+Math.abs(Be)?0<Be?+Math.floor(Be/4294967296)>>>0:~~+Math.ceil((Be-+(~~Be>>>0))/4294967296)>>>0:0)),D>>>0},p:function(){return-52},q:function(){},x:function(D,F,V){function K(Se){return(Se=Se.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Se[1]:"GMT"}V>>>=0;var Z=new Date().getFullYear(),fe=new Date(Z,0,1),be=new Date(Z,6,1);Z=fe.getTimezoneOffset();var xe=be.getTimezoneOffset();_[D>>>0>>2>>>0]=60*Math.max(Z,xe),C[F>>>0>>2>>>0]=+(Z!=xe),D=K(fe),F=K(be),D=ht(D),F=ht(F),xe<Z?(_[V>>2>>>0]=D,_[V+4>>2>>>0]=F):(_[V>>2>>>0]=F,_[V+4>>2>>>0]=D)},e:()=>{ve("")},b:function(D,F,V){return D>>>=0,F=xt(F>>>0,V>>>0),Pe[D].apply(null,F)},i:function(D,F,V){return D>>>=0,F=xt(F>>>0,V>>>0),Pe[D].apply(null,F)},h:function(){return Date.now()},z:function(){return 4294901760},d:()=>performance.now(),M:function(D,F,V){return F>>>=0,A.copyWithin(D>>>0>>>0,F>>>0,F+(V>>>0)>>>0)},w:function(D){D>>>=0;var F=A.length;if(4294901760<D)return!1;for(var V=1;4>=V;V*=2){var K=F*(1+.2/V);K=Math.min(K,D+100663296);var Z=Math;K=Math.max(D,K);e:{Z=Z.min.call(Z,4294901760,K+(65536-K%65536)%65536)-P.buffer.byteLength+65535>>>16;try{P.grow(Z),z();var fe=1;break e}catch{}fe=void 0}if(fe)return!0}return!1},G:function(D,F){D>>>=0,F>>>=0;var V=0;return At().forEach(function(K,Z){var fe=F+V;for(Z=_[D+4*Z>>2>>>0]=fe,fe=0;fe<K.length;++fe)j[Z++>>0>>>0]=K.charCodeAt(fe);j[Z>>0>>>0]=0,V+=K.length+1}),0},H:function(D,F){D>>>=0,F>>>=0;var V=At();_[D>>2>>>0]=V.length;var K=0;return V.forEach(function(Z){K+=Z.length+1}),_[F>>2>>>0]=K,0},n:D=>{R=D,Ct(D)},f:()=>52,k:function(){return 52},u:function(){return 70},j:function(D,F,V,K){F>>>=0,V>>>=0,K>>>=0;for(var Z=0,fe=0;fe<V;fe++){var be=_[F>>2>>>0],xe=_[F+4>>2>>>0];F+=8;for(var Se=0;Se<xe;Se++){var we=A[be+Se>>>0],Te=kt[D];we===0||we===10?((D===1?x:T)(ct(Te,0)),Te.length=0):Te.push(we)}Z+=xe}return _[K>>2>>>0]=Z,0},v:function(D,F){return D>>>=0,pt(A.subarray(D>>>0,D+(F>>>0)>>>0)),0},y:de,c:function(D,F,V,K){return de(D>>>0,F>>>0,V>>>0,K>>>0)}};(function(){function D(V){if(V=function(Z){var fe,be={};for(fe in Z)(function(xe){var Se=Z[xe];be[xe]=typeof Se=="function"?function(){ee.push(xe);try{return Se.apply(null,arguments)}finally{E||(ee.pop()===xe||ve(),U&&mt===1&&ee.length===0&&(mt=0,gt(Et),typeof Fibers<"u"&&Fibers.Ua()))}}:Se})(fe);return be}(V=V.exports),I=V=function(Z){var fe=xe=>()=>xe()>>>0,be=xe=>Se=>xe(Se)>>>0;return(Z=Object.assign({},Z)).__errno_location=fe(Z.__errno_location),Z.malloc=be(Z.malloc),Z.stackSave=fe(Z.stackSave),Z.stackAlloc=be(Z.stackAlloc),Z}(V),P=I.O,z(),Y.unshift(I.P),se--,s.monitorRunDependencies&&s.monitorRunDependencies(se),se==0&&(pe!==null&&(clearInterval(pe),pe=null),ge)){var K=ge;ge=null,K()}return V}var F={a:ut};if(se++,s.monitorRunDependencies&&s.monitorRunDependencies(se),s.instantiateWasm)try{return s.instantiateWasm(F,D)}catch(V){T("Module.instantiateWasm callback failed with error: "+V),u(V)}(function(V,K){var Z=ae;return w||typeof WebAssembly.instantiateStreaming!="function"||Me(Z)||Z.startsWith("file://")||d||typeof fetch!="function"?_e(Z,V,K):fetch(Z,{credentials:"same-origin"}).then(fe=>WebAssembly.instantiateStreaming(fe,V).then(K,function(be){return T("wasm streaming compile failed: "+be),T("falling back to ArrayBuffer instantiation"),_e(Z,V,K)}))})(F,function(V){D(V.instance)}).catch(u)})(),s._OrtInit=(D,F)=>(s._OrtInit=I.Q)(D,F),s._OrtGetLastError=(D,F)=>(s._OrtGetLastError=I.R)(D,F),s._OrtCreateSessionOptions=(D,F,V,K,Z,fe,be,xe,Se,we)=>(s._OrtCreateSessionOptions=I.S)(D,F,V,K,Z,fe,be,xe,Se,we),s._OrtAppendExecutionProvider=(D,F)=>(s._OrtAppendExecutionProvider=I.T)(D,F),s._OrtAddSessionConfigEntry=(D,F,V)=>(s._OrtAddSessionConfigEntry=I.U)(D,F,V),s._OrtReleaseSessionOptions=D=>(s._OrtReleaseSessionOptions=I.V)(D),s._OrtCreateSession=(D,F,V)=>(s._OrtCreateSession=I.W)(D,F,V),s._OrtReleaseSession=D=>(s._OrtReleaseSession=I.X)(D),s._OrtGetInputOutputCount=(D,F,V)=>(s._OrtGetInputOutputCount=I.Y)(D,F,V),s._OrtGetInputName=(D,F)=>(s._OrtGetInputName=I.Z)(D,F),s._OrtGetOutputName=(D,F)=>(s._OrtGetOutputName=I._)(D,F),s._OrtFree=D=>(s._OrtFree=I.$)(D),s._OrtCreateTensor=(D,F,V,K,Z)=>(s._OrtCreateTensor=I.aa)(D,F,V,K,Z),s._OrtGetTensorData=(D,F,V,K,Z)=>(s._OrtGetTensorData=I.ba)(D,F,V,K,Z),s._OrtReleaseTensor=D=>(s._OrtReleaseTensor=I.ca)(D),s._OrtCreateRunOptions=(D,F,V,K)=>(s._OrtCreateRunOptions=I.da)(D,F,V,K),s._OrtAddRunConfigEntry=(D,F,V)=>(s._OrtAddRunConfigEntry=I.ea)(D,F,V),s._OrtReleaseRunOptions=D=>(s._OrtReleaseRunOptions=I.fa)(D),s._OrtRun=(D,F,V,K,Z,fe,be,xe)=>(s._OrtRun=I.ga)(D,F,V,K,Z,fe,be,xe),s._OrtEndProfiling=D=>(s._OrtEndProfiling=I.ha)(D),s._JsepOutput=(D,F,V)=>(s._JsepOutput=I.ia)(D,F,V);var ot,it=s._malloc=D=>(it=s._malloc=I.ja)(D),Pt=s._free=D=>(Pt=s._free=I.ka)(D),It=D=>(It=I.ma)(D),oe=()=>(oe=I.na)(),Fe=D=>(Fe=I.oa)(D),Xe=D=>(Xe=I.pa)(D),yt=D=>(yt=I.ra)(D),Et=()=>(Et=I.sa)(),Nt=D=>(Nt=I.ta)(D),Lt=()=>(Lt=I.ua)();function Ft(){function D(){if(!ot&&(ot=!0,s.calledRun=!0,!E)){if(Ue(Y),p(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;){var F=s.postRun.shift();X.unshift(F)}Ue(X)}}if(!(0<se)){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)te();Ue(L),0<se||(s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),D()},1)):D())}}if(s.___start_em_js=904588,s.___stop_em_js=904749,s.stackAlloc=Xe,s.stackSave=oe,s.stackRestore=Fe,s.UTF8ToString=qe,s.stringToUTF8=(D,F,V)=>tt(D,A,F,V),s.lengthBytesUTF8=Qe,ge=function D(){ot||Ft(),ot||(ge=D)},s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Ft(),h.ready});M.exports=f},4537:M=>{"use strict";M.exports=function(c,y){for(var m=new Array(arguments.length-1),f=0,h=2,p=!0;h<arguments.length;)m[f++]=arguments[h++];return new Promise(function(u,s){m[f]=function(a){if(p)if(p=!1,a)s(a);else{for(var o=new Array(arguments.length-1),n=0;n<o.length;)o[n++]=arguments[n];u.apply(null,o)}};try{c.apply(y||null,m)}catch(a){p&&(p=!1,s(a))}})}},7419:(M,c)=>{"use strict";var y=c;y.length=function(u){var s=u.length;if(!s)return 0;for(var a=0;--s%4>1&&u.charAt(s)==="=";)++a;return Math.ceil(3*u.length)/4-a};for(var m=new Array(64),f=new Array(123),h=0;h<64;)f[m[h]=h<26?h+65:h<52?h+71:h<62?h-4:h-59|43]=h++;y.encode=function(u,s,a){for(var o,n=null,e=[],t=0,r=0;s<a;){var i=u[s++];switch(r){case 0:e[t++]=m[i>>2],o=(3&i)<<4,r=1;break;case 1:e[t++]=m[o|i>>4],o=(15&i)<<2,r=2;break;case 2:e[t++]=m[o|i>>6],e[t++]=m[63&i],r=0}t>8191&&((n||(n=[])).push(String.fromCharCode.apply(String,e)),t=0)}return r&&(e[t++]=m[o],e[t++]=61,r===1&&(e[t++]=61)),n?(t&&n.push(String.fromCharCode.apply(String,e.slice(0,t))),n.join("")):String.fromCharCode.apply(String,e.slice(0,t))};var p="invalid encoding";y.decode=function(u,s,a){for(var o,n=a,e=0,t=0;t<u.length;){var r=u.charCodeAt(t++);if(r===61&&e>1)break;if((r=f[r])===void 0)throw Error(p);switch(e){case 0:o=r,e=1;break;case 1:s[a++]=o<<2|(48&r)>>4,o=r,e=2;break;case 2:s[a++]=(15&o)<<4|(60&r)>>2,o=r,e=3;break;case 3:s[a++]=(3&o)<<6|r,e=0}}if(e===1)throw Error(p);return a-n},y.test=function(u){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(u)}},9211:M=>{"use strict";function c(){this._listeners={}}M.exports=c,c.prototype.on=function(y,m,f){return(this._listeners[y]||(this._listeners[y]=[])).push({fn:m,ctx:f||this}),this},c.prototype.off=function(y,m){if(y===void 0)this._listeners={};else if(m===void 0)this._listeners[y]=[];else for(var f=this._listeners[y],h=0;h<f.length;)f[h].fn===m?f.splice(h,1):++h;return this},c.prototype.emit=function(y){var m=this._listeners[y];if(m){for(var f=[],h=1;h<arguments.length;)f.push(arguments[h++]);for(h=0;h<m.length;)m[h].fn.apply(m[h++].ctx,f)}return this}},945:M=>{"use strict";function c(p){return typeof Float32Array<"u"?function(){var u=new Float32Array([-0]),s=new Uint8Array(u.buffer),a=s[3]===128;function o(r,i,l){u[0]=r,i[l]=s[0],i[l+1]=s[1],i[l+2]=s[2],i[l+3]=s[3]}function n(r,i,l){u[0]=r,i[l]=s[3],i[l+1]=s[2],i[l+2]=s[1],i[l+3]=s[0]}function e(r,i){return s[0]=r[i],s[1]=r[i+1],s[2]=r[i+2],s[3]=r[i+3],u[0]}function t(r,i){return s[3]=r[i],s[2]=r[i+1],s[1]=r[i+2],s[0]=r[i+3],u[0]}p.writeFloatLE=a?o:n,p.writeFloatBE=a?n:o,p.readFloatLE=a?e:t,p.readFloatBE=a?t:e}():function(){function u(a,o,n,e){var t=o<0?1:0;if(t&&(o=-o),o===0)a(1/o>0?0:2147483648,n,e);else if(isNaN(o))a(2143289344,n,e);else if(o>34028234663852886e22)a((t<<31|2139095040)>>>0,n,e);else if(o<11754943508222875e-54)a((t<<31|Math.round(o/1401298464324817e-60))>>>0,n,e);else{var r=Math.floor(Math.log(o)/Math.LN2);a((t<<31|r+127<<23|8388607&Math.round(o*Math.pow(2,-r)*8388608))>>>0,n,e)}}function s(a,o,n){var e=a(o,n),t=2*(e>>31)+1,r=e>>>23&255,i=8388607&e;return r===255?i?NaN:t*(1/0):r===0?1401298464324817e-60*t*i:t*Math.pow(2,r-150)*(i+8388608)}p.writeFloatLE=u.bind(null,y),p.writeFloatBE=u.bind(null,m),p.readFloatLE=s.bind(null,f),p.readFloatBE=s.bind(null,h)}(),typeof Float64Array<"u"?function(){var u=new Float64Array([-0]),s=new Uint8Array(u.buffer),a=s[7]===128;function o(r,i,l){u[0]=r,i[l]=s[0],i[l+1]=s[1],i[l+2]=s[2],i[l+3]=s[3],i[l+4]=s[4],i[l+5]=s[5],i[l+6]=s[6],i[l+7]=s[7]}function n(r,i,l){u[0]=r,i[l]=s[7],i[l+1]=s[6],i[l+2]=s[5],i[l+3]=s[4],i[l+4]=s[3],i[l+5]=s[2],i[l+6]=s[1],i[l+7]=s[0]}function e(r,i){return s[0]=r[i],s[1]=r[i+1],s[2]=r[i+2],s[3]=r[i+3],s[4]=r[i+4],s[5]=r[i+5],s[6]=r[i+6],s[7]=r[i+7],u[0]}function t(r,i){return s[7]=r[i],s[6]=r[i+1],s[5]=r[i+2],s[4]=r[i+3],s[3]=r[i+4],s[2]=r[i+5],s[1]=r[i+6],s[0]=r[i+7],u[0]}p.writeDoubleLE=a?o:n,p.writeDoubleBE=a?n:o,p.readDoubleLE=a?e:t,p.readDoubleBE=a?t:e}():function(){function u(a,o,n,e,t,r){var i=e<0?1:0;if(i&&(e=-e),e===0)a(0,t,r+o),a(1/e>0?0:2147483648,t,r+n);else if(isNaN(e))a(0,t,r+o),a(2146959360,t,r+n);else if(e>17976931348623157e292)a(0,t,r+o),a((i<<31|2146435072)>>>0,t,r+n);else{var l;if(e<22250738585072014e-324)a((l=e/5e-324)>>>0,t,r+o),a((i<<31|l/4294967296)>>>0,t,r+n);else{var d=Math.floor(Math.log(e)/Math.LN2);d===1024&&(d=1023),a(4503599627370496*(l=e*Math.pow(2,-d))>>>0,t,r+o),a((i<<31|d+1023<<20|1048576*l&1048575)>>>0,t,r+n)}}}function s(a,o,n,e,t){var r=a(e,t+o),i=a(e,t+n),l=2*(i>>31)+1,d=i>>>20&2047,g=4294967296*(1048575&i)+r;return d===2047?g?NaN:l*(1/0):d===0?5e-324*l*g:l*Math.pow(2,d-1075)*(g+4503599627370496)}p.writeDoubleLE=u.bind(null,y,0,4),p.writeDoubleBE=u.bind(null,m,4,0),p.readDoubleLE=s.bind(null,f,0,4),p.readDoubleBE=s.bind(null,h,4,0)}(),p}function y(p,u,s){u[s]=255&p,u[s+1]=p>>>8&255,u[s+2]=p>>>16&255,u[s+3]=p>>>24}function m(p,u,s){u[s]=p>>>24,u[s+1]=p>>>16&255,u[s+2]=p>>>8&255,u[s+3]=255&p}function f(p,u){return(p[u]|p[u+1]<<8|p[u+2]<<16|p[u+3]<<24)>>>0}function h(p,u){return(p[u]<<24|p[u+1]<<16|p[u+2]<<8|p[u+3])>>>0}M.exports=c(c)},7199:module=>{"use strict";function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(M){}return null}module.exports=inquire},6662:M=>{"use strict";M.exports=function(c,y,m){var f=m||8192,h=f>>>1,p=null,u=f;return function(s){if(s<1||s>h)return c(s);u+s>f&&(p=c(f),u=0);var a=y.call(p,u,u+=s);return 7&u&&(u=1+(7|u)),a}}},4997:(M,c)=>{"use strict";var y=c;y.length=function(m){for(var f=0,h=0,p=0;p<m.length;++p)(h=m.charCodeAt(p))<128?f+=1:h<2048?f+=2:(64512&h)==55296&&(64512&m.charCodeAt(p+1))==56320?(++p,f+=4):f+=3;return f},y.read=function(m,f,h){if(h-f<1)return"";for(var p,u=null,s=[],a=0;f<h;)(p=m[f++])<128?s[a++]=p:p>191&&p<224?s[a++]=(31&p)<<6|63&m[f++]:p>239&&p<365?(p=((7&p)<<18|(63&m[f++])<<12|(63&m[f++])<<6|63&m[f++])-65536,s[a++]=55296+(p>>10),s[a++]=56320+(1023&p)):s[a++]=(15&p)<<12|(63&m[f++])<<6|63&m[f++],a>8191&&((u||(u=[])).push(String.fromCharCode.apply(String,s)),a=0);return u?(a&&u.push(String.fromCharCode.apply(String,s.slice(0,a))),u.join("")):String.fromCharCode.apply(String,s.slice(0,a))},y.write=function(m,f,h){for(var p,u,s=h,a=0;a<m.length;++a)(p=m.charCodeAt(a))<128?f[h++]=p:p<2048?(f[h++]=p>>6|192,f[h++]=63&p|128):(64512&p)==55296&&(64512&(u=m.charCodeAt(a+1)))==56320?(p=65536+((1023&p)<<10)+(1023&u),++a,f[h++]=p>>18|240,f[h++]=p>>12&63|128,f[h++]=p>>6&63|128,f[h++]=63&p|128):(f[h++]=p>>12|224,f[h++]=p>>6&63|128,f[h++]=63&p|128);return h-s}},3442:(M,c)=>{"use strict";c.__esModule=!0;var y=function(){function m(f){if(!f)throw new TypeError("Invalid argument; `value` has no value.");this.value=m.EMPTY,f&&m.isGuid(f)&&(this.value=f)}return m.isGuid=function(f){var h=f.toString();return f&&(f instanceof m||m.validator.test(h))},m.create=function(){return new m([m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-"))},m.createEmpty=function(){return new m("emptyguid")},m.parse=function(f){return new m(f)},m.raw=function(){return[m.gen(2),m.gen(1),m.gen(1),m.gen(1),m.gen(3)].join("-")},m.gen=function(f){for(var h="",p=0;p<f;p++)h+=(65536*(1+Math.random())|0).toString(16).substring(1);return h},m.prototype.equals=function(f){return m.isGuid(f)&&this.value===f.toString()},m.prototype.isEmpty=function(){return this.value===m.EMPTY},m.prototype.toString=function(){return this.value},m.prototype.toJSON=function(){return{value:this.value}},m.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),m.EMPTY="00000000-0000-0000-0000-000000000000",m}();c.Guid=y},2100:(M,c,y)=>{"use strict";M.exports=y(9482)},9482:(M,c,y)=>{"use strict";var m=c;function f(){m.util._configure(),m.Writer._configure(m.BufferWriter),m.Reader._configure(m.BufferReader)}m.build="minimal",m.Writer=y(1173),m.BufferWriter=y(3155),m.Reader=y(1408),m.BufferReader=y(593),m.util=y(9693),m.rpc=y(5994),m.roots=y(5054),m.configure=f,f()},1408:(M,c,y)=>{"use strict";M.exports=s;var m,f=y(9693),h=f.LongBits,p=f.utf8;function u(i,l){return RangeError("index out of range: "+i.pos+" + "+(l||1)+" > "+i.len)}function s(i){this.buf=i,this.pos=0,this.len=i.length}var a,o=typeof Uint8Array<"u"?function(i){if(i instanceof Uint8Array||Array.isArray(i))return new s(i);throw Error("illegal buffer")}:function(i){if(Array.isArray(i))return new s(i);throw Error("illegal buffer")},n=function(){return f.Buffer?function(i){return(s.create=function(l){return f.Buffer.isBuffer(l)?new m(l):o(l)})(i)}:o};function e(){var i=new h(0,0),l=0;if(!(this.len-this.pos>4)){for(;l<3;++l){if(this.pos>=this.len)throw u(this);if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*l)>>>0,this.buf[this.pos++]<128)return i}return i.lo=(i.lo|(127&this.buf[this.pos++])<<7*l)>>>0,i}for(;l<4;++l)if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*l)>>>0,this.buf[this.pos++]<128)return i;if(i.lo=(i.lo|(127&this.buf[this.pos])<<28)>>>0,i.hi=(i.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return i;if(l=0,this.len-this.pos>4){for(;l<5;++l)if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*l+3)>>>0,this.buf[this.pos++]<128)return i}else for(;l<5;++l){if(this.pos>=this.len)throw u(this);if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*l+3)>>>0,this.buf[this.pos++]<128)return i}throw Error("invalid varint encoding")}function t(i,l){return(i[l-4]|i[l-3]<<8|i[l-2]<<16|i[l-1]<<24)>>>0}function r(){if(this.pos+8>this.len)throw u(this,8);return new h(t(this.buf,this.pos+=4),t(this.buf,this.pos+=4))}s.create=n(),s.prototype._slice=f.Array.prototype.subarray||f.Array.prototype.slice,s.prototype.uint32=(a=4294967295,function(){if(a=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(a=(a|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return a;if((this.pos+=5)>this.len)throw this.pos=this.len,u(this,10);return a}),s.prototype.int32=function(){return 0|this.uint32()},s.prototype.sint32=function(){var i=this.uint32();return i>>>1^-(1&i)|0},s.prototype.bool=function(){return this.uint32()!==0},s.prototype.fixed32=function(){if(this.pos+4>this.len)throw u(this,4);return t(this.buf,this.pos+=4)},s.prototype.sfixed32=function(){if(this.pos+4>this.len)throw u(this,4);return 0|t(this.buf,this.pos+=4)},s.prototype.float=function(){if(this.pos+4>this.len)throw u(this,4);var i=f.float.readFloatLE(this.buf,this.pos);return this.pos+=4,i},s.prototype.double=function(){if(this.pos+8>this.len)throw u(this,4);var i=f.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,i},s.prototype.bytes=function(){var i=this.uint32(),l=this.pos,d=this.pos+i;if(d>this.len)throw u(this,i);return this.pos+=i,Array.isArray(this.buf)?this.buf.slice(l,d):l===d?new this.buf.constructor(0):this._slice.call(this.buf,l,d)},s.prototype.string=function(){var i=this.bytes();return p.read(i,0,i.length)},s.prototype.skip=function(i){if(typeof i=="number"){if(this.pos+i>this.len)throw u(this,i);this.pos+=i}else do if(this.pos>=this.len)throw u(this);while(128&this.buf[this.pos++]);return this},s.prototype.skipType=function(i){switch(i){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(i=7&this.uint32())!=4;)this.skipType(i);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+i+" at offset "+this.pos)}return this},s._configure=function(i){m=i,s.create=n(),m._configure();var l=f.Long?"toLong":"toNumber";f.merge(s.prototype,{int64:function(){return e.call(this)[l](!1)},uint64:function(){return e.call(this)[l](!0)},sint64:function(){return e.call(this).zzDecode()[l](!1)},fixed64:function(){return r.call(this)[l](!0)},sfixed64:function(){return r.call(this)[l](!1)}})}},593:(M,c,y)=>{"use strict";M.exports=h;var m=y(1408);(h.prototype=Object.create(m.prototype)).constructor=h;var f=y(9693);function h(p){m.call(this,p)}h._configure=function(){f.Buffer&&(h.prototype._slice=f.Buffer.prototype.slice)},h.prototype.string=function(){var p=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+p,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+p,this.len))},h._configure()},5054:M=>{"use strict";M.exports={}},5994:(M,c,y)=>{"use strict";c.Service=y(7948)},7948:(M,c,y)=>{"use strict";M.exports=f;var m=y(9693);function f(h,p,u){if(typeof h!="function")throw TypeError("rpcImpl must be a function");m.EventEmitter.call(this),this.rpcImpl=h,this.requestDelimited=!!p,this.responseDelimited=!!u}(f.prototype=Object.create(m.EventEmitter.prototype)).constructor=f,f.prototype.rpcCall=function h(p,u,s,a,o){if(!a)throw TypeError("request must be specified");var n=this;if(!o)return m.asPromise(h,n,p,u,s,a);if(n.rpcImpl)try{return n.rpcImpl(p,u[n.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(e,t){if(e)return n.emit("error",e,p),o(e);if(t!==null){if(!(t instanceof s))try{t=s[n.responseDelimited?"decodeDelimited":"decode"](t)}catch(r){return n.emit("error",r,p),o(r)}return n.emit("data",t,p),o(null,t)}n.end(!0)})}catch(e){return n.emit("error",e,p),void setTimeout(function(){o(e)},0)}else setTimeout(function(){o(Error("already ended"))},0)},f.prototype.end=function(h){return this.rpcImpl&&(h||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(M,c,y)=>{"use strict";M.exports=f;var m=y(9693);function f(s,a){this.lo=s>>>0,this.hi=a>>>0}var h=f.zero=new f(0,0);h.toNumber=function(){return 0},h.zzEncode=h.zzDecode=function(){return this},h.length=function(){return 1};var p=f.zeroHash="\0\0\0\0\0\0\0\0";f.fromNumber=function(s){if(s===0)return h;var a=s<0;a&&(s=-s);var o=s>>>0,n=(s-o)/4294967296>>>0;return a&&(n=~n>>>0,o=~o>>>0,++o>4294967295&&(o=0,++n>4294967295&&(n=0))),new f(o,n)},f.from=function(s){if(typeof s=="number")return f.fromNumber(s);if(m.isString(s)){if(!m.Long)return f.fromNumber(parseInt(s,10));s=m.Long.fromString(s)}return s.low||s.high?new f(s.low>>>0,s.high>>>0):h},f.prototype.toNumber=function(s){if(!s&&this.hi>>>31){var a=1+~this.lo>>>0,o=~this.hi>>>0;return a||(o=o+1>>>0),-(a+4294967296*o)}return this.lo+4294967296*this.hi},f.prototype.toLong=function(s){return m.Long?new m.Long(0|this.lo,0|this.hi,!!s):{low:0|this.lo,high:0|this.hi,unsigned:!!s}};var u=String.prototype.charCodeAt;f.fromHash=function(s){return s===p?h:new f((u.call(s,0)|u.call(s,1)<<8|u.call(s,2)<<16|u.call(s,3)<<24)>>>0,(u.call(s,4)|u.call(s,5)<<8|u.call(s,6)<<16|u.call(s,7)<<24)>>>0)},f.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},f.prototype.zzEncode=function(){var s=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^s)>>>0,this.lo=(this.lo<<1^s)>>>0,this},f.prototype.zzDecode=function(){var s=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^s)>>>0,this.hi=(this.hi>>>1^s)>>>0,this},f.prototype.length=function(){var s=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,o=this.hi>>>24;return o===0?a===0?s<16384?s<128?1:2:s<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:o<128?9:10}},9693:function(M,c,y){"use strict";var m=c;function f(p,u,s){for(var a=Object.keys(u),o=0;o<a.length;++o)p[a[o]]!==void 0&&s||(p[a[o]]=u[a[o]]);return p}function h(p){function u(s,a){if(!(this instanceof u))return new u(s,a);Object.defineProperty(this,"message",{get:function(){return s}}),Error.captureStackTrace?Error.captureStackTrace(this,u):Object.defineProperty(this,"stack",{value:new Error().stack||""}),a&&f(this,a)}return u.prototype=Object.create(Error.prototype,{constructor:{value:u,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return p},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),u}m.asPromise=y(4537),m.base64=y(7419),m.EventEmitter=y(9211),m.float=y(945),m.inquire=y(7199),m.utf8=y(4997),m.pool=y(6662),m.LongBits=y(1945),m.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),m.global=m.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||this,m.emptyArray=Object.freeze?Object.freeze([]):[],m.emptyObject=Object.freeze?Object.freeze({}):{},m.isInteger=Number.isInteger||function(p){return typeof p=="number"&&isFinite(p)&&Math.floor(p)===p},m.isString=function(p){return typeof p=="string"||p instanceof String},m.isObject=function(p){return p&&typeof p=="object"},m.isset=m.isSet=function(p,u){var s=p[u];return!(s==null||!p.hasOwnProperty(u))&&(typeof s!="object"||(Array.isArray(s)?s.length:Object.keys(s).length)>0)},m.Buffer=function(){try{var p=m.inquire("buffer").Buffer;return p.prototype.utf8Write?p:null}catch{return null}}(),m._Buffer_from=null,m._Buffer_allocUnsafe=null,m.newBuffer=function(p){return typeof p=="number"?m.Buffer?m._Buffer_allocUnsafe(p):new m.Array(p):m.Buffer?m._Buffer_from(p):typeof Uint8Array>"u"?p:new Uint8Array(p)},m.Array=typeof Uint8Array<"u"?Uint8Array:Array,m.Long=m.global.dcodeIO&&m.global.dcodeIO.Long||m.global.Long||m.inquire("long"),m.key2Re=/^true|false|0|1$/,m.key32Re=/^-?(?:0|[1-9][0-9]*)$/,m.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,m.longToHash=function(p){return p?m.LongBits.from(p).toHash():m.LongBits.zeroHash},m.longFromHash=function(p,u){var s=m.LongBits.fromHash(p);return m.Long?m.Long.fromBits(s.lo,s.hi,u):s.toNumber(!!u)},m.merge=f,m.lcFirst=function(p){return p.charAt(0).toLowerCase()+p.substring(1)},m.newError=h,m.ProtocolError=h("ProtocolError"),m.oneOfGetter=function(p){for(var u={},s=0;s<p.length;++s)u[p[s]]=1;return function(){for(var a=Object.keys(this),o=a.length-1;o>-1;--o)if(u[a[o]]===1&&this[a[o]]!==void 0&&this[a[o]]!==null)return a[o]}},m.oneOfSetter=function(p){return function(u){for(var s=0;s<p.length;++s)p[s]!==u&&delete this[p[s]]}},m.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},m._configure=function(){var p=m.Buffer;p?(m._Buffer_from=p.from!==Uint8Array.from&&p.from||function(u,s){return new p(u,s)},m._Buffer_allocUnsafe=p.allocUnsafe||function(u){return new p(u)}):m._Buffer_from=m._Buffer_allocUnsafe=null}},1173:(M,c,y)=>{"use strict";M.exports=n;var m,f=y(9693),h=f.LongBits,p=f.base64,u=f.utf8;function s(g,b,v){this.fn=g,this.len=b,this.next=void 0,this.val=v}function a(){}function o(g){this.head=g.head,this.tail=g.tail,this.len=g.len,this.next=g.states}function n(){this.len=0,this.head=new s(a,0,0),this.tail=this.head,this.states=null}var e=function(){return f.Buffer?function(){return(n.create=function(){return new m})()}:function(){return new n}};function t(g,b,v){b[v]=255&g}function r(g,b){this.len=g,this.next=void 0,this.val=b}function i(g,b,v){for(;g.hi;)b[v++]=127&g.lo|128,g.lo=(g.lo>>>7|g.hi<<25)>>>0,g.hi>>>=7;for(;g.lo>127;)b[v++]=127&g.lo|128,g.lo=g.lo>>>7;b[v++]=g.lo}function l(g,b,v){b[v]=255&g,b[v+1]=g>>>8&255,b[v+2]=g>>>16&255,b[v+3]=g>>>24}n.create=e(),n.alloc=function(g){return new f.Array(g)},f.Array!==Array&&(n.alloc=f.pool(n.alloc,f.Array.prototype.subarray)),n.prototype._push=function(g,b,v){return this.tail=this.tail.next=new s(g,b,v),this.len+=b,this},r.prototype=Object.create(s.prototype),r.prototype.fn=function(g,b,v){for(;g>127;)b[v++]=127&g|128,g>>>=7;b[v]=g},n.prototype.uint32=function(g){return this.len+=(this.tail=this.tail.next=new r((g>>>=0)<128?1:g<16384?2:g<2097152?3:g<268435456?4:5,g)).len,this},n.prototype.int32=function(g){return g<0?this._push(i,10,h.fromNumber(g)):this.uint32(g)},n.prototype.sint32=function(g){return this.uint32((g<<1^g>>31)>>>0)},n.prototype.uint64=function(g){var b=h.from(g);return this._push(i,b.length(),b)},n.prototype.int64=n.prototype.uint64,n.prototype.sint64=function(g){var b=h.from(g).zzEncode();return this._push(i,b.length(),b)},n.prototype.bool=function(g){return this._push(t,1,g?1:0)},n.prototype.fixed32=function(g){return this._push(l,4,g>>>0)},n.prototype.sfixed32=n.prototype.fixed32,n.prototype.fixed64=function(g){var b=h.from(g);return this._push(l,4,b.lo)._push(l,4,b.hi)},n.prototype.sfixed64=n.prototype.fixed64,n.prototype.float=function(g){return this._push(f.float.writeFloatLE,4,g)},n.prototype.double=function(g){return this._push(f.float.writeDoubleLE,8,g)};var d=f.Array.prototype.set?function(g,b,v){b.set(g,v)}:function(g,b,v){for(var w=0;w<g.length;++w)b[v+w]=g[w]};n.prototype.bytes=function(g){var b=g.length>>>0;if(!b)return this._push(t,1,0);if(f.isString(g)){var v=n.alloc(b=p.length(g));p.decode(g,v,0),g=v}return this.uint32(b)._push(d,b,g)},n.prototype.string=function(g){var b=u.length(g);return b?this.uint32(b)._push(u.write,b,g):this._push(t,1,0)},n.prototype.fork=function(){return this.states=new o(this),this.head=this.tail=new s(a,0,0),this.len=0,this},n.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new s(a,0,0),this.len=0),this},n.prototype.ldelim=function(){var g=this.head,b=this.tail,v=this.len;return this.reset().uint32(v),v&&(this.tail.next=g.next,this.tail=b,this.len+=v),this},n.prototype.finish=function(){for(var g=this.head.next,b=this.constructor.alloc(this.len),v=0;g;)g.fn(g.val,b,v),v+=g.len,g=g.next;return b},n._configure=function(g){m=g,n.create=e(),m._configure()}},3155:(M,c,y)=>{"use strict";M.exports=h;var m=y(1173);(h.prototype=Object.create(m.prototype)).constructor=h;var f=y(9693);function h(){m.call(this)}function p(u,s,a){u.length<40?f.utf8.write(u,s,a):s.utf8Write?s.utf8Write(u,a):s.write(u,a)}h._configure=function(){h.alloc=f._Buffer_allocUnsafe,h.writeBytesBuffer=f.Buffer&&f.Buffer.prototype instanceof Uint8Array&&f.Buffer.prototype.set.name==="set"?function(u,s,a){s.set(u,a)}:function(u,s,a){if(u.copy)u.copy(s,a,0,u.length);else for(var o=0;o<u.length;)s[a++]=u[o++]}},h.prototype.bytes=function(u){f.isString(u)&&(u=f._Buffer_from(u,"base64"));var s=u.length>>>0;return this.uint32(s),s&&this._push(h.writeBytesBuffer,s,u),this},h.prototype.string=function(u){var s=f.Buffer.byteLength(u);return this.uint32(s),s&&this._push(p,s,u),this},h._configure()},4154:M=>{"use strict";M.exports=`"use strict";var e={},a="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(a){var r=require("worker_threads"),t=r.parentPort;t.on("message",(e=>onmessage({data:e})));var s=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(" ");a?s.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if("load"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:"loaded"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:"callHandler",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if("run"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if("unwind"!=e)throw e}}else"cancel"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===r.data.target||("checkMailbox"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d("worker.js received unknown command "+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},685:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.resolveBackend=c.registerBackend=void 0;let y={},m=[];c.registerBackend=(f,h,p)=>{if(!h||typeof h.init!="function"||typeof h.createSessionHandler!="function")throw new TypeError("not a valid backend");{let u=y[f];if(u===void 0)y[f]={backend:h,priority:p};else{if(u.priority>p)return;if(u.priority===p&&u.backend!==h)throw new Error(`cannot register backend "${f}" using priority ${p}`)}if(p>=0){let s=m.indexOf(f);s!==-1&&m.splice(s,1);for(let a=0;a<m.length;a++)if(y[m[a]].priority<=p)return void m.splice(a,0,f);m.push(f)}}},c.resolveBackend=async f=>{let h=f.length===0?m:f,p=[];for(let u of h){let s=y[u];if(s){if(s.initialized)return s.backend;if(s.aborted)continue;let a=!!s.initPromise;try{return a||(s.initPromise=s.backend.init()),await s.initPromise,s.initialized=!0,s.backend}catch(o){a||p.push({name:u,err:o}),s.aborted=!0}finally{delete s.initPromise}}}throw new Error(`no available backend found. ERR: ${p.map(u=>`[${u.name}] ${u.err}`).join(", ")}`)}},4798:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.registerBackend=void 0;var m=y(685);Object.defineProperty(c,"registerBackend",{enumerable:!0,get:function(){return m.registerBackend}})},3121:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.env=void 0;let m=y(9104),f="warning";c.env={wasm:{},webgl:{},webgpu:{},versions:{common:m.version},set logLevel(h){if(h!==void 0){if(typeof h!="string"||["verbose","info","warning","error","fatal"].indexOf(h)===-1)throw new Error(`Unsupported logging level: ${h}`);f=h}},get logLevel(){return f}},Object.defineProperty(c.env,"logLevel",{enumerable:!0})},2457:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.env=void 0;let m=y(3121);c.env=m.env},2235:function(M,c,y){"use strict";var m=this&&this.__createBinding||(Object.create?function(h,p,u,s){s===void 0&&(s=u);var a=Object.getOwnPropertyDescriptor(p,u);a&&!("get"in a?!p.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return p[u]}}),Object.defineProperty(h,s,a)}:function(h,p,u,s){s===void 0&&(s=u),h[s]=p[u]}),f=this&&this.__exportStar||function(h,p){for(var u in h)u==="default"||Object.prototype.hasOwnProperty.call(p,u)||m(p,h,u)};Object.defineProperty(c,"__esModule",{value:!0}),f(y(4798),c),f(y(2457),c),f(y(3974),c),f(y(963),c),f(y(7852),c)},8036:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.InferenceSession=void 0;let m=y(685),f=y(963);class h{constructor(u){this.handler=u}async run(u,s,a){let o={},n={};if(typeof u!="object"||u===null||u instanceof f.Tensor||Array.isArray(u))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let e=!0;if(typeof s=="object"){if(s===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(s instanceof f.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(s)){if(s.length===0)throw new TypeError("'fetches' cannot be an empty array.");e=!1;for(let i of s){if(typeof i!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(i)===-1)throw new RangeError(`'fetches' contains invalid output name: ${i}.`);o[i]=null}if(typeof a=="object"&&a!==null)n=a;else if(a!==void 0)throw new TypeError("'options' must be an object.")}else{let i=!1,l=Object.getOwnPropertyNames(s);for(let d of this.outputNames)if(l.indexOf(d)!==-1){let g=s[d];(g===null||g instanceof f.Tensor)&&(i=!0,e=!1,o[d]=g)}if(i){if(typeof a=="object"&&a!==null)n=a;else if(a!==void 0)throw new TypeError("'options' must be an object.")}else n=s}}else if(s!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let i of this.inputNames)if(u[i]===void 0)throw new Error(`input '${i}' is missing in 'feeds'.`);if(e)for(let i of this.outputNames)o[i]=null;let t=await this.handler.run(u,o,n),r={};for(let i in t)Object.hasOwnProperty.call(t,i)&&(r[i]=new f.Tensor(t[i].type,t[i].data,t[i].dims));return r}async release(){return this.handler.dispose()}static async create(u,s,a,o){let n,e={};if(typeof u=="string"){if(n=u,typeof s=="object"&&s!==null)e=s;else if(s!==void 0)throw new TypeError("'options' must be an object.")}else if(u instanceof Uint8Array){if(n=u,typeof s=="object"&&s!==null)e=s;else if(s!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(u instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&u instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let l=u,d=0,g=u.byteLength;if(typeof s=="object"&&s!==null)e=s;else if(typeof s=="number"){if(d=s,!Number.isSafeInteger(d))throw new RangeError("'byteOffset' must be an integer.");if(d<0||d>=l.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${l.byteLength}).`);if(g=u.byteLength-d,typeof a=="number"){if(g=a,!Number.isSafeInteger(g))throw new RangeError("'byteLength' must be an integer.");if(g<=0||d+g>l.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${l.byteLength-d}].`);if(typeof o=="object"&&o!==null)e=o;else if(o!==void 0)throw new TypeError("'options' must be an object.")}else if(a!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(s!==void 0)throw new TypeError("'options' must be an object.");n=new Uint8Array(l,d,g)}}let t=(e.executionProviders||[]).map(l=>typeof l=="string"?l:l.name),r=await(0,m.resolveBackend)(t),i=await r.createSessionHandler(n,e);return new h(i)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}c.InferenceSession=h},3974:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.InferenceSession=void 0;let m=y(8036);c.InferenceSession=m.InferenceSession},7852:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0})},2350:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tensorToImageData=c.tensorToDataURL=void 0,c.tensorToDataURL=(y,m)=>{let f=document.createElement("canvas");f.width=y.dims[3],f.height=y.dims[2];let h=f.getContext("2d");if(h!=null){let p,u;m?.tensorLayout!==void 0&&m.tensorLayout==="NHWC"?(p=y.dims[2],u=y.dims[3]):(p=y.dims[3],u=y.dims[2]);let s=m?.format!==void 0?m.format:"RGB",a=m?.norm,o,n;a===void 0||a.mean===void 0?o=[255,255,255,255]:typeof a.mean=="number"?o=[a.mean,a.mean,a.mean,a.mean]:(o=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(o[3]=a.mean[3])),a===void 0||a.bias===void 0?n=[0,0,0,0]:typeof a.bias=="number"?n=[a.bias,a.bias,a.bias,a.bias]:(n=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(n[3]=a.bias[3]));let e=u*p,t=0,r=e,i=2*e,l=-1;s==="RGBA"?(t=0,r=e,i=2*e,l=3*e):s==="RGB"?(t=0,r=e,i=2*e):s==="RBG"&&(t=0,i=e,r=2*e);for(let d=0;d<u;d++)for(let g=0;g<p;g++){let b=(y.data[t++]-n[0])*o[0],v=(y.data[r++]-n[1])*o[1],w=(y.data[i++]-n[2])*o[2],x=l===-1?255:(y.data[l++]-n[3])*o[3];h.fillStyle="rgba("+b+","+v+","+w+","+x+")",h.fillRect(g,d,1,1)}return f.toDataURL()}throw new Error("Can not access image data")},c.tensorToImageData=(y,m)=>{let f=document.createElement("canvas").getContext("2d"),h;if(f==null)throw new Error("Can not access image data");{let p,u,s;m?.tensorLayout!==void 0&&m.tensorLayout==="NHWC"?(p=y.dims[2],u=y.dims[1],s=y.dims[3]):(p=y.dims[3],u=y.dims[2],s=y.dims[1]);let a=m!==void 0&&m.format!==void 0?m.format:"RGB",o=m?.norm,n,e;o===void 0||o.mean===void 0?n=[255,255,255,255]:typeof o.mean=="number"?n=[o.mean,o.mean,o.mean,o.mean]:(n=[o.mean[0],o.mean[1],o.mean[2],255],o.mean[3]!==void 0&&(n[3]=o.mean[3])),o===void 0||o.bias===void 0?e=[0,0,0,0]:typeof o.bias=="number"?e=[o.bias,o.bias,o.bias,o.bias]:(e=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(e[3]=o.bias[3]));let t=u*p;if(m!==void 0&&(m.format!==void 0&&s===4&&m.format!=="RGBA"||s===3&&m.format!=="RGB"&&m.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let r=4,i=0,l=1,d=2,g=3,b=0,v=t,w=2*t,x=-1;a==="RGBA"?(b=0,v=t,w=2*t,x=3*t):a==="RGB"?(b=0,v=t,w=2*t):a==="RBG"&&(b=0,w=t,v=2*t),h=f.createImageData(p,u);for(let T=0;T<u*p;i+=r,l+=r,d+=r,g+=r,T++)h.data[i]=(y.data[b++]-e[0])*n[0],h.data[l]=(y.data[v++]-e[1])*n[1],h.data[d]=(y.data[w++]-e[2])*n[2],h.data[g]=x===-1?255:(y.data[x++]-e[3])*n[3]}return h}},4866:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tensorFromImage=c.bufferToTensor=void 0;let m=y(963);c.bufferToTensor=(f,h)=>{if(f===void 0)throw new Error("Image buffer must be defined");if(h.height===void 0||h.width===void 0)throw new Error("Image height and width must be defined");if(h.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:p,width:u}=h,s=h.norm??{mean:255,bias:0},a,o;a=typeof s.mean=="number"?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],o=typeof s.bias=="number"?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];let n=h.format!==void 0?h.format:"RGBA",e=h.tensorFormat!==void 0&&h.tensorFormat!==void 0?h.tensorFormat:"RGB",t=p*u,r=e==="RGBA"?new Float32Array(4*t):new Float32Array(3*t),i=4,l=0,d=1,g=2,b=3,v=0,w=t,x=2*t,T=-1;n==="RGB"&&(i=3,l=0,d=1,g=2,b=-1),e==="RGBA"?T=3*t:e==="RBG"?(v=0,x=t,w=2*t):e==="BGR"&&(x=0,w=t,v=2*t);for(let O=0;O<t;O++,l+=i,g+=i,d+=i,b+=i)r[v++]=(f[l]+o[0])/a[0],r[w++]=(f[d]+o[1])/a[1],r[x++]=(f[g]+o[2])/a[2],T!==-1&&b!==-1&&(r[T++]=(f[b]+o[3])/a[3]);return e==="RGBA"?new m.Tensor("float32",r,[1,4,p,u]):new m.Tensor("float32",r,[1,3,p,u])},c.tensorFromImage=async(f,h)=>{let p=typeof HTMLImageElement<"u"&&f instanceof HTMLImageElement,u=typeof ImageData<"u"&&f instanceof ImageData,s=typeof ImageBitmap<"u"&&f instanceof ImageBitmap,a=typeof f=="string",o,n=h??{};if(p){let e=document.createElement("canvas");e.width=f.width,e.height=f.height;let t=e.getContext("2d");if(t==null)throw new Error("Can not access image data");{let r=f.height,i=f.width;if(h!==void 0&&h.resizedHeight!==void 0&&h.resizedWidth!==void 0&&(r=h.resizedHeight,i=h.resizedWidth),h!==void 0){if(n=h,h.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=r,n.width=i}else n.tensorFormat="RGBA",n.height=r,n.width=i;t.drawImage(f,0,0),o=t.getImageData(0,0,i,r).data}}else{if(!u){if(s){if(h===void 0)throw new Error("Please provide image config with format for Imagebitmap");let e=document.createElement("canvas");e.width=f.width,e.height=f.height;let t=e.getContext("2d");if(t!=null){let r=f.height,i=f.width;return t.drawImage(f,0,0,i,r),o=t.getImageData(0,0,i,r).data,n.height=r,n.width=i,(0,c.bufferToTensor)(o,n)}throw new Error("Can not access image data")}if(a)return new Promise((e,t)=>{let r=document.createElement("canvas"),i=r.getContext("2d");if(!f||!i)return t();let l=new Image;l.crossOrigin="Anonymous",l.src=f,l.onload=()=>{r.width=l.width,r.height=l.height,i.drawImage(l,0,0,r.width,r.height);let d=i.getImageData(0,0,r.width,r.height);n.height=r.height,n.width=r.width,e((0,c.bufferToTensor)(d.data,n))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let e,t;if(h!==void 0&&h.resizedWidth!==void 0&&h.resizedHeight!==void 0?(e=h.resizedHeight,t=h.resizedWidth):(e=f.height,t=f.width),h!==void 0&&(n=h),n.format="RGBA",n.height=e,n.width=t,h!==void 0){let r=document.createElement("canvas");r.width=t,r.height=e;let i=r.getContext("2d");if(i==null)throw new Error("Can not access image data");i.putImageData(f,0,0),o=i.getImageData(0,0,t,e).data}else o=f.data}}if(o!==void 0)return(0,c.bufferToTensor)(o,n);throw new Error("Input data provided is not supported - aborted tensor creation")}},5957:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Tensor=void 0;let m=y(2350),f=y(4866),h=y(106),p=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),u=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),s=!1;c.Tensor=class{constructor(a,o,n){let e,t,r;if((()=>{if(!s){s=!0;let l=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",d=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";l&&(p.set("int64",BigInt64Array),u.set(BigInt64Array,"int64")),d&&(p.set("uint64",BigUint64Array),u.set(BigUint64Array,"uint64"))}})(),typeof a=="string")if(e=a,r=n,a==="string"){if(!Array.isArray(o))throw new TypeError("A string tensor's data must be a string array.");t=o}else{let l=p.get(a);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${a}.`);if(Array.isArray(o)){if(a==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t=a==="uint64"||a==="int64"?l.from(o,BigInt):l.from(o)}else{if(!(o instanceof l))throw new TypeError(`A ${e} tensor's data must be type of ${l}`);t=o}}else if(r=o,Array.isArray(a)){if(a.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof a[0];if(l==="string")e="string",t=a;else{if(l!=="boolean")throw new TypeError(`Invalid element type of data array: ${l}.`);e="bool",t=Uint8Array.from(a)}}else{let l=u.get(a.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${a.constructor}.`);e=l,t=a}if(r===void 0)r=[t.length];else if(!Array.isArray(r))throw new TypeError("A tensor's dims must be a number array");let i=(0,h.calculateSize)(r);if(i!==t.length)throw new Error(`Tensor's size(${i}) does not match data length(${t.length}).`);this.dims=r,this.type=e,this.data=t,this.size=i}static async fromImage(a,o){return(0,f.tensorFromImage)(a,o)}toDataURL(a){return(0,m.tensorToDataURL)(this,a)}toImageData(a){return(0,m.tensorToImageData)(this,a)}reshape(a){return(0,h.tensorReshape)(this,a)}}},106:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.tensorReshape=c.calculateSize=void 0;let m=y(963);c.calculateSize=f=>{let h=1;for(let p=0;p<f.length;p++){let u=f[p];if(typeof u!="number"||!Number.isSafeInteger(u))throw new TypeError(`dims[${p}] must be an integer, got: ${u}`);if(u<0)throw new RangeError(`dims[${p}] must be a non-negative integer, got: ${u}`);h*=u}return h},c.tensorReshape=(f,h)=>new m.Tensor(f.type,f.data,h)},963:(M,c,y)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Tensor=void 0;let m=y(5957);c.Tensor=m.Tensor},9104:(M,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.version=void 0,c.version="1.16.3"},1583:(M,c)=>{var y,m=function(f){"use strict";Object.defineProperty(f,"__esModule",{value:!0}),f.default=void 0;var h=null;try{h=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function p(_,S,E){this.low=0|_,this.high=0|S,this.unsigned=!!E}function u(_){return(_&&_.__isLong__)===!0}function s(_){var S=Math.clz32(_&-_);return _?31-S:S}p.prototype.__isLong__,Object.defineProperty(p.prototype,"__isLong__",{value:!0}),p.isLong=u;var a={},o={};function n(_,S){var E,z,L;return S?(L=0<=(_>>>=0)&&_<256)&&(z=o[_])?z:(E=t(_,0,!0),L&&(o[_]=E),E):(L=-128<=(_|=0)&&_<128)&&(z=a[_])?z:(E=t(_,_<0?-1:0,!1),L&&(a[_]=E),E)}function e(_,S){if(isNaN(_))return S?x:w;if(S){if(_<0)return x;if(_>=g)return R}else{if(_<=-b)return j;if(_+1>=b)return I}return _<0?e(-_,S).neg():t(_%d|0,_/d|0,S)}function t(_,S,E){return new p(_,S,E)}p.fromInt=n,p.fromNumber=e,p.fromBits=t;var r=Math.pow;function i(_,S,E){if(_.length===0)throw Error("empty string");if(typeof S=="number"?(E=S,S=!1):S=!!S,_==="NaN"||_==="Infinity"||_==="+Infinity"||_==="-Infinity")return S?x:w;if((E=E||10)<2||36<E)throw RangeError("radix");var z;if((z=_.indexOf("-"))>0)throw Error("interior hyphen");if(z===0)return i(_.substring(1),S,E).neg();for(var L=e(r(E,8)),Y=w,X=0;X<_.length;X+=8){var te=Math.min(8,_.length-X),ae=parseInt(_.substring(X,X+te),E);if(te<8){var se=e(r(E,te));Y=Y.mul(se).add(e(ae))}else Y=(Y=Y.mul(L)).add(e(ae))}return Y.unsigned=S,Y}function l(_,S){return typeof _=="number"?e(_,S):typeof _=="string"?i(_,S):t(_.low,_.high,typeof S=="boolean"?S:_.unsigned)}p.fromString=i,p.fromValue=l;var d=4294967296,g=d*d,b=g/2,v=n(1<<24),w=n(0);p.ZERO=w;var x=n(0,!0);p.UZERO=x;var T=n(1);p.ONE=T;var O=n(1,!0);p.UONE=O;var P=n(-1);p.NEG_ONE=P;var I=t(-1,2147483647,!1);p.MAX_VALUE=I;var R=t(-1,-1,!0);p.MAX_UNSIGNED_VALUE=R;var j=t(0,-2147483648,!1);p.MIN_VALUE=j;var A=p.prototype;A.toInt=function(){return this.unsigned?this.low>>>0:this.low},A.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},A.toString=function(_){if((_=_||10)<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(j)){var S=e(_),E=this.div(S),z=E.mul(S).sub(this);return E.toString(_)+z.toInt().toString(_)}return"-"+this.neg().toString(_)}for(var L=e(r(_,6),this.unsigned),Y=this,X="";;){var te=Y.div(L),ae=(Y.sub(te.mul(L)).toInt()>>>0).toString(_);if((Y=te).isZero())return ae+X;for(;ae.length<6;)ae="0"+ae;X=""+ae+X}},A.getHighBits=function(){return this.high},A.getHighBitsUnsigned=function(){return this.high>>>0},A.getLowBits=function(){return this.low},A.getLowBitsUnsigned=function(){return this.low>>>0},A.getNumBitsAbs=function(){if(this.isNegative())return this.eq(j)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,S=31;S>0&&!(_&1<<S);S--);return this.high!=0?S+33:S+1},A.isZero=function(){return this.high===0&&this.low===0},A.eqz=A.isZero,A.isNegative=function(){return!this.unsigned&&this.high<0},A.isPositive=function(){return this.unsigned||this.high>=0},A.isOdd=function(){return(1&this.low)==1},A.isEven=function(){return(1&this.low)==0},A.equals=function(_){return u(_)||(_=l(_)),(this.unsigned===_.unsigned||this.high>>>31!=1||_.high>>>31!=1)&&this.high===_.high&&this.low===_.low},A.eq=A.equals,A.notEquals=function(_){return!this.eq(_)},A.neq=A.notEquals,A.ne=A.notEquals,A.lessThan=function(_){return this.comp(_)<0},A.lt=A.lessThan,A.lessThanOrEqual=function(_){return this.comp(_)<=0},A.lte=A.lessThanOrEqual,A.le=A.lessThanOrEqual,A.greaterThan=function(_){return this.comp(_)>0},A.gt=A.greaterThan,A.greaterThanOrEqual=function(_){return this.comp(_)>=0},A.gte=A.greaterThanOrEqual,A.ge=A.greaterThanOrEqual,A.compare=function(_){if(u(_)||(_=l(_)),this.eq(_))return 0;var S=this.isNegative(),E=_.isNegative();return S&&!E?-1:!S&&E?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},A.comp=A.compare,A.negate=function(){return!this.unsigned&&this.eq(j)?j:this.not().add(T)},A.neg=A.negate,A.add=function(_){u(_)||(_=l(_));var S=this.high>>>16,E=65535&this.high,z=this.low>>>16,L=65535&this.low,Y=_.high>>>16,X=65535&_.high,te=_.low>>>16,ae=0,se=0,pe=0,ge=0;return pe+=(ge+=L+(65535&_.low))>>>16,se+=(pe+=z+te)>>>16,ae+=(se+=E+X)>>>16,ae+=S+Y,t((pe&=65535)<<16|(ge&=65535),(ae&=65535)<<16|(se&=65535),this.unsigned)},A.subtract=function(_){return u(_)||(_=l(_)),this.add(_.neg())},A.sub=A.subtract,A.multiply=function(_){if(this.isZero())return this;if(u(_)||(_=l(_)),h)return t(h.mul(this.low,this.high,_.low,_.high),h.get_high(),this.unsigned);if(_.isZero())return this.unsigned?x:w;if(this.eq(j))return _.isOdd()?j:w;if(_.eq(j))return this.isOdd()?j:w;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(v)&&_.lt(v))return e(this.toNumber()*_.toNumber(),this.unsigned);var S=this.high>>>16,E=65535&this.high,z=this.low>>>16,L=65535&this.low,Y=_.high>>>16,X=65535&_.high,te=_.low>>>16,ae=65535&_.low,se=0,pe=0,ge=0,ve=0;return ge+=(ve+=L*ae)>>>16,pe+=(ge+=z*ae)>>>16,ge&=65535,pe+=(ge+=L*te)>>>16,se+=(pe+=E*ae)>>>16,pe&=65535,se+=(pe+=z*te)>>>16,pe&=65535,se+=(pe+=L*X)>>>16,se+=S*ae+E*te+z*X+L*Y,t((ge&=65535)<<16|(ve&=65535),(se&=65535)<<16|(pe&=65535),this.unsigned)},A.mul=A.multiply,A.divide=function(_){if(u(_)||(_=l(_)),_.isZero())throw Error("division by zero");var S,E,z;if(h)return this.unsigned||this.high!==-2147483648||_.low!==-1||_.high!==-1?t((this.unsigned?h.div_u:h.div_s)(this.low,this.high,_.low,_.high),h.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?x:w;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return x;if(_.gt(this.shru(1)))return O;z=x}else{if(this.eq(j))return _.eq(T)||_.eq(P)?j:_.eq(j)?T:(S=this.shr(1).div(_).shl(1)).eq(w)?_.isNegative()?T:P:(E=this.sub(_.mul(S)),z=S.add(E.div(_)));if(_.eq(j))return this.unsigned?x:w;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();z=w}for(E=this;E.gte(_);){S=Math.max(1,Math.floor(E.toNumber()/_.toNumber()));for(var L=Math.ceil(Math.log(S)/Math.LN2),Y=L<=48?1:r(2,L-48),X=e(S),te=X.mul(_);te.isNegative()||te.gt(E);)te=(X=e(S-=Y,this.unsigned)).mul(_);X.isZero()&&(X=T),z=z.add(X),E=E.sub(te)}return z},A.div=A.divide,A.modulo=function(_){return u(_)||(_=l(_)),h?t((this.unsigned?h.rem_u:h.rem_s)(this.low,this.high,_.low,_.high),h.get_high(),this.unsigned):this.sub(this.div(_).mul(_))},A.mod=A.modulo,A.rem=A.modulo,A.not=function(){return t(~this.low,~this.high,this.unsigned)},A.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},A.clz=A.countLeadingZeros,A.countTrailingZeros=function(){return this.low?s(this.low):s(this.high)+32},A.ctz=A.countTrailingZeros,A.and=function(_){return u(_)||(_=l(_)),t(this.low&_.low,this.high&_.high,this.unsigned)},A.or=function(_){return u(_)||(_=l(_)),t(this.low|_.low,this.high|_.high,this.unsigned)},A.xor=function(_){return u(_)||(_=l(_)),t(this.low^_.low,this.high^_.high,this.unsigned)},A.shiftLeft=function(_){return u(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?t(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):t(0,this.low<<_-32,this.unsigned)},A.shl=A.shiftLeft,A.shiftRight=function(_){return u(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?t(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):t(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},A.shr=A.shiftRight,A.shiftRightUnsigned=function(_){return u(_)&&(_=_.toInt()),(_&=63)==0?this:_<32?t(this.low>>>_|this.high<<32-_,this.high>>>_,this.unsigned):t(_===32?this.high:this.high>>>_-32,0,this.unsigned)},A.shru=A.shiftRightUnsigned,A.shr_u=A.shiftRightUnsigned,A.rotateLeft=function(_){var S;return u(_)&&(_=_.toInt()),(_&=63)==0?this:_===32?t(this.high,this.low,this.unsigned):_<32?(S=32-_,t(this.low<<_|this.high>>>S,this.high<<_|this.low>>>S,this.unsigned)):(S=32-(_-=32),t(this.high<<_|this.low>>>S,this.low<<_|this.high>>>S,this.unsigned))},A.rotl=A.rotateLeft,A.rotateRight=function(_){var S;return u(_)&&(_=_.toInt()),(_&=63)==0?this:_===32?t(this.high,this.low,this.unsigned):_<32?(S=32-_,t(this.high<<S|this.low>>>_,this.low<<S|this.high>>>_,this.unsigned)):(S=32-(_-=32),t(this.low<<S|this.high>>>_,this.high<<S|this.low>>>_,this.unsigned))},A.rotr=A.rotateRight,A.toSigned=function(){return this.unsigned?t(this.low,this.high,!1):this},A.toUnsigned=function(){return this.unsigned?this:t(this.low,this.high,!0)},A.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},A.toBytesLE=function(){var _=this.high,S=this.low;return[255&S,S>>>8&255,S>>>16&255,S>>>24,255&_,_>>>8&255,_>>>16&255,_>>>24]},A.toBytesBE=function(){var _=this.high,S=this.low;return[_>>>24,_>>>16&255,_>>>8&255,255&_,S>>>24,S>>>16&255,S>>>8&255,255&S]},p.fromBytes=function(_,S,E){return E?p.fromBytesLE(_,S):p.fromBytesBE(_,S)},p.fromBytesLE=function(_,S){return new p(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,S)},p.fromBytesBE=function(_,S){return new p(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],S)};var C=p;return f.default=C,"default"in f?f.default:f}({});(y=function(){return m}.apply(c,[]))===void 0||(M.exports=y)},5686:(M,c,y)=>{"use strict";y.r(c),y.d(c,{flatbuffers:()=>m});var m={};m.Offset,m.Table,m.SIZEOF_SHORT=2,m.SIZEOF_INT=4,m.FILE_IDENTIFIER_LENGTH=4,m.SIZE_PREFIX_LENGTH=4,m.Encoding={UTF8_BYTES:1,UTF16_STRING:2},m.int32=new Int32Array(2),m.float32=new Float32Array(m.int32.buffer),m.float64=new Float64Array(m.int32.buffer),m.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,m.Long=function(f,h){this.low=0|f,this.high=0|h},m.Long.create=function(f,h){return f==0&&h==0?m.Long.ZERO:new m.Long(f,h)},m.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},m.Long.prototype.equals=function(f){return this.low==f.low&&this.high==f.high},m.Long.ZERO=new m.Long(0,0),m.Builder=function(f){if(f)h=f;else var h=1024;this.bb=m.ByteBuffer.allocate(h),this.space=h,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},m.Builder.prototype.forceDefaults=function(f){this.force_defaults=f},m.Builder.prototype.dataBuffer=function(){return this.bb},m.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},m.Builder.prototype.prep=function(f,h){f>this.minalign&&(this.minalign=f);for(var p=1+~(this.bb.capacity()-this.space+h)&f-1;this.space<p+f+h;){var u=this.bb.capacity();this.bb=m.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-u}this.pad(p)},m.Builder.prototype.pad=function(f){for(var h=0;h<f;h++)this.bb.writeInt8(--this.space,0)},m.Builder.prototype.writeInt8=function(f){this.bb.writeInt8(this.space-=1,f)},m.Builder.prototype.writeInt16=function(f){this.bb.writeInt16(this.space-=2,f)},m.Builder.prototype.writeInt32=function(f){this.bb.writeInt32(this.space-=4,f)},m.Builder.prototype.writeInt64=function(f){this.bb.writeInt64(this.space-=8,f)},m.Builder.prototype.writeFloat32=function(f){this.bb.writeFloat32(this.space-=4,f)},m.Builder.prototype.writeFloat64=function(f){this.bb.writeFloat64(this.space-=8,f)},m.Builder.prototype.addInt8=function(f){this.prep(1,0),this.writeInt8(f)},m.Builder.prototype.addInt16=function(f){this.prep(2,0),this.writeInt16(f)},m.Builder.prototype.addInt32=function(f){this.prep(4,0),this.writeInt32(f)},m.Builder.prototype.addInt64=function(f){this.prep(8,0),this.writeInt64(f)},m.Builder.prototype.addFloat32=function(f){this.prep(4,0),this.writeFloat32(f)},m.Builder.prototype.addFloat64=function(f){this.prep(8,0),this.writeFloat64(f)},m.Builder.prototype.addFieldInt8=function(f,h,p){(this.force_defaults||h!=p)&&(this.addInt8(h),this.slot(f))},m.Builder.prototype.addFieldInt16=function(f,h,p){(this.force_defaults||h!=p)&&(this.addInt16(h),this.slot(f))},m.Builder.prototype.addFieldInt32=function(f,h,p){(this.force_defaults||h!=p)&&(this.addInt32(h),this.slot(f))},m.Builder.prototype.addFieldInt64=function(f,h,p){!this.force_defaults&&h.equals(p)||(this.addInt64(h),this.slot(f))},m.Builder.prototype.addFieldFloat32=function(f,h,p){(this.force_defaults||h!=p)&&(this.addFloat32(h),this.slot(f))},m.Builder.prototype.addFieldFloat64=function(f,h,p){(this.force_defaults||h!=p)&&(this.addFloat64(h),this.slot(f))},m.Builder.prototype.addFieldOffset=function(f,h,p){(this.force_defaults||h!=p)&&(this.addOffset(h),this.slot(f))},m.Builder.prototype.addFieldStruct=function(f,h,p){h!=p&&(this.nested(h),this.slot(f))},m.Builder.prototype.nested=function(f){if(f!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},m.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},m.Builder.prototype.slot=function(f){this.vtable[f]=this.offset()},m.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},m.Builder.growByteBuffer=function(f){var h=f.capacity();if(3221225472&h)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var p=h<<1,u=m.ByteBuffer.allocate(p);return u.setPosition(p-h),u.bytes().set(f.bytes(),p-h),u},m.Builder.prototype.addOffset=function(f){this.prep(m.SIZEOF_INT,0),this.writeInt32(this.offset()-f+m.SIZEOF_INT)},m.Builder.prototype.startObject=function(f){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=f;for(var h=0;h<f;h++)this.vtable[h]=0;this.isNested=!0,this.object_start=this.offset()},m.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var f=this.offset(),h=this.vtable_in_use-1;h>=0&&this.vtable[h]==0;h--);for(var p=h+1;h>=0;h--)this.addInt16(this.vtable[h]!=0?f-this.vtable[h]:0);this.addInt16(f-this.object_start);var u=(p+2)*m.SIZEOF_SHORT;this.addInt16(u);var s=0,a=this.space;e:for(h=0;h<this.vtables.length;h++){var o=this.bb.capacity()-this.vtables[h];if(u==this.bb.readInt16(o)){for(var n=m.SIZEOF_SHORT;n<u;n+=m.SIZEOF_SHORT)if(this.bb.readInt16(a+n)!=this.bb.readInt16(o+n))continue e;s=this.vtables[h];break}}return s?(this.space=this.bb.capacity()-f,this.bb.writeInt32(this.space,s-f)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-f,this.offset()-f)),this.isNested=!1,f},m.Builder.prototype.finish=function(f,h,p){var u=p?m.SIZE_PREFIX_LENGTH:0;if(h){var s=h;if(this.prep(this.minalign,m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH+u),s.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var a=m.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(s.charCodeAt(a))}this.prep(this.minalign,m.SIZEOF_INT+u),this.addOffset(f),u&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},m.Builder.prototype.finishSizePrefixed=function(f,h){this.finish(f,h,!0)},m.Builder.prototype.requiredField=function(f,h){var p=this.bb.capacity()-f,u=p-this.bb.readInt32(p);if(this.bb.readInt16(u+h)==0)throw new Error("FlatBuffers: field "+h+" must be set")},m.Builder.prototype.startVector=function(f,h,p){this.notNested(),this.vector_num_elems=h,this.prep(m.SIZEOF_INT,f*h),this.prep(p,f*h)},m.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},m.Builder.prototype.createString=function(f){if(f instanceof Uint8Array)var h=f;else{h=[];for(var p=0;p<f.length;){var u,s=f.charCodeAt(p++);(u=s<55296||s>=56320?s:(s<<10)+f.charCodeAt(p++)+-56613888)<128?h.push(u):(u<2048?h.push(u>>6&31|192):(u<65536?h.push(u>>12&15|224):h.push(u>>18&7|240,u>>12&63|128),h.push(u>>6&63|128)),h.push(63&u|128))}}this.addInt8(0),this.startVector(1,h.length,1),this.bb.setPosition(this.space-=h.length),p=0;for(var a=this.space,o=this.bb.bytes();p<h.length;p++)o[a++]=h[p];return this.endVector()},m.Builder.prototype.createLong=function(f,h){return m.Long.create(f,h)},m.ByteBuffer=function(f){this.bytes_=f,this.position_=0},m.ByteBuffer.allocate=function(f){return new m.ByteBuffer(new Uint8Array(f))},m.ByteBuffer.prototype.clear=function(){this.position_=0},m.ByteBuffer.prototype.bytes=function(){return this.bytes_},m.ByteBuffer.prototype.position=function(){return this.position_},m.ByteBuffer.prototype.setPosition=function(f){this.position_=f},m.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},m.ByteBuffer.prototype.readInt8=function(f){return this.readUint8(f)<<24>>24},m.ByteBuffer.prototype.readUint8=function(f){return this.bytes_[f]},m.ByteBuffer.prototype.readInt16=function(f){return this.readUint16(f)<<16>>16},m.ByteBuffer.prototype.readUint16=function(f){return this.bytes_[f]|this.bytes_[f+1]<<8},m.ByteBuffer.prototype.readInt32=function(f){return this.bytes_[f]|this.bytes_[f+1]<<8|this.bytes_[f+2]<<16|this.bytes_[f+3]<<24},m.ByteBuffer.prototype.readUint32=function(f){return this.readInt32(f)>>>0},m.ByteBuffer.prototype.readInt64=function(f){return new m.Long(this.readInt32(f),this.readInt32(f+4))},m.ByteBuffer.prototype.readUint64=function(f){return new m.Long(this.readUint32(f),this.readUint32(f+4))},m.ByteBuffer.prototype.readFloat32=function(f){return m.int32[0]=this.readInt32(f),m.float32[0]},m.ByteBuffer.prototype.readFloat64=function(f){return m.int32[m.isLittleEndian?0:1]=this.readInt32(f),m.int32[m.isLittleEndian?1:0]=this.readInt32(f+4),m.float64[0]},m.ByteBuffer.prototype.writeInt8=function(f,h){this.bytes_[f]=h},m.ByteBuffer.prototype.writeUint8=function(f,h){this.bytes_[f]=h},m.ByteBuffer.prototype.writeInt16=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8},m.ByteBuffer.prototype.writeUint16=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8},m.ByteBuffer.prototype.writeInt32=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8,this.bytes_[f+2]=h>>16,this.bytes_[f+3]=h>>24},m.ByteBuffer.prototype.writeUint32=function(f,h){this.bytes_[f]=h,this.bytes_[f+1]=h>>8,this.bytes_[f+2]=h>>16,this.bytes_[f+3]=h>>24},m.ByteBuffer.prototype.writeInt64=function(f,h){this.writeInt32(f,h.low),this.writeInt32(f+4,h.high)},m.ByteBuffer.prototype.writeUint64=function(f,h){this.writeUint32(f,h.low),this.writeUint32(f+4,h.high)},m.ByteBuffer.prototype.writeFloat32=function(f,h){m.float32[0]=h,this.writeInt32(f,m.int32[0])},m.ByteBuffer.prototype.writeFloat64=function(f,h){m.float64[0]=h,this.writeInt32(f,m.int32[m.isLittleEndian?0:1]),this.writeInt32(f+4,m.int32[m.isLittleEndian?1:0])},m.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+m.SIZEOF_INT+m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var f="",h=0;h<m.FILE_IDENTIFIER_LENGTH;h++)f+=String.fromCharCode(this.readInt8(this.position_+m.SIZEOF_INT+h));return f},m.ByteBuffer.prototype.__offset=function(f,h){var p=f-this.readInt32(f);return h<this.readInt16(p)?this.readInt16(p+h):0},m.ByteBuffer.prototype.__union=function(f,h){return f.bb_pos=h+this.readInt32(h),f.bb=this,f},m.ByteBuffer.prototype.__string=function(f,h){f+=this.readInt32(f);var p=this.readInt32(f),u="",s=0;if(f+=m.SIZEOF_INT,h===m.Encoding.UTF8_BYTES)return this.bytes_.subarray(f,f+p);for(;s<p;){var a,o=this.readUint8(f+s++);if(o<192)a=o;else{var n=this.readUint8(f+s++);if(o<224)a=(31&o)<<6|63&n;else{var e=this.readUint8(f+s++);a=o<240?(15&o)<<12|(63&n)<<6|63&e:(7&o)<<18|(63&n)<<12|(63&e)<<6|63&this.readUint8(f+s++)}}a<65536?u+=String.fromCharCode(a):(a-=65536,u+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return u},m.ByteBuffer.prototype.__indirect=function(f){return f+this.readInt32(f)},m.ByteBuffer.prototype.__vector=function(f){return f+this.readInt32(f)+m.SIZEOF_INT},m.ByteBuffer.prototype.__vector_len=function(f){return this.readInt32(f+this.readInt32(f))},m.ByteBuffer.prototype.__has_identifier=function(f){if(f.length!=m.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+m.FILE_IDENTIFIER_LENGTH);for(var h=0;h<m.FILE_IDENTIFIER_LENGTH;h++)if(f.charCodeAt(h)!=this.readInt8(this.position_+m.SIZEOF_INT+h))return!1;return!0},m.ByteBuffer.prototype.createLong=function(f,h){return m.Long.create(f,h)}}},__webpack_module_cache__={};function __webpack_require__(M){var c=__webpack_module_cache__[M];if(c!==void 0)return c.exports;var y=__webpack_module_cache__[M]={exports:{}};return __webpack_modules__[M].call(y.exports,y,y.exports,__webpack_require__),y.exports}__webpack_require__.n=M=>{var c=M&&M.__esModule?()=>M.default:()=>M;return __webpack_require__.d(c,{a:c}),c},__webpack_require__.d=(M,c)=>{for(var y in c)__webpack_require__.o(c,y)&&!__webpack_require__.o(M,y)&&Object.defineProperty(M,y,{enumerable:!0,get:c[y]})},__webpack_require__.o=(M,c)=>Object.prototype.hasOwnProperty.call(M,c),__webpack_require__.r=M=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(M,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(M,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())});var Gt=bn(yn(),1),wn=bn(vn(),1);var $n=(M=()=>{})=>{globalThis.WORKER={};let c=(m,f,h,p)=>{if(globalThis.WORKER.SENDERS&&p!==!0)if(p!==void 0&&p!=="both")globalThis.WORKER.SENDERS[p]&&(m?.message?globalThis.WORKER.SENDERS[p].postMessage({message:m.message,overridePort:m?.overridePort},m.transfer):globalThis.WORKER.SENDERS[p].postMessage({message:m,overridePort:m?.overridePort}));else{for(let u in globalThis.WORKER.SENDERS){if(globalThis.WORKER.BLOCKING[u]){if(globalThis.WORKER.BLOCKED[u]){console.error("Thread Blocked: "+u);continue}globalThis.WORKER.BLOCKED[u]=!0}m?.message?globalThis.WORKER.SENDERS[u].postMessage({message:m.message,overridePort:m?.overridePort},m.transfer):globalThis.WORKER.SENDERS[u].postMessage({message:m,overridePort:m?.overridePort})}h&&postMessage(!0)}(!globalThis.WORKER.SENDERS||p===!0||p==="both")&&(m?.message?postMessage({message:m.message,cb:f,overridePort:m?.overridePort},m.transfer):postMessage({message:m,cb:f,overridePort:m?.overridePort}))},y=(m,f)=>{let h=M(m.data?.message);h?.then?h.then(p=>{f&&f.postMessage(!0),c(p,m.data.cb,m.data.oneOff,m.data.overridePort)}):(f&&f.postMessage(!0),c(h,m.data.cb,m.data.oneOff,m.data.overridePort))};globalThis.onmessage=m=>{if(m.data?.COMMAND){let f=m.data.COMMAND;if(typeof f.SETLOOP=="number"){globalThis.WORKER.LOOP&&clearTimeout(globalThis.WORKER.LOOP);let h=()=>{y(m),globalThis.WORKER.LOOP=setTimeout(()=>{h()},f.SETLOOP)};h()}if(f.SETANIM){globalThis.WORKER.ANIM&&cancelAnimationFrame(globalThis.WORKER.ANIM);let h=()=>{y(m),globalThis.WORKER.ANIM=requestAnimationFrame(()=>{h()})};h()}if(f.STOP&&(globalThis.WORKER.LOOP&&clearTimeout(globalThis.WORKER.LOOP),globalThis.WORKER.ANIM&&cancelAnimationFrame(globalThis.WORKER.ANIM)),f.RECEIVER){let h=f.blocking;globalThis.WORKER.RECEIVERS||(globalThis.WORKER.RTCR=0,globalThis.WORKER.RECEIVERS={});let p=f.id;globalThis.WORKER.RECEIVERS[p]=f.RECEIVER,globalThis.WORKER.RTCR++,f.RECEIVER.onmessage=u=>{y(u,h?f.RECEIVER:void 0)},f.RECEIVER.onerror=u=>{delete globalThis.WORKER.RECEIVERS[p]}}if(f.SENDER){globalThis.WORKER.SENDERS||(globalThis.WORKER.PCTR=0,globalThis.WORKER.SENDERS={},globalThis.WORKER.BLOCKING={},globalThis.WORKER.BLOCKED={});let h=f.blocking,p=f.id?f.id:globalThis.WORKER.PCTR;globalThis.WORKER.SENDERS[p]=f.SENDER,globalThis.WORKER.PCTR++,h&&(globalThis.WORKER.BLOCKING[p]=!0),f.SENDER.onmessage=u=>{globalThis.WORKER.BLOCKING[p]&&(globalThis.WORKER.BLOCKED[p]=!1)},f.SENDER.onerror=u=>{delete globalThis.WORKER.SENDERS[p]}}f.DELETED&&(delete globalThis.WORKER.RECEIVERS?.[f.DELETED],delete globalThis.WORKER.SENDERS?.[f.DELETED])}else y(m)},globalThis.onerror=m=>{console.error(m)}},Ur=$n.toString();function dn(M,c,y){let m=c*y,f=new Float32Array(m*3),h=.485,p=.229,u=.456,s=.224,a=.406,o=.225,n=new Uint32Array(M.buffer),e=0,t=m,r=2*m;for(let i=0;i<m;i++){let l=n[i],d=(l&255)/255,g=(l>>8&255)/255,b=(l>>16&255)/255;f[e++]=(d-h)/p,f[t++]=(g-u)/s,f[r++]=(b-a)/o}return f}var fn=(M=()=>{})=>{globalThis.WORKER={},M=M.bind(globalThis.WORKER);let c=(m,f,h,p)=>{if(globalThis.WORKER.SENDERS&&p!==!0)if(p!==void 0&&p!=="both")globalThis.WORKER.SENDERS[p]&&(m?.message?globalThis.WORKER.SENDERS[p].postMessage({message:m.message,overridePort:m?.overridePort},m.transfer):globalThis.WORKER.SENDERS[p].postMessage({message:m,overridePort:m?.overridePort}));else{for(let u in globalThis.WORKER.SENDERS){if(globalThis.WORKER.BLOCKING[u]){if(globalThis.WORKER.BLOCKED[u]){console.error("Thread Blocked: "+u);continue}globalThis.WORKER.BLOCKED[u]=!0}m?.message?globalThis.WORKER.SENDERS[u].postMessage({message:m.message,overridePort:m?.overridePort},m.transfer):globalThis.WORKER.SENDERS[u].postMessage({message:m,overridePort:m?.overridePort})}h&&postMessage(!0)}(!globalThis.WORKER.SENDERS||p===!0||p==="both")&&(m?.message?postMessage({message:m.message,cb:f,overridePort:m?.overridePort},m.transfer):postMessage({message:m,cb:f,overridePort:m?.overridePort}))},y=(m,f)=>{let h=M(m.data?.message);h?.then?h.then(p=>{f&&f.postMessage(!0),c(p,m.data.cb,m.data.oneOff,m.data.overridePort)}):(f&&f.postMessage(!0),c(h,m.data.cb,m.data.oneOff,m.data.overridePort))};globalThis.onmessage=m=>{if(m.data?.COMMAND){let f=m.data.COMMAND;if(typeof f.SETLOOP=="number"){globalThis.WORKER.LOOP&&clearTimeout(globalThis.WORKER.LOOP);let h=()=>{y(m),globalThis.WORKER.LOOP=setTimeout(()=>{h()},f.SETLOOP)};h()}if(f.SETANIM){globalThis.WORKER.ANIM&&cancelAnimationFrame(globalThis.WORKER.ANIM);let h=()=>{y(m),globalThis.WORKER.ANIM=requestAnimationFrame(()=>{h()})};h()}if(f.STOP&&(globalThis.WORKER.LOOP&&clearTimeout(globalThis.WORKER.LOOP),globalThis.WORKER.ANIM&&cancelAnimationFrame(globalThis.WORKER.ANIM)),f.RECEIVER){let h=f.blocking;globalThis.WORKER.RECEIVERS||(globalThis.WORKER.RTCR=0,globalThis.WORKER.RECEIVERS={});let p=f.id;globalThis.WORKER.RECEIVERS[p]=f.RECEIVER,globalThis.WORKER.RTCR++,f.RECEIVER.onmessage=u=>{y(u,h?f.RECEIVER:void 0)},f.RECEIVER.onerror=u=>{delete globalThis.WORKER.RECEIVERS[p]}}if(f.SENDER){globalThis.WORKER.SENDERS||(globalThis.WORKER.PCTR=0,globalThis.WORKER.SENDERS={},globalThis.WORKER.BLOCKING={},globalThis.WORKER.BLOCKED={});let h=f.blocking,p=f.id?f.id:globalThis.WORKER.PCTR;globalThis.WORKER.SENDERS[p]=f.SENDER,globalThis.WORKER.PCTR++,h&&(globalThis.WORKER.BLOCKING[p]=!0),f.SENDER.onmessage=u=>{globalThis.WORKER.BLOCKING[p]&&(globalThis.WORKER.BLOCKED[p]=!1)},f.SENDER.onerror=u=>{delete globalThis.WORKER.SENDERS[p]}}f.DELETED&&(delete globalThis.WORKER.RECEIVERS?.[f.DELETED],delete globalThis.WORKER.SENDERS?.[f.DELETED])}else y(m)},globalThis.onerror=m=>{console.error(m)}},qr=fn.toString();if(typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope){let M=(o,n,e=1)=>Array(Math.ceil((n-o)/e)).fill(o).map((t,r)=>t+r*e),c="inception-mnist.onnx",y="mnist-labels.txt",m="input",f="output",h=224,p=224,u=0,s=0;(async()=>{let o,n;async function e(t){if(t.command==="configure"){t.modelName&&(c=t.modelName),t.labelsName&&(y=t.labelsName),t.outputName&&(f=t.outputName),t.inputName&&(m=t.inputName),t.outputWidth&&(h=t.outputWidth),t.outputHeight&&(p=t.outputHeight);try{o=await wn.InferenceSession.create(location.origin+"/models/"+c,{executionProviders:["webgpu"]}),console.log("Created WebGPU ONNX session")}catch(I){console.error("WebGPU ONNX Create Session error:",I);try{o=await Gt.InferenceSession.create(location.origin+"/models/"+c,{executionProviders:["webgl"]}),console.log("Created WebGL ONNX session")}catch(R){console.error("WebGL ONNX Create Session error:",R);try{o=await Gt.InferenceSession.create(location.origin+"/models/"+c,{executionProviders:["wasm"]}),console.log("Created WASM ONNX session")}catch(j){console.error("WASM ONNX Create Session error:",j)}}}n=(await(t.labels?t.labels:fetch(location.origin+"/models/"+y).then(I=>I.text()))).split(/\n/g);return}if(!t)return;let r,i;if(t.image&&t.input==="image")i=dn(t.image,h,p),r=new Gt.Tensor("float32",i,[1,3,h,p]);else if(t.image&&t.input==="imageflattened")i=dn(t.image,h,p),r=new Gt.Tensor("float32",i,[1,i.length]);else if(t.spectral&&t.input==="spectral"){let P=t.spectral.intensities;i=new Float32Array(P.length*4);let I=P.length,R=P.length*2,j=P.length*3;P.forEach((A,C)=>{i[C]=A.i,i[C+I]=A.r,i[C+j]=A.g,i[C+R]=A.b}),r=new Gt.Tensor("float32",i,[1,i.length])}let l={[m]:r},d=performance.now(),g;try{g=await o.run(l)}catch(P){console.error(P)}if(!g)return{name:t.name,id:t.id,width:t.width,height:t.height,cropIndex:t.cropIndex,input:t.input};let b=performance.now()-d;u++,s+=b;let v;v=g[f]?.data;let w=-1,x=-1;for(let P=0;P<v.length;P++){let I=v[P];I>w&&(w=I,x=P)}let T=s/u,O=u/(s*.001);return{probs:v,maxProb:w,label:n[x],inferenceTime:b,avgFrameTime:T,avgFrameRate:O,name:t.name,id:t.id,width:t.width,height:t.height,cropIndex:t.cropIndex}}fn(e)})()}var Zr=self;export{Zr as default};
/*! Bundled license information:

onnxruntime-web/dist/ort.min.js:
  (*!
  * ONNX Runtime Web v1.16.3
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  *)

onnxruntime-web/dist/ort.webgpu.min.js:
  (*!
  * ONNX Runtime Web v1.16.3
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  *)
*/
